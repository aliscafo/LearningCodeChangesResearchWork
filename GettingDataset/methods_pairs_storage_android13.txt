597
#method_before
public void getNetworkRegistrationState(int domain, @NonNull NetworkServiceCallback callback) {
    callback.onGetNetworkRegistrationStateComplete(NetworkServiceCallback.RESULT_ERROR_UNSUPPORTED, null);
}
#method_after
public void getNetworkRegistrationState(int domain, NetworkServiceCallback callback) {
    callback.onGetNetworkRegistrationStateComplete(NetworkServiceCallback.RESULT_ERROR_UNSUPPORTED, null);
}
#end_block

#method_before
@NonNull
public FragmentFactory getFragmentFactory() {
    if (mFragmentFactory == null) {
        mFragmentFactory = new FragmentFactory();
    }
    return mFragmentFactory;
}
#method_after
@NonNull
public FragmentFactory getFragmentFactory() {
    if (mFragmentFactory == null) {
        mFragmentFactory = DEFAULT_FACTORY;
    }
    return mFragmentFactory;
}
#end_block

#method_before
private void startVpn(String[] addresses, String[] routes, String allowedApplications, String disallowedApplications) throws Exception {
    prepareVpn();
    // Register a callback so we will be notified when our VPN comes up.
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).build();
    mCallback = new NetworkCallback() {

        public void onAvailable(Network network) {
            synchronized (mLock) {
                Log.i(TAG, "Got available callback for network=" + network);
                mNetwork = network;
                mLock.notify();
            }
        }
    };
    // Unregistered in tearDown.
    mCM.registerNetworkCallback(request, mCallback);
    // Start the service and wait up for TIMEOUT_MS ms for the VPN to come up.
    Intent intent = new Intent(mActivity, MyVpnService.class).putExtra(mPackageName + ".cmd", "connect").putExtra(mPackageName + ".addresses", TextUtils.join(",", addresses)).putExtra(mPackageName + ".routes", TextUtils.join(",", routes)).putExtra(mPackageName + ".allowedapplications", allowedApplications).putExtra(mPackageName + ".disallowedapplications", disallowedApplications);
    mActivity.startService(intent);
    synchronized (mLock) {
        if (mNetwork == null) {
            Log.i(TAG, "bf mLock");
            mLock.wait(TIMEOUT_MS);
            Log.i(TAG, "af mLock");
        }
    }
    if (mNetwork == null) {
        fail("VPN did not become available after " + TIMEOUT_MS + "ms");
    }
    // configured. Give the system some time to do so. http://b/18436087 .
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
    }
}
#method_after
private void startVpn(String[] addresses, String[] routes, String allowedApplications, String disallowedApplications, ProxyInfo proxyInfo) throws Exception {
    prepareVpn();
    // Register a callback so we will be notified when our VPN comes up.
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).build();
    mCallback = new NetworkCallback() {

        public void onAvailable(Network network) {
            synchronized (mLock) {
                Log.i(TAG, "Got available callback for network=" + network);
                mNetwork = network;
                mLock.notify();
            }
        }
    };
    // Unregistered in tearDown.
    mCM.registerNetworkCallback(request, mCallback);
    // Start the service and wait up for TIMEOUT_MS ms for the VPN to come up.
    Intent intent = new Intent(mActivity, MyVpnService.class).putExtra(mPackageName + ".cmd", "connect").putExtra(mPackageName + ".addresses", TextUtils.join(",", addresses)).putExtra(mPackageName + ".routes", TextUtils.join(",", routes)).putExtra(mPackageName + ".allowedapplications", allowedApplications).putExtra(mPackageName + ".disallowedapplications", disallowedApplications).putExtra(mPackageName + ".httpProxy", proxyInfo);
    mActivity.startService(intent);
    synchronized (mLock) {
        if (mNetwork == null) {
            Log.i(TAG, "bf mLock");
            mLock.wait(TIMEOUT_MS);
            Log.i(TAG, "af mLock");
        }
    }
    if (mNetwork == null) {
        fail("VPN did not become available after " + TIMEOUT_MS + "ms");
    }
    // configured. Give the system some time to do so. http://b/18436087 .
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
    }
}
#end_block

#method_before
public void testDefault() throws Exception {
    if (!supportedHardware())
        return;
    // support adb over network, see b/119382723.
    if (SystemProperties.getInt("persist.adb.tcp.port", -1) > -1 || SystemProperties.getInt("service.adb.tcp.port", -1) > -1) {
        Log.i(TAG, "adb is running over the network, so skip this test");
        return;
    }
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "0.0.0.0/0", "::/0" }, "", "");
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
}
#method_after
public void testDefault() throws Exception {
    if (!supportedHardware())
        return;
    // support adb over network, see b/119382723.
    if (SystemProperties.getInt("persist.adb.tcp.port", -1) > -1 || SystemProperties.getInt("service.adb.tcp.port", -1) > -1) {
        Log.i(TAG, "adb is running over the network, so skip this test");
        return;
    }
    final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(getInstrumentation().getTargetContext(), MyVpnService.ACTION_ESTABLISHED);
    receiver.register();
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "0.0.0.0/0", "::/0" }, "", "", null);
    final Intent intent = receiver.awaitForBroadcast(TimeUnit.MINUTES.toMillis(1));
    assertNotNull("Failed to receive broadcast from VPN service", intent);
    assertFalse("Wrong VpnService#isAlwaysOn", intent.getBooleanExtra(MyVpnService.EXTRA_ALWAYS_ON, true));
    assertFalse("Wrong VpnService#isLockdownEnabled", intent.getBooleanExtra(MyVpnService.EXTRA_LOCKDOWN_ENABLED, true));
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
    receiver.unregisterQuietly();
}
#end_block

#method_before
public void testAppAllowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    // Shell app must not be put in here or it would kill the ADB-over-network use case
    String allowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, allowedApps, "");
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
}
#method_after
public void testAppAllowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    // Shell app must not be put in here or it would kill the ADB-over-network use case
    String allowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, allowedApps, "", null);
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
}
#end_block

#method_before
public void testAppDisallowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor localFd = openSocketFd(TEST_HOST, 80, TIMEOUT_MS);
    FileDescriptor remoteFd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    String disallowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    // If adb TCP port opened, this test may running by adb over TCP.
    // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,
    // see b/119382723.
    // Note: The test don't support running adb over network for root device
    disallowedApps = disallowedApps + ",com.android.shell";
    Log.i(TAG, "Append shell app to disallowedApps: " + disallowedApps);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, "", disallowedApps);
    assertSocketStillOpen(localFd, TEST_HOST);
    assertSocketStillOpen(remoteFd, TEST_HOST);
    checkNoTrafficOnVpn();
}
#method_after
public void testAppDisallowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor localFd = openSocketFd(TEST_HOST, 80, TIMEOUT_MS);
    FileDescriptor remoteFd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    String disallowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    // If adb TCP port opened, this test may running by adb over TCP.
    // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,
    // see b/119382723.
    // Note: The test don't support running adb over network for root device
    disallowedApps = disallowedApps + ",com.android.shell";
    Log.i(TAG, "Append shell app to disallowedApps: " + disallowedApps);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, "", disallowedApps, null);
    assertSocketStillOpen(localFd, TEST_HOST);
    assertSocketStillOpen(remoteFd, TEST_HOST);
    checkNoTrafficOnVpn();
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    // always-on is null by default
    assertNull(mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    mPackageName = mContext.getPackageName();
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    // Always-on is null by default.
    assertNull(mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    mPackageName = mContext.getPackageName();
}
#end_block

#method_before
public void testAlwaysOnVpn() throws Exception {
    // test always-on is null by default
    assertNull(mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* lockdown */
    false, /* usable */
    true);
    VpnTestHelper.checkPing(TEST_ADDRESS);
    VpnTestHelper.assertIsAlwaysOnAndLockdown(mContext, /* alwaysOn */
    true, /* lockdown */
    false);
}
#method_after
public void testAlwaysOnVpn() throws Exception {
    // test always-on is null by default
    assertNull(mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* usable */
    true, /* lockdown */
    true, /* whitelist */
    false);
    VpnTestHelper.checkPing(TEST_ADDRESS);
}
#end_block

#method_before
public void testAllowedApps() throws Exception {
    final Bundle restrictions = new Bundle();
    restrictions.putStringArray(RESTRICTION_ALLOWED, new String[] { mPackageName });
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* lockdown */
    true, /* usable */
    true);
    assertTrue(VpnTestHelper.isNetworkVpn(mContext));
}
#method_after
public void testAllowedApps() throws Exception {
    final Bundle restrictions = new Bundle();
    restrictions.putStringArray(RESTRICTION_ALLOWED, new String[] { mPackageName });
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* usable */
    true, /* lockdown */
    true, /* whitelist */
    false);
    assertTrue(VpnTestHelper.isNetworkVpn(mContext));
}
#end_block

#method_before
public void testDisallowedApps() throws Exception {
    final Bundle restrictions = new Bundle();
    restrictions.putStringArray(RESTRICTION_DISALLOWED, new String[] { mPackageName });
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* lockdown */
    true, /* usable */
    false);
    assertFalse(VpnTestHelper.isNetworkVpn(mContext));
}
#method_after
public void testDisallowedApps() throws Exception {
    final Bundle restrictions = new Bundle();
    restrictions.putStringArray(RESTRICTION_DISALLOWED, new String[] { mPackageName });
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* usable */
    false, /* lockdown */
    true, /* whitelist */
    false);
    assertFalse(VpnTestHelper.isNetworkVpn(mContext));
}
#end_block

#method_before
public void testAlwaysOnSet() throws Exception {
    // Setup always-on vpn
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* lockdown */
    false, /* usable */
    true);
    assertTrue(VpnTestHelper.isNetworkVpn(mContext));
    VpnTestHelper.checkPing(TEST_ADDRESS);
}
#method_after
public void testAlwaysOnSet() throws Exception {
    // Setup always-on vpn
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* usable */
    true, /* lockdown */
    true, /* whitelist */
    false);
    assertTrue(VpnTestHelper.isNetworkVpn(mContext));
    VpnTestHelper.checkPing(TEST_ADDRESS);
}
#end_block

#method_before
public void testAlwaysOnSetAfterReboot() throws Exception {
    VpnTestHelper.waitForVpn(mContext, null, /* lockdown */
    false, /* usable */
    true);
    VpnTestHelper.checkPing(TEST_ADDRESS);
}
#method_after
public void testAlwaysOnSetAfterReboot() throws Exception {
    VpnTestHelper.waitForVpn(mContext, null, /* usable */
    true, /* lockdown */
    true, /* whitelist */
    true);
    VpnTestHelper.checkPing(TEST_ADDRESS);
    final List<String> whitelist = mDevicePolicyManager.getAlwaysOnVpnLockdownWhitelist(ADMIN_RECEIVER_COMPONENT);
    assertTrue("Lockdown bit lost after reboot", mDevicePolicyManager.isAlwaysOnVpnLockdownEnabled(ADMIN_RECEIVER_COMPONENT));
    assertNotNull("whitelist is lost after reboot", whitelist);
    assertTrue("whitelist changed after reboot", whitelist.size() == 1 && mContext.getPackageName().equals(whitelist.get(0)));
}
#end_block

#method_before
public static void waitForVpn(Context context, String packageName, boolean lockdown, boolean usable) {
    DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
    if (packageName == null) {
        assertNotNull(dpm.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    }
    ConnectivityManager cm = context.getSystemService(ConnectivityManager.class);
    final CountDownLatch vpnLatch = new CountDownLatch(1);
    final IntentFilter intentFilter = new IntentFilter(ACTION_VPN_IS_UP);
    final BroadcastReceiver receiver = new BroadcastReceiver() {

        @Override
        public void onReceive(final Context context, final Intent intent) {
            if (!intent.getPackage().equals(MY_PACKAGE))
                return;
            vpnLatch.countDown();
            context.unregisterReceiver(this);
        }
    };
    context.registerReceiver(receiver, intentFilter);
    try {
        if (packageName != null) {
            dpm.setAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT, packageName, lockdown);
            assertEquals(packageName, dpm.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
        }
        if (!vpnLatch.await(NETWORK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
            if (!isNetworkVpn(context)) {
                fail("Took too long waiting to establish a VPN-backed connection");
            }
        }
        Thread.sleep(NETWORK_SETTLE_GRACE_MS);
    } catch (InterruptedException | PackageManager.NameNotFoundException e) {
        fail("Failed while waiting for VPN: " + e);
    }
    // Do we have a network?
    NetworkInfo vpnInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_VPN);
    assertNotNull(vpnInfo);
    // Is it usable?
    assertEquals(usable, vpnInfo.isConnected());
}
#method_after
public static void waitForVpn(Context context, String packageName, boolean usable, boolean lockdown, boolean whitelist) {
    final DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
    if (packageName == null) {
        assertNotNull(dpm.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    }
    ConnectivityManager cm = context.getSystemService(ConnectivityManager.class);
    final CountDownLatch vpnLatch = new CountDownLatch(1);
    final IntentFilter intentFilter = new IntentFilter(ACTION_VPN_IS_UP);
    final AtomicBoolean isAlwaysOn = new AtomicBoolean();
    final AtomicBoolean isLockdown = new AtomicBoolean();
    final BroadcastReceiver receiver = new BroadcastReceiver() {

        @Override
        public void onReceive(final Context context, final Intent intent) {
            if (!intent.getPackage().equals(MY_PACKAGE))
                return;
            isAlwaysOn.set(intent.getBooleanExtra(EXTRA_ALWAYS_ON, false));
            isLockdown.set(intent.getBooleanExtra(EXTRA_LOCKDOWN, !lockdown));
            vpnLatch.countDown();
            context.unregisterReceiver(this);
        }
    };
    context.registerReceiver(receiver, intentFilter);
    try {
        if (packageName != null) {
            setAlwaysOnVpn(context, packageName, lockdown, whitelist);
        }
        if (!vpnLatch.await(NETWORK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
            if (!isNetworkVpn(context)) {
                fail("Took too long waiting to establish a VPN-backed connection");
            }
        } else {
            assertTrue("Wrong VpnService#isAlwaysOn()", isAlwaysOn.get());
            assertEquals("Wrong VpnService#isLockdownEnabled()", lockdown, isLockdown.get());
        }
        Thread.sleep(NETWORK_SETTLE_GRACE_MS);
    } catch (InterruptedException | PackageManager.NameNotFoundException e) {
        fail("Failed while waiting for VPN: " + e);
    }
    // Do we have a network?
    NetworkInfo vpnInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_VPN);
    assertNotNull(vpnInfo);
    // Is it usable?
    assertEquals(usable, vpnInfo.isConnected());
}
#end_block

#method_before
@Override
public void schedule(WorkSpec... workSpecs) {
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    for (WorkSpec workSpec : workSpecs) {
        workDatabase.beginTransaction();
        try {
            // It is possible that this WorkSpec got cancelled/pruned since this isn't part of
            // the same database transaction as marking it enqueued (for example, if we using
            // any of the synchronous operations).  For now, handle this gracefully by exiting
            // the loop.  When we plumb ListenableFutures all the way through, we can remove the
            // *sync methods and return ListenableFutures, which will block on an operation on
            // the background task thread so all database operations happen on the same thread.
            // See b/114705286.
            WorkSpec currentDbWorkSpec = workDatabase.workSpecDao().getWorkSpec(workSpec.id);
            if (currentDbWorkSpec == null) {
                Logger.get().warning(TAG, "Skipping scheduling " + workSpec.id + " because it's no longer in the DB");
                continue;
            } else if (currentDbWorkSpec.state != WorkInfo.State.ENQUEUED) {
                Logger.get().warning(TAG, "Skipping scheduling " + workSpec.id + " because it is no longer enqueued");
                continue;
            }
            SystemIdInfo info = workDatabase.systemIdInfoDao().getSystemIdInfo(workSpec.id);
            if (info != null) {
                JobInfo jobInfo = mJobScheduler.getPendingJob(info.systemId);
                if (jobInfo != null) {
                    Logger.get().info(TAG, String.format("Skipping scheduling %s because JobScheduler is aware of it " + "already.", workSpec.id));
                    continue;
                }
            }
            int jobId = info != null ? info.systemId : mIdGenerator.nextJobSchedulerIdWithRange(mWorkManager.getConfiguration().getMinJobSchedulerId(), mWorkManager.getConfiguration().getMaxJobSchedulerId());
            if (info == null) {
                SystemIdInfo newSystemIdInfo = new SystemIdInfo(workSpec.id, jobId);
                mWorkManager.getWorkDatabase().systemIdInfoDao().insertSystemIdInfo(newSystemIdInfo);
            }
            scheduleInternal(workSpec, jobId);
            // in SystemJobService as needed.
            if (Build.VERSION.SDK_INT == 23) {
                int nextJobId = mIdGenerator.nextJobSchedulerIdWithRange(mWorkManager.getConfiguration().getMinJobSchedulerId(), mWorkManager.getConfiguration().getMaxJobSchedulerId());
                scheduleInternal(workSpec, nextJobId);
            }
            workDatabase.setTransactionSuccessful();
        } finally {
            workDatabase.endTransaction();
        }
    }
}
#method_after
@Override
public void schedule(WorkSpec... workSpecs) {
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    for (WorkSpec workSpec : workSpecs) {
        workDatabase.beginTransaction();
        try {
            // It is possible that this WorkSpec got cancelled/pruned since this isn't part of
            // the same database transaction as marking it enqueued (for example, if we using
            // any of the synchronous operations).  For now, handle this gracefully by exiting
            // the loop.  When we plumb ListenableFutures all the way through, we can remove the
            // *sync methods and return ListenableFutures, which will block on an operation on
            // the background task thread so all database operations happen on the same thread.
            // See b/114705286.
            WorkSpec currentDbWorkSpec = workDatabase.workSpecDao().getWorkSpec(workSpec.id);
            if (currentDbWorkSpec == null) {
                Logger.get().warning(TAG, "Skipping scheduling " + workSpec.id + " because it's no longer in the DB");
                continue;
            } else if (currentDbWorkSpec.state != WorkInfo.State.ENQUEUED) {
                Logger.get().warning(TAG, "Skipping scheduling " + workSpec.id + " because it is no longer enqueued");
                continue;
            }
            SystemIdInfo info = workDatabase.systemIdInfoDao().getSystemIdInfo(workSpec.id);
            if (info != null) {
                JobInfo jobInfo = mJobScheduler.getPendingJob(info.systemId);
                if (jobInfo != null) {
                    Logger.get().debug(TAG, String.format("Skipping scheduling %s because JobScheduler is aware of it " + "already.", workSpec.id));
                    continue;
                }
            }
            int jobId = info != null ? info.systemId : mIdGenerator.nextJobSchedulerIdWithRange(mWorkManager.getConfiguration().getMinJobSchedulerId(), mWorkManager.getConfiguration().getMaxJobSchedulerId());
            if (info == null) {
                SystemIdInfo newSystemIdInfo = new SystemIdInfo(workSpec.id, jobId);
                mWorkManager.getWorkDatabase().systemIdInfoDao().insertSystemIdInfo(newSystemIdInfo);
            }
            scheduleInternal(workSpec, jobId);
            // in SystemJobService as needed.
            if (Build.VERSION.SDK_INT == 23) {
                int nextJobId = mIdGenerator.nextJobSchedulerIdWithRange(mWorkManager.getConfiguration().getMinJobSchedulerId(), mWorkManager.getConfiguration().getMaxJobSchedulerId());
                scheduleInternal(workSpec, nextJobId);
            }
            workDatabase.setTransactionSuccessful();
        } finally {
            workDatabase.endTransaction();
        }
    }
}
#end_block

#method_before
private void runWorker() {
    if (tryCheckForInterruptionAndResolve()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.get().error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            resolve(false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            resolveIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            Logger.get().debug(TAG, String.format("%s is not in ENQUEUED state. Nothing more to do.", mWorkSpec.workerClassName));
            return;
        }
        if (mWorkSpec.isPeriodic() || mWorkSpec.isBackedOff()) {
            long now = System.currentTimeMillis();
            if (now < mWorkSpec.calculateNextRunTime()) {
                Logger.get().debug(TAG, String.format("%s has been eagerly scheduled. Delaying execution", mWorkSpec.workerClassName));
                // For AlarmManager implementation we need to reschedule this kind  of Work.
                // This is not a problem for JobScheduler because we will only reschedule
                // work if JobScheduler is unaware of a jobId.
                resolve(true);
                return;
            }
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.get().error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndResolve();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    WorkerParameters params = new WorkerParameters(UUID.fromString(mWorkSpecId), input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount, mConfiguration.getExecutor(), mWorkTaskExecutor, mConfiguration.getWorkerFactory());
    // in test mode.
    if (mWorker == null) {
        mWorker = mConfiguration.getWorkerFactory().createWorkerWithDefaultFallback(mAppContext, mWorkSpec.workerClassName, params);
    }
    if (mWorker == null) {
        Logger.get().error(TAG, String.format("Could not create Worker %s", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    if (mWorker.isUsed()) {
        Logger.get().error(TAG, String.format("Received an already-used Worker %s; WorkerFactory should return " + "new instances", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    mWorker.setUsed();
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndResolve()) {
            return;
        }
        final SettableFuture<ListenableWorker.Result> future = SettableFuture.create();
        // Call mWorker.startWork() on the main thread.
        mWorkTaskExecutor.getMainThreadExecutor().execute(new Runnable() {

            @Override
            public void run() {
                try {
                    Logger.get().debug(TAG, String.format("Starting work for %s", mWorkSpec.workerClassName));
                    mInnerFuture = mWorker.startWork();
                    future.setFuture(mInnerFuture);
                } catch (Throwable e) {
                    future.setException(e);
                }
            }
        });
        // Avoid synthetic accessors.
        final String workDescription = mWorkDescription;
        future.addListener(new Runnable() {

            @Override
            @SuppressLint("SyntheticAccessor")
            public void run() {
                try {
                    // If the ListenableWorker returns a null result treat it as a failure.
                    ListenableWorker.Result result = future.get();
                    if (result == null) {
                        Logger.get().error(TAG, String.format("%s returned a null result. Treating it as a failure.", mWorkSpec.workerClassName));
                    } else {
                        Logger.get().debug(TAG, String.format("%s returned a %s result.", mWorkSpec.workerClassName, result));
                        mResult = result;
                    }
                } catch (CancellationException exception) {
                    // Cancellations need to be treated with care here because innerFuture
                    // cancellations will bubble up, and we need to gracefully handle that.
                    Logger.get().info(TAG, String.format("%s was cancelled", workDescription), exception);
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.get().error(TAG, String.format("%s failed because it threw an exception/error", workDescription), exception);
                } finally {
                    onWorkFinished();
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        resolveIncorrectStatus();
    }
}
#method_after
private void runWorker() {
    if (tryCheckForInterruptionAndResolve()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.get().error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            resolve(false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            resolveIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            Logger.get().debug(TAG, String.format("%s is not in ENQUEUED state. Nothing more to do.", mWorkSpec.workerClassName));
            return;
        }
        if (mWorkSpec.isPeriodic() || mWorkSpec.isBackedOff()) {
            long now = System.currentTimeMillis();
            if (now < mWorkSpec.calculateNextRunTime()) {
                Logger.get().debug(TAG, String.format("Delaying execution for %s because it is being executed " + "before schedule.", mWorkSpec.workerClassName));
                // For AlarmManager implementation we need to reschedule this kind  of Work.
                // This is not a problem for JobScheduler because we will only reschedule
                // work if JobScheduler is unaware of a jobId.
                resolve(true);
                return;
            }
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.get().error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndResolve();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    WorkerParameters params = new WorkerParameters(UUID.fromString(mWorkSpecId), input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount, mConfiguration.getExecutor(), mWorkTaskExecutor, mConfiguration.getWorkerFactory());
    // in test mode.
    if (mWorker == null) {
        mWorker = mConfiguration.getWorkerFactory().createWorkerWithDefaultFallback(mAppContext, mWorkSpec.workerClassName, params);
    }
    if (mWorker == null) {
        Logger.get().error(TAG, String.format("Could not create Worker %s", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    if (mWorker.isUsed()) {
        Logger.get().error(TAG, String.format("Received an already-used Worker %s; WorkerFactory should return " + "new instances", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    mWorker.setUsed();
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndResolve()) {
            return;
        }
        final SettableFuture<ListenableWorker.Result> future = SettableFuture.create();
        // Call mWorker.startWork() on the main thread.
        mWorkTaskExecutor.getMainThreadExecutor().execute(new Runnable() {

            @Override
            public void run() {
                try {
                    Logger.get().debug(TAG, String.format("Starting work for %s", mWorkSpec.workerClassName));
                    mInnerFuture = mWorker.startWork();
                    future.setFuture(mInnerFuture);
                } catch (Throwable e) {
                    future.setException(e);
                }
            }
        });
        // Avoid synthetic accessors.
        final String workDescription = mWorkDescription;
        future.addListener(new Runnable() {

            @Override
            @SuppressLint("SyntheticAccessor")
            public void run() {
                try {
                    // If the ListenableWorker returns a null result treat it as a failure.
                    ListenableWorker.Result result = future.get();
                    if (result == null) {
                        Logger.get().error(TAG, String.format("%s returned a null result. Treating it as a failure.", mWorkSpec.workerClassName));
                    } else {
                        Logger.get().debug(TAG, String.format("%s returned a %s result.", mWorkSpec.workerClassName, result));
                        mResult = result;
                    }
                } catch (CancellationException exception) {
                    // Cancellations need to be treated with care here because innerFuture
                    // cancellations will bubble up, and we need to gracefully handle that.
                    Logger.get().info(TAG, String.format("%s was cancelled", workDescription), exception);
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.get().error(TAG, String.format("%s failed because it threw an exception/error", workDescription), exception);
                } finally {
                    onWorkFinished();
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        resolveIncorrectStatus();
    }
}
#end_block

#method_before
private void handleScheduleWorkIntent(@NonNull Intent intent, int startId, @NonNull SystemAlarmDispatcher dispatcher) {
    Bundle extras = intent.getExtras();
    String workSpecId = extras.getString(KEY_WORKSPEC_ID);
    Logger.get().debug(TAG, String.format("Handling schedule work for %s", workSpecId));
    WorkManagerImpl workManager = dispatcher.getWorkManager();
    WorkDatabase workDatabase = workManager.getWorkDatabase();
    workDatabase.beginTransaction();
    try {
        WorkSpecDao workSpecDao = workDatabase.workSpecDao();
        WorkSpec workSpec = workSpecDao.getWorkSpec(workSpecId);
        // See b/114705286.
        if (workSpec == null) {
            Logger.get().warning(TAG, "Skipping scheduling " + workSpecId + " because it's no longer in " + "the DB");
            return;
        } else if (workSpec.state.isFinished()) {
            // We need to schedule the Alarms, even when the Worker is RUNNING. This is because
            // if the process gets killed, the Alarm is necessary to pick up the execution of
            // Work.
            Logger.get().warning(TAG, "Skipping scheduling " + workSpecId + "is finished.");
            return;
        }
        // Note: The first instance of PeriodicWorker getting scheduled will set an alarm in the
        // past. This is because periodStartTime = 0.
        long triggerAt = workSpec.calculateNextRunTime();
        if (!workSpec.hasConstraints()) {
            Logger.get().debug(TAG, String.format("Setting up Alarms for %s at %s", workSpecId, triggerAt));
            Alarms.setAlarm(mContext, dispatcher.getWorkManager(), workSpecId, triggerAt);
        } else {
            // Schedule an alarm irrespective of whether all constraints matched.
            Logger.get().debug(TAG, String.format("Opportunistically setting an alarm for %s at %s", workSpecId, triggerAt));
            Alarms.setAlarm(mContext, dispatcher.getWorkManager(), workSpecId, triggerAt);
            // Schedule an update for constraint proxies
            // This in turn sets enables us to track changes in constraints
            Intent constraintsUpdate = CommandHandler.createConstraintsChangedIntent(mContext);
            dispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(dispatcher, constraintsUpdate, startId));
        }
        workDatabase.setTransactionSuccessful();
    } finally {
        workDatabase.endTransaction();
    }
}
#method_after
private void handleScheduleWorkIntent(@NonNull Intent intent, int startId, @NonNull SystemAlarmDispatcher dispatcher) {
    Bundle extras = intent.getExtras();
    String workSpecId = extras.getString(KEY_WORKSPEC_ID);
    Logger.get().debug(TAG, String.format("Handling schedule work for %s", workSpecId));
    WorkManagerImpl workManager = dispatcher.getWorkManager();
    WorkDatabase workDatabase = workManager.getWorkDatabase();
    workDatabase.beginTransaction();
    try {
        WorkSpecDao workSpecDao = workDatabase.workSpecDao();
        WorkSpec workSpec = workSpecDao.getWorkSpec(workSpecId);
        // See b/114705286.
        if (workSpec == null) {
            Logger.get().warning(TAG, "Skipping scheduling " + workSpecId + " because it's no longer in " + "the DB");
            return;
        } else if (workSpec.state.isFinished()) {
            // We need to schedule the Alarms, even when the Worker is RUNNING. This is because
            // if the process gets killed, the Alarm is necessary to pick up the execution of
            // Work.
            Logger.get().warning(TAG, "Skipping scheduling " + workSpecId + "because it is finished.");
            return;
        }
        // Note: The first instance of PeriodicWorker getting scheduled will set an alarm in the
        // past. This is because periodStartTime = 0.
        long triggerAt = workSpec.calculateNextRunTime();
        if (!workSpec.hasConstraints()) {
            Logger.get().debug(TAG, String.format("Setting up Alarms for %s at %s", workSpecId, triggerAt));
            Alarms.setAlarm(mContext, dispatcher.getWorkManager(), workSpecId, triggerAt);
        } else {
            // Schedule an alarm irrespective of whether all constraints matched.
            Logger.get().debug(TAG, String.format("Opportunistically setting an alarm for %s at %s", workSpecId, triggerAt));
            Alarms.setAlarm(mContext, dispatcher.getWorkManager(), workSpecId, triggerAt);
            // Schedule an update for constraint proxies
            // This in turn sets enables us to track changes in constraints
            Intent constraintsUpdate = CommandHandler.createConstraintsChangedIntent(mContext);
            dispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(dispatcher, constraintsUpdate, startId));
        }
        workDatabase.setTransactionSuccessful();
    } finally {
        workDatabase.endTransaction();
    }
}
#end_block

#method_before
@Test
public void testDelayMet_withAlwaysRetryWorker() throws InterruptedException {
    OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(RetryWorker.class).setPeriodStartTime(System.currentTimeMillis(), TimeUnit.MILLISECONDS).build();
    insertWork(work);
    String workSpecId = work.getStringId();
    final Intent scheduleWork = CommandHandler.createDelayMetIntent(mContext, workSpecId);
    mSpyDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(mSpyDispatcher, scheduleWork, START_ID));
    mLatch.await(TEST_TIMEOUT, TimeUnit.SECONDS);
    assertThat(mLatch.getCount(), is(0L));
    verify(mSpyProcessor, times(1)).startWork(workSpecId);
    List<String> intentActions = mSpyDispatcher.getIntentActions();
    assertThat(intentActions, IsIterableContainingInOrder.contains(CommandHandler.ACTION_DELAY_MET, CommandHandler.ACTION_EXECUTION_COMPLETED, CommandHandler.ACTION_SCHEDULE_WORK));
    WorkSpecDao workSpecDao = mDatabase.workSpecDao();
    WorkSpec workSpec = workSpecDao.getWorkSpec(work.getStringId());
    assertThat(workSpec.state, is(WorkInfo.State.ENQUEUED));
    // It should be scheduled
    assertThat(workSpec.scheduleRequestedAt, is(not(-1L)));
}
#method_after
@Test
public void testDelayMet_withAlwaysRetryWorker() throws InterruptedException {
    OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(RetryWorker.class).setPeriodStartTime(System.currentTimeMillis(), TimeUnit.MILLISECONDS).build();
    insertWork(work);
    String workSpecId = work.getStringId();
    final Intent scheduleWork = CommandHandler.createDelayMetIntent(mContext, workSpecId);
    mSpyDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(mSpyDispatcher, scheduleWork, START_ID));
    mLatch.await(TEST_TIMEOUT, TimeUnit.SECONDS);
    assertThat(mLatch.getCount(), is(0L));
    verify(mSpyProcessor, times(1)).startWork(workSpecId);
    List<String> intentActions = mSpyDispatcher.getIntentActions();
    assertThat(intentActions, IsIterableContainingInOrder.contains(CommandHandler.ACTION_DELAY_MET, CommandHandler.ACTION_EXECUTION_COMPLETED, CommandHandler.ACTION_SCHEDULE_WORK));
    WorkSpecDao workSpecDao = mDatabase.workSpecDao();
    WorkSpec workSpec = workSpecDao.getWorkSpec(work.getStringId());
    assertThat(workSpec.state, is(WorkInfo.State.ENQUEUED));
    // It should be scheduled
    assertThat(workSpec.scheduleRequestedAt, is(not(WorkSpec.SCHEDULE_NOT_REQUESTED_YET)));
}
#end_block

#method_before
private void initPrecompiledViews(boolean enablePrecompiledViews) {
    mUseCompiledView = enablePrecompiledViews;
    try {
        if (mUseCompiledView) {
            mPrecompiledClassLoader = mContext.getClassLoader();
            String dexFile = mContext.getCodeCacheDir() + COMPILED_VIEW_DEX_FILE_NAME;
            if (new File(dexFile).exists()) {
                mPrecompiledClassLoader = new PathClassLoader(dexFile, mPrecompiledClassLoader);
            } else {
                // If the precompiled layout file doesn't exist, then disable precompiled
                // layouts.
                mUseCompiledView = false;
            }
        }
    } catch (Throwable e) {
        if (DEBUG) {
            Log.e(TAG, "Failed to initialized precompiled views layouts", e);
        }
        mUseCompiledView = false;
    }
}
#method_after
private void initPrecompiledViews(boolean enablePrecompiledViews) {
    mUseCompiledView = enablePrecompiledViews;
    try {
        if (mUseCompiledView) {
            mPrecompiledClassLoader = mContext.getClassLoader();
            String dexFile = mContext.getCodeCacheDir() + COMPILED_VIEW_DEX_FILE_NAME;
            if (new File(dexFile).exists()) {
                mPrecompiledClassLoader = new PathClassLoader(dexFile, mPrecompiledClassLoader);
            } else {
                // If the precompiled layout file doesn't exist, then disable precompiled
                // layouts.
                mUseCompiledView = false;
            }
        }
    } catch (Throwable e) {
        if (DEBUG) {
            Log.e(TAG, "Failed to initialized precompiled views layouts", e);
        }
        mUseCompiledView = false;
    }
    if (!mUseCompiledView) {
        mPrecompiledClassLoader = null;
    }
}
#end_block

#method_before
@SuppressLint("RestrictedApi")
public static TextClassificationManager of(@NonNull Context context) {
    Preconditions.checkNotNull(context);
    TextClassificationManager textClassificationManager = null;
    synchronized (sLock) {
        WeakReference<TextClassificationManager> textClassificationManagerWeakReference = sMapping.get(context);
        if (textClassificationManagerWeakReference != null) {
            textClassificationManager = textClassificationManagerWeakReference.get();
        }
        if (textClassificationManager == null) {
            textClassificationManager = new TextClassificationManager(context);
        }
        sMapping.put(context, new WeakReference<>(textClassificationManager));
    }
    return textClassificationManager;
}
#method_after
@SuppressLint("RestrictedApi")
public static TextClassificationManager of(@NonNull Context context) {
    Preconditions.checkNotNull(context);
    TextClassificationManager textClassificationManager = null;
    synchronized (sLock) {
        WeakReference<TextClassificationManager> textClassificationManagerWeakReference = sMapping.get(context);
        if (textClassificationManagerWeakReference != null) {
            textClassificationManager = textClassificationManagerWeakReference.get();
        }
        if (textClassificationManager == null) {
            textClassificationManager = new TextClassificationManager(context);
            sMapping.put(context, new WeakReference<>(textClassificationManager));
        }
    }
    return textClassificationManager;
}
#end_block

#method_before
private void start() {
    final UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
    final Bundle restrictions = um.getApplicationRestrictions(getPackageName());
    sendBroadcastToAdmin(ACTION_VPN_ON_START);
    if (restrictions.getBoolean(RESTRICTION_DONT_ESTABLISH)) {
        stopSelf();
        return;
    }
    VpnService.prepare(this);
    ensureNetworkCallbackUnregistered();
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).build();
    mNetworkCallback = new ConnectivityManager.NetworkCallback() {

        @Override
        public void onAvailable(final Network net) {
            sendBroadcastToAdmin(ACTION_VPN_IS_UP);
            ensureNetworkCallbackUnregistered();
        }
    };
    mConnectivityManager.registerNetworkCallback(request, mNetworkCallback);
    Builder builder = new Builder();
    String[] addressArray = restrictions.getStringArray(RESTRICTION_ADDRESSES);
    if (addressArray == null) {
        // Addresses for IPv4/IPv6 documentation purposes according to rfc5737/rfc3849.
        addressArray = new String[] { "192.0.2.3/32", "2001:db8:1:2::/128" };
    }
    ;
    for (int i = 0; i < addressArray.length; i++) {
        String[] prefixAndMask = addressArray[i].split("/");
        try {
            InetAddress address = InetAddress.getByName(prefixAndMask[0]);
            int prefixLength = Integer.parseInt(prefixAndMask[1]);
            builder.addAddress(address, prefixLength);
        } catch (NumberFormatException | UnknownHostException e) {
            Log.w(TAG, "Ill-formed address: " + addressArray[i]);
            continue;
        }
    }
    String[] routeArray = restrictions.getStringArray(RESTRICTION_ROUTES);
    if (routeArray == null) {
        routeArray = new String[] { "0.0.0.0/0", "::/0" };
    }
    for (int i = 0; i < routeArray.length; i++) {
        String[] prefixAndMask = routeArray[i].split("/");
        try {
            InetAddress address = InetAddress.getByName(prefixAndMask[0]);
            int prefixLength = Integer.parseInt(prefixAndMask[1]);
            builder.addRoute(address, prefixLength);
        } catch (NumberFormatException | UnknownHostException e) {
            Log.w(TAG, "Ill-formed route: " + routeArray[i]);
            continue;
        }
    }
    String[] allowedArray = restrictions.getStringArray(RESTRICTION_ALLOWED);
    if (allowedArray != null) {
        for (int i = 0; i < allowedArray.length; i++) {
            String allowedPackage = allowedArray[i];
            if (!TextUtils.isEmpty(allowedPackage)) {
                try {
                    builder.addAllowedApplication(allowedPackage);
                } catch (NameNotFoundException e) {
                    Log.w(TAG, "Allowed package not found: " + allowedPackage);
                    continue;
                }
            }
        }
    }
    String[] disallowedArray = restrictions.getStringArray(RESTRICTION_DISALLOWED);
    if (disallowedArray != null) {
        for (int i = 0; i < disallowedArray.length; i++) {
            String disallowedPackage = disallowedArray[i];
            if (!TextUtils.isEmpty(disallowedPackage)) {
                try {
                    builder.addDisallowedApplication(disallowedPackage);
                } catch (NameNotFoundException e) {
                    Log.w(TAG, "Disallowed package not found: " + disallowedPackage);
                    continue;
                }
            }
        }
    }
    builder.setMtu(MTU);
    builder.setBlocking(true);
    builder.setSession(TAG);
    mFd = builder.establish();
    if (mFd == null) {
        Log.e(TAG, "Unable to establish file descriptor for VPN connection");
        return;
    }
    Log.i(TAG, "Established, fd=" + mFd.getFd());
    mPingReflector = new PingReflector(mFd.getFileDescriptor(), MTU);
    mPingReflector.start();
}
#method_after
private void start() {
    final UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
    final Bundle restrictions = um.getApplicationRestrictions(getPackageName());
    sendBroadcastToAdmin(ACTION_VPN_ON_START);
    if (restrictions.getBoolean(RESTRICTION_DONT_ESTABLISH)) {
        stopSelf();
        return;
    }
    VpnService.prepare(this);
    ensureNetworkCallbackUnregistered();
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).build();
    mNetworkCallback = new ConnectivityManager.NetworkCallback() {

        @Override
        public void onAvailable(final Network net) {
            sendBroadcastToAdmin(ACTION_VPN_IS_UP);
            ensureNetworkCallbackUnregistered();
        }
    };
    mConnectivityManager.registerNetworkCallback(request, mNetworkCallback);
    Builder builder = new Builder();
    String[] addressArray = restrictions.getStringArray(RESTRICTION_ADDRESSES);
    if (addressArray == null) {
        // Addresses for IPv4/IPv6 documentation purposes according to rfc5737/rfc3849.
        addressArray = new String[] { "192.0.2.3/32", "2001:db8:1:2::/128" };
    }
    ;
    for (int i = 0; i < addressArray.length; i++) {
        String[] prefixAndMask = addressArray[i].split("/");
        try {
            InetAddress address = InetAddress.getByName(prefixAndMask[0]);
            int prefixLength = Integer.parseInt(prefixAndMask[1]);
            builder.addAddress(address, prefixLength);
        } catch (NumberFormatException | UnknownHostException e) {
            Log.w(TAG, "Ill-formed address: " + addressArray[i]);
            continue;
        }
    }
    String[] routeArray = restrictions.getStringArray(RESTRICTION_ROUTES);
    if (routeArray == null) {
        routeArray = new String[] { "0.0.0.0/0", "::/0" };
    }
    for (int i = 0; i < routeArray.length; i++) {
        String[] prefixAndMask = routeArray[i].split("/");
        try {
            InetAddress address = InetAddress.getByName(prefixAndMask[0]);
            int prefixLength = Integer.parseInt(prefixAndMask[1]);
            builder.addRoute(address, prefixLength);
        } catch (NumberFormatException | UnknownHostException e) {
            Log.w(TAG, "Ill-formed route: " + routeArray[i]);
            continue;
        }
    }
    String[] allowedArray = restrictions.getStringArray(RESTRICTION_ALLOWED);
    if (allowedArray != null) {
        for (int i = 0; i < allowedArray.length; i++) {
            String allowedPackage = allowedArray[i];
            if (!TextUtils.isEmpty(allowedPackage)) {
                try {
                    builder.addAllowedApplication(allowedPackage);
                } catch (NameNotFoundException e) {
                    Log.w(TAG, "Allowed package not found: " + allowedPackage);
                    continue;
                }
            }
        }
    }
    String[] disallowedArray = restrictions.getStringArray(RESTRICTION_DISALLOWED);
    if (disallowedArray != null) {
        for (int i = 0; i < disallowedArray.length; i++) {
            String disallowedPackage = disallowedArray[i];
            if (!TextUtils.isEmpty(disallowedPackage)) {
                try {
                    builder.addDisallowedApplication(disallowedPackage);
                } catch (NameNotFoundException e) {
                    Log.w(TAG, "Disallowed package not found: " + disallowedPackage);
                    continue;
                }
            }
        }
    }
    if (allowedArray == null && (SystemProperties.getInt("persist.adb.tcp.port", -1) > -1 || SystemProperties.getInt("service.adb.tcp.port", -1) > -1)) {
        try {
            // If adb TCP port opened the test may be running by adb over network.
            // Add com.android.shell application into blacklist to exclude adb socket
            // for VPN tests.
            builder.addDisallowedApplication("com.android.shell");
        } catch (NameNotFoundException e) {
            Log.w(TAG, "com.android.shell not found");
        }
    }
    builder.setMtu(MTU);
    builder.setBlocking(true);
    builder.setSession(TAG);
    mFd = builder.establish();
    if (mFd == null) {
        Log.e(TAG, "Unable to establish file descriptor for VPN connection");
        return;
    }
    Log.i(TAG, "Established, fd=" + mFd.getFd());
    mPingReflector = new PingReflector(mFd.getFileDescriptor(), MTU);
    mPingReflector.start();
}
#end_block

#method_before
private void sendBroadcastToAdmin(String action) {
    final Intent vpnIsUpIntent = new Intent(action);
    vpnIsUpIntent.setPackage(DEVICE_AND_PROFILE_OWNER_PACKAGE);
    sendBroadcast(vpnIsUpIntent);
}
#method_after
private void sendBroadcastToAdmin(String action) {
    final Intent intent = new Intent(action);
    intent.setPackage(DEVICE_AND_PROFILE_OWNER_PACKAGE);
    sendBroadcast(intent);
}
#end_block

#method_before
@RequiresDevice
public void testAlwaysOnVpnAcrossReboot() throws Exception {
    // password during reboot, which we can't handle easily.
    if (!mHasFeature || !mSupportsFbe) {
        return;
    }
    // Set a password to encrypt the user
    final String testPassword = "1234";
    changeUserCredential(testPassword, null, /*oldCredential*/
    mUserId);
    try {
        installAppAsUser(VPN_APP_APK, mUserId);
        executeDeviceTestMethod(".AlwaysOnVpnMultiStageTest", "testAlwaysOnSetWithWhitelist");
        rebootAndWaitUntilReady();
        verifyUserCredential(testPassword, mUserId);
        executeDeviceTestMethod(".AlwaysOnVpnMultiStageTest", "testAlwaysOnSetAfterReboot");
    } finally {
        changeUserCredential(null, /*newCredential*/
        testPassword, mUserId);
        executeDeviceTestMethod(".AlwaysOnVpnMultiStageTest", "testCleanup");
    }
}
#method_after
@RequiresDevice
public void testAlwaysOnVpnAcrossReboot() throws Exception {
    // password during reboot, which we can't handle easily.
    if (!mHasFeature || !mSupportsFbe) {
        return;
    }
    // Set a password to encrypt the user
    final String testPassword = "1234";
    changeUserCredential(testPassword, null, /*oldCredential*/
    mUserId);
    try {
        installAppAsUser(VPN_APP_APK, mUserId);
        executeDeviceTestMethod(".AlwaysOnVpnMultiStageTest", "testAlwaysOnSetWithWhitelist");
        rebootAndWaitUntilReady();
        // Make sure profile user initialization is complete before proceeding.
        waitForBroadcastIdle();
        verifyUserCredential(testPassword, mUserId);
        executeDeviceTestMethod(".AlwaysOnVpnMultiStageTest", "testAlwaysOnSetAfterReboot");
    } finally {
        changeUserCredential(null, /*newCredential*/
        testPassword, mUserId);
        executeDeviceTestMethod(".AlwaysOnVpnMultiStageTest", "testCleanup");
    }
}
#end_block

#method_before
public void testAlwaysOnSetAfterReboot() throws Exception {
    VpnTestHelper.waitForVpn(mContext, null, /* usable */
    true, /* whitelist */
    true);
    VpnTestHelper.checkPing(TEST_ADDRESS);
    final List<String> whitelist = mDevicePolicyManager.getAlwaysOnVpnLockdownWhitelist(ADMIN_RECEIVER_COMPONENT);
    assertTrue("Lockdown bit lost after reboot", mDevicePolicyManager.getAlwaysOnVpnLockdownEnabled(ADMIN_RECEIVER_COMPONENT));
    assertNotNull("whitelist is lost after reboot", whitelist);
    assertTrue("whitelist changed after reboot", whitelist.size() == 1 && mContext.getPackageName().equals(whitelist.get(0)));
}
#method_after
public void testAlwaysOnSetAfterReboot() throws Exception {
    VpnTestHelper.waitForVpn(mContext, null, /* usable */
    true, /* whitelist */
    true);
    VpnTestHelper.checkPing(TEST_ADDRESS);
    final List<String> whitelist = mDevicePolicyManager.getAlwaysOnVpnLockdownWhitelist(ADMIN_RECEIVER_COMPONENT);
    assertTrue("Lockdown bit lost after reboot", mDevicePolicyManager.isAlwaysOnVpnLockdownEnabled(ADMIN_RECEIVER_COMPONENT));
    assertNotNull("whitelist is lost after reboot", whitelist);
    assertTrue("whitelist changed after reboot", whitelist.size() == 1 && mContext.getPackageName().equals(whitelist.get(0)));
}
#end_block

#method_before
public void testVpnLockdownUpdateWhitelist() throws Exception {
    assertConnectivity(true, "VPN is off");
    // VPN won't start.
    final Bundle restrictions = new Bundle();
    restrictions.putBoolean(RESTRICTION_DONT_ESTABLISH, true);
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    // VPN service is started asynchronously, we need to wait for it to avoid starting a
    // service using stale app restrictions.
    final BlockingBroadcastReceiver receiver = VpnTestHelper.registerOnStartReceiver(mContext);
    VpnTestHelper.setAlwaysOnVpn(mContext, VPN_PACKAGE);
    assertConnectivity(true, "VPN service not started, no lockdown");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    false);
    assertConnectivity(false, "VPN in lockdown, service not started");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    true);
    assertConnectivity(true, "VPN in lockdown, service not started, app whitelisted");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    false);
    assertConnectivity(false, "VPN in lockdown, service not started");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    receiver.unregisterQuietly();
}
#method_after
public void testVpnLockdownUpdateWhitelist() throws Exception {
    assertConnectivity(true, "VPN is off");
    // VPN won't start.
    final Bundle restrictions = new Bundle();
    restrictions.putBoolean(RESTRICTION_DONT_ESTABLISH, true);
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    // VPN service is started asynchronously, we need to wait for it to avoid stale service
    // instance interfering with the next test.
    final BlockingBroadcastReceiver receiver = VpnTestHelper.registerOnStartReceiver(mContext);
    VpnTestHelper.setAlwaysOnVpnWithoutLockdown(mContext, VPN_PACKAGE);
    assertConnectivity(true, "VPN service not started, no lockdown");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    false);
    assertConnectivity(false, "VPN in lockdown, service not started");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    true);
    assertConnectivity(true, "VPN in lockdown, service not started, app whitelisted");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    false);
    assertConnectivity(false, "VPN in lockdown, service not started");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    receiver.unregisterQuietly();
}
#end_block

#method_before
public void testVpnLockdownWhitelistVpnComesUp() throws Exception {
    assertConnectivity(true, "VPN is off");
    // VPN won't start initially.
    final Bundle restrictions = new Bundle();
    restrictions.putBoolean(RESTRICTION_DONT_ESTABLISH, true);
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    // VPN service is started asynchronously, we need to wait for it to avoid starting a
    // service using stale app restrictions.
    final BlockingBroadcastReceiver receiver = VpnTestHelper.registerOnStartReceiver(mContext);
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    true);
    assertConnectivity(true, "VPN in lockdown, service not started, app whitelisted");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    // Make VPN workable again and restart.
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, null);
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* usable */
    true, /* whitelist */
    true);
    // Now we should be on VPN.
    VpnTestHelper.checkPing(TEST_ADDRESS);
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    receiver.unregisterQuietly();
}
#method_after
public void testVpnLockdownWhitelistVpnComesUp() throws Exception {
    assertConnectivity(true, "VPN is off");
    // VPN won't start initially.
    final Bundle restrictions = new Bundle();
    restrictions.putBoolean(RESTRICTION_DONT_ESTABLISH, true);
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);
    // VPN service is started asynchronously, we need to wait for it to avoid stale service
    // instance interfering with the next test.
    final BlockingBroadcastReceiver receiver = VpnTestHelper.registerOnStartReceiver(mContext);
    VpnTestHelper.setAlwaysOnVpnWithLockdown(mContext, VPN_PACKAGE, /* whitelist */
    true);
    assertConnectivity(true, "VPN in lockdown, service not started, app whitelisted");
    assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));
    // Make VPN workable again and restart.
    mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, null);
    VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE, /* usable */
    true, /* whitelist */
    true);
    // Now we should be on VPN.
    VpnTestHelper.checkPing(TEST_ADDRESS);
    receiver.unregisterQuietly();
}
#end_block

#method_before
private void assertConnectivity(boolean expected, String message) {
    try {
        new Socket(CONNECTIVITY_CHECK_HOST, 80);
        if (!expected)
            fail("Connectivity available while not expected: " + message);
    } catch (IOException e) {
        if (expected) {
            Log.e(TAG, "Connectivity check failed", e);
            fail("Connectivity isn't available while expected: " + message);
        }
    }
}
#method_after
private void assertConnectivity(boolean shouldHaveConnectivity, String message) {
    try {
        new Socket(CONNECTIVITY_CHECK_HOST, 80);
        if (!shouldHaveConnectivity) {
            fail("Connectivity available while not expected: " + message);
        }
    } catch (IOException e) {
        if (shouldHaveConnectivity) {
            Log.e(TAG, "Connectivity check failed", e);
            fail("Connectivity isn't available while expected: " + message);
        }
    }
}
#end_block

#method_before
public static void setAlwaysOnVpnWithLockdown(Context context, String packageName, boolean whitelist) throws PackageManager.NameNotFoundException {
    final DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
    final List<String> lockdownWhitelist = whitelist ? Collections.singletonList(context.getPackageName()) : Collections.emptyList();
    dpm.setAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT, packageName, true, lockdownWhitelist);
    assertEquals(packageName, dpm.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    assertTrue(dpm.getAlwaysOnVpnLockdownEnabled(ADMIN_RECEIVER_COMPONENT));
    assertEquals(lockdownWhitelist, dpm.getAlwaysOnVpnLockdownWhitelist(ADMIN_RECEIVER_COMPONENT));
}
#method_after
public static void setAlwaysOnVpnWithLockdown(Context context, String packageName, boolean whitelist) throws PackageManager.NameNotFoundException {
    final DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
    final List<String> lockdownWhitelist = whitelist ? Collections.singletonList(context.getPackageName()) : Collections.emptyList();
    dpm.setAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT, packageName, true, lockdownWhitelist);
    assertEquals(packageName, dpm.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    assertTrue(dpm.isAlwaysOnVpnLockdownEnabled(ADMIN_RECEIVER_COMPONENT));
    assertEquals(lockdownWhitelist, dpm.getAlwaysOnVpnLockdownWhitelist(ADMIN_RECEIVER_COMPONENT));
}
#end_block

#method_before
Stream<String> getLibraries() {
    try {
        String result = runShellCommand(getInstrumentation(), "cmd package list libraries");
        return Arrays.stream(result.split("\n")).map(line -> line.split(":")[1]);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private Stream<String> getLibraries() {
    try {
        String result = runShellCommand(getInstrumentation(), "cmd package list libraries");
        return Arrays.stream(result.split("\n")).map(line -> line.split(":")[1]);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
boolean checkLibrary(String name) {
    if (!checkLibraryNames) {
        return true;
    }
    String libraryName = name.substring(name.lastIndexOf('/') + 1).split("-")[0];
    if (getLibraries().filter(lib -> lib.equals(libraryName)).findAny().isPresent()) {
        return true;
    }
    return false;
}
#method_after
private boolean checkLibrary(String name) {
    if (!checkLibraryNames) {
        return true;
    }
    String libraryName = name.substring(name.lastIndexOf('/') + 1).split("-")[0];
    if (getLibraries().filter(lib -> lib.equals(libraryName)).findAny().isPresent()) {
        return true;
    }
    return false;
}
#end_block

#method_before
Stream<InputStream> readFile(File file) {
    try {
        if (file.getName().endsWith(".zip")) {
            ZipFile zip = new ZipFile(file);
            return zip.stream().filter(entry -> checkLibrary(entry.getName())).map(entry -> {
                try {
                    return zip.getInputStream(entry);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
        } else {
            return Stream.of(new FileInputStream(file));
        }
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
protected Stream<InputStream> readFile(File file) {
    try {
        if (file.getName().endsWith(".zip")) {
            ZipFile zip = new ZipFile(file);
            return zip.stream().filter(entry -> checkLibrary(entry.getName())).map(entry -> {
                try {
                    return zip.getInputStream(entry);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
        } else {
            return Stream.of(new FileInputStream(file));
        }
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
Stream<JDiffClassDescription> parseApiFilesAsStream(ApiDocumentParser apiDocumentParser, String[] apiFiles) throws XmlPullParserException, IOException {
    return Stream.of(apiFiles).map(name -> new File(API_FILE_DIRECTORY + "/" + name)).flatMap(file -> readFile(file)).flatMap(stream -> {
        try {
            return apiDocumentParser.parseAsStream(stream).filter(AbstractApiTest::isAccessibleClass);
        } catch (IOException | XmlPullParserException e) {
            throw new RuntimeException(e);
        }
    });
}
#method_after
protected Stream<JDiffClassDescription> parseApiFilesAsStream(ApiDocumentParser apiDocumentParser, String[] apiFiles) throws XmlPullParserException, IOException {
    return Stream.of(apiFiles).map(name -> new File(API_FILE_DIRECTORY + "/" + name)).flatMap(file -> readFile(file)).flatMap(stream -> {
        try {
            return apiDocumentParser.parseAsStream(stream).filter(AbstractApiTest::isAccessibleClass);
        } catch (IOException | XmlPullParserException e) {
            throw new RuntimeException(e);
        }
    });
}
#end_block

#method_before
@Override
protected void initializeFromArgs(Bundle instrumentationArgs) throws Exception {
    expectedApiFiles = getCommaSeparatedList(instrumentationArgs, "expected-api-files");
    baseApiFiles = getCommaSeparatedList(instrumentationArgs, "base-api-files");
    unexpectedApiFiles = getCommaSeparatedList(instrumentationArgs, "unexpected-api-files");
    String checkLibraryNames = instrumentationArgs.getString("check-library-names");
    if (checkLibraryNames != null && checkLibraryNames.equals("true")) {
        setCheckLibraryNames();
    }
}
#method_after
@Override
protected void initializeFromArgs(Bundle instrumentationArgs) throws Exception {
    expectedApiFiles = getCommaSeparatedList(instrumentationArgs, "expected-api-files");
    baseApiFiles = getCommaSeparatedList(instrumentationArgs, "base-api-files");
    unexpectedApiFiles = getCommaSeparatedList(instrumentationArgs, "unexpected-api-files");
    String checkLibraryNames = instrumentationArgs.getString("check-library-names");
    if (Boolean.valueOf(checkLibraryNames)) {
        setCheckLibraryNames();
    }
}
#end_block

#method_before
public void notifyInterfaceClassActivity(int type, boolean isActive, long tsNanos, int uid, boolean fromRadio) {
    final boolean isMobile = ConnectivityManager.isNetworkTypeMobile(type);
    int powerState = isActive ? DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH : DataConnectionRealTimeInfo.DC_POWER_STATE_LOW;
    if (isMobile) {
        if (!fromRadio) {
            if (mMobileActivityFromRadio) {
                // If this call is not coming from a report from the radio itself, but we
                // have previously received reports from the radio, then we will take the
                // power state to just be whatever the radio last reported.
                powerState = mLastPowerStateFromRadio;
            }
        } else {
            mMobileActivityFromRadio = true;
        }
        if (mLastPowerStateFromRadio != powerState) {
            mLastPowerStateFromRadio = powerState;
            try {
                getBatteryStats().noteMobileRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    if (ConnectivityManager.isNetworkTypeWifi(type)) {
        if (mLastPowerStateFromWifi != powerState) {
            mLastPowerStateFromWifi = powerState;
            try {
                getBatteryStats().noteWifiRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    if (!isMobile || fromRadio || !mMobileActivityFromRadio) {
        // Report the change in data activity.  We don't do this if this is a change
        // on the mobile network, that is not coming from the radio itself, and we
        // have previously seen change reports from the radio.  In that case only
        // the radio is the authority for the current state.
        final boolean active = isActive;
        super.notifyInterfaceClassActivity(type, isActive, tsNanos, uid, fromRadio);
    }
    boolean report = false;
    synchronized (mIdleTimerLock) {
        if (mActiveIdleTimers.isEmpty()) {
            // If there are no idle timers, we are not monitoring activity, so we
            // are always considered active.
            isActive = true;
        }
        if (mNetworkActive != isActive) {
            mNetworkActive = isActive;
            report = isActive;
        }
    }
    if (report) {
        reportNetworkActive();
    }
}
#method_after
@Override
public void notifyInterfaceClassActivity(int type, boolean isActive, long tsNanos, int uid, boolean fromRadio) {
    final boolean isMobile = ConnectivityManager.isNetworkTypeMobile(type);
    int powerState = isActive ? DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH : DataConnectionRealTimeInfo.DC_POWER_STATE_LOW;
    if (isMobile) {
        if (!fromRadio) {
            if (mMobileActivityFromRadio) {
                // If this call is not coming from a report from the radio itself, but we
                // have previously received reports from the radio, then we will take the
                // power state to just be whatever the radio last reported.
                powerState = mLastPowerStateFromRadio;
            }
        } else {
            mMobileActivityFromRadio = true;
        }
        if (mLastPowerStateFromRadio != powerState) {
            mLastPowerStateFromRadio = powerState;
            try {
                getBatteryStats().noteMobileRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    if (ConnectivityManager.isNetworkTypeWifi(type)) {
        if (mLastPowerStateFromWifi != powerState) {
            mLastPowerStateFromWifi = powerState;
            try {
                getBatteryStats().noteWifiRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    if (!isMobile || fromRadio || !mMobileActivityFromRadio) {
        // Report the change in data activity.  We don't do this if this is a change
        // on the mobile network, that is not coming from the radio itself, and we
        // have previously seen change reports from the radio.  In that case only
        // the radio is the authority for the current state.
        final boolean active = isActive;
        super.notifyInterfaceClassActivity(type, isActive, tsNanos, uid, fromRadio);
    }
    boolean report = false;
    synchronized (mIdleTimerLock) {
        if (mActiveIdleTimers.isEmpty()) {
            // If there are no idle timers, we are not monitoring activity, so we
            // are always considered active.
            isActive = true;
        }
        if (mNetworkActive != isActive) {
            mNetworkActive = isActive;
            report = isActive;
        }
    }
    if (report) {
        reportNetworkActive();
    }
}
#end_block

#method_before
public void notifyInterfaceRemoved(String iface) {
    // netd already clears out quota and alerts for removed ifaces; update
    // our sanity-checking state.
    mActiveAlerts.remove(iface);
    mActiveQuotas.remove(iface);
    super.notifyInterfaceRemoved(iface);
}
#method_after
@Override
public void notifyInterfaceRemoved(String iface) {
    // netd already clears out quota and alerts for removed ifaces; update
    // our sanity-checking state.
    mActiveAlerts.remove(iface);
    mActiveQuotas.remove(iface);
    super.notifyInterfaceRemoved(iface);
}
#end_block

#method_before
private void connectNativeNetdService() {
    mNetdService = mServices.getNetd();
    try {
        mNetworkObserverRegistry.register(mNetdService);
        if (DBG)
            Slog.d(TAG, "Register unsolicited event listener");
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Failed to set Netd unsolicited event listener " + e);
    }
}
#method_after
private void connectNativeNetdService() {
    mNetdService = mServices.getNetd();
    try {
        mNetworkObserverRegistry = new NMSNetworkObserverRegistry(mContext, mDaemonHandler, mNetdService);
        if (DBG)
            Slog.d(TAG, "Registered NetworkObserverRegistry");
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.wtf(TAG, "Failed to register NetworkObserverRegistry: " + e);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message message) {
    synchronized (mLock) {
        if (!mReadyToRock) {
            return;
        }
        switch(message.what) {
            case MSG_JOB_EXPIRED:
                {
                    JobStatus runNow = (JobStatus) message.obj;
                    // state is such that all ready jobs should be run immediately.
                    if (runNow != null && isReadyToBeExecutedLocked(runNow)) {
                        mJobPackageTracker.notePending(runNow);
                        addOrderedItem(mPendingJobs, runNow, mEnqueueTimeComparator);
                    } else {
                        queueReadyJobsForExecutionLocked();
                    }
                }
                break;
            case MSG_CHECK_JOB:
                if (mReportedActive) {
                    // if jobs are currently being run, queue all ready jobs for execution.
                    queueReadyJobsForExecutionLocked();
                } else {
                    // Check the list of jobs and run some of them if we feel inclined.
                    maybeQueueReadyJobsForExecutionLocked();
                }
                break;
            case MSG_CHECK_JOB_GREEDY:
                queueReadyJobsForExecutionLocked();
                break;
            case MSG_STOP_JOB:
                cancelJobImplLocked((JobStatus) message.obj, null, "app no longer allowed to run");
                break;
            case MSG_UID_STATE_CHANGED:
                {
                    final int uid = message.arg1;
                    final int procState = message.arg2;
                    updateUidState(uid, procState);
                    break;
                }
            case MSG_UID_GONE:
                {
                    final int uid = message.arg1;
                    final boolean disabled = message.arg2 != 0;
                    updateUidState(uid, ActivityManager.PROCESS_STATE_CACHED_EMPTY);
                    if (disabled) {
                        cancelJobsForUid(uid, "uid gone");
                    }
                    synchronized (mLock) {
                        mDeviceIdleJobsController.setUidActiveLocked(uid, false);
                    }
                    break;
                }
            case MSG_UID_ACTIVE:
                {
                    final int uid = message.arg1;
                    synchronized (mLock) {
                        mDeviceIdleJobsController.setUidActiveLocked(uid, true);
                    }
                    break;
                }
            case MSG_UID_IDLE:
                {
                    final int uid = message.arg1;
                    final boolean disabled = message.arg2 != 0;
                    if (disabled) {
                        cancelJobsForUid(uid, "app uid idle");
                    }
                    synchronized (mLock) {
                        mDeviceIdleJobsController.setUidActiveLocked(uid, false);
                    }
                    break;
                }
        }
        maybeRunPendingJobsLocked();
        // Don't remove JOB_EXPIRED in case one came along while processing the queue.
        if (message.what == MSG_CHECK_JOB)
            removeMessages(MSG_CHECK_JOB);
    }
}
#method_after
@Override
public void handleMessage(Message message) {
    synchronized (mLock) {
        if (!mReadyToRock) {
            return;
        }
        switch(message.what) {
            case MSG_JOB_EXPIRED:
                {
                    JobStatus runNow = (JobStatus) message.obj;
                    // state is such that all ready jobs should be run immediately.
                    if (runNow != null && isReadyToBeExecutedLocked(runNow)) {
                        mJobPackageTracker.notePending(runNow);
                        addOrderedItem(mPendingJobs, runNow, mEnqueueTimeComparator);
                    } else {
                        queueReadyJobsForExecutionLocked();
                    }
                }
                break;
            case MSG_CHECK_JOB:
                removeMessages(MSG_CHECK_JOB);
                if (mReportedActive) {
                    // if jobs are currently being run, queue all ready jobs for execution.
                    queueReadyJobsForExecutionLocked();
                } else {
                    // Check the list of jobs and run some of them if we feel inclined.
                    maybeQueueReadyJobsForExecutionLocked();
                }
                break;
            case MSG_CHECK_JOB_GREEDY:
                queueReadyJobsForExecutionLocked();
                break;
            case MSG_STOP_JOB:
                cancelJobImplLocked((JobStatus) message.obj, null, "app no longer allowed to run");
                break;
            case MSG_UID_STATE_CHANGED:
                {
                    final int uid = message.arg1;
                    final int procState = message.arg2;
                    updateUidState(uid, procState);
                    break;
                }
            case MSG_UID_GONE:
                {
                    final int uid = message.arg1;
                    final boolean disabled = message.arg2 != 0;
                    updateUidState(uid, ActivityManager.PROCESS_STATE_CACHED_EMPTY);
                    if (disabled) {
                        cancelJobsForUid(uid, "uid gone");
                    }
                    synchronized (mLock) {
                        mDeviceIdleJobsController.setUidActiveLocked(uid, false);
                    }
                    break;
                }
            case MSG_UID_ACTIVE:
                {
                    final int uid = message.arg1;
                    synchronized (mLock) {
                        mDeviceIdleJobsController.setUidActiveLocked(uid, true);
                    }
                    break;
                }
            case MSG_UID_IDLE:
                {
                    final int uid = message.arg1;
                    final boolean disabled = message.arg2 != 0;
                    if (disabled) {
                        cancelJobsForUid(uid, "app uid idle");
                    }
                    synchronized (mLock) {
                        mDeviceIdleJobsController.setUidActiveLocked(uid, false);
                    }
                    break;
                }
        }
        maybeRunPendingJobsLocked();
    // Don't remove JOB_EXPIRED in case one came along while processing the queue.
    }
}
#end_block

#method_before
@Override
public boolean onPreferenceTreeClick(Preference preference) {
    if (preference.getFragment() != null) {
        boolean handled = false;
        if (getCallbackFragment() instanceof OnPreferenceStartFragmentCallback) {
            handled = ((OnPreferenceStartFragmentCallback) getCallbackFragment()).onPreferenceStartFragment(this, preference);
        }
        if (!handled && getActivity() instanceof OnPreferenceStartFragmentCallback) {
            handled = ((OnPreferenceStartFragmentCallback) getActivity()).onPreferenceStartFragment(this, preference);
        }
        if (!handled) {
            Log.w(TAG, "onPreferenceStartFragment is not implemented in the parent activity - " + "attempting to use a fallback implementation. You should " + "implement this method so that you can configure the new " + "fragment that will be displayed, and set a transition between " + "the fragments.");
            final FragmentManager fragmentManager = requireActivity().getSupportFragmentManager();
            final Fragment fragment = fragmentManager.getFragmentFactory().instantiate(requireActivity().getClassLoader(), preference.getFragment());
            fragment.setArguments(preference.getExtras());
            fragment.setTargetFragment(this, 0);
            fragmentManager.beginTransaction().replace((((View) getView().getParent()).getId()), fragment).addToBackStack(null).commit();
        }
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onPreferenceTreeClick(Preference preference) {
    if (preference.getFragment() != null) {
        boolean handled = false;
        if (getCallbackFragment() instanceof OnPreferenceStartFragmentCallback) {
            handled = ((OnPreferenceStartFragmentCallback) getCallbackFragment()).onPreferenceStartFragment(this, preference);
        }
        if (!handled && getActivity() instanceof OnPreferenceStartFragmentCallback) {
            handled = ((OnPreferenceStartFragmentCallback) getActivity()).onPreferenceStartFragment(this, preference);
        }
        if (!handled) {
            Log.w(TAG, "onPreferenceStartFragment is not implemented in the parent activity - " + "attempting to use a fallback implementation. You should " + "implement this method so that you can configure the new " + "fragment that will be displayed, and set a transition between " + "the fragments.");
            final FragmentManager fragmentManager = requireActivity().getSupportFragmentManager();
            final Bundle args = preference.getExtras();
            final Fragment fragment = fragmentManager.getFragmentFactory().instantiate(requireActivity().getClassLoader(), preference.getFragment(), args);
            fragment.setArguments(args);
            fragment.setTargetFragment(this, 0);
            fragmentManager.beginTransaction().replace((((View) getView().getParent()).getId()), fragment).addToBackStack(null).commit();
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void onNavigateToScreen(PreferenceScreen preferenceScreen) {
    boolean handled = false;
    if (getCallbackFragment() instanceof OnPreferenceStartScreenCallback) {
        handled = ((OnPreferenceStartScreenCallback) getCallbackFragment()).onPreferenceStartScreen(this, preferenceScreen);
    }
    if (!handled && getActivity() instanceof OnPreferenceStartScreenCallback) {
        handled = ((OnPreferenceStartScreenCallback) getActivity()).onPreferenceStartScreen(this, preferenceScreen);
    }
    if (!handled) {
        Log.w(TAG, "onPreferenceStartScreen is not implemented in the parent activity - " + "attempting to use a fallback implementation. You should implement " + "this method so that you can configure the new fragment that will " + "display the nested hierarchy, and set a transition between the " + "fragments.");
        // Try and use a new instance of this fragment to display the nested hierarchy
        final FragmentManager fragmentManager = requireActivity().getSupportFragmentManager();
        final Fragment fragment = fragmentManager.getFragmentFactory().instantiate(requireActivity().getClassLoader(), getClass().getName());
        final Bundle args = new Bundle(1);
        args.putString(PreferenceFragmentCompat.ARG_PREFERENCE_ROOT, preferenceScreen.getKey());
        fragment.setArguments(args);
        fragmentManager.beginTransaction().replace((((View) getView().getParent()).getId()), fragment).addToBackStack(null).commit();
    }
}
#method_after
@Override
public void onNavigateToScreen(PreferenceScreen preferenceScreen) {
    boolean handled = false;
    if (getCallbackFragment() instanceof OnPreferenceStartScreenCallback) {
        handled = ((OnPreferenceStartScreenCallback) getCallbackFragment()).onPreferenceStartScreen(this, preferenceScreen);
    }
    if (!handled && getActivity() instanceof OnPreferenceStartScreenCallback) {
        handled = ((OnPreferenceStartScreenCallback) getActivity()).onPreferenceStartScreen(this, preferenceScreen);
    }
    if (!handled) {
        Log.w(TAG, "onPreferenceStartScreen is not implemented in the parent activity - " + "attempting to use a fallback implementation. You should implement " + "this method so that you can configure the new fragment that will " + "display the nested hierarchy, and set a transition between the " + "fragments.");
        // Try and use a new instance of this fragment to display the nested hierarchy
        final FragmentManager fragmentManager = requireActivity().getSupportFragmentManager();
        final Bundle args = new Bundle(1);
        args.putString(PreferenceFragmentCompat.ARG_PREFERENCE_ROOT, preferenceScreen.getKey());
        final Fragment fragment = fragmentManager.getFragmentFactory().instantiate(requireActivity().getClassLoader(), getClass().getName(), args);
        fragment.setArguments(args);
        fragmentManager.beginTransaction().replace((((View) getView().getParent()).getId()), fragment).addToBackStack(null).commit();
    }
}
#end_block

#method_before
@NonNull
public Fragment instantiate(@NonNull ClassLoader classLoader, @NonNull String className) {
    try {
        Class<? extends Fragment> cls = Fragment.parseFragmentClass(classLoader, className);
        return cls.getConstructor().newInstance();
    } catch (java.lang.InstantiationException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (IllegalAccessException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (NoSuchMethodException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": could not find Fragment constructor", e);
    } catch (InvocationTargetException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": calling Fragment constructor caused an exception", e);
    }
}
#method_after
@NonNull
public Fragment instantiate(@NonNull ClassLoader classLoader, @NonNull String className, @SuppressWarnings("unused") @Nullable Bundle args) {
    try {
        Class<? extends Fragment> cls = loadFragmentClass(classLoader, className);
        return cls.getConstructor().newInstance();
    } catch (java.lang.InstantiationException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (IllegalAccessException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (NoSuchMethodException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": could not find Fragment constructor", e);
    } catch (InvocationTargetException e) {
        throw new Fragment.InstantiationException("Unable to instantiate fragment " + className + ": calling Fragment constructor caused an exception", e);
    }
}
#end_block

#method_before
@Deprecated
public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) {
    try {
        Class<? extends Fragment> clazz = parseFragmentClass(context.getClassLoader(), fname);
        Fragment f = clazz.getConstructor().newInstance();
        if (args != null) {
            args.setClassLoader(f.getClass().getClassLoader());
            f.setArguments(args);
        }
        return f;
    } catch (java.lang.InstantiationException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (IllegalAccessException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (NoSuchMethodException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": could not find Fragment constructor", e);
    } catch (InvocationTargetException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": calling Fragment constructor caused an exception", e);
    }
}
#method_after
@Deprecated
public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) {
    try {
        Class<? extends Fragment> clazz = FragmentFactory.loadFragmentClass(context.getClassLoader(), fname);
        Fragment f = clazz.getConstructor().newInstance();
        if (args != null) {
            args.setClassLoader(f.getClass().getClassLoader());
            f.setArguments(args);
        }
        return f;
    } catch (java.lang.InstantiationException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (IllegalAccessException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": make sure class name exists, is public, and has an" + " empty constructor that is public", e);
    } catch (NoSuchMethodException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": could not find Fragment constructor", e);
    } catch (InvocationTargetException e) {
        throw new InstantiationException("Unable to instantiate fragment " + fname + ": calling Fragment constructor caused an exception", e);
    }
}
#end_block

#method_before
@Override
public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
    if (!"fragment".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, "class");
    TypedArray a = context.obtainStyledAttributes(attrs, FragmentTag.Fragment);
    if (fname == null) {
        fname = a.getString(FragmentTag.Fragment_name);
    }
    int id = a.getResourceId(FragmentTag.Fragment_id, View.NO_ID);
    String tag = a.getString(FragmentTag.Fragment_tag);
    a.recycle();
    if (fname == null || !Fragment.isSupportFragmentClass(mHost.getContext(), fname)) {
        // This will allow android.app.Fragments to do the right thing.
        return null;
    }
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Must specify unique android:id, android:tag, or have a parent with an id for " + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, "onCreateView: id=0x" + Integer.toHexString(id) + " fname=" + fname + " existing=" + fragment);
    if (fragment == null) {
        fragment = getFragmentFactory().instantiate(context.getClassLoader(), fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.mHost = mHost;
        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Duplicate id 0x" + Integer.toHexString(id) + ", tag " + tag + ", or parent id 0x" + Integer.toHexString(containerId) + " with another fragment for " + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        fragment.mHost = mHost;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        }
    }
    // for compliant fragments below.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException("Fragment " + fname + " did not create a view.");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}
#method_after
@Override
public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
    if (!"fragment".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, "class");
    TypedArray a = context.obtainStyledAttributes(attrs, FragmentTag.Fragment);
    if (fname == null) {
        fname = a.getString(FragmentTag.Fragment_name);
    }
    int id = a.getResourceId(FragmentTag.Fragment_id, View.NO_ID);
    String tag = a.getString(FragmentTag.Fragment_tag);
    a.recycle();
    if (fname == null || !FragmentFactory.isFragmentClass(context.getClassLoader(), fname)) {
        // This will allow android.app.Fragments to do the right thing.
        return null;
    }
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Must specify unique android:id, android:tag, or have a parent with an id for " + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, "onCreateView: id=0x" + Integer.toHexString(id) + " fname=" + fname + " existing=" + fragment);
    if (fragment == null) {
        fragment = getFragmentFactory().instantiate(context.getClassLoader(), fname, null);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.mHost = mHost;
        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Duplicate id 0x" + Integer.toHexString(id) + ", tag " + tag + ", or parent id 0x" + Integer.toHexString(containerId) + " with another fragment for " + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        fragment.mHost = mHost;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        }
    }
    // for compliant fragments below.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException("Fragment " + fname + " did not create a view.");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}
#end_block

#method_before
@Override
public Fragment getItem(int position) {
    TabInfo info = mTabs.get(position);
    Fragment fragment = mFragmentFactory.instantiate(mContext.getClassLoader(), info.clss.getName());
    fragment.setArguments(info.args);
    return fragment;
}
#method_after
@Override
public Fragment getItem(int position) {
    TabInfo info = mTabs.get(position);
    Fragment fragment = mFragmentFactory.instantiate(mContext.getClassLoader(), info.clss.getName(), info.args);
    fragment.setArguments(info.args);
    return fragment;
}
#end_block

#method_before
public Fragment instantiate(FragmentHostCallback host, @NonNull FragmentFactory factory, Fragment parent, FragmentManagerNonConfig childNonConfig, ViewModelStore viewModelStore) {
    if (mInstance == null) {
        final Context context = host.getContext();
        final ClassLoader classLoader = context.getClassLoader();
        if (mArguments != null) {
            mArguments.setClassLoader(classLoader);
        }
        mInstance = factory.instantiate(classLoader, mClassName);
        mInstance.setArguments(mArguments);
        if (mSavedFragmentState != null) {
            mSavedFragmentState.setClassLoader(classLoader);
            mInstance.mSavedFragmentState = mSavedFragmentState;
        }
        mInstance.setIndex(mIndex, parent);
        mInstance.mFromLayout = mFromLayout;
        mInstance.mRestored = true;
        mInstance.mFragmentId = mFragmentId;
        mInstance.mContainerId = mContainerId;
        mInstance.mTag = mTag;
        mInstance.mRetainInstance = mRetainInstance;
        mInstance.mDetached = mDetached;
        mInstance.mHidden = mHidden;
        mInstance.mFragmentManager = host.mFragmentManager;
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, "Instantiated fragment " + mInstance);
        }
    }
    mInstance.mChildNonConfig = childNonConfig;
    mInstance.mViewModelStore = viewModelStore;
    return mInstance;
}
#method_after
public Fragment instantiate(FragmentHostCallback host, @NonNull FragmentFactory factory, Fragment parent, FragmentManagerNonConfig childNonConfig, ViewModelStore viewModelStore) {
    if (mInstance == null) {
        final Context context = host.getContext();
        final ClassLoader classLoader = context.getClassLoader();
        if (mArguments != null) {
            mArguments.setClassLoader(classLoader);
        }
        mInstance = factory.instantiate(classLoader, mClassName, mArguments);
        mInstance.setArguments(mArguments);
        if (mSavedFragmentState != null) {
            mSavedFragmentState.setClassLoader(classLoader);
            mInstance.mSavedFragmentState = mSavedFragmentState;
        }
        mInstance.setIndex(mIndex, parent);
        mInstance.mFromLayout = mFromLayout;
        mInstance.mRestored = true;
        mInstance.mFragmentId = mFragmentId;
        mInstance.mContainerId = mContainerId;
        mInstance.mTag = mTag;
        mInstance.mRetainInstance = mRetainInstance;
        mInstance.mDetached = mDetached;
        mInstance.mHidden = mHidden;
        mInstance.mFragmentManager = host.mFragmentManager;
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, "Instantiated fragment " + mInstance);
        }
    }
    mInstance.mChildNonConfig = childNonConfig;
    mInstance.mViewModelStore = viewModelStore;
    return mInstance;
}
#end_block

#method_before
@Nullable
private FragmentTransaction doTabChanged(@Nullable String tag, @Nullable FragmentTransaction ft) {
    final TabInfo newTab = getTabInfoForTag(tag);
    if (mLastTab != newTab) {
        if (ft == null) {
            ft = mFragmentManager.beginTransaction();
        }
        if (mLastTab != null) {
            if (mLastTab.fragment != null) {
                ft.detach(mLastTab.fragment);
            }
        }
        if (newTab != null) {
            if (newTab.fragment == null) {
                newTab.fragment = mFragmentManager.getFragmentFactory().instantiate(mContext.getClassLoader(), newTab.clss.getName());
                newTab.fragment.setArguments(newTab.args);
                ft.add(mContainerId, newTab.fragment, newTab.tag);
            } else {
                ft.attach(newTab.fragment);
            }
        }
        mLastTab = newTab;
    }
    return ft;
}
#method_after
@Nullable
private FragmentTransaction doTabChanged(@Nullable String tag, @Nullable FragmentTransaction ft) {
    final TabInfo newTab = getTabInfoForTag(tag);
    if (mLastTab != newTab) {
        if (ft == null) {
            ft = mFragmentManager.beginTransaction();
        }
        if (mLastTab != null) {
            if (mLastTab.fragment != null) {
                ft.detach(mLastTab.fragment);
            }
        }
        if (newTab != null) {
            if (newTab.fragment == null) {
                newTab.fragment = mFragmentManager.getFragmentFactory().instantiate(mContext.getClassLoader(), newTab.clss.getName(), newTab.args);
                newTab.fragment.setArguments(newTab.args);
                ft.add(mContainerId, newTab.fragment, newTab.tag);
            } else {
                ft.attach(newTab.fragment);
            }
        }
        mLastTab = newTab;
    }
    return ft;
}
#end_block

#method_before
@Override
public boolean onPreferenceStartFragment(PreferenceFragmentCompat caller, Preference pref) {
    final Fragment f = getChildFragmentManager().getFragmentFactory().instantiate(requireActivity().getClassLoader(), pref.getFragment());
    f.setArguments(pref.getExtras());
    f.setTargetFragment(caller, 0);
    if (f instanceof PreferenceFragmentCompat || f instanceof PreferenceDialogFragmentCompat) {
        startPreferenceFragment(f);
    } else {
        startImmersiveFragment(f);
    }
    return true;
}
#method_after
@Override
public boolean onPreferenceStartFragment(PreferenceFragmentCompat caller, Preference pref) {
    final Bundle args = pref.getExtras();
    final Fragment f = getChildFragmentManager().getFragmentFactory().instantiate(requireActivity().getClassLoader(), pref.getFragment(), args);
    f.setArguments(args);
    f.setTargetFragment(caller, 0);
    if (f instanceof PreferenceFragmentCompat || f instanceof PreferenceDialogFragmentCompat) {
        startPreferenceFragment(f);
    } else {
        startImmersiveFragment(f);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean onPreferenceStartFragment(PreferenceFragmentCompat caller, Preference pref) {
    final Fragment f = getChildFragmentManager().getFragmentFactory().instantiate(requireActivity().getClassLoader(), pref.getFragment());
    f.setArguments(pref.getExtras());
    f.setTargetFragment(caller, 0);
    if (f instanceof PreferenceFragmentCompat || f instanceof PreferenceDialogFragmentCompat) {
        startPreferenceFragment(f);
    } else {
        startImmersiveFragment(f);
    }
    return true;
}
#method_after
@Override
public boolean onPreferenceStartFragment(PreferenceFragmentCompat caller, Preference pref) {
    final Bundle args = pref.getExtras();
    final Fragment f = getChildFragmentManager().getFragmentFactory().instantiate(requireActivity().getClassLoader(), pref.getFragment(), args);
    f.setArguments(args);
    f.setTargetFragment(caller, 0);
    if (f instanceof PreferenceFragmentCompat || f instanceof PreferenceDialogFragmentCompat) {
        startPreferenceFragment(f);
    } else {
        startImmersiveFragment(f);
    }
    return true;
}
#end_block

#method_before
@MediumTest
public void test_getProxyServiceConnect() {
    if (!(mIsBleSupported && mIsHearingAidSupported))
        return;
    // Wait for the Profile to be ready
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
}
#method_after
@MediumTest
public void test_getProxyServiceConnect() {
    if (!(mIsBleSupported && mIsHearingAidSupported))
        return;
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
}
#end_block

#method_before
@MediumTest
public void test_getConnectionState() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    // Wait for the Profile to be ready
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    // Create a dummy device
    BluetoothDevice device = mBluetoothAdapter.getRemoteDevice("00:11:22:AA:BB:CC");
    assertNotNull(device);
    int connectionState = mService.getConnectionState(device);
    // Dummy device should be disconnected
    assertEquals(connectionState, BluetoothProfile.STATE_DISCONNECTED);
}
#method_after
@MediumTest
public void test_getConnectionState() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    // Create a dummy device
    BluetoothDevice device = mBluetoothAdapter.getRemoteDevice("00:11:22:AA:BB:CC");
    assertNotNull(device);
    int connectionState = mService.getConnectionState(device);
    // Dummy device should be disconnected
    assertEquals(connectionState, BluetoothProfile.STATE_DISCONNECTED);
}
#end_block

#method_before
@MediumTest
public void test_getConnectedDevices() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    // Wait for the Profile to be ready
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    List<BluetoothDevice> deviceList;
    deviceList = mService.getConnectedDevices();
    Log.d(TAG, "getConnectedDevices(): size=" + deviceList.size());
    for (BluetoothDevice device : deviceList) {
        int connectionState = mService.getConnectionState(device);
        checkValidConnectionState(connectionState);
    }
}
#method_after
@MediumTest
public void test_getConnectedDevices() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    List<BluetoothDevice> deviceList;
    deviceList = mService.getConnectedDevices();
    Log.d(TAG, "getConnectedDevices(): size=" + deviceList.size());
    for (BluetoothDevice device : deviceList) {
        int connectionState = mService.getConnectionState(device);
        checkValidConnectionState(connectionState);
    }
}
#end_block

#method_before
@MediumTest
public void test_getDevicesMatchingConnectionStates() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    // Wait for the Profile to be ready
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    for (int connectionState : mValidConnectionStates) {
        List<BluetoothDevice> deviceList;
        deviceList = mService.getDevicesMatchingConnectionStates(new int[] { connectionState });
        assertNotNull(deviceList);
        Log.d(TAG, "getDevicesMatchingConnectionStates(" + connectionState + "): size=" + deviceList.size());
        checkDeviceListAndStates(deviceList, connectionState);
    }
}
#method_after
@MediumTest
public void test_getDevicesMatchingConnectionStates() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    for (int connectionState : mValidConnectionStates) {
        List<BluetoothDevice> deviceList;
        deviceList = mService.getDevicesMatchingConnectionStates(new int[] { connectionState });
        assertNotNull(deviceList);
        Log.d(TAG, "getDevicesMatchingConnectionStates(" + connectionState + "): size=" + deviceList.size());
        checkDeviceListAndStates(deviceList, connectionState);
    }
}
#end_block

#method_before
@MediumTest
public void test_getConnectionStateChangedIntent() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    // Wait for the Profile to be ready
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    // Find out how many Hearing Aid bonded devices
    List<BluetoothDevice> bondedDeviceList = new ArrayList();
    int numDevices = 0;
    for (int connectionState : mValidConnectionStates) {
        List<BluetoothDevice> deviceList;
        deviceList = mService.getDevicesMatchingConnectionStates(new int[] { connectionState });
        bondedDeviceList.addAll(deviceList);
        numDevices += deviceList.size();
    }
    if (numDevices <= 0)
        return;
    Log.d(TAG, "Number Hearing Aids devices bonded=" + numDevices);
    mIntentCallbackDeviceList = new ArrayList();
    // Set up the Connection State Changed receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
    mIntentReceiver = new HearingAidIntentReceiver();
    mContext.registerReceiver(mIntentReceiver, filter);
    Log.d(TAG, "test_getConnectionStateChangedIntent: disable adapter and wait");
    assertTrue(disableAdapter());
    Log.d(TAG, "test_getConnectionStateChangedIntent: enable adapter and wait");
    assertTrue(enableAdapter());
    Log.d(TAG, "test_getConnectionStateChangedIntent: re-enable adapter and wait");
    mBluetoothAdapter.enable();
    int sanityCount = WAIT_FOR_INTENT_TIMEOUT_MS;
    while ((numDevices != mIntentCallbackDeviceList.size()) && (sanityCount > 0)) {
        final int SLEEP_QUANTUM_MS = 100;
        sleep(SLEEP_QUANTUM_MS);
        sanityCount -= SLEEP_QUANTUM_MS;
    }
    // Tear down
    mContext.unregisterReceiver(mIntentReceiver);
    Log.d(TAG, "test_getConnectionStateChangedIntent: number of bonded device=" + numDevices + ", mIntentCallbackDeviceList.size()=" + mIntentCallbackDeviceList.size());
    for (BluetoothDevice device : mIntentCallbackDeviceList) {
        assertTrue(bondedDeviceList.contains(device));
    }
}
#method_after
@MediumTest
public void test_getConnectionStateChangedIntent() {
    if (!(mIsBleSupported && mIsHearingAidSupported)) {
        return;
    }
    waitForProfileConnect();
    assertTrue(mIsProfileReady);
    assertNotNull(mService);
    // Find out how many Hearing Aid bonded devices
    List<BluetoothDevice> bondedDeviceList = new ArrayList();
    int numDevices = 0;
    for (int connectionState : mValidConnectionStates) {
        List<BluetoothDevice> deviceList;
        deviceList = mService.getDevicesMatchingConnectionStates(new int[] { connectionState });
        bondedDeviceList.addAll(deviceList);
        numDevices += deviceList.size();
    }
    if (numDevices <= 0)
        return;
    Log.d(TAG, "Number Hearing Aids devices bonded=" + numDevices);
    mIntentCallbackDeviceList = new ArrayList();
    // Set up the Connection State Changed receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
    mIntentReceiver = new HearingAidIntentReceiver();
    mContext.registerReceiver(mIntentReceiver, filter);
    Log.d(TAG, "test_getConnectionStateChangedIntent: disable adapter and wait");
    assertTrue(disableAdapter());
    Log.d(TAG, "test_getConnectionStateChangedIntent: enable adapter and wait");
    assertTrue(enableAdapter());
    int sanityCount = WAIT_FOR_INTENT_TIMEOUT_MS;
    while ((numDevices != mIntentCallbackDeviceList.size()) && (sanityCount > 0)) {
        final int SLEEP_QUANTUM_MS = 100;
        sleep(SLEEP_QUANTUM_MS);
        sanityCount -= SLEEP_QUANTUM_MS;
    }
    // Tear down
    mContext.unregisterReceiver(mIntentReceiver);
    Log.d(TAG, "test_getConnectionStateChangedIntent: number of bonded device=" + numDevices + ", mIntentCallbackDeviceList.size()=" + mIntentCallbackDeviceList.size());
    for (BluetoothDevice device : mIntentCallbackDeviceList) {
        assertTrue(bondedDeviceList.contains(device));
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {
        int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, -1);
        int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);
        Log.d(TAG, "Previous state: " + previousState + " New state: " + newState);
        if (newState == BluetoothAdapter.STATE_ON) {
            mAdapterStateEnablinglock.lock();
            try {
                mConditionAdapterIsEnabled.signal();
            } finally {
                mAdapterStateEnablinglock.unlock();
            }
        } else if (newState == BluetoothAdapter.STATE_OFF) {
            mAdapterStateDisablinglock.lock();
            try {
                mAdapterOffSignalReceived = true;
                mConditionAdapterIsDisabled.signal();
            } finally {
                mAdapterStateDisablinglock.unlock();
            }
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {
        int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, -1);
        int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);
        Log.d(TAG, "Previous state: " + previousState + " New state: " + newState);
        if (newState == BluetoothAdapter.STATE_ON) {
            mAdapterStateEnablinglock.lock();
            try {
                mConditionAdapterIsEnabled.signal();
            } finally {
                mAdapterStateEnablinglock.unlock();
            }
        } else if (newState == BluetoothAdapter.STATE_OFF) {
            mAdapterStateDisablinglock.lock();
            mAdapterOffSignalReceived = true;
            try {
                mConditionAdapterIsDisabled.signal();
            } finally {
                mAdapterStateDisablinglock.unlock();
            }
        }
    }
}
#end_block

#method_before
private boolean disableAdapter() {
    // Note: !mBluetoothAdapter.isEnabled() is not an accurate indication that the
    // BluetoothAdapter is OFF.
    mBluetoothAdapter.disable();
    mAdapterOffSignalReceived = false;
    mAdapterStateDisablinglock.lock();
    try {
        // Wait for the Adapter to be disabled
        while (!mAdapterOffSignalReceived) {
            if (!mConditionAdapterIsDisabled.await(ADAPTER_ENABLE_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                // Timeout
                Log.e(TAG, "Timeout while waiting for the Bluetooth Adapter disable");
                break;
            }
        // else spurious wakeups
        }
    } catch (InterruptedException e) {
        Log.e(TAG, "enableAdapter: interrrupted");
    } finally {
        mAdapterStateDisablinglock.unlock();
    }
    return mAdapterOffSignalReceived;
}
#method_after
private boolean disableAdapter() {
    // Note: !mBluetoothAdapter.isEnabled() is not an accurate indication that the
    // BluetoothAdapter is OFF.
    mBluetoothAdapter.disable();
    mAdapterOffSignalReceived = false;
    mAdapterStateDisablinglock.lock();
    try {
        // Wait for the Adapter to be disabled
        while (!mAdapterOffSignalReceived) {
            if (!mConditionAdapterIsDisabled.await(ADAPTER_DISABLE_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                // Timeout
                Log.e(TAG, "Timeout while waiting for the Bluetooth Adapter disable");
                break;
            }
        // else spurious wakeups
        }
    } catch (InterruptedException e) {
        Log.e(TAG, "enableAdapter: interrrupted");
    } finally {
        mAdapterStateDisablinglock.unlock();
    }
    return mAdapterOffSignalReceived;
}
#end_block

#method_before
public void onServiceConnected(int profile, BluetoothProfile proxy) {
    mProfileConnectedlock.lock();
    mService = (BluetoothHearingAid) proxy;
    try {
        mIsProfileReady = true;
        mConditionProfileIsConnected.signal();
    } finally {
        mProfileConnectedlock.unlock();
    }
}
#method_after
public void onServiceConnected(int profile, BluetoothProfile proxy) {
    mProfileConnectedlock.lock();
    mService = (BluetoothHearingAid) proxy;
    mIsProfileReady = true;
    try {
        mConditionProfileIsConnected.signal();
    } finally {
        mProfileConnectedlock.unlock();
    }
}
#end_block

#method_before
@Override
protected void initializeFromArgs(Bundle instrumentationArgs) throws Exception {
    libraryNames = getCommaSeparatedList(instrumentationArgs, "library-name");
    versions = getCommaSeparatedList(instrumentationArgs, "version");
    api_levels = getCommaSeparatedList(instrumentationArgs, "api_level");
    super.initializeFromArgs(instrumentationArgs);
}
#method_after
@Override
protected void initializeFromArgs(Bundle instrumentationArgs) throws Exception {
    libraryNames = getCommaSeparatedList(instrumentationArgs, "library-names");
    versions = getCommaSeparatedList(instrumentationArgs, "versions");
    api_levels = getCommaSeparatedList(instrumentationArgs, "api_levels");
    super.initializeFromArgs(instrumentationArgs);
}
#end_block

#method_before
@Override
public void testSignature() {
    String[] packageListLibraries;
    try {
        packageListLibraries = getLibraries();
    } catch (Exception e) {
        return;
    }
    ArrayList<String> expected = new ArrayList<>();
    for (String lib : libraryNames) {
        if (Arrays.stream(packageListLibraries).filter(name -> name.equals(lib)).findAny().isPresent()) {
            for (String ver : versions) {
                for (String api_level : api_levels) {
                    expected.add(lib + "-" + ver + "-" + api_level + ".api");
                }
            }
        }
    }
    expectedApiFiles = expected.toArray(new String[expected.size()]);
    super.testSignature();
}
#method_after
@Override
public void testSignature() {
    Stream<String> packageListLibraries = getLibraries();
    ArrayList<String> expected = new ArrayList<>();
    packageListLibraries.forEach(lib -> {
        if (Arrays.asList(libraryNames).indexOf(lib) >= 0) {
            for (String ver : versions) {
                for (String api_level : api_levels) {
                    expected.add(lib + "-" + ver + "-" + api_level + ".api");
                }
            }
        }
    });
    expectedApiFiles = expected.toArray(new String[expected.size()]);
    super.testSignature();
}
#end_block

#method_before
private String[] getLibraries() throws Exception {
    String result = runShellCommand(getInstrumentation(), "cmd package list libraries");
    return Arrays.stream(result.split("\n")).map(line -> line.split(":")[1]).toArray(size -> new String[size]);
}
#method_after
private Stream<String> getLibraries() {
    try {
        String result = runShellCommand(getInstrumentation(), "cmd package list libraries");
        return Arrays.stream(result.split("\n")).map(line -> line.split(":")[1]);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Test
public void testSetUp_install() throws Exception {
    Set<String> set = new HashSet<>();
    doReturn(set).when(mMockDevice).getInstalledPackageNames();
    doReturn(1).when(mMockDevice).getCurrentUser();
    doReturn(null).when(mMockDevice).installPackageForUser(any(), eq(true), eq(true), eq(1));
    assertTrue(mProvider.setUp());
}
#method_after
@Test
public void testSetUp_install() throws Exception {
    Set<String> set = new HashSet<>();
    doReturn(set).when(mMockDevice).getInstalledPackageNames();
    doReturn(1).when(mMockDevice).getCurrentUser();
    doReturn(null).when(mMockDevice).installPackage(any(), eq(true), eq(true));
    assertTrue(mProvider.setUp());
}
#end_block

#method_before
@Test
public void testSetUp_installFail() throws Exception {
    Set<String> set = new HashSet<>();
    doReturn(set).when(mMockDevice).getInstalledPackageNames();
    doReturn(1).when(mMockDevice).getCurrentUser();
    doReturn("fail").when(mMockDevice).installPackageForUser(any(), eq(true), eq(true), eq(1));
    assertFalse(mProvider.setUp());
}
#method_after
@Test
public void testSetUp_installFail() throws Exception {
    Set<String> set = new HashSet<>();
    doReturn(set).when(mMockDevice).getInstalledPackageNames();
    doReturn(1).when(mMockDevice).getCurrentUser();
    doReturn("fail").when(mMockDevice).installPackage(any(), eq(true), eq(true));
    assertFalse(mProvider.setUp());
}
#end_block

#method_before
public boolean setUp() throws DeviceNotAvailableException, IOException {
    Set<String> packageNames = mDevice.getInstalledPackageNames();
    if (packageNames.contains(PACKAGE_NAME)) {
        return true;
    }
    if (mContentProviderApk == null) {
        mContentProviderApk = extractResourceApk();
    }
    String output = mDevice.installPackageForUser(mContentProviderApk, true, true, mDevice.getCurrentUser());
    if (output == null) {
        return true;
    }
    CLog.e("Something went wrong while installing the content provider apk: %s", output);
    FileUtil.deleteFile(mContentProviderApk);
    return false;
}
#method_after
public boolean setUp() throws DeviceNotAvailableException, IOException {
    Set<String> packageNames = mDevice.getInstalledPackageNames();
    if (packageNames.contains(PACKAGE_NAME)) {
        return true;
    }
    if (mContentProviderApk == null) {
        mContentProviderApk = extractResourceApk();
    }
    // Install package for all users
    String output = mDevice.installPackage(mContentProviderApk, true, true);
    if (output == null) {
        return true;
    }
    CLog.e("Something went wrong while installing the content provider apk: %s", output);
    FileUtil.deleteFile(mContentProviderApk);
    return false;
}
#end_block

#method_before
int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {
    if (getChildCount() == 0 || dy == 0) {
        return 0;
    }
    mLayoutState.mRecycle = true;
    ensureLayoutState();
    final int layoutDirection = dy > 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;
    final int absDy = Math.abs(dy);
    updateLayoutState(layoutDirection, absDy, true, state);
    final int consumed = mLayoutState.mScrollingOffset + fill(recycler, mLayoutState, state, false);
    if (consumed < 0) {
        if (DEBUG) {
            Log.d(TAG, "Don't have any more elements to scroll");
        }
        return 0;
    }
    final int scrolled = absDy > consumed ? layoutDirection * consumed : dy;
    mOrientationHelper.offsetChildren(-scrolled);
    if (DEBUG) {
        Log.d(TAG, "scroll req: " + dy + " scrolled: " + scrolled);
    }
    mLayoutState.mLastScrollDelta = scrolled;
    return scrolled;
}
#method_after
int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {
    if (getChildCount() == 0 || dy == 0) {
        return 0;
    }
    ensureLayoutState();
    mLayoutState.mRecycle = true;
    final int layoutDirection = dy > 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;
    final int absDy = Math.abs(dy);
    updateLayoutState(layoutDirection, absDy, true, state);
    final int consumed = mLayoutState.mScrollingOffset + fill(recycler, mLayoutState, state, false);
    if (consumed < 0) {
        if (DEBUG) {
            Log.d(TAG, "Don't have any more elements to scroll");
        }
        return 0;
    }
    final int scrolled = absDy > consumed ? layoutDirection * consumed : dy;
    mOrientationHelper.offsetChildren(-scrolled);
    if (DEBUG) {
        Log.d(TAG, "scroll req: " + dy + " scrolled: " + scrolled);
    }
    mLayoutState.mLastScrollDelta = scrolled;
    return scrolled;
}
#end_block

#method_before
@Override
public void onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount) {
    mSpanSizeLookup.invalidateSpanIndexCache();
}
#method_after
@Override
public void onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount) {
    mSpanSizeLookup.invalidateSpanIndexCache();
    mSpanSizeLookup.invalidateSpanGroupIndexCache();
}
#end_block

#method_before
@Override
public void onItemsChanged(RecyclerView recyclerView) {
    mSpanSizeLookup.invalidateSpanIndexCache();
}
#method_after
@Override
public void onItemsChanged(RecyclerView recyclerView) {
    mSpanSizeLookup.invalidateSpanIndexCache();
    mSpanSizeLookup.invalidateSpanGroupIndexCache();
}
#end_block

#method_before
@Override
public void onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount) {
    mSpanSizeLookup.invalidateSpanIndexCache();
}
#method_after
@Override
public void onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount) {
    mSpanSizeLookup.invalidateSpanIndexCache();
    mSpanSizeLookup.invalidateSpanGroupIndexCache();
}
#end_block

#method_before
@Override
public void onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount, Object payload) {
    mSpanSizeLookup.invalidateSpanIndexCache();
}
#method_after
@Override
public void onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount, Object payload) {
    mSpanSizeLookup.invalidateSpanIndexCache();
    mSpanSizeLookup.invalidateSpanGroupIndexCache();
}
#end_block

#method_before
@Override
public void onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount) {
    mSpanSizeLookup.invalidateSpanIndexCache();
}
#method_after
@Override
public void onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount) {
    mSpanSizeLookup.invalidateSpanIndexCache();
    mSpanSizeLookup.invalidateSpanGroupIndexCache();
}
#end_block

#method_before
private int getSpanGroupIndex(RecyclerView.Recycler recycler, RecyclerView.State state, int viewPosition) {
    if (!state.isPreLayout()) {
        return mSpanSizeLookup.getSpanGroupIndex(viewPosition, mSpanCount);
    }
    final int adapterPosition = recycler.convertPreLayoutPositionToPostLayout(viewPosition);
    if (adapterPosition == -1) {
        if (DEBUG) {
            throw new RuntimeException("Cannot find span group index for position " + viewPosition);
        }
        Log.w(TAG, "Cannot find span size for pre layout position. " + viewPosition);
        return 0;
    }
    return mSpanSizeLookup.getSpanGroupIndex(adapterPosition, mSpanCount);
}
#method_after
private int getSpanGroupIndex(RecyclerView.Recycler recycler, RecyclerView.State state, int viewPosition) {
    if (!state.isPreLayout()) {
        return mSpanSizeLookup.getCachedSpanGroupIndex(viewPosition, mSpanCount);
    }
    final int adapterPosition = recycler.convertPreLayoutPositionToPostLayout(viewPosition);
    if (adapterPosition == -1) {
        if (DEBUG) {
            throw new RuntimeException("Cannot find span group index for position " + viewPosition);
        }
        Log.w(TAG, "Cannot find span size for pre layout position. " + viewPosition);
        return 0;
    }
    return mSpanSizeLookup.getCachedSpanGroupIndex(adapterPosition, mSpanCount);
}
#end_block

#method_before
public void setSpanIndexCacheEnabled(boolean cacheSpanIndices) {
    mCacheSpanIndices = cacheSpanIndices;
}
#method_after
public void setSpanIndexCacheEnabled(boolean cacheSpanIndices) {
    if (!cacheSpanIndices) {
        mSpanGroupIndexCache.clear();
    }
    mCacheSpanIndices = cacheSpanIndices;
}
#end_block

#method_before
public int getSpanIndex(int position, int spanCount) {
    int positionSpanSize = getSpanSize(position);
    if (positionSpanSize == spanCount) {
        // quick return for full-span items
        return 0;
    }
    int span = 0;
    int startPos = 0;
    // If caching is enabled, try to jump
    if (mCacheSpanIndices && mSpanIndexCache.size() > 0) {
        int prevKey = findReferenceIndexFromCache(position);
        if (prevKey >= 0) {
            span = mSpanIndexCache.get(prevKey) + getSpanSize(prevKey);
            startPos = prevKey + 1;
        }
    }
    for (int i = startPos; i < position; i++) {
        int size = getSpanSize(i);
        span += size;
        if (span == spanCount) {
            span = 0;
        } else if (span > spanCount) {
            // did not fit, moving to next row / column
            span = size;
        }
    }
    if (span + positionSpanSize <= spanCount) {
        return span;
    }
    return 0;
}
#method_after
public int getSpanIndex(int position, int spanCount) {
    int positionSpanSize = getSpanSize(position);
    if (positionSpanSize == spanCount) {
        // quick return for full-span items
        return 0;
    }
    int span = 0;
    int startPos = 0;
    // If caching is enabled, try to jump
    if (mCacheSpanIndices) {
        int prevKey = findFirstKeyLessThan(mSpanIndexCache, position);
        if (prevKey >= 0) {
            span = mSpanIndexCache.get(prevKey) + getSpanSize(prevKey);
            startPos = prevKey + 1;
        }
    }
    for (int i = startPos; i < position; i++) {
        int size = getSpanSize(i);
        span += size;
        if (span == spanCount) {
            span = 0;
        } else if (span > spanCount) {
            // did not fit, moving to next row / column
            span = size;
        }
    }
    if (span + positionSpanSize <= spanCount) {
        return span;
    }
    return 0;
}
#end_block

#method_before
public int getSpanGroupIndex(int adapterPosition, int spanCount) {
    int span = 0;
    int group = 0;
    int positionSpanSize = getSpanSize(adapterPosition);
    for (int i = 0; i < adapterPosition; i++) {
        int size = getSpanSize(i);
        span += size;
        if (span == spanCount) {
            span = 0;
            group++;
        } else if (span > spanCount) {
            // did not fit, moving to next row / column
            span = size;
            group++;
        }
    }
    if (span + positionSpanSize > spanCount) {
        group++;
    }
    return group;
}
#method_after
public int getSpanGroupIndex(int adapterPosition, int spanCount) {
    int span = 0;
    int group = 0;
    int start = 0;
    if (mCacheSpanGroupIndices) {
        // This finds the first non empty cached group cache key.
        int prevKey = findFirstKeyLessThan(mSpanGroupIndexCache, adapterPosition);
        if (prevKey != -1) {
            group = mSpanGroupIndexCache.get(prevKey);
            start = prevKey + 1;
            span = getCachedSpanIndex(prevKey, spanCount) + getSpanSize(prevKey);
            if (span == spanCount) {
                span = 0;
                group++;
            }
        }
    }
    int positionSpanSize = getSpanSize(adapterPosition);
    for (int i = start; i < adapterPosition; i++) {
        int size = getSpanSize(i);
        span += size;
        if (span == spanCount) {
            span = 0;
            group++;
        } else if (span > spanCount) {
            // did not fit, moving to next row / column
            span = size;
            group++;
        }
    }
    if (span + positionSpanSize > spanCount) {
        group++;
    }
    return group;
}
#end_block

#method_before
@Override
public int computeHorizontalScrollRange(RecyclerView.State state) {
    return computeScrollRange(state);
}
#method_after
@Override
public int computeHorizontalScrollRange(RecyclerView.State state) {
    if (mUsingSpansToEstimateScrollBarDimensions) {
        return computeScrollRangeWithSpanInfo(state);
    } else {
        return super.computeHorizontalScrollRange(state);
    }
}
#end_block

#method_before
@Override
public int computeVerticalScrollRange(RecyclerView.State state) {
    return computeScrollRange(state);
}
#method_after
@Override
public int computeVerticalScrollRange(RecyclerView.State state) {
    if (mUsingSpansToEstimateScrollBarDimensions) {
        return computeScrollRangeWithSpanInfo(state);
    } else {
        return super.computeVerticalScrollRange(state);
    }
}
#end_block

#method_before
@Override
public int computeHorizontalScrollOffset(RecyclerView.State state) {
    return super.computeHorizontalScrollOffset(state);
}
#method_after
@Override
public int computeHorizontalScrollOffset(RecyclerView.State state) {
    if (mUsingSpansToEstimateScrollBarDimensions) {
        return computeScrollOffsetWithSpanInfo(state);
    } else {
        return super.computeHorizontalScrollOffset(state);
    }
}
#end_block

#method_before
@Override
public int computeVerticalScrollOffset(RecyclerView.State state) {
    return computeScrollOffset(state);
}
#method_after
@Override
public int computeVerticalScrollOffset(RecyclerView.State state) {
    if (mUsingSpansToEstimateScrollBarDimensions) {
        return computeScrollOffsetWithSpanInfo(state);
    } else {
        return super.computeVerticalScrollOffset(state);
    }
}
#end_block

#method_before
@Test
public void leftUnfocusableViewsVisibility() throws Throwable {
    // The maximum number of columns that can be fully in-bounds of RV.
    final int visibleColCount = 5;
    final int spanCount = 3;
    final int consecutiveFocusableColsCount = 4;
    final int consecutiveUnFocusableColsCount = 8;
    final int itemCount = (consecutiveFocusableColsCount + consecutiveUnFocusableColsCount) * spanCount;
    final RecyclerView recyclerView = setupBasic(new Config(spanCount, itemCount).orientation(HORIZONTAL).reverseLayout(true), new GridTestAdapter(itemCount, 1) {

        RecyclerView mAttachedRv;

        @Override
        public TestViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
            TestViewHolder testViewHolder = super.onCreateViewHolder(parent, viewType);
            // Good to have colors for debugging
            StateListDrawable stl = new StateListDrawable();
            stl.addState(new int[] { android.R.attr.state_focused }, new ColorDrawable(Color.RED));
            stl.addState(StateSet.WILD_CARD, new ColorDrawable(Color.BLUE));
            // noinspection deprecation using this for kitkat tests
            testViewHolder.itemView.setBackgroundDrawable(stl);
            return testViewHolder;
        }

        @Override
        public void onAttachedToRecyclerView(RecyclerView recyclerView) {
            mAttachedRv = recyclerView;
        }

        @Override
        public void onBindViewHolder(@NonNull TestViewHolder holder, int position) {
            super.onBindViewHolder(holder, position);
            if (position < spanCount * consecutiveFocusableColsCount) {
                holder.itemView.setFocusable(true);
                holder.itemView.setFocusableInTouchMode(true);
            } else {
                holder.itemView.setFocusable(false);
                holder.itemView.setFocusableInTouchMode(false);
            }
            holder.itemView.setMinimumWidth(mAttachedRv.getWidth() / visibleColCount);
        }
    });
    waitForFirstLayout(recyclerView);
    // adapter position of the currently focused item.
    int focusIndex = 1;
    RecyclerView.ViewHolder toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
    View viewToFocus = toFocus.itemView;
    assertTrue(requestFocus(viewToFocus, true));
    assertSame(viewToFocus, recyclerView.getFocusedChild());
    // adapter position of the item (whether focusable or not) that just becomes fully
    // visible after focusSearch.
    int visibleIndex = focusIndex;
    // The VH of the above adapter position
    RecyclerView.ViewHolder toVisible = null;
    int maxFocusIndex = (consecutiveFocusableColsCount - 1) * spanCount + focusIndex;
    int maxVisibleIndex = (consecutiveFocusableColsCount + visibleColCount - 2) * spanCount + visibleIndex;
    // Navigate left through the focusable and unfocusable columns. The focusable columns should
    // become focused one by one until hitting the last focusable column, at which point,
    // unfocusable columns should become visible on the screen until the currently focused
    // column stays on the screen.
    int pos = focusIndex + spanCount;
    while (pos < itemCount) {
        focusSearch(recyclerView.getFocusedChild(), View.FOCUS_LEFT, true);
        waitForIdleScroll(recyclerView);
        focusIndex = Math.min(maxFocusIndex, (focusIndex + spanCount));
        toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
        visibleIndex = Math.min(maxVisibleIndex, (visibleIndex + spanCount));
        toVisible = recyclerView.findViewHolderForAdapterPosition(visibleIndex);
        assertThat("Child at position " + focusIndex + " should be focused", toFocus.itemView.hasFocus(), is(true));
        assertTrue("Focused child should be at least partially visible.", isViewPartiallyInBound(recyclerView, toFocus.itemView));
        assertTrue("Child view at adapter pos " + visibleIndex + " should be fully visible.", isViewFullyInBound(recyclerView, toVisible.itemView));
        pos += spanCount;
    }
}
#method_after
@Test
public void leftUnfocusableViewsVisibility() throws Throwable {
    // The maximum number of columns that can be fully in-bounds of RV.
    final int visibleColCount = 5;
    final int spanCount = 3;
    final int consecutiveFocusableColsCount = 4;
    final int consecutiveUnFocusableColsCount = 8;
    final int itemCount = (consecutiveFocusableColsCount + consecutiveUnFocusableColsCount) * spanCount;
    final int childWidth = 200;
    final int childHeight = WRAP_CONTENT;
    // Parent width is 1 more than 4 times child width, so when focusable child is 1 pixel on
    // screen 4 non-focusable children can fit on screen.
    final int parentWidth = childWidth * 4 + 1;
    final int parentHeight = 1000;
    final RecyclerView recyclerView = setupBasic(new Config(spanCount, itemCount).orientation(HORIZONTAL).reverseLayout(true), new GridTestAdapter(itemCount, 1) {

        @Override
        public TestViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
            TestViewHolder testViewHolder = super.onCreateViewHolder(parent, viewType);
            // Good to have colors for debugging
            StateListDrawable stl = new StateListDrawable();
            stl.addState(new int[] { android.R.attr.state_focused }, new ColorDrawable(Color.RED));
            stl.addState(StateSet.WILD_CARD, new ColorDrawable(Color.BLUE));
            // noinspection deprecation using this for kitkat tests
            testViewHolder.itemView.setBackgroundDrawable(stl);
            return testViewHolder;
        }

        @Override
        public void onBindViewHolder(@NonNull TestViewHolder holder, int position) {
            super.onBindViewHolder(holder, position);
            if (position < spanCount * consecutiveFocusableColsCount) {
                holder.itemView.setFocusable(true);
                holder.itemView.setFocusableInTouchMode(true);
            } else {
                holder.itemView.setFocusable(false);
                holder.itemView.setFocusableInTouchMode(false);
            }
            holder.itemView.setLayoutParams(new RecyclerView.LayoutParams(childWidth, childHeight));
        }
    });
    recyclerView.setLayoutParams(new ViewGroup.LayoutParams(parentWidth, parentHeight));
    waitForFirstLayout(recyclerView);
    // adapter position of the currently focused item.
    int focusIndex = 1;
    RecyclerView.ViewHolder toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
    View viewToFocus = toFocus.itemView;
    assertTrue(requestFocus(viewToFocus, true));
    assertSame(viewToFocus, recyclerView.getFocusedChild());
    // adapter position of the item (whether focusable or not) that just becomes fully
    // visible after focusSearch.
    int visibleIndex = focusIndex;
    // The VH of the above adapter position
    RecyclerView.ViewHolder toVisible = null;
    int maxFocusIndex = (consecutiveFocusableColsCount - 1) * spanCount + focusIndex;
    int maxVisibleIndex = (consecutiveFocusableColsCount + visibleColCount - 2) * spanCount + visibleIndex;
    // Navigate left through the focusable and unfocusable columns. The focusable columns should
    // become focused one by one until hitting the last focusable column, at which point,
    // unfocusable columns should become visible on the screen until the currently focused
    // column stays on the screen.
    int pos = focusIndex + spanCount;
    while (pos < itemCount) {
        focusSearch(recyclerView.getFocusedChild(), View.FOCUS_LEFT, true);
        waitForIdleScroll(recyclerView);
        focusIndex = Math.min(maxFocusIndex, (focusIndex + spanCount));
        toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
        visibleIndex = Math.min(maxVisibleIndex, (visibleIndex + spanCount));
        toVisible = recyclerView.findViewHolderForAdapterPosition(visibleIndex);
        assertThat("Child at position " + focusIndex + " should be focused", toFocus.itemView.hasFocus(), is(true));
        assertTrue("Focused child should be at least partially visible.", isViewPartiallyInBound(recyclerView, toFocus.itemView));
        assertTrue("Child view at adapter pos " + visibleIndex + " should be fully visible.", isViewFullyInBound(recyclerView, toVisible.itemView));
        pos += spanCount;
    }
}
#end_block

#method_before
@Test
public void rightUnfocusableViewsVisibility() throws Throwable {
    // The maximum number of columns that can be fully in-bounds of RV.
    final int visibleColCount = 5;
    final int spanCount = 3;
    final int consecutiveFocusableColsCount = 4;
    final int consecutiveUnFocusableColsCount = 8;
    final int itemCount = (consecutiveFocusableColsCount + consecutiveUnFocusableColsCount) * spanCount;
    final RecyclerView recyclerView = setupBasic(new Config(spanCount, itemCount).orientation(HORIZONTAL).reverseLayout(false), new GridTestAdapter(itemCount, 1) {

        RecyclerView mAttachedRv;

        @Override
        public TestViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
            TestViewHolder testViewHolder = super.onCreateViewHolder(parent, viewType);
            // Good to have colors for debugging
            StateListDrawable stl = new StateListDrawable();
            stl.addState(new int[] { android.R.attr.state_focused }, new ColorDrawable(Color.RED));
            stl.addState(StateSet.WILD_CARD, new ColorDrawable(Color.BLUE));
            // noinspection deprecation using this for kitkat tests
            testViewHolder.itemView.setBackgroundDrawable(stl);
            return testViewHolder;
        }

        @Override
        public void onAttachedToRecyclerView(RecyclerView recyclerView) {
            mAttachedRv = recyclerView;
        }

        @Override
        public void onBindViewHolder(@NonNull TestViewHolder holder, int position) {
            super.onBindViewHolder(holder, position);
            if (position < spanCount * consecutiveFocusableColsCount) {
                holder.itemView.setFocusable(true);
                holder.itemView.setFocusableInTouchMode(true);
            } else {
                holder.itemView.setFocusable(false);
                holder.itemView.setFocusableInTouchMode(false);
            }
            holder.itemView.setMinimumWidth(mAttachedRv.getWidth() / visibleColCount);
        }
    });
    waitForFirstLayout(recyclerView);
    // adapter position of the currently focused item.
    int focusIndex = 1;
    RecyclerView.ViewHolder toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
    View viewToFocus = toFocus.itemView;
    assertTrue(requestFocus(viewToFocus, true));
    assertSame(viewToFocus, recyclerView.getFocusedChild());
    // adapter position of the item (whether focusable or not) that just becomes fully
    // visible after focusSearch.
    int visibleIndex = focusIndex;
    // The VH of the above adapter position
    RecyclerView.ViewHolder toVisible = null;
    int maxFocusIndex = (consecutiveFocusableColsCount - 1) * spanCount + focusIndex;
    int maxVisibleIndex = (consecutiveFocusableColsCount + visibleColCount - 2) * spanCount + visibleIndex;
    // Navigate right through the focusable and unfocusable columns. The focusable columns
    // should become focused one by one until hitting the last focusable column, at which point,
    // unfocusable columns should become visible on the screen until the currently focused
    // column stays on the screen.
    int pos = focusIndex + spanCount;
    while (pos < itemCount) {
        focusSearch(recyclerView.getFocusedChild(), View.FOCUS_RIGHT, true);
        waitForIdleScroll(recyclerView);
        focusIndex = Math.min(maxFocusIndex, (focusIndex + spanCount));
        toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
        visibleIndex = Math.min(maxVisibleIndex, (visibleIndex + spanCount));
        toVisible = recyclerView.findViewHolderForAdapterPosition(visibleIndex);
        assertThat("Child at position " + focusIndex + " should be focused", toFocus.itemView.hasFocus(), is(true));
        assertTrue("Focused child should be at least partially visible.", isViewPartiallyInBound(recyclerView, toFocus.itemView));
        assertTrue("Child view at adapter pos " + visibleIndex + " should be fully visible.", isViewFullyInBound(recyclerView, toVisible.itemView));
        pos += spanCount;
    }
}
#method_after
@Test
public void rightUnfocusableViewsVisibility() throws Throwable {
    // The maximum number of columns that can be fully in-bounds of RV.
    final int visibleColCount = 5;
    final int spanCount = 3;
    final int consecutiveFocusableColsCount = 4;
    final int consecutiveUnFocusableColsCount = 8;
    final int itemCount = (consecutiveFocusableColsCount + consecutiveUnFocusableColsCount) * spanCount;
    final int childWidth = 200;
    final int childHeight = WRAP_CONTENT;
    // Parent width is 1 more than 4 times child width, so when focusable child is 1 pixel on
    // screen 4 non-focusable children can fit on screen.
    final int parentWidth = childWidth * 4 + 1;
    final int parentHeight = 1000;
    final RecyclerView recyclerView = setupBasic(new Config(spanCount, itemCount).orientation(HORIZONTAL).reverseLayout(false), new GridTestAdapter(itemCount, 1) {

        @Override
        public TestViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
            TestViewHolder testViewHolder = super.onCreateViewHolder(parent, viewType);
            // Good to have colors for debugging
            StateListDrawable stl = new StateListDrawable();
            stl.addState(new int[] { android.R.attr.state_focused }, new ColorDrawable(Color.RED));
            stl.addState(StateSet.WILD_CARD, new ColorDrawable(Color.BLUE));
            // noinspection deprecation using this for kitkat tests
            testViewHolder.itemView.setBackgroundDrawable(stl);
            return testViewHolder;
        }

        @Override
        public void onBindViewHolder(@NonNull TestViewHolder holder, int position) {
            super.onBindViewHolder(holder, position);
            if (position < spanCount * consecutiveFocusableColsCount) {
                holder.itemView.setFocusable(true);
                holder.itemView.setFocusableInTouchMode(true);
            } else {
                holder.itemView.setFocusable(false);
                holder.itemView.setFocusableInTouchMode(false);
            }
            holder.itemView.setLayoutParams(new RecyclerView.LayoutParams(childWidth, childHeight));
        }
    });
    recyclerView.setLayoutParams(new ViewGroup.LayoutParams(parentWidth, parentHeight));
    waitForFirstLayout(recyclerView);
    // adapter position of the currently focused item.
    int focusIndex = 1;
    RecyclerView.ViewHolder toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
    View viewToFocus = toFocus.itemView;
    assertTrue(requestFocus(viewToFocus, true));
    assertSame(viewToFocus, recyclerView.getFocusedChild());
    // adapter position of the item (whether focusable or not) that just becomes fully
    // visible after focusSearch.
    int visibleIndex = focusIndex;
    // The VH of the above adapter position
    RecyclerView.ViewHolder toVisible = null;
    int maxFocusIndex = (consecutiveFocusableColsCount - 1) * spanCount + focusIndex;
    int maxVisibleIndex = (consecutiveFocusableColsCount + visibleColCount - 2) * spanCount + visibleIndex;
    // Navigate right through the focusable and unfocusable columns. The focusable columns
    // should become focused one by one until hitting the last focusable column, at which point,
    // unfocusable columns should become visible on the screen until the currently focused
    // column stays on the screen.
    int pos = focusIndex + spanCount;
    while (pos < itemCount) {
        focusSearch(recyclerView.getFocusedChild(), View.FOCUS_RIGHT, true);
        waitForIdleScroll(recyclerView);
        focusIndex = Math.min(maxFocusIndex, (focusIndex + spanCount));
        toFocus = recyclerView.findViewHolderForAdapterPosition(focusIndex);
        visibleIndex = Math.min(maxVisibleIndex, (visibleIndex + spanCount));
        toVisible = recyclerView.findViewHolderForAdapterPosition(visibleIndex);
        assertThat("Child at position " + focusIndex + " should be focused", toFocus.itemView.hasFocus(), is(true));
        assertTrue("Focused child should be at least partially visible.", isViewPartiallyInBound(recyclerView, toFocus.itemView));
        assertTrue("Child view at adapter pos " + visibleIndex + " should be fully visible.", isViewFullyInBound(recyclerView, toVisible.itemView));
        pos += spanCount;
    }
}
#end_block

#method_before
@Test
public void spanLookupCache() {
    final GridLayoutManager.SpanSizeLookup ssl = new GridLayoutManager.SpanSizeLookup() {

        @Override
        public int getSpanSize(int position) {
            if (position > 6) {
                return 2;
            }
            return 1;
        }
    };
    ssl.setSpanIndexCacheEnabled(true);
    assertEquals("reference child non existent", -1, ssl.findReferenceIndexFromCache(2));
    ssl.getCachedSpanIndex(4, 5);
    assertEquals("reference child non existent", -1, ssl.findReferenceIndexFromCache(3));
    // this should not happen and if happens, it is better to return -1
    assertEquals("reference child itself", -1, ssl.findReferenceIndexFromCache(4));
    assertEquals("reference child before", 4, ssl.findReferenceIndexFromCache(5));
    assertEquals("reference child before", 4, ssl.findReferenceIndexFromCache(100));
    ssl.getCachedSpanIndex(6, 5);
    assertEquals("reference child before", 6, ssl.findReferenceIndexFromCache(7));
    assertEquals("reference child before", 4, ssl.findReferenceIndexFromCache(6));
    assertEquals("reference child itself", -1, ssl.findReferenceIndexFromCache(4));
    ssl.getCachedSpanIndex(12, 5);
    assertEquals("reference child before", 12, ssl.findReferenceIndexFromCache(13));
    assertEquals("reference child before", 6, ssl.findReferenceIndexFromCache(12));
    assertEquals("reference child before", 6, ssl.findReferenceIndexFromCache(7));
    for (int i = 0; i < 6; i++) {
        ssl.getCachedSpanIndex(i, 5);
    }
    for (int i = 1; i < 7; i++) {
        assertEquals("reference child right before " + i, i - 1, ssl.findReferenceIndexFromCache(i));
    }
    assertEquals("reference child before 0 ", -1, ssl.findReferenceIndexFromCache(0));
}
#method_after
@Test
public void spanLookupCache() {
    final GridLayoutManager.SpanSizeLookup ssl = new GridLayoutManager.SpanSizeLookup() {

        @Override
        public int getSpanSize(int position) {
            if (position > 6) {
                return 2;
            }
            return 1;
        }
    };
    ssl.setSpanIndexCacheEnabled(true);
    assertEquals("reference child non existent", -1, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 2));
    ssl.getCachedSpanIndex(4, 5);
    assertEquals("reference child non existent", -1, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 3));
    // this should not happen and if happens, it is better to return -1
    assertEquals("reference child itself", -1, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 4));
    assertEquals("reference child before", 4, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 5));
    assertEquals("reference child before", 4, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 100));
    ssl.getCachedSpanIndex(6, 5);
    assertEquals("reference child before", 6, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 7));
    assertEquals("reference child before", 4, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 6));
    assertEquals("reference child itself", -1, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 4));
    ssl.getCachedSpanIndex(12, 5);
    assertEquals("reference child before", 12, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 13));
    assertEquals("reference child before", 6, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 12));
    assertEquals("reference child before", 6, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 7));
    for (int i = 0; i < 6; i++) {
        ssl.getCachedSpanIndex(i, 5);
    }
    for (int i = 1; i < 7; i++) {
        assertEquals("reference child right before " + i, i - 1, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, i));
    }
    assertEquals("reference child before 0 ", -1, GridLayoutManager.SpanSizeLookup.findFirstKeyLessThan(ssl.mSpanIndexCache, 0));
}
#end_block

#method_before
@Test
public void insertOrAbort() {
    final OnConflictStrategyDatabase db = openDatabase();
    try {
        db.animal().insertOrAbort(Arrays.asList(new Animal(1, "Dog"), new Animal(2, "Cat"), new Animal(2, "Bird"), new Animal(3, "Monkey")));
        fail("Was expecting an exception");
    } catch (SQLiteConstraintException e) {
        assertThat(e.getMessage(), containsString("Animal.id"));
    }
    assertThat(db.animal().allNames(), are());
}
#method_after
@Test
public void insertOrAbort() {
    final OnConflictStrategyDatabase db = openDatabase();
    try {
        db.animal().insertOrAbort(Arrays.asList(new Animal(1, "Dog"), new Animal(2, "Cat"), new Animal(2, "Bird"), new Animal(3, "Monkey")));
        fail("Was expecting an exception");
    } catch (SQLiteConstraintException e) {
        assertThat(e.getMessage(), is(notNullValue()));
    }
    assertThat(db.animal().allNames(), are());
}
#end_block

#method_before
@SafeVarargs
private final <E> Matcher<Collection<E>> are(E... args) {
    return allOf((Matcher<? super Collection<E>>) hasSize(args.length), hasItems(args));
}
#method_after
@SuppressWarnings("unchecked")
private <E> Matcher<Collection<E>> are(E... args) {
    return allOf((Matcher<? super Collection<E>>) hasSize(args.length), hasItems(args));
}
#end_block

#method_before
private void startVpn(String[] addresses, String[] routes, String allowedApplications, String disallowedApplications) throws Exception {
    startVpnWithProxy(addresses, routes, allowedApplications, disallowedApplications, null);
}
#method_after
private void startVpn(String[] addresses, String[] routes, String allowedApplications, String disallowedApplications, ProxyInfo proxyInfo) throws Exception {
    prepareVpn();
    // Register a callback so we will be notified when our VPN comes up.
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).build();
    mCallback = new NetworkCallback() {

        public void onAvailable(Network network) {
            synchronized (mLock) {
                Log.i(TAG, "Got available callback for network=" + network);
                mNetwork = network;
                mLock.notify();
            }
        }
    };
    // Unregistered in tearDown.
    mCM.registerNetworkCallback(request, mCallback);
    // Start the service and wait up for TIMEOUT_MS ms for the VPN to come up.
    Intent intent = new Intent(mActivity, MyVpnService.class).putExtra(mPackageName + ".cmd", "connect").putExtra(mPackageName + ".addresses", TextUtils.join(",", addresses)).putExtra(mPackageName + ".routes", TextUtils.join(",", routes)).putExtra(mPackageName + ".allowedapplications", allowedApplications).putExtra(mPackageName + ".disallowedapplications", disallowedApplications).putExtra(mPackageName + ".httpProxy", proxyInfo);
    mActivity.startService(intent);
    synchronized (mLock) {
        if (mNetwork == null) {
            Log.i(TAG, "bf mLock");
            mLock.wait(TIMEOUT_MS);
            Log.i(TAG, "af mLock");
        }
    }
    if (mNetwork == null) {
        fail("VPN did not become available after " + TIMEOUT_MS + "ms");
    }
    // configured. Give the system some time to do so. http://b/18436087 .
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
    }
}
#end_block

#method_before
public void testDefault() throws Exception {
    if (!supportedHardware())
        return;
    // support adb over network, see b/119382723.
    if (SystemProperties.getInt("persist.adb.tcp.port", -1) > -1 || SystemProperties.getInt("service.adb.tcp.port", -1) > -1) {
        Log.i(TAG, "adb is running over the network, so skip this test");
        return;
    }
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "0.0.0.0/0", "::/0" }, "", "");
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
}
#method_after
public void testDefault() throws Exception {
    if (!supportedHardware())
        return;
    // support adb over network, see b/119382723.
    if (SystemProperties.getInt("persist.adb.tcp.port", -1) > -1 || SystemProperties.getInt("service.adb.tcp.port", -1) > -1) {
        Log.i(TAG, "adb is running over the network, so skip this test");
        return;
    }
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "0.0.0.0/0", "::/0" }, "", "", null);
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
}
#end_block

#method_before
public void testAppAllowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    // Shell app must not be put in here or it would kill the ADB-over-network use case
    String allowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, allowedApps, "");
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
}
#method_after
public void testAppAllowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    // Shell app must not be put in here or it would kill the ADB-over-network use case
    String allowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, allowedApps, "", null);
    assertSocketClosed(fd, TEST_HOST);
    checkTrafficOnVpn();
}
#end_block

#method_before
public void testAppDisallowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor localFd = openSocketFd(TEST_HOST, 80, TIMEOUT_MS);
    FileDescriptor remoteFd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    String disallowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    // If adb TCP port opened, this test may running by adb over TCP.
    // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,
    // see b/119382723.
    // Note: The test don't support running adb over network for root device
    disallowedApps = disallowedApps + ",com.android.shell";
    Log.i(TAG, "Append shell app to disallowedApps: " + disallowedApps);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, "", disallowedApps);
    assertSocketStillOpen(localFd, TEST_HOST);
    assertSocketStillOpen(remoteFd, TEST_HOST);
    checkNoTrafficOnVpn();
}
#method_after
public void testAppDisallowed() throws Exception {
    if (!supportedHardware())
        return;
    FileDescriptor localFd = openSocketFd(TEST_HOST, 80, TIMEOUT_MS);
    FileDescriptor remoteFd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
    String disallowedApps = mRemoteSocketFactoryClient.getPackageName() + "," + mPackageName;
    // If adb TCP port opened, this test may running by adb over TCP.
    // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,
    // see b/119382723.
    // Note: The test don't support running adb over network for root device
    disallowedApps = disallowedApps + ",com.android.shell";
    Log.i(TAG, "Append shell app to disallowedApps: " + disallowedApps);
    startVpn(new String[] { "192.0.2.2/32", "2001:db8:1:2::ffe/128" }, new String[] { "192.0.2.0/24", "2001:db8::/32" }, "", disallowedApps, null);
    assertSocketStillOpen(localFd, TEST_HOST);
    assertSocketStillOpen(remoteFd, TEST_HOST);
    checkNoTrafficOnVpn();
}
#end_block

#method_before
private void start(String packageName, Intent intent) {
    Builder builder = new Builder();
    String addresses = intent.getStringExtra(packageName + ".addresses");
    if (addresses != null) {
        String[] addressArray = addresses.split(",");
        for (int i = 0; i < addressArray.length; i++) {
            String[] prefixAndMask = addressArray[i].split("/");
            try {
                InetAddress address = InetAddress.getByName(prefixAndMask[0]);
                int prefixLength = Integer.parseInt(prefixAndMask[1]);
                builder.addAddress(address, prefixLength);
            } catch (UnknownHostException | NumberFormatException | ArrayIndexOutOfBoundsException e) {
                continue;
            }
        }
    }
    String routes = intent.getStringExtra(packageName + ".routes");
    if (routes != null) {
        String[] routeArray = routes.split(",");
        for (int i = 0; i < routeArray.length; i++) {
            String[] prefixAndMask = routeArray[i].split("/");
            try {
                InetAddress address = InetAddress.getByName(prefixAndMask[0]);
                int prefixLength = Integer.parseInt(prefixAndMask[1]);
                builder.addRoute(address, prefixLength);
            } catch (UnknownHostException | NumberFormatException | ArrayIndexOutOfBoundsException e) {
                continue;
            }
        }
    }
    String allowed = intent.getStringExtra(packageName + ".allowedapplications");
    if (allowed != null) {
        String[] packageArray = allowed.split(",");
        for (int i = 0; i < packageArray.length; i++) {
            String allowedPackage = packageArray[i];
            if (!TextUtils.isEmpty(allowedPackage)) {
                try {
                    builder.addAllowedApplication(allowedPackage);
                } catch (NameNotFoundException e) {
                    continue;
                }
            }
        }
    }
    String disallowed = intent.getStringExtra(packageName + ".disallowedapplications");
    if (disallowed != null) {
        String[] packageArray = disallowed.split(",");
        for (int i = 0; i < packageArray.length; i++) {
            String disallowedPackage = packageArray[i];
            if (!TextUtils.isEmpty(disallowedPackage)) {
                try {
                    builder.addDisallowedApplication(disallowedPackage);
                } catch (NameNotFoundException e) {
                    continue;
                }
            }
        }
    }
    String vpnProxy = intent.getStringExtra(packageName + ".httpProxy");
    if (vpnProxy != null) {
        String[] proxy = vpnProxy.split(":");
        if (proxy != null && proxy.length == 2) {
            builder.setHttpProxy(ProxyInfo.buildDirectProxy(proxy[0], Integer.parseUnsignedInt(proxy[1])));
        }
    }
    builder.setMtu(MTU);
    builder.setBlocking(true);
    builder.setSession("MyVpnService");
    Log.i(TAG, "Establishing VPN," + " addresses=" + addresses + " routes=" + routes + " allowedApplications=" + allowed + " disallowedApplications=" + disallowed);
    mFd = builder.establish();
    Log.i(TAG, "Established, fd=" + (mFd == null ? "null" : mFd.getFd()));
    mPacketReflector = new PacketReflector(mFd.getFileDescriptor(), MTU);
    mPacketReflector.start();
}
#method_after
private void start(String packageName, Intent intent) {
    Builder builder = new Builder();
    String addresses = intent.getStringExtra(packageName + ".addresses");
    if (addresses != null) {
        String[] addressArray = addresses.split(",");
        for (int i = 0; i < addressArray.length; i++) {
            String[] prefixAndMask = addressArray[i].split("/");
            try {
                InetAddress address = InetAddress.getByName(prefixAndMask[0]);
                int prefixLength = Integer.parseInt(prefixAndMask[1]);
                builder.addAddress(address, prefixLength);
            } catch (UnknownHostException | NumberFormatException | ArrayIndexOutOfBoundsException e) {
                continue;
            }
        }
    }
    String routes = intent.getStringExtra(packageName + ".routes");
    if (routes != null) {
        String[] routeArray = routes.split(",");
        for (int i = 0; i < routeArray.length; i++) {
            String[] prefixAndMask = routeArray[i].split("/");
            try {
                InetAddress address = InetAddress.getByName(prefixAndMask[0]);
                int prefixLength = Integer.parseInt(prefixAndMask[1]);
                builder.addRoute(address, prefixLength);
            } catch (UnknownHostException | NumberFormatException | ArrayIndexOutOfBoundsException e) {
                continue;
            }
        }
    }
    String allowed = intent.getStringExtra(packageName + ".allowedapplications");
    if (allowed != null) {
        String[] packageArray = allowed.split(",");
        for (int i = 0; i < packageArray.length; i++) {
            String allowedPackage = packageArray[i];
            if (!TextUtils.isEmpty(allowedPackage)) {
                try {
                    builder.addAllowedApplication(allowedPackage);
                } catch (NameNotFoundException e) {
                    continue;
                }
            }
        }
    }
    String disallowed = intent.getStringExtra(packageName + ".disallowedapplications");
    if (disallowed != null) {
        String[] packageArray = disallowed.split(",");
        for (int i = 0; i < packageArray.length; i++) {
            String disallowedPackage = packageArray[i];
            if (!TextUtils.isEmpty(disallowedPackage)) {
                try {
                    builder.addDisallowedApplication(disallowedPackage);
                } catch (NameNotFoundException e) {
                    continue;
                }
            }
        }
    }
    ProxyInfo vpnProxy = intent.getParcelableExtra(packageName + ".httpProxy");
    builder.setHttpProxy(vpnProxy);
    builder.setMtu(MTU);
    builder.setBlocking(true);
    builder.setSession("MyVpnService");
    Log.i(TAG, "Establishing VPN," + " addresses=" + addresses + " routes=" + routes + " allowedApplications=" + allowed + " disallowedApplications=" + disallowed);
    mFd = builder.establish();
    Log.i(TAG, "Established, fd=" + (mFd == null ? "null" : mFd.getFd()));
    mPacketReflector = new PacketReflector(mFd.getFileDescriptor(), MTU);
    mPacketReflector.start();
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int videoWidth = 0;
    int videoHeight = 0;
    if (mMediaPlayer != null) {
        VideoSize size = mMediaPlayer.getVideoSize();
        videoWidth = size.getWidth();
        videoHeight = size.getHeight();
    }
    if (DEBUG) {
        Log.d(TAG, "onMeasure(" + MeasureSpec.toString(widthMeasureSpec) + ", " + MeasureSpec.toString(heightMeasureSpec) + ")");
        Log.i(TAG, " measuredSize: " + getMeasuredWidth() + "/" + getMeasuredHeight());
        Log.i(TAG, " viewSize: " + getWidth() + "/" + getHeight());
        Log.i(TAG, " mVideoWidth/height: " + videoWidth + ", " + videoHeight);
    }
    int width = resolveSize(videoWidth, widthMeasureSpec);
    int height = resolveSize(videoHeight, heightMeasureSpec);
    if (videoWidth > 0 && videoHeight > 0) {
        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
        width = widthSpecSize;
        height = heightSpecSize;
        // for compatibility, we adjust size based on aspect ratio
        if (videoWidth * height < width * videoHeight) {
            width = height * videoWidth / videoHeight;
            if (DEBUG) {
                Log.d(TAG, "image too wide, correcting. width: " + width);
            }
        } else if (videoWidth * height > width * videoHeight) {
            height = width * videoHeight / videoWidth;
            if (DEBUG) {
                Log.d(TAG, "image too tall, correcting. height: " + height);
            }
        }
    }
    setMeasuredDimension(width, height);
    if (DEBUG) {
        Log.i(TAG, "end of onMeasure()");
        Log.i(TAG, " measuredSize: " + getMeasuredWidth() + "/" + getMeasuredHeight());
    }
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (mMediaPlayer == null) {
        setMeasuredDimension(0, 0);
        return;
    }
    VideoSize videoSize = mMediaPlayer.getVideoSize();
    final int videoWidth = videoSize.getWidth();
    final int videoHeight = videoSize.getHeight();
    if (videoWidth == 0 || videoHeight == 0) {
        setMeasuredDimension(0, 0);
        return;
    }
    int width;
    int height;
    final int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
    final int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
    final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
    final int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
    if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {
        // the size is fixed
        width = widthSpecSize;
        height = heightSpecSize;
        // for compatibility, we adjust size based on aspect ratio
        if (videoWidth * height < width * videoHeight) {
            width = height * videoWidth / videoHeight;
        } else if (videoWidth * height > width * videoHeight) {
            height = width * videoHeight / videoWidth;
        }
    } else if (widthSpecMode == MeasureSpec.EXACTLY) {
        // only the width is fixed, adjust the height to match aspect ratio if possible
        width = widthSpecSize;
        height = width * videoHeight / videoWidth;
        if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {
            // couldn't match aspect ratio within the constraints
            height = heightSpecSize | MEASURED_STATE_TOO_SMALL;
        }
    } else if (heightSpecMode == MeasureSpec.EXACTLY) {
        // only the height is fixed, adjust the width to match aspect ratio if possible
        height = heightSpecSize;
        width = height * videoWidth / videoHeight;
        if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {
            // couldn't match aspect ratio within the constraints
            width = widthSpecSize | MEASURED_STATE_TOO_SMALL;
        }
    } else {
        // neither the width nor the height are fixed, try to use actual video size
        width = videoWidth;
        height = videoHeight;
        if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {
            // too tall, decrease both width and height
            height = heightSpecSize;
            width = height * videoWidth / videoHeight;
        }
        if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {
            // too wide, decrease both width and height
            width = widthSpecSize;
            height = width * videoHeight / videoWidth;
        }
    }
    setMeasuredDimension(width, height);
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int videoWidth = 0;
    int videoHeight = 0;
    if (mMediaPlayer != null) {
        VideoSize size = mMediaPlayer.getVideoSize();
        videoWidth = size.getWidth();
        videoHeight = size.getHeight();
    }
    if (DEBUG) {
        Log.d(TAG, "onMeasure(" + MeasureSpec.toString(widthMeasureSpec) + ", " + MeasureSpec.toString(heightMeasureSpec) + ")");
        Log.i(TAG, " measuredSize: " + getMeasuredWidth() + "/" + getMeasuredHeight());
        Log.i(TAG, " viewSize: " + getWidth() + "/" + getHeight());
        Log.i(TAG, " mVideoWidth/height: " + videoWidth + ", " + videoHeight);
    }
    int width = resolveSize(videoWidth, widthMeasureSpec);
    int height = resolveSize(videoHeight, heightMeasureSpec);
    if (videoWidth > 0 && videoHeight > 0) {
        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
        width = widthSpecSize;
        height = heightSpecSize;
        // for compatibility, we adjust size based on aspect ratio
        if (videoWidth * height < width * videoHeight) {
            width = height * videoWidth / videoHeight;
            if (DEBUG) {
                Log.d(TAG, "image too wide, correcting. width: " + width);
            }
        } else if (videoWidth * height > width * videoHeight) {
            height = width * videoHeight / videoWidth;
            if (DEBUG) {
                Log.d(TAG, "image too tall, correcting. height: " + height);
            }
        }
    }
    setMeasuredDimension(width, height);
    if (DEBUG) {
        Log.i(TAG, "end of onMeasure()");
        Log.i(TAG, " measuredSize: " + getMeasuredWidth() + "/" + getMeasuredHeight());
    }
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (mMediaPlayer == null) {
        setMeasuredDimension(0, 0);
        return;
    }
    VideoSize videoSize = mMediaPlayer.getVideoSize();
    final int videoWidth = videoSize.getWidth();
    final int videoHeight = videoSize.getHeight();
    if (videoWidth == 0 || videoHeight == 0) {
        setMeasuredDimension(0, 0);
        return;
    }
    int width;
    int height;
    final int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
    final int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
    final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
    final int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
    if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {
        // the size is fixed
        width = widthSpecSize;
        height = heightSpecSize;
        // for compatibility, we adjust size based on aspect ratio
        if (videoWidth * height < width * videoHeight) {
            width = height * videoWidth / videoHeight;
        } else if (videoWidth * height > width * videoHeight) {
            height = width * videoHeight / videoWidth;
        }
    } else if (widthSpecMode == MeasureSpec.EXACTLY) {
        // only the width is fixed, adjust the height to match aspect ratio if possible
        width = widthSpecSize;
        height = width * videoHeight / videoWidth;
        if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {
            // couldn't match aspect ratio within the constraints
            height = heightSpecSize | MEASURED_STATE_TOO_SMALL;
        }
    } else if (heightSpecMode == MeasureSpec.EXACTLY) {
        // only the height is fixed, adjust the width to match aspect ratio if possible
        height = heightSpecSize;
        width = height * videoWidth / videoHeight;
        if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {
            // couldn't match aspect ratio within the constraints
            width = widthSpecSize | MEASURED_STATE_TOO_SMALL;
        }
    } else {
        // neither the width nor the height are fixed, try to use actual video size
        width = videoWidth;
        height = videoHeight;
        if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {
            // too tall, decrease both width and height
            height = heightSpecSize;
            width = height * videoWidth / videoHeight;
        }
        if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {
            // too wide, decrease both width and height
            width = widthSpecSize;
            height = width * videoHeight / videoWidth;
        }
    }
    setMeasuredDimension(width, height);
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    final int count = getChildCount();
    int maxHeight = 0;
    int maxWidth = 0;
    int childState = 0;
    // Measure its children of which doNotMeasure is false
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        if (child.getVisibility() != View.GONE && !lp.doNotMeasure) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
            maxWidth = Math.max(maxWidth, child.getMeasuredWidth());
            maxHeight = Math.max(maxHeight, child.getMeasuredHeight());
            childState = childState | child.getMeasuredState();
        }
    }
    // Account for padding too
    maxWidth += getPositivePaddingLeft() + getPositivePaddingRight();
    maxHeight += getPositivePaddingTop() + getPositivePaddingBottom();
    // Check against our minimum height and width
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    if (Build.VERSION.SDK_INT >= 23) {
        // Check against our foreground's minimum height and width
        final Drawable drawable = getForeground();
        if (drawable != null) {
            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
        }
    }
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState << View.MEASURED_HEIGHT_STATE_SHIFT));
    // Measure its children of which doNotMeasure is true
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        if (child.getVisibility() != View.GONE && lp.doNotMeasure) {
            child.measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
        }
    }
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    final int count = getChildCount();
    int maxWidth = 0;
    int maxHeight = 0;
    int childState = 0;
    // Measure its children of which forceMatchParent is false
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        if (child.getVisibility() != View.GONE && !lp.forceMatchParent) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
            maxWidth = Math.max(maxWidth, child.getMeasuredWidth());
            maxHeight = Math.max(maxHeight, child.getMeasuredHeight());
            childState = childState | child.getMeasuredState();
        }
    }
    // Account for padding too
    maxWidth += getPositivePaddingLeft() + getPositivePaddingRight();
    maxHeight += getPositivePaddingTop() + getPositivePaddingBottom();
    // Check against our minimum height and width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    if (Build.VERSION.SDK_INT >= 23) {
        // Check against our foreground's minimum height and width
        final Drawable drawable = getForeground();
        if (drawable != null) {
            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
        }
    }
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState << View.MEASURED_HEIGHT_STATE_SHIFT));
    // Measure its children of which forceMatchParent is true
    final int widthMeasureSpecForChild = MeasureSpec.makeMeasureSpec(getMeasuredWidth() - (getPositivePaddingLeft() + getPositivePaddingRight()), MeasureSpec.EXACTLY);
    final int heightMeasureSpecForChild = MeasureSpec.makeMeasureSpec(getMeasuredHeight() - (getPositivePaddingTop() + getPositivePaddingBottom()), MeasureSpec.EXACTLY);
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        if (child.getVisibility() != View.GONE && lp.forceMatchParent) {
            child.measure(widthMeasureSpecForChild, heightMeasureSpecForChild);
        }
    }
}
#end_block

#method_before
private void initialize(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    mSelectedSubtitleTrackIndex = INVALID_TRACK_INDEX;
    mAudioAttributes = new AudioAttributesCompat.Builder().setUsage(AudioAttributesCompat.USAGE_MEDIA).setContentType(AudioAttributesCompat.CONTENT_TYPE_MOVIE).build();
    mCallbackExecutor = ContextCompat.getMainExecutor(context);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
    mTextureView = new VideoTextureView(context);
    mSurfaceView = new VideoSurfaceView(context);
    mTextureView.setSurfaceListener(this);
    mSurfaceView.setSurfaceListener(this);
    addView(mTextureView);
    addView(mSurfaceView);
    mSubtitleAnchorView = new SubtitleAnchorView(context);
    mSubtitleAnchorView.setBackgroundColor(0);
    addView(mSubtitleAnchorView);
    mMusicView = new MusicView(context);
    mMusicView.setVisibility(View.GONE);
    addView(mMusicView, new SelectiveLayout.LayoutParams(true));
    boolean enableControlView = (attrs == null) || attrs.getAttributeBooleanValue("http://schemas.android.com/apk/res-auto", "enableControlView", true);
    if (enableControlView) {
        mMediaControlView = new MediaControlView(context);
    }
    // Choose surface view by default
    int viewType = (attrs == null) ? VideoView.VIEW_TYPE_SURFACEVIEW : attrs.getAttributeIntValue("http://schemas.android.com/apk/res-auto", "viewType", VideoView.VIEW_TYPE_SURFACEVIEW);
    if (viewType == VideoView.VIEW_TYPE_SURFACEVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is surfaceView.");
        }
        mTextureView.setVisibility(View.GONE);
        mSurfaceView.setVisibility(View.VISIBLE);
        mCurrentView = mSurfaceView;
    } else if (viewType == VideoView.VIEW_TYPE_TEXTUREVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is textureView.");
        }
        mTextureView.setVisibility(View.VISIBLE);
        mSurfaceView.setVisibility(View.GONE);
        mCurrentView = mTextureView;
    }
    mTargetView = mCurrentView;
    MediaRouteSelector.Builder builder = new MediaRouteSelector.Builder();
    builder.addControlCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_AUDIO);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_VIDEO);
    mRouteSelector = builder.build();
}
#method_after
private void initialize(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    mSelectedSubtitleTrackIndex = INVALID_TRACK_INDEX;
    mAudioAttributes = new AudioAttributesCompat.Builder().setUsage(AudioAttributesCompat.USAGE_MEDIA).setContentType(AudioAttributesCompat.CONTENT_TYPE_MOVIE).build();
    mCallbackExecutor = ContextCompat.getMainExecutor(context);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
    mTextureView = new VideoTextureView(context);
    mSurfaceView = new VideoSurfaceView(context);
    mTextureView.setSurfaceListener(this);
    mSurfaceView.setSurfaceListener(this);
    addView(mTextureView);
    addView(mSurfaceView);
    SelectiveLayout.LayoutParams params = new SelectiveLayout.LayoutParams();
    params.forceMatchParent = true;
    mSubtitleAnchorView = new SubtitleAnchorView(context);
    mSubtitleAnchorView.setBackgroundColor(0);
    addView(mSubtitleAnchorView, params);
    mMusicView = new MusicView(context);
    mMusicView.setVisibility(View.GONE);
    addView(mMusicView, params);
    boolean enableControlView = (attrs == null) || attrs.getAttributeBooleanValue("http://schemas.android.com/apk/res-auto", "enableControlView", true);
    if (enableControlView) {
        mMediaControlView = new MediaControlView(context);
    }
    // Choose surface view by default
    int viewType = (attrs == null) ? VideoView.VIEW_TYPE_SURFACEVIEW : attrs.getAttributeIntValue("http://schemas.android.com/apk/res-auto", "viewType", VideoView.VIEW_TYPE_SURFACEVIEW);
    if (viewType == VideoView.VIEW_TYPE_SURFACEVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is surfaceView.");
        }
        mTextureView.setVisibility(View.GONE);
        mSurfaceView.setVisibility(View.VISIBLE);
        mCurrentView = mSurfaceView;
    } else if (viewType == VideoView.VIEW_TYPE_TEXTUREVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is textureView.");
        }
        mTextureView.setVisibility(View.VISIBLE);
        mSurfaceView.setVisibility(View.GONE);
        mCurrentView = mTextureView;
    }
    mTargetView = mCurrentView;
    MediaRouteSelector.Builder builder = new MediaRouteSelector.Builder();
    builder.addControlCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_AUDIO);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_VIDEO);
    mRouteSelector = builder.build();
}
#end_block

#method_before
// /////////////////////////////////////////////////
// Protected or private methods
private void attachMediaControlView() {
    if (mMediaControlView == null)
        return;
    // Get MediaController from MediaSession and set it inside MediaControlView
    mMediaControlView.setSessionToken(mMediaSession.getToken());
    addView(mMediaControlView, new SelectiveLayout.LayoutParams(true));
}
#method_after
// /////////////////////////////////////////////////
// Protected or private methods
private void attachMediaControlView() {
    if (mMediaControlView == null)
        return;
    // Get MediaController from MediaSession and set it inside MediaControlView
    mMediaControlView.setSessionToken(mMediaSession.getToken());
    SelectiveLayout.LayoutParams params = new SelectiveLayout.LayoutParams();
    params.forceMatchParent = true;
    addView(mMediaControlView, params);
}
#end_block

#method_before
private void authenticateInternal(@NonNull PromptInfo info, @Nullable CryptoObject crypto) {
    final Bundle bundle = info.getBundle();
    final FragmentManager fragmentManager = mFragmentActivity.getSupportFragmentManager();
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
        // Create the fragment that wraps BiometricPrompt once.
        if (mBiometricFragment == null) {
            mBiometricFragment = BiometricFragment.newInstance();
            mBiometricFragment.setCallbacks(mExecutor, mNegativeButtonListener, mAuthenticationCallback);
        }
        // Set the crypto object.
        mBiometricFragment.setCryptoObject(crypto);
        mBiometricFragment.setBundle(bundle);
        if (fragmentManager.findFragmentByTag(BIOMETRIC_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mBiometricFragment, BIOMETRIC_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mBiometricFragment).commit();
        }
    } else {
        // Create the UI
        if (mFingerprintDialogFragment == null) {
            mFingerprintDialogFragment = FingerprintDialogFragment.newInstance(bundle);
            mFingerprintDialogFragment.setNegativeButtonListener(mNegativeButtonListener);
        }
        mFingerprintDialogFragment.show(fragmentManager, DIALOG_FRAGMENT_TAG);
        // Create the connection to FingerprintManager
        if (mFingerprintHelperFragment == null) {
            mFingerprintHelperFragment = FingerprintHelperFragment.newInstance();
            mFingerprintHelperFragment.setCallback(mExecutor, mAuthenticationCallback);
        }
        mFingerprintHelperFragment.setHandler(mFingerprintDialogFragment.getHandler());
        mFingerprintHelperFragment.setCryptoObject(crypto);
        if (fragmentManager.findFragmentByTag(FINGERPRINT_HELPER_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mFingerprintHelperFragment, FINGERPRINT_HELPER_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mFingerprintHelperFragment).commit();
        }
    }
}
#method_after
private void authenticateInternal(@NonNull PromptInfo info, @Nullable CryptoObject crypto) {
    final Bundle bundle = info.getBundle();
    final FragmentManager fragmentManager = mFragmentActivity.getSupportFragmentManager();
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
        // Create the fragment that wraps BiometricPrompt once.
        if (mBiometricFragment == null) {
            mBiometricFragment = BiometricFragment.newInstance();
            mBiometricFragment.setCallbacks(mExecutor, mNegativeButtonListener, mAuthenticationCallback);
        }
        // Set the crypto object.
        mBiometricFragment.setCryptoObject(crypto);
        mBiometricFragment.setBundle(bundle);
        if (fragmentManager.findFragmentByTag(BIOMETRIC_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mBiometricFragment, BIOMETRIC_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mBiometricFragment).commit();
        }
    } else {
        // Create the UI
        if (mFingerprintDialogFragment == null) {
            mFingerprintDialogFragment = FingerprintDialogFragment.newInstance();
            mFingerprintDialogFragment.setNegativeButtonListener(mNegativeButtonListener);
        }
        mFingerprintDialogFragment.setBundle(bundle);
        mFingerprintDialogFragment.show(fragmentManager, DIALOG_FRAGMENT_TAG);
        // Create the connection to FingerprintManager
        if (mFingerprintHelperFragment == null) {
            mFingerprintHelperFragment = FingerprintHelperFragment.newInstance();
            mFingerprintHelperFragment.setCallback(mExecutor, mAuthenticationCallback);
        }
        mFingerprintHelperFragment.setHandler(mFingerprintDialogFragment.getHandler());
        mFingerprintHelperFragment.setCryptoObject(crypto);
        if (fragmentManager.findFragmentByTag(FINGERPRINT_HELPER_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mFingerprintHelperFragment, FINGERPRINT_HELPER_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mFingerprintHelperFragment).commit();
        }
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (savedInstanceState != null) {
        mUseCrypto = savedInstanceState.getBoolean(KEY_SAVED_USE_CRYPTO);
        mMode = savedInstanceState.getInt(KEY_SAVED_RADIO);
        mNumberFailedAttempts = savedInstanceState.getInt(KEY_SAVED_FAILURES);
    }
    setContentView(R.layout.fragment_activity);
    final Button buttonCreateKeys;
    buttonCreateKeys = findViewById(R.id.button_enable_biometric_with_crypto);
    final Button buttonAuthenticate;
    buttonAuthenticate = findViewById(R.id.button_authenticate);
    mBiometricPrompt = new BiometricPrompt(this, /* fragmentActivity */
    mExecutor, mAuthenticationCallback);
    try {
        mKeyStore = KeyStore.getInstance("AndroidKeyStore");
    } catch (java.security.KeyStoreException e) {
        throw new RuntimeException("Failed to get an instance of KeyStore", e);
    }
    if (!mUseCrypto) {
        buttonCreateKeys.setVisibility(View.GONE);
    } else {
        buttonCreateKeys.setVisibility(View.VISIBLE);
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        buttonCreateKeys.setOnClickListener(v -> enableBiometricWithCrypto());
    }
    buttonAuthenticate.setOnClickListener(v -> startAuthentication());
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (savedInstanceState != null) {
        mUseCrypto = savedInstanceState.getBoolean(KEY_SAVED_USE_CRYPTO);
        mMode = savedInstanceState.getInt(KEY_SAVED_RADIO);
        mNumberFailedAttempts = savedInstanceState.getInt(KEY_SAVED_FAILURES);
        mCounter = savedInstanceState.getInt(KEY_COUNTER);
    }
    setContentView(R.layout.fragment_activity);
    final Button buttonCreateKeys;
    buttonCreateKeys = findViewById(R.id.button_enable_biometric_with_crypto);
    final Button buttonAuthenticate;
    buttonAuthenticate = findViewById(R.id.button_authenticate);
    mBiometricPrompt = new BiometricPrompt(this, /* fragmentActivity */
    mExecutor, mAuthenticationCallback);
    try {
        mKeyStore = KeyStore.getInstance("AndroidKeyStore");
    } catch (java.security.KeyStoreException e) {
        throw new RuntimeException("Failed to get an instance of KeyStore", e);
    }
    if (!mUseCrypto) {
        buttonCreateKeys.setVisibility(View.GONE);
    } else {
        buttonCreateKeys.setVisibility(View.VISIBLE);
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        buttonCreateKeys.setOnClickListener(v -> enableBiometricWithCrypto());
    }
    buttonAuthenticate.setOnClickListener(v -> startAuthentication());
}
#end_block

#method_before
@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putBoolean(KEY_SAVED_USE_CRYPTO, mUseCrypto);
    outState.putInt(KEY_SAVED_RADIO, mMode);
    outState.putInt(KEY_SAVED_FAILURES, mNumberFailedAttempts);
}
#method_after
@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putBoolean(KEY_SAVED_USE_CRYPTO, mUseCrypto);
    outState.putInt(KEY_SAVED_RADIO, mMode);
    outState.putInt(KEY_SAVED_FAILURES, mNumberFailedAttempts);
    outState.putInt(KEY_COUNTER, mCounter);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_car_toolbar);
    CarToolbar carToolbar = findViewById(R.id.car_toolbar);
    carToolbar.setNavigationIconOnClickListener(v -> onSupportNavigateUp());
    Toolbar toolbar = findViewById(R.id.toolbar);
    toolbar.setNavigationOnClickListener(v -> onSupportNavigateUp());
    setSupportActionBar(toolbar);
    List<CarMenuItem> items = new ArrayList<>();
    CarMenuItem.OnClickListener onClickListener = (item -> {
        if (item.isCheckable()) {
            Log.d(TAG, "Switch checked? " + item.isChecked());
        } else {
            CharSequence title = item.getTitle();
            Log.d(TAG, "Clicked" + (title != null ? ": " + title : ""));
        }
    });
    findViewById(R.id.add_action).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Action item").setDisplayBehavior(CarMenuItem.DisplayBehavior.ALWAYS).setIcon(Icon.createWithResource(this, android.R.drawable.sym_def_app_icon)).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_checkable).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Checkable item").setDisplayBehavior(CarMenuItem.DisplayBehavior.ALWAYS).setCheckable(true).setEnabled(false).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_if_room).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("If-Room item").setDisplayBehavior(CarMenuItem.DisplayBehavior.IF_ROOM).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_overflow).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Overflow item").setDisplayBehavior(CarMenuItem.DisplayBehavior.NEVER).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.clear_menu).setOnClickListener(v -> {
        items.clear();
        carToolbar.setMenuItems(null);
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_car_toolbar);
    CarToolbar carToolbar = findViewById(R.id.car_toolbar);
    carToolbar.setNavigationIconOnClickListener(v -> onSupportNavigateUp());
    Toolbar toolbar = findViewById(R.id.toolbar);
    toolbar.setNavigationOnClickListener(v -> onSupportNavigateUp());
    setSupportActionBar(toolbar);
    List<CarMenuItem> items = new ArrayList<>();
    CarMenuItem.OnClickListener onClickListener = item -> {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
            if (item.isCheckable()) {
                Log.d(TAG, "Switch checked? " + item.isChecked());
            } else {
                Log.d(TAG, "Clicked title: " + item.getTitle());
            }
        }
    };
    findViewById(R.id.add_action).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Action item").setDisplayBehavior(CarMenuItem.DisplayBehavior.ALWAYS).setIcon(Icon.createWithResource(this, android.R.drawable.sym_def_app_icon)).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_checkable).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Checkable item").setDisplayBehavior(CarMenuItem.DisplayBehavior.ALWAYS).setCheckable(true).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_if_room).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("If-Room item").setDisplayBehavior(CarMenuItem.DisplayBehavior.IF_ROOM).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.add_overflow).setOnClickListener(v -> {
        items.add(new CarMenuItem.Builder().setTitle("Overflow item").setDisplayBehavior(CarMenuItem.DisplayBehavior.NEVER).setOnClickListener(onClickListener).build());
        carToolbar.setMenuItems(items);
    });
    findViewById(R.id.clear_menu).setOnClickListener(v -> {
        items.clear();
        carToolbar.setMenuItems(null);
    });
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    // display priority than the title, subtitle, or the titleIcon.
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mEdgeButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mEdgeButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mEdgeButtonIconSize, MeasureSpec.EXACTLY);
        mOverflowButtonView.measure(measureSpec, measureSpec);
        width += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth()) + getHorizontalMargins(mOverflowButtonView);
    }
    if (!mActionViews.isEmpty()) {
        for (View view : mActionViews) {
            measureChild(view, widthMeasureSpec, width, childHeightMeasureSpec, 0);
            width += view.getMeasuredWidth() + getHorizontalMargins(view);
        }
    }
    if (mTitleIconView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mTitleIconSize, MeasureSpec.EXACTLY);
        mTitleIconView.measure(measureSpec, measureSpec);
        width += mTitleIconView.getMeasuredWidth();
    }
    int titleLength = 0;
    int subtitleLength = 0;
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        titleLength = mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    if (mSubtitleTextView.getVisibility() != GONE) {
        measureChild(mSubtitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        subtitleLength = mSubtitleTextView.getMeasuredWidth() + getHorizontalMargins(mSubtitleTextView);
    }
    width += Math.max(titleLength, subtitleLength);
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Desired height should be the height constraint for all child views.
    int desiredHeight = getPaddingTop() + getSuggestedMinimumHeight() + getPaddingBottom();
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.AT_MOST);
    int width = 0;
    // display priority than the title, subtitle, or the titleIcon.
    if (mNavButtonView.getVisibility() != GONE) {
        // Size of nav button is fixed.
        int measureSpec = MeasureSpec.makeMeasureSpec(mEdgeButtonIconSize, MeasureSpec.EXACTLY);
        mNavButtonView.measure(measureSpec, measureSpec);
        // Nav button width includes its container.
        int navWidth = Math.max(mEdgeButtonContainerWidth, mNavButtonView.getMeasuredWidth());
        width += navWidth + getHorizontalMargins(mNavButtonView);
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mEdgeButtonIconSize, MeasureSpec.EXACTLY);
        mOverflowButtonView.measure(measureSpec, measureSpec);
        width += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth()) + getHorizontalMargins(mOverflowButtonView);
    }
    for (View view : mActionViews) {
        measureChild(view, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        width += view.getMeasuredWidth() + getHorizontalMargins(view);
    }
    if (mTitleIconView.getVisibility() != GONE) {
        int measureSpec = MeasureSpec.makeMeasureSpec(mTitleIconSize, MeasureSpec.EXACTLY);
        mTitleIconView.measure(measureSpec, measureSpec);
        width += mTitleIconView.getMeasuredWidth() + getHorizontalMargins(mTitleIconView);
    }
    int titleLength = 0;
    int subtitleLength = 0;
    if (mTitleTextView.getVisibility() != GONE) {
        measureChild(mTitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        titleLength = mTitleTextView.getMeasuredWidth() + getHorizontalMargins(mTitleTextView);
    }
    if (mSubtitleTextView.getVisibility() != GONE) {
        measureChild(mSubtitleTextView, widthMeasureSpec, width, childHeightMeasureSpec, 0);
        subtitleLength = mSubtitleTextView.getMeasuredWidth() + getHorizontalMargins(mSubtitleTextView);
    }
    width += Math.max(titleLength, subtitleLength);
    setMeasuredDimension(resolveSize(width, widthMeasureSpec), resolveSize(desiredHeight, heightMeasureSpec));
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    int layoutRight = getPaddingRight();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mEdgeButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewFromLeftVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int horizontalMargin = (mEdgeButtonContainerWidth - mOverflowButtonView.getMeasuredWidth()) / 2;
        layoutViewFromRightVerticallyCentered(mOverflowButtonView, right - horizontalMargin, height);
        layoutRight += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth());
    }
    if (!mActionViews.isEmpty()) {
        for (View view : mActionViews) {
            layoutViewFromRightVerticallyCentered(view, right - layoutRight, height);
            layoutRight += view.getMeasuredWidth();
        }
    }
    if (mTitleIconView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleIconView, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth();
    }
    if (mTitleTextView.getVisibility() != GONE && mSubtitleTextView.getVisibility() != GONE) {
        layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
    } else if (mTitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleTextView, layoutLeft, height);
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mSubtitleTextView, layoutLeft, height);
    }
}
#method_after
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int height = bottom - top;
    int layoutLeft = getPaddingLeft();
    int layoutRight = getPaddingRight();
    if (mNavButtonView.getVisibility() != GONE) {
        // Nav button is centered in container.
        int navButtonWidth = mNavButtonView.getMeasuredWidth();
        int containerWidth = Math.max(mEdgeButtonContainerWidth, navButtonWidth);
        int navButtonLeft = (containerWidth - navButtonWidth) / 2;
        layoutViewFromLeftVerticallyCentered(mNavButtonView, navButtonLeft, height);
        layoutLeft += containerWidth;
    }
    if (mOverflowButtonView.getVisibility() != GONE) {
        int horizontalMargin = (mEdgeButtonContainerWidth - mOverflowButtonView.getMeasuredWidth()) / 2;
        layoutViewFromRightVerticallyCentered(mOverflowButtonView, right - horizontalMargin, height);
        layoutRight += Math.max(mEdgeButtonContainerWidth, mOverflowButtonView.getMeasuredWidth());
    }
    for (View view : mActionViews) {
        layoutViewFromRightVerticallyCentered(view, right - layoutRight, height);
        layoutRight += view.getMeasuredWidth();
    }
    if (mTitleIconView.getVisibility() != GONE) {
        MarginLayoutParams marginParams = (MarginLayoutParams) mTitleIconView.getLayoutParams();
        layoutLeft += marginParams.getMarginStart();
        layoutViewFromLeftVerticallyCentered(mTitleIconView, layoutLeft, height);
        layoutLeft += mTitleIconView.getMeasuredWidth() + marginParams.getMarginEnd();
    }
    if (mTitleTextView.getVisibility() != GONE && mSubtitleTextView.getVisibility() != GONE) {
        layoutTextViewsVerticallyCentered(mTitleTextView, mSubtitleTextView, layoutLeft, height);
    } else if (mTitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mTitleTextView, layoutLeft, height);
    } else if (mSubtitleTextView.getVisibility() != GONE) {
        layoutViewFromLeftVerticallyCentered(mSubtitleTextView, layoutLeft, height);
    }
}
#end_block

#method_before
public void setMenuItems(@Nullable List<CarMenuItem> items) {
    mMenuItems = items;
    List<CarMenuItem> actionItems = new ArrayList<>();
    mOverflowMenuItems = new ArrayList<>();
    // Remove all old action views from the Layout then the list.
    mActionViews.forEach(this::removeView);
    mActionViews.clear();
    if (mMenuItems != null) {
        mMenuItems.forEach(item -> {
            if (item.getDisplayBehavior() == CarMenuItem.DisplayBehavior.NEVER) {
                mOverflowMenuItems.add(item);
            } else {
                // Treat If-Room items as Action until that behavior is supported.
                actionItems.add(item);
            }
        });
    }
    // Show the overflow menu button if there are any overflow menu items.
    mOverflowButtonView.setVisibility(mOverflowMenuItems.isEmpty() ? GONE : VISIBLE);
    actionItems.forEach(item -> {
        View view = item.isCheckable() ? createCheckableAction(item) : createAction(item);
        MarginLayoutParams marginLayoutParams = new MarginLayoutParams(LayoutParams.WRAP_CONTENT, mActionButtonHeight);
        view.setLayoutParams(marginLayoutParams);
        mActionViews.add(view);
        addView(view);
    });
    requestLayout();
}
#method_after
public void setMenuItems(@Nullable List<CarMenuItem> items) {
    mMenuItems = items;
    mOverflowMenuItems.clear();
    // Remove all old action views from the Layout then the list.
    mActionViews.forEach(this::removeView);
    mActionViews.clear();
    List<CarMenuItem> actionItems = new ArrayList<>();
    if (mMenuItems != null) {
        for (CarMenuItem item : mMenuItems) {
            if (item.getDisplayBehavior() == CarMenuItem.DisplayBehavior.ALWAYS) {
                actionItems.add(item);
            } else {
                // Treat If-Room items as overflow until that behavior is supported.
                mOverflowMenuItems.add(item);
            }
        }
    }
    // Show the overflow menu button if there are any overflow menu items.
    mOverflowButtonView.setVisibility(mOverflowMenuItems.isEmpty() ? GONE : VISIBLE);
    for (CarMenuItem item : actionItems) {
        View action = item.isCheckable() ? createCheckableAction(item) : createAction(item);
        MarginLayoutParams marginLayoutParams = new MarginLayoutParams(LayoutParams.WRAP_CONTENT, mActionButtonHeight);
        action.setLayoutParams(marginLayoutParams);
        mActionViews.add(action);
        addView(action);
    }
    requestLayout();
}
#end_block

#method_before
private Button createAction(CarMenuItem item) {
    Context context = getContext();
    Button button = new Button(new ContextThemeWrapper(context, item.getStyleResId()), null, 0);
    CharSequence title = item.getTitle();
    button.setText(title);
    if (item.getIcon() != null) {
        Drawable icon = item.getIcon().loadDrawable(context);
        icon.setBounds(0, 0, 30, 30);
        // Set the Drawable on the left side.
        button.setCompoundDrawables(icon, null, null, null);
        if (title != null && !TextUtils.isEmpty(title)) {
            // Add padding after the icon only if there's a title.
            button.setCompoundDrawablePadding(mActionButtonPadding);
        }
    }
    button.setEnabled(item.isEnabled());
    button.setOnClickListener(v -> {
        CarMenuItem.OnClickListener onClickListener = item.getOnClickListener();
        if (onClickListener != null) {
            onClickListener.onClick(item);
        }
    });
    return button;
}
#method_after
private Button createAction(CarMenuItem item) {
    Context context = getContext();
    Button button = new Button(context, null, 0, item.getStyleResId());
    CharSequence title = item.getTitle();
    button.setText(title);
    if (item.getIcon() != null) {
        Drawable icon = item.getIcon().loadDrawable(context);
        icon.setBounds(0, 0, mActionButtonIconBound, mActionButtonIconBound);
        // Set the Drawable on the left side.
        button.setCompoundDrawables(icon, null, null, null);
        if (!TextUtils.isEmpty(title)) {
            // Add padding after the icon only if there's a title.
            button.setCompoundDrawablePadding(mActionButtonPadding);
        }
    }
    button.setEnabled(item.isEnabled());
    button.setOnClickListener(v -> {
        CarMenuItem.OnClickListener onClickListener = item.getOnClickListener();
        if (onClickListener != null) {
            onClickListener.onClick(item);
        }
    });
    return button;
}
#end_block

#method_before
private View createCheckableAction(CarMenuItem item) {
    Context context = getContext();
    Switch switchWidget = new Switch(context);
    switchWidget.setEnabled(item.isEnabled());
    switchWidget.setChecked(item.isChecked());
    switchWidget.setScaleX(mSwitchScale);
    switchWidget.setScaleY(mSwitchScale);
    switchWidget.setPadding(mActionButtonPadding, 0, mActionButtonPadding, 0);
    CharSequence title = item.getTitle();
    if (title == null || TextUtils.isEmpty(title)) {
        switchWidget.setOnCheckedChangeListener((b, isChecked) -> {
            item.setChecked(isChecked);
            CarMenuItem.OnClickListener itemOnClickListener = item.getOnClickListener();
            if (itemOnClickListener != null) {
                itemOnClickListener.onClick(item);
            }
        });
        return switchWidget;
    } else {
        // Use a LinearLayout that contains the switch and the text.
        LinearLayout linearLayout = new LinearLayout(context);
        linearLayout.setGravity(Gravity.CENTER_VERTICAL);
        linearLayout.setOnClickListener((v -> {
            if (!item.isEnabled()) {
                return;
            }
            switchWidget.toggle();
            item.setChecked(switchWidget.isChecked());
            CarMenuItem.OnClickListener itemOnClickListener = item.getOnClickListener();
            if (itemOnClickListener != null) {
                itemOnClickListener.onClick(item);
            }
        }));
        // Set the switch to be un-clickable so that the clicks are handled by the LinearLayout.
        switchWidget.setClickable(false);
        // Use a Button instead of TextView so the style is applied properly.
        Button button = new Button(new ContextThemeWrapper(context, item.getStyleResId()), null, 0);
        button.setText(title);
        // Remove ripple effect on text.
        button.setBackgroundResource(0);
        linearLayout.addView(switchWidget);
        linearLayout.addView(button);
        return linearLayout;
    }
}
#method_after
private View createCheckableAction(CarMenuItem item) {
    Context context = getContext();
    ViewGroup checkableAction = (ViewGroup) LayoutInflater.from(context).inflate(R.layout.checkable_action_item, this, false);
    Switch switchWidget = checkableAction.findViewById(R.id.switch_widget);
    switchWidget.setEnabled(item.isEnabled());
    switchWidget.setChecked(item.isChecked());
    if (item.isEnabled()) {
        checkableAction.setOnClickListener(v -> {
            switchWidget.toggle();
            item.setChecked(switchWidget.isChecked());
            CarMenuItem.OnClickListener itemOnClickListener = item.getOnClickListener();
            if (itemOnClickListener != null) {
                itemOnClickListener.onClick(item);
            }
        });
    } else {
        checkableAction.setClickable(false);
    }
    CharSequence title = item.getTitle();
    if (!TextUtils.isEmpty(title)) {
        Button button = new Button(context, null, 0, item.getStyleResId());
        // The button is added programmatically so that we can apply a custom style.
        button.setText(title);
        checkableAction.addView(button);
    }
    return checkableAction;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public int getProvisioningIntValue(int key) {
    try {
        return getITelephony().getImsProvisioningInt(mSubId, key);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@WorkerThread
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public int getProvisioningIntValue(int key) {
    try {
        return getITelephony().getImsProvisioningInt(mSubId, key);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public String getProvisioningStringValue(int key) {
    try {
        return getITelephony().getImsProvisioningString(mSubId, key);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@WorkerThread
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public String getProvisioningStringValue(int key) {
    try {
        return getITelephony().getImsProvisioningString(mSubId, key);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.MODIFY_PHONE_STATE)
@ImsConfigImplBase.SetConfigResult
public int setProvisioningIntValue(int key, int value) {
    try {
        return getITelephony().setImsProvisioningInt(mSubId, key, value);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@WorkerThread
@RequiresPermission(Manifest.permission.MODIFY_PHONE_STATE)
@ImsConfigImplBase.SetConfigResult
public int setProvisioningIntValue(int key, int value) {
    try {
        return getITelephony().setImsProvisioningInt(mSubId, key, value);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.MODIFY_PHONE_STATE)
@ImsConfigImplBase.SetConfigResult
public int setProvisioningStringValue(int key, String value) {
    try {
        return getITelephony().setImsProvisioningString(mSubId, key, value);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@WorkerThread
@RequiresPermission(Manifest.permission.MODIFY_PHONE_STATE)
@ImsConfigImplBase.SetConfigResult
public int setProvisioningStringValue(int key, String value) {
    try {
        return getITelephony().setImsProvisioningString(mSubId, key, value);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
/**
 * @hide
 */
// Only exposed as public method for compatibility with deprecated ImsManager APIs.
public void setExecutor(Executor executor) {
    mBinder.setExecutor(executor);
}
#method_after
/**
 * @hide
 */
// Only exposed as public method for compatibility with deprecated ImsManager APIs.
public final void setExecutor(Executor executor) {
    mBinder.setExecutor(executor);
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public void registerMmTelCapabilityCallback(@CallbackExecutor Executor executor, @NonNull CapabilityCallback c) {
    if (c == null) {
        throw new IllegalArgumentException("Must include a non-null RegistrationCallback.");
    }
    if (executor == null) {
        throw new IllegalArgumentException("Must include a non-null Executor.");
    }
    c.setExecutor(executor);
    try {
        getITelephony().registerMmTelCapabilityCallback(mSubId, c.getBinder());
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public void registerMmTelCapabilityCallback(@NonNull @CallbackExecutor Executor executor, @NonNull CapabilityCallback c) {
    if (c == null) {
        throw new IllegalArgumentException("Must include a non-null RegistrationCallback.");
    }
    if (executor == null) {
        throw new IllegalArgumentException("Must include a non-null Executor.");
    }
    c.setExecutor(executor);
    try {
        getITelephony().registerMmTelCapabilityCallback(mSubId, c.getBinder());
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
@WiFiCallingMode
int getVoWiFiRoamingModeSetting() {
    try {
        return getITelephony().getVoWiFiRoamingModeSetting(mSubId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
@WiFiCallingMode
public int getVoWiFiRoamingModeSetting() {
    try {
        return getITelephony().getVoWiFiRoamingModeSetting(mSubId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
public void setWfcMode(int wfcMode) {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    setWfcMode(wfcMode, tm.isNetworkRoaming(getSubId()));
}
#method_after
public void setWfcMode(int wfcMode) {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    setWfcMode(wfcMode, false);
}
#end_block

#method_before
public void updateImsServiceConfig(boolean force) {
    if (!force) {
        TelephonyManager tm = new TelephonyManager(mContext, getSubId());
        if (tm.getSimState() != TelephonyManager.SIM_STATE_READY) {
            log("updateImsServiceConfig: SIM not ready");
            // Don't disable IMS if SIM is not ready
            return;
        }
    }
    if (!mConfigUpdated || force) {
        try {
            // Note: currently the order of updates is set to produce different order of
            // changeEnabledCapabilities() function calls from setAdvanced4GMode(). This is done
            // to differentiate this code path from vendor code perspective.
            boolean isImsUsed = updateVolteFeatureValue();
            isImsUsed |= updateWfcFeatureAndProvisionedValues();
            isImsUsed |= updateVideoCallFeatureValue();
            isImsUsed |= updateUtFeatureValue();
            isImsUsed |= updateRttConfigValue();
            if (isImsUsed || !isTurnOffImsAllowedByPlatform()) {
                // Turn on IMS if it is used.
                // Also, if turning off is not allowed for current carrier,
                // we need to turn IMS on because it might be turned off before
                // phone switched to current carrier.
                log("updateImsServiceConfig: turnOnIms");
                turnOnIms();
            } else {
                // Turn off IMS if it is not used AND turning off is allowed for carrier.
                log("updateImsServiceConfig: turnOffIms");
                turnOffIms();
            }
            mConfigUpdated = true;
        } catch (ImsException e) {
            loge("updateImsServiceConfig: ", e);
            mConfigUpdated = false;
        }
    }
}
#method_after
public void updateImsServiceConfig(boolean force) {
    if (!force) {
        TelephonyManager tm = new TelephonyManager(mContext, getSubId());
        if (tm.getSimState() != TelephonyManager.SIM_STATE_READY) {
            log("updateImsServiceConfig: SIM not ready");
            // Don't disable IMS if SIM is not ready
            return;
        }
    }
    if (!mConfigUpdated || force) {
        try {
            // Note: currently the order of updates is set to produce different order of
            // changeEnabledCapabilities() function calls from setAdvanced4GMode(). This is done
            // to differentiate this code path from vendor code perspective.
            boolean isImsUsed = updateVolteFeatureValue();
            isImsUsed |= updateWfcFeatureAndProvisionedValues();
            isImsUsed |= updateVideoCallFeatureValue();
            isImsUsed |= updateRttConfigValue();
            // Supplementary services over UT do not require IMS registration. Do not alter IMS
            // registration based on UT.
            updateUtFeatureValue();
            if (isImsUsed || !isTurnOffImsAllowedByPlatform()) {
                // Turn on IMS if it is used.
                // Also, if turning off is not allowed for current carrier,
                // we need to turn IMS on because it might be turned off before
                // phone switched to current carrier.
                log("updateImsServiceConfig: turnOnIms");
                turnOnIms();
            } else {
                // Turn off IMS if it is not used AND turning off is allowed for carrier.
                log("updateImsServiceConfig: turnOffIms");
                turnOffIms();
            }
            mConfigUpdated = true;
        } catch (ImsException e) {
            loge("updateImsServiceConfig: ", e);
            mConfigUpdated = false;
        }
    }
}
#end_block

#method_before
public void setWfcNonPersistent(boolean enabled, int wfcMode, boolean isNetworkRoaming) {
    // Force IMS to register over LTE when turning off WFC
    int imsWfcModeFeatureValue = enabled ? wfcMode : ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED;
    try {
        changeMmTelCapability(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE, ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, enabled);
        if (enabled) {
            log("setWfcSetting() : turnOnIms");
            turnOnIms();
        } else if (isTurnOffImsAllowedByPlatform() && (!isVolteEnabledByPlatform() || !isEnhanced4gLteModeSettingEnabledByUser())) {
            log("setWfcSetting() : imsServiceAllowTurnOff -> turnOffIms");
            turnOffIms();
        }
        setWfcModeInternal(imsWfcModeFeatureValue);
        // If isNetworkRoaming or enabled is false, shortcut to false,
        // otherwise use user's setting.
        setWfcRoamingSettingInternal(enabled && isNetworkRoaming && isWfcRoamingEnabledByUser());
    } catch (ImsException e) {
        loge("setWfcSetting(): ", e);
    }
}
#method_after
public void setWfcNonPersistent(boolean enabled, int wfcMode, boolean isNetworkRoaming) {
    // Force IMS to register over LTE when turning off WFC
    int imsWfcModeFeatureValue = enabled ? wfcMode : ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED;
    try {
        changeMmTelCapability(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE, ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, enabled);
        // Set the mode and roaming enabled settings before turning on IMS
        setWfcModeInternal(imsWfcModeFeatureValue);
        // If isNetworkRoaming or enabled is false, shortcut to false because of the ImsService
        // implementation for WFC roaming, otherwise use the correct user's setting.
        setWfcRoamingSettingInternal(enabled && isNetworkRoaming && isWfcRoamingEnabledByUser());
        if (enabled) {
            log("setWfcSetting() : turnOnIms");
            turnOnIms();
        } else if (isTurnOffImsAllowedByPlatform() && (!isVolteEnabledByPlatform() || !isEnhanced4gLteModeSettingEnabledByUser())) {
            log("setWfcSetting() : imsServiceAllowTurnOff -> turnOffIms");
            turnOffIms();
        }
    } catch (ImsException e) {
        loge("setWfcSetting(): ", e);
    }
}
#end_block

#method_before
public void setWfcMode(int wfcMode) {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    setWfcMode(wfcMode, tm.isNetworkRoaming(getSubId()));
}
#method_after
public void setWfcMode(int wfcMode) {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    setWfcMode(wfcMode, false);
}
#end_block

#method_before
public void setWfcMode(int wfcMode, boolean roaming) {
    int subId = getSubId();
    if (isSubIdValid(subId)) {
        if (!roaming) {
            if (DBG)
                log("setWfcMode(i,b) - setting=" + wfcMode);
            SubscriptionManager.setSubscriptionProperty(subId, SubscriptionManager.WFC_IMS_MODE, Integer.toString(wfcMode));
        } else {
            if (DBG)
                log("setWfcMode(i,b) (roaming) - setting=" + wfcMode);
            SubscriptionManager.setSubscriptionProperty(subId, SubscriptionManager.WFC_IMS_ROAMING_MODE, Integer.toString(wfcMode));
        }
    } else {
        loge("setWfcMode(i,b): invalid sub id, skip setting setting in siminfo db; subId=" + subId);
    }
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    // call setWfcModeInternal when roaming == telephony roaming status. Otherwise, ignore.
    if (roaming == tm.isNetworkRoaming(getSubId())) {
        setWfcModeInternal(wfcMode);
        // if roaming is false, shortcut and just set the setting to false. Otherwise, use the
        // user's setting.
        setWfcRoamingSettingInternal(roaming && isWfcRoamingEnabledByUser());
    }
}
#method_after
public void setWfcMode(int wfcMode, boolean roaming) {
    int subId = getSubId();
    if (isSubIdValid(subId)) {
        if (!roaming) {
            if (DBG)
                log("setWfcMode(i,b) - setting=" + wfcMode);
            SubscriptionManager.setSubscriptionProperty(subId, SubscriptionManager.WFC_IMS_MODE, Integer.toString(wfcMode));
        } else {
            if (DBG)
                log("setWfcMode(i,b) (roaming) - setting=" + wfcMode);
            SubscriptionManager.setSubscriptionProperty(subId, SubscriptionManager.WFC_IMS_ROAMING_MODE, Integer.toString(wfcMode));
        }
    } else {
        loge("setWfcMode(i,b): invalid sub id, skip setting setting in siminfo db; subId=" + subId);
    }
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    // call setWfcModeInternal when roaming == telephony roaming status. Otherwise, ignore.
    if (roaming == tm.isNetworkRoaming(getSubId())) {
        setWfcModeInternal(wfcMode);
        // if roaming is false, shortcut and just set the setting to false. If WFC is not
        // enabled at all by the user, then just shortcut to false as well, because the current
        // ImsService implementation expects the roaming setting to be alsofalse if WFC is
        // false. Otherwise, use the user's setting.
        setWfcRoamingSettingInternal(roaming && isWfcEnabledByUser() && isWfcRoamingEnabledByUser());
    }
}
#end_block

#method_before
public void addRegistrationCallback(ImsMmTelManager.RegistrationCallback callback) throws ImsException {
    if (callback == null) {
        throw new NullPointerException("registration callback can't be null");
    }
    try {
        callback.setExecutor(getThreadExecutor());
        mMmTelFeatureConnection.addRegistrationCallback(callback.getBinder());
        log("Registration Callback registered.");
    // Only record if there isn't a RemoteException.
    } catch (RemoteException e) {
        throw new ImsException("addRegistrationCallback(IRIB)", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public void addRegistrationCallback(ImsMmTelManager.RegistrationCallback callback) throws ImsException {
    if (callback == null) {
        throw new NullPointerException("registration callback can't be null");
    }
    try {
        callback.setExecutor(getThreadExecutor());
        mMmTelFeatureConnection.addRegistrationCallback(callback.getBinder());
        log("Registration Callback registered.");
    // Only record if there isn't a RemoteException.
    } catch (IllegalStateException e) {
        throw new ImsException("addRegistrationCallback(IRIB)", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public void addRegistrationCallbackForSubscription(IImsRegistrationCallback callback, int subId) throws RemoteException {
    if (callback == null) {
        throw new NullPointerException("registration callback can't be null");
    }
    mMmTelFeatureConnection.addRegistrationCallbackForSubscription(callback, subId);
    log("Registration Callback registered.");
// Only record if there isn't a RemoteException.
}
#method_after
public void addRegistrationCallbackForSubscription(IImsRegistrationCallback callback, int subId) throws RemoteException {
    if (callback == null) {
        throw new IllegalArgumentException("registration callback can't be null");
    }
    mMmTelFeatureConnection.addRegistrationCallbackForSubscription(callback, subId);
    log("Registration Callback registered.");
// Only record if there isn't a RemoteException.
}
#end_block

#method_before
public void removeRegistrationCallbackForSubscription(IImsRegistrationCallback callback, int subId) {
    if (callback == null) {
        throw new NullPointerException("registration callback can't be null");
    }
    mMmTelFeatureConnection.removeRegistrationCallbackForSubscription(callback, subId);
}
#method_after
public void removeRegistrationCallbackForSubscription(IImsRegistrationCallback callback, int subId) {
    if (callback == null) {
        throw new IllegalArgumentException("registration callback can't be null");
    }
    mMmTelFeatureConnection.removeRegistrationCallbackForSubscription(callback, subId);
}
#end_block

#method_before
public void addCapabilitiesCallback(ImsMmTelManager.CapabilityCallback callback) throws ImsException {
    if (callback == null) {
        throw new NullPointerException("capabilities callback can't be null");
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        callback.setExecutor(getThreadExecutor());
        mMmTelFeatureConnection.addCapabilityCallback(callback.getBinder());
        log("Capability Callback registered.");
    // Only record if there isn't a RemoteException.
    } catch (RemoteException e) {
        throw new ImsException("addCapabilitiesCallback(IF)", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public void addCapabilitiesCallback(ImsMmTelManager.CapabilityCallback callback) throws ImsException {
    if (callback == null) {
        throw new NullPointerException("capabilities callback can't be null");
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        callback.setExecutor(getThreadExecutor());
        mMmTelFeatureConnection.addCapabilityCallback(callback.getBinder());
        log("Capability Callback registered.");
    // Only record if there isn't a RemoteException.
    } catch (IllegalStateException e) {
        throw new ImsException("addCapabilitiesCallback(IF)", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public void addCapabilitiesCallbackForSubscription(IImsCapabilityCallback callback, int subId) throws RemoteException {
    if (callback == null) {
        throw new NullPointerException("registration callback can't be null");
    }
    mMmTelFeatureConnection.addCapabilityCallbackForSubscription(callback, subId);
    log("Capability Callback registered for subscription.");
}
#method_after
public void addCapabilitiesCallbackForSubscription(IImsCapabilityCallback callback, int subId) throws RemoteException {
    if (callback == null) {
        throw new IllegalArgumentException("registration callback can't be null");
    }
    mMmTelFeatureConnection.addCapabilityCallbackForSubscription(callback, subId);
    log("Capability Callback registered for subscription.");
}
#end_block

#method_before
public void removeCapabilitiesCallbackForSubscription(IImsCapabilityCallback callback, int subId) {
    if (callback == null) {
        throw new NullPointerException("capabilities callback can't be null");
    }
    mMmTelFeatureConnection.removeCapabilityCallbackForSubscription(callback, subId);
}
#method_after
public void removeCapabilitiesCallbackForSubscription(IImsCapabilityCallback callback, int subId) {
    if (callback == null) {
        throw new IllegalArgumentException("capabilities callback can't be null");
    }
    mMmTelFeatureConnection.removeCapabilityCallbackForSubscription(callback, subId);
}
#end_block

#method_before
public ImsConfig getConfigInterface() throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsConfig config = mMmTelFeatureConnection.getConfigInterface();
        if (config == null) {
            throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
        }
        return new ImsConfig(config);
    } catch (RemoteException e) {
        throw new ImsException("getConfigInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public ImsConfig getConfigInterface() throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    IImsConfig config = mMmTelFeatureConnection.getConfigInterface();
    if (config == null) {
        throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    return new ImsConfig(config);
}
#end_block

#method_before
private void initPrecompiledViews() {
    try {
        mUseCompiledView = android.os.SystemProperties.getBoolean("view.use_precompiled_layouts", false);
        if (mUseCompiledView) {
            mPrecompiledClassLoader = mContext.getClassLoader();
            String dexFile = mContext.getCodeCacheDir() + "/compiled_view.dex";
            if (new File(dexFile).exists()) {
                mPrecompiledClassLoader = new PathClassLoader(dexFile, mPrecompiledClassLoader);
            }
        }
    } catch (Throwable e) {
        if (DEBUG) {
            Log.e(TAG, "Failed to initialized precompiled views layouts", e);
        }
        mUseCompiledView = false;
    }
}
#method_after
private void initPrecompiledViews() {
    try {
        mUseCompiledView = SystemProperties.getBoolean(USE_PRECOMPILED_LAYOUT_SYSTEM_PROPERTY, false);
        if (mUseCompiledView) {
            mPrecompiledClassLoader = mContext.getClassLoader();
            String dexFile = mContext.getCodeCacheDir() + COMPILED_VIEW_DEX_FILE_NAME;
            if (new File(dexFile).exists()) {
                mPrecompiledClassLoader = new PathClassLoader(dexFile, mPrecompiledClassLoader);
            } else {
                // If the precompiled layout file doesn't exist, then disable precompiled
                // layouts.
                mUseCompiledView = false;
            }
        }
    } catch (Throwable e) {
        if (DEBUG) {
            Log.e(TAG, "Failed to initialized precompiled views layouts", e);
        }
        mUseCompiledView = false;
    }
}
#end_block

#method_before
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")");
    }
    View view = tryInflatePrecompiled(resource, res);
    if (view != null) {
        return view;
    }
    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
#method_after
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")");
    }
    View view = tryInflatePrecompiled(resource, res, root, attachToRoot);
    if (view != null) {
        return view;
    }
    XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
#end_block

#method_before
private View tryInflatePrecompiled(@LayoutRes int resource, Resources res) {
    if (!mUseCompiledView) {
        return null;
    }
    // Try to inflate using a precompiled layout.
    String pkg = res.getResourcePackageName(resource);
    String layout = res.getResourceEntryName(resource);
    boolean traceStarted = false;
    try {
        Class clazz = mPrecompiledClassLoader.loadClass("" + pkg + ".CompiledView");
        Method inflater = clazz.getMethod(layout, Context.class, int.class);
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate (precompiled)");
        traceStarted = true;
        return (View) inflater.invoke(null, mContext, resource);
    } catch (Throwable e) {
        if (DEBUG) {
            Log.e(TAG, "Failed to use precompiled view", e);
        }
    } finally {
        if (traceStarted)
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    return null;
}
#method_after
@Nullable
private View tryInflatePrecompiled(@LayoutRes int resource, Resources res, @Nullable ViewGroup root, boolean attachToRoot) {
    if (!mUseCompiledView) {
        return null;
    }
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate (precompiled)");
    // Try to inflate using a precompiled layout.
    String pkg = res.getResourcePackageName(resource);
    String layout = res.getResourceEntryName(resource);
    try {
        Class clazz = mPrecompiledClassLoader.loadClass("" + pkg + ".CompiledView");
        Method inflater = clazz.getMethod(layout, Context.class, int.class);
        View view = (View) inflater.invoke(null, mContext, resource);
        if (view != null && root != null) {
            // We were able to use the precompiled inflater, but now we need to do some work to
            // attach the view to the root correctly.
            XmlResourceParser parser = res.getLayout(resource);
            try {
                AttributeSet attrs = Xml.asAttributeSet(parser);
                advanceToRootNode(parser);
                ViewGroup.LayoutParams params = root.generateLayoutParams(attrs);
                if (attachToRoot) {
                    root.addView(view, params);
                } else {
                    view.setLayoutParams(params);
                }
            } finally {
                parser.close();
            }
        }
        return view;
    } catch (Throwable e) {
        if (DEBUG) {
            Log.e(TAG, "Failed to use precompiled view", e);
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    return null;
}
#end_block

#method_before
public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate");
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + ": No start tag found!");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println("**************************");
                System.out.println("Creating root view: " + name);
                System.out.println("**************************");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException("<merge /> can be used only with a valid " + "ViewGroup root and attachToRoot=true");
                }
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println("Creating params from root: " + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println("-----> start inflating children");
                }
                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println("-----> done inflating children");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            final InflateException ie = new InflateException(e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } catch (Exception e) {
            final InflateException ie = new InflateException(parser.getPositionDescription() + ": " + e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
        return result;
    }
}
#method_after
public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate");
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;
        try {
            advanceToRootNode(parser);
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println("**************************");
                System.out.println("Creating root view: " + name);
                System.out.println("**************************");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException("<merge /> can be used only with a valid " + "ViewGroup root and attachToRoot=true");
                }
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println("Creating params from root: " + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println("-----> start inflating children");
                }
                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println("-----> done inflating children");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            final InflateException ie = new InflateException(e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } catch (Exception e) {
            final InflateException ie = new InflateException(parser.getPositionDescription() + ": " + e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
        return result;
    }
}
#end_block

#method_before
@UnsupportedAppUsage
private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException {
    int type;
    if (!(parent instanceof ViewGroup)) {
        throw new InflateException("<include /> can only be used inside of a ViewGroup");
    }
    // Apply a theme wrapper, if requested. This is sort of a weird
    // edge case, since developers think the <include> overwrites
    // values in the AttributeSet of the included View. So, if the
    // included View has a theme attribute, we'll need to ignore it.
    final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
    final int themeResId = ta.getResourceId(0, 0);
    final boolean hasThemeOverride = themeResId != 0;
    if (hasThemeOverride) {
        context = new ContextThemeWrapper(context, themeResId);
    }
    ta.recycle();
    // If the layout is pointing to a theme attribute, we have to
    // massage the value to get a resource identifier out of it.
    int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
    if (layout == 0) {
        final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
        if (value == null || value.length() <= 0) {
            throw new InflateException("You must specify a layout in the" + " include tag: <include layout=\"@layout/layoutID\" />");
        }
        // Attempt to resolve the "?attr/name" string to an attribute
        // within the default (e.g. application) package.
        layout = context.getResources().getIdentifier(value.substring(1), "attr", context.getPackageName());
    }
    // The layout might be referencing a theme attribute.
    if (mTempValue == null) {
        mTempValue = new TypedValue();
    }
    if (layout != 0 && context.getTheme().resolveAttribute(layout, mTempValue, true)) {
        layout = mTempValue.resourceId;
    }
    if (layout == 0) {
        final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
        throw new InflateException("You must specify a valid layout " + "reference. The layout ID " + value + " is not valid.");
    }
    View precompiled = tryInflatePrecompiled(layout, context.getResources());
    if (precompiled != null) {
        ViewGroup precompiledGroup = (ViewGroup) parent;
        final XmlResourceParser childParser2 = context.getResources().getLayout(layout);
        // start document
        childParser2.next();
        // start view
        childParser2.next();
        ViewGroup.LayoutParams precompiledParams = precompiledGroup.generateLayoutParams(childParser2);
        precompiledGroup.addView(precompiled, precompiledParams);
    } else {
        final XmlResourceParser childParser = context.getResources().getLayout(layout);
        try {
            final AttributeSet childAttrs = Xml.asAttributeSet(childParser);
            while ((type = childParser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty.
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(childParser.getPositionDescription() + ": No start tag found!");
            }
            final String childName = childParser.getName();
            if (TAG_MERGE.equals(childName)) {
                // The <merge> tag doesn't support android:theme, so
                // nothing special to do here.
                rInflate(childParser, parent, context, childAttrs, false);
            } else {
                final View view = createViewFromTag(parent, childName, context, childAttrs, hasThemeOverride);
                final ViewGroup group = (ViewGroup) parent;
                final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Include);
                final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
                final int visibility = a.getInt(R.styleable.Include_visibility, -1);
                a.recycle();
                // We try to load the layout params set in the <include /> tag.
                // If the parent can't generate layout params (ex. missing width
                // or height for the framework ViewGroups, though this is not
                // necessarily true of all ViewGroups) then we expect it to throw
                // a runtime exception.
                // We catch this exception and set localParams accordingly: true
                // means we successfully loaded layout params from the <include>
                // tag, false means we need to rely on the included layout params.
                ViewGroup.LayoutParams params = null;
                try {
                    params = group.generateLayoutParams(attrs);
                } catch (RuntimeException e) {
                // Ignore, just fail over to child attrs.
                }
                if (params == null) {
                    params = group.generateLayoutParams(childAttrs);
                }
                view.setLayoutParams(params);
                // Inflate all children.
                rInflateChildren(childParser, view, childAttrs, true);
                if (id != View.NO_ID) {
                    view.setId(id);
                }
                switch(visibility) {
                    case 0:
                        view.setVisibility(View.VISIBLE);
                        break;
                    case 1:
                        view.setVisibility(View.INVISIBLE);
                        break;
                    case 2:
                        view.setVisibility(View.GONE);
                        break;
                }
                group.addView(view);
            }
        } finally {
            childParser.close();
        }
    }
    LayoutInflater.consumeChildElements(parser);
}
#method_after
@UnsupportedAppUsage
private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException {
    int type;
    if (!(parent instanceof ViewGroup)) {
        throw new InflateException("<include /> can only be used inside of a ViewGroup");
    }
    // Apply a theme wrapper, if requested. This is sort of a weird
    // edge case, since developers think the <include> overwrites
    // values in the AttributeSet of the included View. So, if the
    // included View has a theme attribute, we'll need to ignore it.
    final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
    final int themeResId = ta.getResourceId(0, 0);
    final boolean hasThemeOverride = themeResId != 0;
    if (hasThemeOverride) {
        context = new ContextThemeWrapper(context, themeResId);
    }
    ta.recycle();
    // If the layout is pointing to a theme attribute, we have to
    // massage the value to get a resource identifier out of it.
    int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
    if (layout == 0) {
        final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
        if (value == null || value.length() <= 0) {
            throw new InflateException("You must specify a layout in the" + " include tag: <include layout=\"@layout/layoutID\" />");
        }
        // Attempt to resolve the "?attr/name" string to an attribute
        // within the default (e.g. application) package.
        layout = context.getResources().getIdentifier(value.substring(1), "attr", context.getPackageName());
    }
    // The layout might be referencing a theme attribute.
    if (mTempValue == null) {
        mTempValue = new TypedValue();
    }
    if (layout != 0 && context.getTheme().resolveAttribute(layout, mTempValue, true)) {
        layout = mTempValue.resourceId;
    }
    if (layout == 0) {
        final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
        throw new InflateException("You must specify a valid layout " + "reference. The layout ID " + value + " is not valid.");
    }
    final View precompiled = tryInflatePrecompiled(layout, context.getResources(), (ViewGroup) parent, /*attachToRoot=*/
    true);
    if (precompiled == null) {
        final XmlResourceParser childParser = context.getResources().getLayout(layout);
        try {
            final AttributeSet childAttrs = Xml.asAttributeSet(childParser);
            while ((type = childParser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty.
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(childParser.getPositionDescription() + ": No start tag found!");
            }
            final String childName = childParser.getName();
            if (TAG_MERGE.equals(childName)) {
                // The <merge> tag doesn't support android:theme, so
                // nothing special to do here.
                rInflate(childParser, parent, context, childAttrs, false);
            } else {
                final View view = createViewFromTag(parent, childName, context, childAttrs, hasThemeOverride);
                final ViewGroup group = (ViewGroup) parent;
                final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Include);
                final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
                final int visibility = a.getInt(R.styleable.Include_visibility, -1);
                a.recycle();
                // We try to load the layout params set in the <include /> tag.
                // If the parent can't generate layout params (ex. missing width
                // or height for the framework ViewGroups, though this is not
                // necessarily true of all ViewGroups) then we expect it to throw
                // a runtime exception.
                // We catch this exception and set localParams accordingly: true
                // means we successfully loaded layout params from the <include>
                // tag, false means we need to rely on the included layout params.
                ViewGroup.LayoutParams params = null;
                try {
                    params = group.generateLayoutParams(attrs);
                } catch (RuntimeException e) {
                // Ignore, just fail over to child attrs.
                }
                if (params == null) {
                    params = group.generateLayoutParams(childAttrs);
                }
                view.setLayoutParams(params);
                // Inflate all children.
                rInflateChildren(childParser, view, childAttrs, true);
                if (id != View.NO_ID) {
                    view.setId(id);
                }
                switch(visibility) {
                    case 0:
                        view.setVisibility(View.VISIBLE);
                        break;
                    case 1:
                        view.setVisibility(View.INVISIBLE);
                        break;
                    case 2:
                        view.setVisibility(View.GONE);
                        break;
                }
                group.addView(view);
            }
        } finally {
            childParser.close();
        }
    }
    LayoutInflater.consumeChildElements(parser);
}
#end_block

#method_before
private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, final int compilationReason, boolean bootComplete) {
    int numberOfPackagesVisited = 0;
    int numberOfPackagesOptimized = 0;
    int numberOfPackagesSkipped = 0;
    int numberOfPackagesFailed = 0;
    final int numberOfPackagesToDexopt = pkgs.size();
    for (PackageParser.Package pkg : pkgs) {
        numberOfPackagesVisited++;
        boolean useProfileForDexopt = false;
        if (SystemProperties.getBoolean("view.precompiled_layout_enabled", false)) {
            compileLayouts(pkg.packageName);
        }
        if ((isFirstBoot() || isUpgrade()) && isSystemApp(pkg)) {
            // Copy over initial preopt profiles since we won't get any JIT samples for methods
            // that are already compiled.
            File profileFile = new File(getPrebuildProfilePath(pkg));
            // Copy profile if it exists.
            if (profileFile.exists()) {
                try {
                    // is that we don't have a good way to say "do this only once".
                    if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                        Log.e(TAG, "Installer failed to copy system profile!");
                    } else {
                    // Disabled as this causes speed-profile compilation during first boot
                    // even if things are already compiled.
                    // useProfileForDexopt = true;
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                }
            } else {
                PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                // The other paths will not change the filter.
                if (disabledPs != null && disabledPs.pkg.isStub) {
                    // The package is the stub one, remove the stub suffix to get the normal
                    // package and APK names.
                    String systemProfilePath = getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, "");
                    profileFile = new File(systemProfilePath);
                    // directories are not set up at that point.
                    if (profileFile.exists()) {
                        try {
                            // once".
                            if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                                Log.e(TAG, "Failed to copy system profile for stub package!");
                            } else {
                                useProfileForDexopt = true;
                            }
                        } catch (Exception e) {
                            Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                        }
                    }
                }
            }
        }
        if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
            if (DEBUG_DEXOPT) {
                Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
            }
            numberOfPackagesSkipped++;
            continue;
        }
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Updating app " + numberOfPackagesVisited + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
        }
        if (showDialog) {
            try {
                ActivityManager.getService().showBootMessage(mContext.getResources().getString(R.string.android_upgrading_apk, numberOfPackagesVisited, numberOfPackagesToDexopt), true);
            } catch (RemoteException e) {
            }
            synchronized (mPackages) {
                mDexOptDialogShown = true;
            }
        }
        int pkgCompilationReason = compilationReason;
        if (useProfileForDexopt) {
            // Use background dexopt mode to try and use the profile. Note that this does not
            // guarantee usage of the profile.
            pkgCompilationReason = PackageManagerService.REASON_BACKGROUND_DEXOPT;
        }
        // checkProfiles is false to avoid merging profiles during boot which
        // might interfere with background compilation (b/28612421).
        // Unfortunately this will also means that "pm.dexopt.boot=speed-profile" will
        // behave differently than "pm.dexopt.bg-dexopt=speed-profile" but that's a
        // trade-off worth doing to save boot time work.
        int dexoptFlags = bootComplete ? DexoptOptions.DEXOPT_BOOT_COMPLETE : 0;
        if (compilationReason == REASON_FIRST_BOOT) {
            // TODO: This doesn't cover the upgrade case, we should check for this too.
            dexoptFlags |= DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE;
        }
        int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, dexoptFlags));
        switch(primaryDexOptStaus) {
            case PackageDexOptimizer.DEX_OPT_PERFORMED:
                numberOfPackagesOptimized++;
                break;
            case PackageDexOptimizer.DEX_OPT_SKIPPED:
                numberOfPackagesSkipped++;
                break;
            case PackageDexOptimizer.DEX_OPT_FAILED:
                numberOfPackagesFailed++;
                break;
            default:
                Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                break;
        }
    }
    return new int[] { numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed };
}
#method_after
private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, final int compilationReason, boolean bootComplete) {
    int numberOfPackagesVisited = 0;
    int numberOfPackagesOptimized = 0;
    int numberOfPackagesSkipped = 0;
    int numberOfPackagesFailed = 0;
    final int numberOfPackagesToDexopt = pkgs.size();
    for (PackageParser.Package pkg : pkgs) {
        numberOfPackagesVisited++;
        boolean useProfileForDexopt = false;
        if ((isFirstBoot() || isUpgrade()) && isSystemApp(pkg)) {
            // Copy over initial preopt profiles since we won't get any JIT samples for methods
            // that are already compiled.
            File profileFile = new File(getPrebuildProfilePath(pkg));
            // Copy profile if it exists.
            if (profileFile.exists()) {
                try {
                    // is that we don't have a good way to say "do this only once".
                    if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                        Log.e(TAG, "Installer failed to copy system profile!");
                    } else {
                    // Disabled as this causes speed-profile compilation during first boot
                    // even if things are already compiled.
                    // useProfileForDexopt = true;
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                }
            } else {
                PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                // The other paths will not change the filter.
                if (disabledPs != null && disabledPs.pkg.isStub) {
                    // The package is the stub one, remove the stub suffix to get the normal
                    // package and APK names.
                    String systemProfilePath = getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, "");
                    profileFile = new File(systemProfilePath);
                    // directories are not set up at that point.
                    if (profileFile.exists()) {
                        try {
                            // once".
                            if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                                Log.e(TAG, "Failed to copy system profile for stub package!");
                            } else {
                                useProfileForDexopt = true;
                            }
                        } catch (Exception e) {
                            Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                        }
                    }
                }
            }
        }
        if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
            if (DEBUG_DEXOPT) {
                Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
            }
            numberOfPackagesSkipped++;
            continue;
        }
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Updating app " + numberOfPackagesVisited + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
        }
        if (showDialog) {
            try {
                ActivityManager.getService().showBootMessage(mContext.getResources().getString(R.string.android_upgrading_apk, numberOfPackagesVisited, numberOfPackagesToDexopt), true);
            } catch (RemoteException e) {
            }
            synchronized (mPackages) {
                mDexOptDialogShown = true;
            }
        }
        int pkgCompilationReason = compilationReason;
        if (useProfileForDexopt) {
            // Use background dexopt mode to try and use the profile. Note that this does not
            // guarantee usage of the profile.
            pkgCompilationReason = PackageManagerService.REASON_BACKGROUND_DEXOPT;
        }
        if (PRECOMPILED_LAYOUT_ENABLED) {
            mArtManagerService.compileLayouts(pkg);
        }
        // checkProfiles is false to avoid merging profiles during boot which
        // might interfere with background compilation (b/28612421).
        // Unfortunately this will also means that "pm.dexopt.boot=speed-profile" will
        // behave differently than "pm.dexopt.bg-dexopt=speed-profile" but that's a
        // trade-off worth doing to save boot time work.
        int dexoptFlags = bootComplete ? DexoptOptions.DEXOPT_BOOT_COMPLETE : 0;
        if (compilationReason == REASON_FIRST_BOOT) {
            // TODO: This doesn't cover the upgrade case, we should check for this too.
            dexoptFlags |= DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE;
        }
        int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, dexoptFlags));
        switch(primaryDexOptStaus) {
            case PackageDexOptimizer.DEX_OPT_PERFORMED:
                numberOfPackagesOptimized++;
                break;
            case PackageDexOptimizer.DEX_OPT_SKIPPED:
                numberOfPackagesSkipped++;
                break;
            case PackageDexOptimizer.DEX_OPT_FAILED:
                numberOfPackagesFailed++;
                break;
            default:
                Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                break;
        }
    }
    return new int[] { numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed };
}
#end_block

#method_before
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    final boolean virtualPreload = ((installFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);
    boolean replace = false;
    @ScanFlags
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    if (virtualPreload) {
        scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    res.installerPackageName = installerPackageName;
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    @ParseFlags
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
        DexMetadataHelper.validatePackageDexMetadata(pkg);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps have several additional install-time checks.
    if (instantApp) {
        if (pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.O) {
            Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target at least O");
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package must target at least O");
            return;
        }
        if (pkg.applicationInfo.targetSandboxVersion != 2) {
            Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package must use targetSandboxVersion 2");
            return;
        }
        if (pkg.mSharedUserId != null) {
            Slog.w(TAG, "Instant app package " + pkg.packageName + " may not declare sharedUserId.");
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package may not declare a sharedUserId");
            return;
        }
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
            pkg.setSigningDetails(args.signingDetails);
        } else {
            PackageParser.collectCertificates(pkg, false);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    if (instantApp && pkg.mSigningDetails.signatureSchemeVersion < SignatureSchemeVersion.SIGNING_BLOCK_V2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " is not signed with at least APK Signature Scheme v2");
        res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package must be signed with APK Signature Scheme v2 or greater");
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent persistent apps from being updated
                if ((oldPackage.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0) {
                    res.setError(PackageManager.INSTALL_FAILED_INVALID_APK, "Package " + oldPackage.packageName + " is a persistent app. " + "Persistent apps are not updateable.");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryInfo libraryInfo = getLatestSharedLibraVersionLPr(pkg);
                if (libraryInfo != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryInfo.getPackageName());
                }
            }
            // Quick sanity check that we're signed correctly if updating;
            // we'll check this again later when scanning, but we want to
            // bail early here before tripping over redefined permissions.
            final KeySetManagerService ksms = mSettings.mKeySetManagerService;
            if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                if (!ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    final boolean compareCompat = isCompatSignatureUpdateNeeded(pkg);
                    final boolean compareRecover = isRecoverSignatureUpdateNeeded(pkg);
                    // We don't care about disabledPkgSetting on install for now.
                    final boolean compatMatch = verifySignatures(signatureCheckPs, null, pkg.mSigningDetails, compareCompat, compareRecover);
                    // The new KeySets will be re-added later in the scanning process.
                    if (compatMatch) {
                        synchronized (mPackages) {
                            ksms.removeAppKeySetDataLPw(pkg.packageName);
                        }
                    }
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            final PackageParser.Permission perm = pkg.permissions.get(i);
            final BasePermission bp = (BasePermission) mPermissionManager.getPermissionTEMP(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_INSTANT;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                final String sourcePackageName = bp.getSourcePackageName();
                final PackageSettingBase sourcePackageSetting = bp.getSourcePackageSetting();
                final KeySetManagerService ksms = mSettings.mKeySetManagerService;
                if (sourcePackageName.equals(pkg.packageName) && (ksms.shouldCheckUpgradeKeySetLocked(sourcePackageSetting, scanFlags))) {
                    sigsOk = ksms.checkUpgradeKeySetLocked(sourcePackageSetting, pkg);
                } else {
                    // older certificate with which the current is ok with sharing permissions
                    if (sourcePackageSetting.signatures.mSigningDetails.checkCapability(pkg.mSigningDetails, PackageParser.SigningDetails.CertCapabilities.PERMISSION)) {
                        sigsOk = true;
                    } else if (pkg.mSigningDetails.checkCapability(sourcePackageSetting.signatures.mSigningDetails, PackageParser.SigningDetails.CertCapabilities.PERMISSION)) {
                        // the scanned package checks out, has signing certificate rotation
                        // history, and is newer; bring it over
                        sourcePackageSetting.signatures.mSigningDetails = pkg.mSigningDetails;
                        sigsOk = true;
                    } else {
                        sigsOk = false;
                    }
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!sourcePackageName.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName);
                        res.origPermission = perm.info.name;
                        res.origPackage = sourcePackageName;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.getProtectionLevel();
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, abiOverride, extractNativeLibs);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    if (PackageManagerServiceUtils.isApkVerityEnabled()) {
        String apkPath = null;
        synchronized (mPackages) {
            // Note that if the attacker managed to skip verify setup, for example by tampering
            // with the package settings, upon reboot we will do full apk verification when
            // verity is not detected.
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps != null && ps.isPrivileged()) {
                apkPath = pkg.baseCodePath;
            }
        }
        if (apkPath != null) {
            final VerityUtils.SetupResult result = VerityUtils.generateApkVeritySetupData(apkPath);
            if (result.isOk()) {
                if (Build.IS_DEBUGGABLE)
                    Slog.i(TAG, "Enabling apk verity to " + apkPath);
                FileDescriptor fd = result.getUnownedFileDescriptor();
                try {
                    final byte[] signedRootHash = VerityUtils.generateFsverityRootHash(apkPath);
                    mInstaller.installApkVerity(apkPath, fd, result.getContentSize());
                    mInstaller.assertFsverityRootHashMatches(apkPath, signedRootHash);
                } catch (InstallerException | IOException | DigestException | NoSuchAlgorithmException e) {
                    res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Failed to set up verity: " + e);
                    return;
                } finally {
                    IoUtils.closeQuietly(fd);
                }
            } else if (result.isFailed()) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Failed to generate verity");
                return;
            } else {
            // Do nothing if verity is skipped. Will fall back to full apk verification on
            // reboot.
            }
        }
    }
    if (!instantApp) {
        startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    } else {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Not verifying instant app install for app links: " + pkgName);
        }
    }
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.getLongVersionCode() != pkg.getLongVersionCode()) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    // Prepare the application profiles for the new code paths.
    // This needs to be done before invoking dexopt so that any install-time profile
    // can be used for optimizations.
    mArtManagerService.prepareAppProfiles(pkg, resolveUserIds(args.user.getIdentifier()), /* updateReferenceProfileContent= */
    true);
    // Compile the views.
    if (SystemProperties.getBoolean("view.precompiled_layout_enabled", false)) {
        compileLayouts(pkgName);
    }
    // Check whether we need to dexopt the app.
    // 
    // NOTE: it is IMPORTANT to call dexopt:
    // - after doRename which will sync the package data from PackageParser.Package and its
    // corresponding ApplicationInfo.
    // - after installNewPackageLIF or replacePackageLIF which will update result with the
    // uid of the application (pkg.applicationInfo.uid).
    // This update happens in place!
    // 
    // We only need to dexopt if the package meets ALL of the following conditions:
    // 1) it is not forward locked.
    // 2) it is not on on an external ASEC container.
    // 3) it is not an instant app or if it is then dexopt is enabled via gservices.
    // 4) it is not debuggable.
    // 
    // Note that we do not dexopt instant apps by default. dexopt can take some time to
    // complete, so we skip this step during installation. Instead, we'll take extra time
    // the first time the instant app starts. It's preferred to do it this way to provide
    // continuous progress to the useur instead of mysteriously blocking somewhere in the
    // middle of running an instant app. The default behaviour can be overridden
    // via gservices.
    final boolean performDexopt = (res.returnCode == PackageManager.INSTALL_SUCCEEDED) && !forwardLocked && !pkg.applicationInfo.isExternalAsec() && (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0) && ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0);
    if (performDexopt) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Do not run PackageDexOptimizer through the local performDexOpt
        // method because `pkg` may not be in `mPackages` yet.
        // 
        // Also, don't fail application installs if the dexopt step fails.
        DexoptOptions dexoptOptions = new DexoptOptions(pkg.packageName, REASON_INSTALL, DexoptOptions.DEXOPT_BOOT_COMPLETE | DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE);
        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryInfos, null, /* instructionSets */
        getOrCreateCompilerPackageStats(pkg), mDexManager.getPackageUseInfoOrDefault(pkg.packageName), dexoptOptions);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Notify BackgroundDexOptService that the package has been changed.
    // If this is an update of a package which used to fail to compile,
    // BackgroundDexOptService will remove it from its blacklist.
    // TODO: Layering violation
    BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#method_after
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    final boolean virtualPreload = ((installFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);
    boolean replace = false;
    @ScanFlags
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    if (virtualPreload) {
        scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    res.installerPackageName = installerPackageName;
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    @ParseFlags
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
        DexMetadataHelper.validatePackageDexMetadata(pkg);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps have several additional install-time checks.
    if (instantApp) {
        if (pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.O) {
            Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target at least O");
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package must target at least O");
            return;
        }
        if (pkg.applicationInfo.targetSandboxVersion != 2) {
            Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package must use targetSandboxVersion 2");
            return;
        }
        if (pkg.mSharedUserId != null) {
            Slog.w(TAG, "Instant app package " + pkg.packageName + " may not declare sharedUserId.");
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package may not declare a sharedUserId");
            return;
        }
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
            pkg.setSigningDetails(args.signingDetails);
        } else {
            PackageParser.collectCertificates(pkg, false);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    if (instantApp && pkg.mSigningDetails.signatureSchemeVersion < SignatureSchemeVersion.SIGNING_BLOCK_V2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " is not signed with at least APK Signature Scheme v2");
        res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Instant app package must be signed with APK Signature Scheme v2 or greater");
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent persistent apps from being updated
                if ((oldPackage.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0) {
                    res.setError(PackageManager.INSTALL_FAILED_INVALID_APK, "Package " + oldPackage.packageName + " is a persistent app. " + "Persistent apps are not updateable.");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryInfo libraryInfo = getLatestSharedLibraVersionLPr(pkg);
                if (libraryInfo != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryInfo.getPackageName());
                }
            }
            // Quick sanity check that we're signed correctly if updating;
            // we'll check this again later when scanning, but we want to
            // bail early here before tripping over redefined permissions.
            final KeySetManagerService ksms = mSettings.mKeySetManagerService;
            if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                if (!ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    final boolean compareCompat = isCompatSignatureUpdateNeeded(pkg);
                    final boolean compareRecover = isRecoverSignatureUpdateNeeded(pkg);
                    // We don't care about disabledPkgSetting on install for now.
                    final boolean compatMatch = verifySignatures(signatureCheckPs, null, pkg.mSigningDetails, compareCompat, compareRecover);
                    // The new KeySets will be re-added later in the scanning process.
                    if (compatMatch) {
                        synchronized (mPackages) {
                            ksms.removeAppKeySetDataLPw(pkg.packageName);
                        }
                    }
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            final PackageParser.Permission perm = pkg.permissions.get(i);
            final BasePermission bp = (BasePermission) mPermissionManager.getPermissionTEMP(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_INSTANT;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                final String sourcePackageName = bp.getSourcePackageName();
                final PackageSettingBase sourcePackageSetting = bp.getSourcePackageSetting();
                final KeySetManagerService ksms = mSettings.mKeySetManagerService;
                if (sourcePackageName.equals(pkg.packageName) && (ksms.shouldCheckUpgradeKeySetLocked(sourcePackageSetting, scanFlags))) {
                    sigsOk = ksms.checkUpgradeKeySetLocked(sourcePackageSetting, pkg);
                } else {
                    // older certificate with which the current is ok with sharing permissions
                    if (sourcePackageSetting.signatures.mSigningDetails.checkCapability(pkg.mSigningDetails, PackageParser.SigningDetails.CertCapabilities.PERMISSION)) {
                        sigsOk = true;
                    } else if (pkg.mSigningDetails.checkCapability(sourcePackageSetting.signatures.mSigningDetails, PackageParser.SigningDetails.CertCapabilities.PERMISSION)) {
                        // the scanned package checks out, has signing certificate rotation
                        // history, and is newer; bring it over
                        sourcePackageSetting.signatures.mSigningDetails = pkg.mSigningDetails;
                        sigsOk = true;
                    } else {
                        sigsOk = false;
                    }
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!sourcePackageName.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName);
                        res.origPermission = perm.info.name;
                        res.origPackage = sourcePackageName;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.getProtectionLevel();
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, abiOverride, extractNativeLibs);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    if (PackageManagerServiceUtils.isApkVerityEnabled()) {
        String apkPath = null;
        synchronized (mPackages) {
            // Note that if the attacker managed to skip verify setup, for example by tampering
            // with the package settings, upon reboot we will do full apk verification when
            // verity is not detected.
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps != null && ps.isPrivileged()) {
                apkPath = pkg.baseCodePath;
            }
        }
        if (apkPath != null) {
            final VerityUtils.SetupResult result = VerityUtils.generateApkVeritySetupData(apkPath);
            if (result.isOk()) {
                if (Build.IS_DEBUGGABLE)
                    Slog.i(TAG, "Enabling apk verity to " + apkPath);
                FileDescriptor fd = result.getUnownedFileDescriptor();
                try {
                    final byte[] signedRootHash = VerityUtils.generateFsverityRootHash(apkPath);
                    mInstaller.installApkVerity(apkPath, fd, result.getContentSize());
                    mInstaller.assertFsverityRootHashMatches(apkPath, signedRootHash);
                } catch (InstallerException | IOException | DigestException | NoSuchAlgorithmException e) {
                    res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Failed to set up verity: " + e);
                    return;
                } finally {
                    IoUtils.closeQuietly(fd);
                }
            } else if (result.isFailed()) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Failed to generate verity");
                return;
            } else {
            // Do nothing if verity is skipped. Will fall back to full apk verification on
            // reboot.
            }
        }
    }
    if (!instantApp) {
        startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    } else {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Not verifying instant app install for app links: " + pkgName);
        }
    }
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.getLongVersionCode() != pkg.getLongVersionCode()) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    // Prepare the application profiles for the new code paths.
    // This needs to be done before invoking dexopt so that any install-time profile
    // can be used for optimizations.
    mArtManagerService.prepareAppProfiles(pkg, resolveUserIds(args.user.getIdentifier()), /* updateReferenceProfileContent= */
    true);
    // Check whether we need to dexopt the app.
    // 
    // NOTE: it is IMPORTANT to call dexopt:
    // - after doRename which will sync the package data from PackageParser.Package and its
    // corresponding ApplicationInfo.
    // - after installNewPackageLIF or replacePackageLIF which will update result with the
    // uid of the application (pkg.applicationInfo.uid).
    // This update happens in place!
    // 
    // We only need to dexopt if the package meets ALL of the following conditions:
    // 1) it is not forward locked.
    // 2) it is not on on an external ASEC container.
    // 3) it is not an instant app or if it is then dexopt is enabled via gservices.
    // 4) it is not debuggable.
    // 
    // Note that we do not dexopt instant apps by default. dexopt can take some time to
    // complete, so we skip this step during installation. Instead, we'll take extra time
    // the first time the instant app starts. It's preferred to do it this way to provide
    // continuous progress to the useur instead of mysteriously blocking somewhere in the
    // middle of running an instant app. The default behaviour can be overridden
    // via gservices.
    final boolean performDexopt = (res.returnCode == PackageManager.INSTALL_SUCCEEDED) && !forwardLocked && !pkg.applicationInfo.isExternalAsec() && (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0) && ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0);
    if (performDexopt) {
        // Compile the layout resources.
        if (PRECOMPILED_LAYOUT_ENABLED) {
            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "compileLayouts");
            mArtManagerService.compileLayouts(pkg);
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Do not run PackageDexOptimizer through the local performDexOpt
        // method because `pkg` may not be in `mPackages` yet.
        // 
        // Also, don't fail application installs if the dexopt step fails.
        DexoptOptions dexoptOptions = new DexoptOptions(pkg.packageName, REASON_INSTALL, DexoptOptions.DEXOPT_BOOT_COMPLETE | DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE);
        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryInfos, null, /* instructionSets */
        getOrCreateCompilerPackageStats(pkg), mDexManager.getPackageUseInfoOrDefault(pkg.packageName), dexoptOptions);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Notify BackgroundDexOptService that the package has been changed.
    // If this is an update of a package which used to fail to compile,
    // BackgroundDexOptService will remove it from its blacklist.
    // TODO: Layering violation
    BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#end_block

#method_before
public boolean compileLayouts(String apkPath, String packageName, String outDexFile) {
    try {
        return mInstalld.compileLayouts(apkPath, packageName, outDexFile);
    } catch (RemoteException e) {
        return false;
    }
}
#method_after
public boolean compileLayouts(String apkPath, String packageName, String outDexFile, int uid) {
    try {
        return mInstalld.compileLayouts(apkPath, packageName, outDexFile, uid);
    } catch (RemoteException e) {
        return false;
    }
}
#end_block

#method_before
private int runCompile() throws RemoteException {
    final PrintWriter pw = getOutPrintWriter();
    boolean checkProfiles = SystemProperties.getBoolean("dalvik.vm.usejitprofiles", false);
    boolean forceCompilation = false;
    boolean allPackages = false;
    boolean clearProfileData = false;
    String compilerFilter = null;
    String compilationReason = null;
    String checkProfilesRaw = null;
    boolean secondaryDex = false;
    String split = null;
    boolean compileLayouts = false;
    String opt;
    while ((opt = getNextOption()) != null) {
        switch(opt) {
            case "-a":
                allPackages = true;
                break;
            case "-c":
                clearProfileData = true;
                break;
            case "-f":
                forceCompilation = true;
                break;
            case "-m":
                compilerFilter = getNextArgRequired();
                break;
            case "-r":
                compilationReason = getNextArgRequired();
                break;
            case "--compile-layouts":
                compileLayouts = true;
                break;
            case "--check-prof":
                checkProfilesRaw = getNextArgRequired();
                break;
            case "--reset":
                forceCompilation = true;
                clearProfileData = true;
                compilationReason = "install";
                break;
            case "--secondary-dex":
                secondaryDex = true;
                break;
            case "--split":
                split = getNextArgRequired();
                break;
            default:
                pw.println("Error: Unknown option: " + opt);
                return 1;
        }
    }
    if (checkProfilesRaw != null) {
        if ("true".equals(checkProfilesRaw)) {
            checkProfiles = true;
        } else if ("false".equals(checkProfilesRaw)) {
            checkProfiles = false;
        } else {
            pw.println("Invalid value for \"--check-prof\". Expected \"true\" or \"false\".");
            return 1;
        }
    }
    if (compilerFilter != null && compilationReason != null) {
        pw.println("Cannot use compilation filter (\"-m\") and compilation reason (\"-r\") " + "at the same time");
        return 1;
    }
    if (compilerFilter == null && compilationReason == null && !compileLayouts) {
        pw.println("Cannot run without any of compilation filter (\"-m\") and compilation " + "reason (\"-r\") at the same time");
        return 1;
    }
    if (allPackages && split != null) {
        pw.println("-a cannot be specified together with --split");
        return 1;
    }
    if (secondaryDex && split != null) {
        pw.println("--secondary-dex cannot be specified together with --split");
        return 1;
    }
    String targetCompilerFilter = null;
    if (compilerFilter != null) {
        if (!DexFile.isValidCompilerFilter(compilerFilter)) {
            pw.println("Error: \"" + compilerFilter + "\" is not a valid compilation filter.");
            return 1;
        }
        targetCompilerFilter = compilerFilter;
    } else if (!compileLayouts || compilationReason != null) {
        // if compileLayouts is true, then we don't need a compilation reason.
        int reason = -1;
        for (int i = 0; i < PackageManagerServiceCompilerMapping.REASON_STRINGS.length; i++) {
            if (PackageManagerServiceCompilerMapping.REASON_STRINGS[i].equals(compilationReason)) {
                reason = i;
                break;
            }
        }
        if (reason == -1) {
            pw.println("Error: Unknown compilation reason: " + compilationReason);
            return 1;
        }
        targetCompilerFilter = PackageManagerServiceCompilerMapping.getCompilerFilterForReason(reason);
    }
    List<String> packageNames = null;
    if (allPackages) {
        packageNames = mInterface.getAllPackages();
    } else {
        String packageName = getNextArg();
        if (packageName == null) {
            pw.println("Error: package name not specified");
            return 1;
        }
        packageNames = Collections.singletonList(packageName);
    }
    List<String> failedPackages = new ArrayList<>();
    int index = 0;
    for (String packageName : packageNames) {
        if (clearProfileData) {
            mInterface.clearApplicationProfileData(packageName);
        }
        if (allPackages) {
            pw.println(++index + "/" + packageNames.size() + ": " + packageName);
            pw.flush();
        }
        boolean result = true;
        if (compileLayouts) {
            result = mInterface.compileLayouts(packageName);
        }
        if (result && targetCompilerFilter != null) {
            result = secondaryDex ? mInterface.performDexOptSecondary(packageName, targetCompilerFilter, forceCompilation) : mInterface.performDexOptMode(packageName, checkProfiles, targetCompilerFilter, forceCompilation, true, /* bootComplete */
            split);
        }
        if (!result) {
            failedPackages.add(packageName);
        }
    }
    if (failedPackages.isEmpty()) {
        pw.println("Success");
        return 0;
    } else if (failedPackages.size() == 1) {
        pw.println("Failure: package " + failedPackages.get(0) + " could not be compiled");
        return 1;
    } else {
        pw.print("Failure: the following packages could not be compiled: ");
        boolean is_first = true;
        for (String packageName : failedPackages) {
            if (is_first) {
                is_first = false;
            } else {
                pw.print(", ");
            }
            pw.print(packageName);
        }
        pw.println();
        return 1;
    }
}
#method_after
private int runCompile() throws RemoteException {
    final PrintWriter pw = getOutPrintWriter();
    boolean checkProfiles = SystemProperties.getBoolean("dalvik.vm.usejitprofiles", false);
    boolean forceCompilation = false;
    boolean allPackages = false;
    boolean clearProfileData = false;
    String compilerFilter = null;
    String compilationReason = null;
    String checkProfilesRaw = null;
    boolean secondaryDex = false;
    String split = null;
    boolean compileLayouts = false;
    String opt;
    while ((opt = getNextOption()) != null) {
        switch(opt) {
            case "-a":
                allPackages = true;
                break;
            case "-c":
                clearProfileData = true;
                break;
            case "-f":
                forceCompilation = true;
                break;
            case "-m":
                compilerFilter = getNextArgRequired();
                break;
            case "-r":
                compilationReason = getNextArgRequired();
                break;
            case "--compile-layouts":
                compileLayouts = true;
                break;
            case "--check-prof":
                checkProfilesRaw = getNextArgRequired();
                break;
            case "--reset":
                forceCompilation = true;
                clearProfileData = true;
                compilationReason = "install";
                break;
            case "--secondary-dex":
                secondaryDex = true;
                break;
            case "--split":
                split = getNextArgRequired();
                break;
            default:
                pw.println("Error: Unknown option: " + opt);
                return 1;
        }
    }
    if (checkProfilesRaw != null) {
        if ("true".equals(checkProfilesRaw)) {
            checkProfiles = true;
        } else if ("false".equals(checkProfilesRaw)) {
            checkProfiles = false;
        } else {
            pw.println("Invalid value for \"--check-prof\". Expected \"true\" or \"false\".");
            return 1;
        }
    }
    final boolean compilerFilterGiven = compilerFilter != null;
    final boolean compilationReasonGiven = compilationReason != null;
    // Make sure exactly one of -m, -r, or --compile-layouts is given.
    if ((!compilerFilterGiven && !compilationReasonGiven && !compileLayouts) || (!compilerFilterGiven && compilationReasonGiven && compileLayouts) || (compilerFilterGiven && !compilationReasonGiven && compileLayouts) || (compilerFilterGiven && compilationReasonGiven && !compileLayouts) || (compilerFilterGiven && compilationReasonGiven && compileLayouts)) {
        pw.println("Must specify exactly one of compilation filter (\"-m\"), compilation " + "reason (\"-r\"), or compile layouts (\"--compile-layouts\")");
        return 1;
    }
    if (allPackages && split != null) {
        pw.println("-a cannot be specified together with --split");
        return 1;
    }
    if (secondaryDex && split != null) {
        pw.println("--secondary-dex cannot be specified together with --split");
        return 1;
    }
    String targetCompilerFilter = null;
    if (compilerFilterGiven) {
        if (!DexFile.isValidCompilerFilter(compilerFilter)) {
            pw.println("Error: \"" + compilerFilter + "\" is not a valid compilation filter.");
            return 1;
        }
        targetCompilerFilter = compilerFilter;
    }
    if (compilationReasonGiven) {
        int reason = -1;
        for (int i = 0; i < PackageManagerServiceCompilerMapping.REASON_STRINGS.length; i++) {
            if (PackageManagerServiceCompilerMapping.REASON_STRINGS[i].equals(compilationReason)) {
                reason = i;
                break;
            }
        }
        if (reason == -1) {
            pw.println("Error: Unknown compilation reason: " + compilationReason);
            return 1;
        }
        targetCompilerFilter = PackageManagerServiceCompilerMapping.getCompilerFilterForReason(reason);
    }
    List<String> packageNames = null;
    if (allPackages) {
        packageNames = mInterface.getAllPackages();
    } else {
        String packageName = getNextArg();
        if (packageName == null) {
            pw.println("Error: package name not specified");
            return 1;
        }
        packageNames = Collections.singletonList(packageName);
    }
    List<String> failedPackages = new ArrayList<>();
    int index = 0;
    for (String packageName : packageNames) {
        if (clearProfileData) {
            mInterface.clearApplicationProfileData(packageName);
        }
        if (allPackages) {
            pw.println(++index + "/" + packageNames.size() + ": " + packageName);
            pw.flush();
        }
        boolean result = true;
        if (compileLayouts) {
            PackageManagerInternal internal = LocalServices.getService(PackageManagerInternal.class);
            result = internal.compileLayouts(packageName);
        } else {
            result = secondaryDex ? mInterface.performDexOptSecondary(packageName, targetCompilerFilter, forceCompilation) : mInterface.performDexOptMode(packageName, checkProfiles, targetCompilerFilter, forceCompilation, true, /* bootComplete */
            split);
        }
        if (!result) {
            failedPackages.add(packageName);
        }
    }
    if (failedPackages.isEmpty()) {
        pw.println("Success");
        return 0;
    } else if (failedPackages.size() == 1) {
        pw.println("Failure: package " + failedPackages.get(0) + " could not be compiled");
        return 1;
    } else {
        pw.print("Failure: the following packages could not be compiled: ");
        boolean is_first = true;
        for (String packageName : failedPackages) {
            if (is_first) {
                is_first = false;
            } else {
                pw.print(", ");
            }
            pw.print(packageName);
        }
        pw.println();
        return 1;
    }
}
#end_block

#method_before
AlarmManager getAlarmManager() {
    return (AlarmManager) mContext.getSystemService(AlarmManager.class);
}
#method_after
AlarmManager getAlarmManager() {
    return mContext.getSystemService(AlarmManager.class);
}
#end_block

#method_before
@Override
public int getCurrentFailedPasswordAttempts(int userHandle, boolean parent) {
    enforceFullCrossUsersPermission(userHandle);
    synchronized (getLockObject()) {
        if (!isCallerWithSystemUid()) {
            // This API can only be called by an active device admin,
            // so try to retrieve it to check that the caller is one.
            getActiveAdminForCallerLocked(null, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);
        }
        DevicePolicyData policy = getUserDataUnchecked(getCredentialOwner(userHandle, parent));
        return policy.mFailedPasswordAttempts;
    }
}
#method_after
@Override
public int getCurrentFailedPasswordAttempts(int userHandle, boolean parent) {
    enforceFullCrossUsersPermission(userHandle);
    synchronized (getLockObject()) {
        if (!isCallerWithSystemUid()) {
            // This API can be called by an active device admin or by keyguard code.
            if (mContext.checkCallingPermission(permission.ACCESS_KEYGUARD_SECURE_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                getActiveAdminForCallerLocked(null, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);
            }
        }
        DevicePolicyData policy = getUserDataUnchecked(getCredentialOwner(userHandle, parent));
        return policy.mFailedPasswordAttempts;
    }
}
#end_block

#method_before
private boolean resetPasswordInternal(String password, long tokenHandle, byte[] token, int flags, int callingUid, int userHandle) {
    int quality;
    synchronized (getLockObject()) {
        quality = getPasswordQuality(null, userHandle, /* parent */
        false);
        if (quality == DevicePolicyManager.PASSWORD_QUALITY_MANAGED) {
            quality = PASSWORD_QUALITY_UNSPECIFIED;
        }
        final PasswordMetrics metrics = PasswordMetrics.computeForPassword(password);
        if (quality != PASSWORD_QUALITY_UNSPECIFIED) {
            final int realQuality = metrics.quality;
            if (realQuality < quality && quality != DevicePolicyManager.PASSWORD_QUALITY_COMPLEX) {
                Slog.w(LOG_TAG, "resetPassword: password quality 0x" + Integer.toHexString(realQuality) + " does not meet required quality 0x" + Integer.toHexString(quality));
                return false;
            }
            quality = Math.max(realQuality, quality);
        }
        int length = getPasswordMinimumLength(null, userHandle, /* parent */
        false);
        if (password.length() < length) {
            Slog.w(LOG_TAG, "resetPassword: password length " + password.length() + " does not meet required length " + length);
            return false;
        }
        if (quality == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX) {
            int neededLetters = getPasswordMinimumLetters(null, userHandle, /* parent */
            false);
            if (metrics.letters < neededLetters) {
                Slog.w(LOG_TAG, "resetPassword: number of letters " + metrics.letters + " does not meet required number of letters " + neededLetters);
                return false;
            }
            int neededNumeric = getPasswordMinimumNumeric(null, userHandle, /* parent */
            false);
            if (metrics.numeric < neededNumeric) {
                Slog.w(LOG_TAG, "resetPassword: number of numerical digits " + metrics.numeric + " does not meet required number of numerical digits " + neededNumeric);
                return false;
            }
            int neededLowerCase = getPasswordMinimumLowerCase(null, userHandle, /* parent */
            false);
            if (metrics.lowerCase < neededLowerCase) {
                Slog.w(LOG_TAG, "resetPassword: number of lowercase letters " + metrics.lowerCase + " does not meet required number of lowercase letters " + neededLowerCase);
                return false;
            }
            int neededUpperCase = getPasswordMinimumUpperCase(null, userHandle, /* parent */
            false);
            if (metrics.upperCase < neededUpperCase) {
                Slog.w(LOG_TAG, "resetPassword: number of uppercase letters " + metrics.upperCase + " does not meet required number of uppercase letters " + neededUpperCase);
                return false;
            }
            int neededSymbols = getPasswordMinimumSymbols(null, userHandle, /* parent */
            false);
            if (metrics.symbols < neededSymbols) {
                Slog.w(LOG_TAG, "resetPassword: number of special symbols " + metrics.symbols + " does not meet required number of special symbols " + neededSymbols);
                return false;
            }
            int neededNonLetter = getPasswordMinimumNonLetter(null, userHandle, /* parent */
            false);
            if (metrics.nonLetter < neededNonLetter) {
                Slog.w(LOG_TAG, "resetPassword: number of non-letter characters " + metrics.nonLetter + " does not meet required number of non-letter characters " + neededNonLetter);
                return false;
            }
        }
    }
    DevicePolicyData policy = getUserData(userHandle);
    if (policy.mPasswordOwner >= 0 && policy.mPasswordOwner != callingUid) {
        Slog.w(LOG_TAG, "resetPassword: already set by another uid and not entered by user");
        return false;
    }
    boolean callerIsDeviceOwnerAdmin = isCallerDeviceOwner(callingUid);
    boolean doNotAskCredentialsOnBoot = (flags & DevicePolicyManager.RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT) != 0;
    if (callerIsDeviceOwnerAdmin && doNotAskCredentialsOnBoot) {
        setDoNotAskCredentialsOnBoot();
    }
    // Don't do this with the lock held, because it is going to call
    // back in to the service.
    final long ident = mInjector.binderClearCallingIdentity();
    final boolean result;
    try {
        if (token == null) {
            if (!TextUtils.isEmpty(password)) {
                mLockPatternUtils.saveLockPassword(password, null, quality, userHandle);
            } else {
                mLockPatternUtils.clearLock(null, userHandle);
            }
            result = true;
        } else {
            result = mLockPatternUtils.setLockCredentialWithToken(password, TextUtils.isEmpty(password) ? LockPatternUtils.CREDENTIAL_TYPE_NONE : LockPatternUtils.CREDENTIAL_TYPE_PASSWORD, quality, tokenHandle, token, userHandle);
        }
        boolean requireEntry = (flags & DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY) != 0;
        if (requireEntry) {
            mLockPatternUtils.requireStrongAuth(STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW, UserHandle.USER_ALL);
        }
        synchronized (getLockObject()) {
            int newOwner = requireEntry ? callingUid : -1;
            if (policy.mPasswordOwner != newOwner) {
                policy.mPasswordOwner = newOwner;
                saveSettingsLocked(userHandle);
            }
        }
    } finally {
        mInjector.binderRestoreCallingIdentity(ident);
    }
    return result;
}
#method_after
private boolean resetPasswordInternal(String password, long tokenHandle, byte[] token, int flags, int callingUid, int userHandle) {
    int quality;
    final int realQuality;
    synchronized (getLockObject()) {
        quality = getPasswordQuality(null, userHandle, /* parent */
        false);
        if (quality == DevicePolicyManager.PASSWORD_QUALITY_MANAGED) {
            quality = PASSWORD_QUALITY_UNSPECIFIED;
        }
        final PasswordMetrics metrics = PasswordMetrics.computeForPassword(password);
        realQuality = metrics.quality;
        if (quality != PASSWORD_QUALITY_UNSPECIFIED) {
            if (realQuality < quality && quality != DevicePolicyManager.PASSWORD_QUALITY_COMPLEX) {
                Slog.w(LOG_TAG, "resetPassword: password quality 0x" + Integer.toHexString(realQuality) + " does not meet required quality 0x" + Integer.toHexString(quality));
                return false;
            }
            quality = Math.max(realQuality, quality);
        }
        int length = getPasswordMinimumLength(null, userHandle, /* parent */
        false);
        if (password.length() < length) {
            Slog.w(LOG_TAG, "resetPassword: password length " + password.length() + " does not meet required length " + length);
            return false;
        }
        if (quality == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX) {
            int neededLetters = getPasswordMinimumLetters(null, userHandle, /* parent */
            false);
            if (metrics.letters < neededLetters) {
                Slog.w(LOG_TAG, "resetPassword: number of letters " + metrics.letters + " does not meet required number of letters " + neededLetters);
                return false;
            }
            int neededNumeric = getPasswordMinimumNumeric(null, userHandle, /* parent */
            false);
            if (metrics.numeric < neededNumeric) {
                Slog.w(LOG_TAG, "resetPassword: number of numerical digits " + metrics.numeric + " does not meet required number of numerical digits " + neededNumeric);
                return false;
            }
            int neededLowerCase = getPasswordMinimumLowerCase(null, userHandle, /* parent */
            false);
            if (metrics.lowerCase < neededLowerCase) {
                Slog.w(LOG_TAG, "resetPassword: number of lowercase letters " + metrics.lowerCase + " does not meet required number of lowercase letters " + neededLowerCase);
                return false;
            }
            int neededUpperCase = getPasswordMinimumUpperCase(null, userHandle, /* parent */
            false);
            if (metrics.upperCase < neededUpperCase) {
                Slog.w(LOG_TAG, "resetPassword: number of uppercase letters " + metrics.upperCase + " does not meet required number of uppercase letters " + neededUpperCase);
                return false;
            }
            int neededSymbols = getPasswordMinimumSymbols(null, userHandle, /* parent */
            false);
            if (metrics.symbols < neededSymbols) {
                Slog.w(LOG_TAG, "resetPassword: number of special symbols " + metrics.symbols + " does not meet required number of special symbols " + neededSymbols);
                return false;
            }
            int neededNonLetter = getPasswordMinimumNonLetter(null, userHandle, /* parent */
            false);
            if (metrics.nonLetter < neededNonLetter) {
                Slog.w(LOG_TAG, "resetPassword: number of non-letter characters " + metrics.nonLetter + " does not meet required number of non-letter characters " + neededNonLetter);
                return false;
            }
        }
    }
    DevicePolicyData policy = getUserData(userHandle);
    if (policy.mPasswordOwner >= 0 && policy.mPasswordOwner != callingUid) {
        Slog.w(LOG_TAG, "resetPassword: already set by another uid and not entered by user");
        return false;
    }
    boolean callerIsDeviceOwnerAdmin = isCallerDeviceOwner(callingUid);
    boolean doNotAskCredentialsOnBoot = (flags & DevicePolicyManager.RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT) != 0;
    if (callerIsDeviceOwnerAdmin && doNotAskCredentialsOnBoot) {
        setDoNotAskCredentialsOnBoot();
    }
    // Don't do this with the lock held, because it is going to call
    // back in to the service.
    final long ident = mInjector.binderClearCallingIdentity();
    final boolean result;
    try {
        if (token == null) {
            if (!TextUtils.isEmpty(password)) {
                mLockPatternUtils.saveLockPassword(password, null, realQuality, userHandle);
            } else {
                mLockPatternUtils.clearLock(null, userHandle);
            }
            result = true;
        } else {
            result = mLockPatternUtils.setLockCredentialWithToken(password, TextUtils.isEmpty(password) ? LockPatternUtils.CREDENTIAL_TYPE_NONE : LockPatternUtils.CREDENTIAL_TYPE_PASSWORD, realQuality, tokenHandle, token, userHandle);
        }
        boolean requireEntry = (flags & DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY) != 0;
        if (requireEntry) {
            mLockPatternUtils.requireStrongAuth(STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW, UserHandle.USER_ALL);
        }
        synchronized (getLockObject()) {
            int newOwner = requireEntry ? callingUid : -1;
            if (policy.mPasswordOwner != newOwner) {
                policy.mPasswordOwner = newOwner;
                saveSettingsLocked(userHandle);
            }
        }
    } finally {
        mInjector.binderRestoreCallingIdentity(ident);
    }
    return result;
}
#end_block

#method_before
@Override
public boolean setAlwaysOnVpnPackage(ComponentName admin, String vpnPackage, boolean lockdown, List<String> lockdownWhitelist) throws SecurityException {
    enforceProfileOrDeviceOwner(admin);
    final int userId = mInjector.userHandleGetCallingUserId();
    final long token = mInjector.binderClearCallingIdentity();
    try {
        if (vpnPackage != null && !isPackageInstalledForUser(vpnPackage, userId)) {
            return false;
        }
        ConnectivityManager connectivityManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (!connectivityManager.setAlwaysOnVpnPackageForUser(userId, vpnPackage, lockdown, lockdownWhitelist)) {
            throw new UnsupportedOperationException();
        }
    } finally {
        mInjector.binderRestoreCallingIdentity(token);
    }
    return true;
}
#method_after
@Override
public boolean setAlwaysOnVpnPackage(ComponentName admin, String vpnPackage, boolean lockdown, List<String> lockdownWhitelist) throws SecurityException {
    enforceProfileOrDeviceOwner(admin);
    final int userId = mInjector.userHandleGetCallingUserId();
    final long token = mInjector.binderClearCallingIdentity();
    try {
        if (vpnPackage != null && !isPackageInstalledForUser(vpnPackage, userId)) {
            Slog.w(LOG_TAG, "Non-existent VPN package specified: " + vpnPackage);
            throw new ServiceSpecificException(DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, vpnPackage);
        }
        if (vpnPackage != null && lockdown && lockdownWhitelist != null) {
            for (String packageName : lockdownWhitelist) {
                if (!isPackageInstalledForUser(packageName, userId)) {
                    Slog.w(LOG_TAG, "Non-existent package in VPN whitelist: " + packageName);
                    throw new ServiceSpecificException(DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, packageName);
                }
            }
        }
        // If some package is uninstalled after the check above, it will be ignored by CM.
        if (!mInjector.getConnectivityManager().setAlwaysOnVpnPackageForUser(userId, vpnPackage, lockdown, lockdownWhitelist)) {
            throw new UnsupportedOperationException();
        }
    } finally {
        mInjector.binderRestoreCallingIdentity(token);
    }
    return true;
}
#end_block

#method_before
@Override
public String getAlwaysOnVpnPackage(ComponentName admin) throws SecurityException {
    enforceProfileOrDeviceOwner(admin);
    final int userId = mInjector.userHandleGetCallingUserId();
    final long token = mInjector.binderClearCallingIdentity();
    try {
        ConnectivityManager connectivityManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        return connectivityManager.getAlwaysOnVpnPackageForUser(userId);
    } finally {
        mInjector.binderRestoreCallingIdentity(token);
    }
}
#method_after
@Override
public String getAlwaysOnVpnPackage(ComponentName admin) throws SecurityException {
    enforceProfileOrDeviceOwner(admin);
    final int userId = mInjector.userHandleGetCallingUserId();
    final long token = mInjector.binderClearCallingIdentity();
    try {
        return mInjector.getConnectivityManager().getAlwaysOnVpnPackageForUser(userId);
    } finally {
        mInjector.binderRestoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public void setRecommendedGlobalProxy(ComponentName who, ProxyInfo proxyInfo) {
    synchronized (getLockObject()) {
        getActiveAdminForCallerLocked(who, DeviceAdminInfo.USES_POLICY_DEVICE_OWNER);
    }
    long token = mInjector.binderClearCallingIdentity();
    try {
        ConnectivityManager connectivityManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        connectivityManager.setGlobalProxy(proxyInfo);
    } finally {
        mInjector.binderRestoreCallingIdentity(token);
    }
}
#method_after
@Override
public void setRecommendedGlobalProxy(ComponentName who, ProxyInfo proxyInfo) {
    synchronized (getLockObject()) {
        getActiveAdminForCallerLocked(who, DeviceAdminInfo.USES_POLICY_DEVICE_OWNER);
    }
    long token = mInjector.binderClearCallingIdentity();
    try {
        mInjector.getConnectivityManager().setGlobalProxy(proxyInfo);
    } finally {
        mInjector.binderRestoreCallingIdentity(token);
    }
}
#end_block

#method_before
public boolean getLockdown() {
    return mLockdown;
}
#method_after
public synchronized boolean getLockdown() {
    return mLockdown;
}
#end_block

#method_before
@GuardedBy("this")
private boolean setAlwaysOnPackageInternal(String packageName, boolean lockdown, List<String> lockdownWhitelist) {
    if (VpnConfig.LEGACY_VPN.equals(packageName)) {
        Log.w(TAG, "Not setting legacy VPN \"" + packageName + "\" as always-on.");
        return false;
    }
    if (packageName != null) {
        // Pre-authorize new always-on VPN package.
        if (!setPackageAuthorization(packageName, true)) {
            return false;
        }
        mAlwaysOn = true;
    } else {
        packageName = VpnConfig.LEGACY_VPN;
        mAlwaysOn = false;
    }
    mLockdown = (mAlwaysOn && lockdown);
    if (isCurrentPreparedPackage(packageName)) {
        updateAlwaysOnNotification(mNetworkInfo.getDetailedState());
    } else {
        // Prepare this app. The notification will update as a side-effect of updateState().
        prepareInternal(packageName);
    }
    mLockdownWhitelist = lockdownWhitelist != null ? lockdownWhitelist : Collections.emptyList();
    maybeRegisterPackageChangeReceiverLocked(packageName);
    setVpnForcedLocked(mLockdown);
    return true;
}
#method_after
@GuardedBy("this")
private boolean setAlwaysOnPackageInternal(String packageName, boolean lockdown, List<String> lockdownWhitelist) {
    if (VpnConfig.LEGACY_VPN.equals(packageName)) {
        Log.w(TAG, "Not setting legacy VPN \"" + packageName + "\" as always-on.");
        return false;
    }
    if (lockdownWhitelist != null) {
        for (String pkg : lockdownWhitelist) {
            if (pkg.contains(",")) {
                Log.w(TAG, "Not setting always-on vpn, invalid whitelisted package: " + pkg);
                return false;
            }
        }
    }
    if (packageName != null) {
        // Pre-authorize new always-on VPN package.
        if (!setPackageAuthorization(packageName, true)) {
            return false;
        }
        mAlwaysOn = true;
    } else {
        packageName = VpnConfig.LEGACY_VPN;
        mAlwaysOn = false;
    }
    mLockdown = (mAlwaysOn && lockdown);
    mLockdownWhitelist = (mLockdown && lockdownWhitelist != null) ? Collections.unmodifiableList(new ArrayList<>(lockdownWhitelist)) : Collections.emptyList();
    if (isCurrentPreparedPackage(packageName)) {
        updateAlwaysOnNotification(mNetworkInfo.getDetailedState());
        setVpnForcedLocked(mLockdown);
    } else {
        // Prepare this app. The notification will update as a side-effect of updateState().
        // It also calls setVpnForcedLocked().
        prepareInternal(packageName);
    }
    return true;
}
#end_block

#method_before
@GuardedBy("this")
private void saveAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, getAlwaysOnPackage(), mUserHandle);
        mSystemServices.settingsSecurePutIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, (mAlwaysOn && mLockdown ? 1 : 0), mUserHandle);
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_WHITELIST, String.join(",", mLockdownWhitelist), mUserHandle);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@GuardedBy("this")
private void saveAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, getAlwaysOnPackage(), mUserHandle);
        mSystemServices.settingsSecurePutIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, (mAlwaysOn && mLockdown ? 1 : 0), mUserHandle);
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN_WHITELIST, String.join(",", mLockdownWhitelist), mUserHandle);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@GuardedBy("this")
private void loadAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        final String alwaysOnPackage = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, mUserHandle);
        final boolean alwaysOnLockdown = mSystemServices.settingsSecureGetIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, 0, /*default*/
        mUserHandle) != 0;
        final String whitelistString = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_WHITELIST, mUserHandle);
        final List<String> whitelistedPackages = parseWhitelist(whitelistString);
        setAlwaysOnPackageInternal(alwaysOnPackage, alwaysOnLockdown, whitelistedPackages);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@GuardedBy("this")
private void loadAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        final String alwaysOnPackage = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, mUserHandle);
        final boolean alwaysOnLockdown = mSystemServices.settingsSecureGetIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, 0, /*default*/
        mUserHandle) != 0;
        final String whitelistString = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN_WHITELIST, mUserHandle);
        final List<String> whitelistedPackages = TextUtils.isEmpty(whitelistString) ? Collections.emptyList() : Arrays.asList(whitelistString.split(","));
        setAlwaysOnPackageInternal(alwaysOnPackage, alwaysOnLockdown, whitelistedPackages);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdown(false);
    mAlwaysOn = false;
    unregisterPackageChangeReceiverLocked();
    // Quit any active connections
    agentDisconnect();
}
#method_after
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdown(false);
    mAlwaysOn = false;
    // Quit any active connections
    agentDisconnect();
}
#end_block

#method_before
@GuardedBy("this")
private void setVpnForcedLocked(boolean enforce) {
    final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers);
    Set<UidRange> addedRanges = Collections.emptySet();
    if (enforce) {
        addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */
        null, /* disallowedApplications */
        getExemptedPackagesLocked());
        // it through (b/69873852).
        for (UidRange range : addedRanges) {
            if (range.start == 0) {
                addedRanges.remove(range);
                if (range.stop != 0) {
                    addedRanges.add(new UidRange(1, range.stop));
                }
            }
        }
        removedRanges.removeAll(addedRanges);
        addedRanges.removeAll(mBlockedUsers);
    }
    setAllowOnlyVpnForUids(false, removedRanges);
    setAllowOnlyVpnForUids(true, addedRanges);
}
#method_after
@GuardedBy("this")
private void setVpnForcedLocked(boolean enforce) {
    final List<String> exemptedPackages;
    if (isNullOrLegacyVpn(mPackage)) {
        exemptedPackages = null;
    } else {
        exemptedPackages = new ArrayList<>(mLockdownWhitelist);
        exemptedPackages.add(mPackage);
    }
    final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers);
    Set<UidRange> addedRanges = Collections.emptySet();
    if (enforce) {
        addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */
        null, /* disallowedApplications */
        exemptedPackages);
        // it through (b/69873852).
        for (UidRange range : addedRanges) {
            if (range.start == 0) {
                addedRanges.remove(range);
                if (range.stop != 0) {
                    addedRanges.add(new UidRange(1, range.stop));
                }
            }
        }
        removedRanges.removeAll(addedRanges);
        addedRanges.removeAll(mBlockedUsers);
    }
    setAllowOnlyVpnForUids(false, removedRanges);
    setAllowOnlyVpnForUids(true, addedRanges);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo getActiveNetworkInfo() {
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkInfo getActiveNetworkInfo() {
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public Network getActiveNetwork() {
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public Network getActiveNetwork() {
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public Network getActiveNetworkForUid(int uid) {
    return getActiveNetworkForUid(uid, false);
}
#method_after
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
@Nullable
public Network getActiveNetworkForUid(int uid) {
    return getActiveNetworkForUid(uid, false);
}
#end_block

#method_before
public boolean setAlwaysOnVpnPackageForUser(int userId, @Nullable String vpnPackage, boolean lockdownEnabled, List<String> lockdownWhitelist) {
    try {
        return mService.setAlwaysOnVpnPackage(userId, vpnPackage, lockdownEnabled, lockdownWhitelist);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.CONTROL_ALWAYS_ON_VPN)
public boolean setAlwaysOnVpnPackageForUser(int userId, @Nullable String vpnPackage, boolean lockdownEnabled, @Nullable List<String> lockdownWhitelist) {
    try {
        return mService.setAlwaysOnVpnPackage(userId, vpnPackage, lockdownEnabled, lockdownWhitelist);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public String getAlwaysOnVpnPackageForUser(int userId) {
    try {
        return mService.getAlwaysOnVpnPackage(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.CONTROL_ALWAYS_ON_VPN)
public String getAlwaysOnVpnPackageForUser(int userId) {
    try {
        return mService.getAlwaysOnVpnPackage(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo getNetworkInfo(int networkType) {
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkInfo getNetworkInfo(int networkType) {
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo getNetworkInfo(Network network) {
    return getNetworkInfoForUid(network, Process.myUid(), false);
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkInfo getNetworkInfo(@Nullable Network network) {
    return getNetworkInfoForUid(network, Process.myUid(), false);
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo[] getAllNetworkInfo() {
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@NonNull
public NetworkInfo[] getAllNetworkInfo() {
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public Network[] getAllNetworks() {
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@NonNull
public Network[] getAllNetworks() {
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public LinkProperties getLinkProperties(Network network) {
    try {
        return mService.getLinkProperties(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public LinkProperties getLinkProperties(@Nullable Network network) {
    try {
        return mService.getLinkProperties(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkCapabilities getNetworkCapabilities(Network network) {
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkCapabilities getNetworkCapabilities(@Nullable Network network) {
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void removeDefaultNetworkActiveListener(OnNetworkActiveListener l) {
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    Preconditions.checkArgument(rl != null, "Listener was not registered.");
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void removeDefaultNetworkActiveListener(@NonNull OnNetworkActiveListener l) {
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    Preconditions.checkArgument(rl != null, "Listener was not registered.");
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
public void reportBadNetwork(Network network) {
    printStackTrace();
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
public void reportBadNetwork(@Nullable Network network) {
    printStackTrace();
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void reportNetworkConnectivity(Network network, boolean hasConnectivity) {
    printStackTrace();
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void reportNetworkConnectivity(@Nullable Network network, boolean hasConnectivity) {
    printStackTrace();
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public ProxyInfo getDefaultProxy() {
    return getProxyForNetwork(getBoundNetworkForProcess());
}
#method_after
@Nullable
public ProxyInfo getDefaultProxy() {
    return getProxyForNetwork(getBoundNetworkForProcess());
}
#end_block

#method_before
@UnsupportedAppUsage
public void unregisterNetworkFactory(Messenger messenger) {
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public void unregisterNetworkFactory(Messenger messenger) {
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, int timeoutMs, int legacyType, Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, timeoutMs, REQUEST, legacyType, cbHandler);
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs, int legacyType, @NonNull Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, timeoutMs, REQUEST, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback) {
    requestNetwork(request, networkCallback, getDefaultHandler());
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback) {
    requestNetwork(request, networkCallback, getDefaultHandler());
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, Handler handler) {
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, 0, legacyType, cbHandler);
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler) {
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, 0, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, Handler handler, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
public void releaseNetworkRequest(PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void releaseNetworkRequest(@NonNull PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(NetworkRequest request, NetworkCallback networkCallback) {
    registerNetworkCallback(request, networkCallback, getDefaultHandler());
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback) {
    registerNetworkCallback(request, networkCallback, getDefaultHandler());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(NetworkRequest request, NetworkCallback networkCallback, Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, 0, LISTEN, TYPE_NONE, cbHandler);
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, 0, LISTEN, TYPE_NONE, cbHandler);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(NetworkRequest request, PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback) {
    registerDefaultNetworkCallback(networkCallback, getDefaultHandler());
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback) {
    registerDefaultNetworkCallback(networkCallback, getDefaultHandler());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback, Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(null, /* NetworkCapabilities need */
    networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(null, /* NetworkCapabilities need */
    networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#end_block

#method_before
public boolean requestBandwidthUpdate(Network network) {
    try {
        return mService.requestBandwidthUpdate(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public boolean requestBandwidthUpdate(@NonNull Network network) {
    try {
        return mService.requestBandwidthUpdate(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    printStackTrace();
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.networkRequest != null, "NetworkCallback was not registered");
        Preconditions.checkArgument(networkCallback.networkRequest != ALREADY_UNREGISTERED, "NetworkCallback was already unregistered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = ALREADY_UNREGISTERED;
    }
}
#method_after
public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback) {
    printStackTrace();
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.networkRequest != null, "NetworkCallback was not registered");
        Preconditions.checkArgument(networkCallback.networkRequest != ALREADY_UNREGISTERED, "NetworkCallback was already unregistered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = ALREADY_UNREGISTERED;
    }
}
#end_block

#method_before
public void unregisterNetworkCallback(PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    releaseNetworkRequest(operation);
}
#method_after
public void unregisterNetworkCallback(@NonNull PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    releaseNetworkRequest(operation);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@MultipathPreference
public int getMultipathPreference(Network network) {
    try {
        return mService.getMultipathPreference(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@MultipathPreference
public int getMultipathPreference(@Nullable Network network) {
    try {
        return mService.getMultipathPreference(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public boolean bindProcessToNetwork(Network network) {
    // instantiated.
    return setProcessDefaultNetwork(network);
}
#method_after
public boolean bindProcessToNetwork(@Nullable Network network) {
    // instantiated.
    return setProcessDefaultNetwork(network);
}
#end_block

#method_before
@Deprecated
public static boolean setProcessDefaultNetwork(Network network) {
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getBoundNetworkForProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // TODO: Deprecate this static method and replace it with a non-static version.
        try {
            Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        } catch (SecurityException e) {
            // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
            Log.e(TAG, "Can't set proxy properties", e);
        }
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}
#method_after
@Deprecated
public static boolean setProcessDefaultNetwork(@Nullable Network network) {
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getBoundNetworkForProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // TODO: Deprecate this static method and replace it with a non-static version.
        try {
            Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        } catch (SecurityException e) {
            // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
            Log.e(TAG, "Can't set proxy properties", e);
        }
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public Network getBoundNetworkForProcess() {
    // instantiated.
    return getProcessDefaultNetwork();
}
#method_after
@Nullable
public Network getBoundNetworkForProcess() {
    // instantiated.
    return getProcessDefaultNetwork();
}
#end_block

#method_before
@Deprecated
public static Network getProcessDefaultNetwork() {
    int netId = NetworkUtils.getBoundNetworkForProcess();
    if (netId == NETID_UNSET)
        return null;
    return new Network(netId);
}
#method_after
@Deprecated
@Nullable
public static Network getProcessDefaultNetwork() {
    int netId = NetworkUtils.getBoundNetworkForProcess();
    if (netId == NETID_UNSET)
        return null;
    return new Network(netId);
}
#end_block

#method_before
public byte[] getNetworkWatchlistConfigHash() {
    try {
        return mService.getNetworkWatchlistConfigHash();
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to get watchlist config hash");
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Nullable
public byte[] getNetworkWatchlistConfigHash() {
    try {
        return mService.getNetworkWatchlistConfigHash();
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to get watchlist config hash");
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int getConnectionOwnerUid(int protocol, InetSocketAddress local, InetSocketAddress remote) {
    ConnectionInfo connectionInfo = new ConnectionInfo(protocol, local, remote);
    try {
        return mService.getConnectionOwnerUid(connectionInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote) {
    ConnectionInfo connectionInfo = new ConnectionInfo(protocol, local, remote);
    try {
        return mService.getConnectionOwnerUid(connectionInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordQuality(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordQuality(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return PASSWORD_QUALITY_UNSPECIFIED;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordQuality(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordQuality(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return PASSWORD_QUALITY_UNSPECIFIED;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordMinimumLength(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLength(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordMinimumLength(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLength(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordMinimumUpperCase(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumUpperCase(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordMinimumUpperCase(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumUpperCase(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordMinimumLowerCase(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLowerCase(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordMinimumLowerCase(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLowerCase(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordMinimumLetters(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLetters(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordMinimumLetters(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLetters(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordMinimumNumeric(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumNumeric(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordMinimumNumeric(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumNumeric(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordMinimumSymbols(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumSymbols(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordMinimumSymbols(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumSymbols(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordMinimumNonLetter(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumNonLetter(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordMinimumNonLetter(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordMinimumNonLetter(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
@UnsupportedAppUsage
public int getPasswordHistoryLength(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordHistoryLength(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public int getPasswordHistoryLength(@Nullable ComponentName admin, int userHandle) {
    if (mService != null) {
        try {
            return mService.getPasswordHistoryLength(admin, userHandle, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}
#end_block

#method_before
public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled) throws NameNotFoundException, UnsupportedOperationException {
    throwIfParentInstance("setAlwaysOnVpnPackage");
    if (mService != null) {
        try {
            if (!mService.setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled, Collections.emptyList())) {
                throw new NameNotFoundException(vpnPackage);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#method_after
public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled) throws NameNotFoundException, UnsupportedOperationException {
    setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled, Collections.emptyList());
}
#end_block

#method_before
public void setAlwaysOnVpnPackage(ComponentName admin, String vpnPackage, boolean lockdownEnabled, @NonNull List<String> lockdownWhitelist) throws NameNotFoundException, UnsupportedOperationException {
    throwIfParentInstance("setAlwaysOnVpnPackage");
    if (mService != null) {
        try {
            if (!mService.setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled, lockdownWhitelist)) {
                // TODO: pass it via ServiceSpecificException
                throw new NameNotFoundException(vpnPackage);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#method_after
public void setAlwaysOnVpnPackage(@NonNull ComponentName admin, @Nullable String vpnPackage, boolean lockdownEnabled, @Nullable List<String> lockdownWhitelist) throws NameNotFoundException, UnsupportedOperationException {
    throwIfParentInstance("setAlwaysOnVpnPackage");
    if (mService != null) {
        try {
            mService.setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled, lockdownWhitelist);
        } catch (ServiceSpecificException e) {
            switch(e.errorCode) {
                case ERROR_VPN_PACKAGE_NOT_FOUND:
                    throw new NameNotFoundException(e.getMessage());
                default:
                    throw new RuntimeException("Unknown error setting always-on VPN: " + e.errorCode);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
private NetworkCapabilities networkCapabilitiesRestrictedForCallerPermissions(NetworkCapabilities nc, int callerPid, int callerUid) {
    final NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (!checkSettingsPermission(callerPid, callerUid)) {
        newNc.setUids(null);
        newNc.setSSID(null);
    }
    return newNc;
}
#method_after
private NetworkCapabilities networkCapabilitiesRestrictedForCallerPermissions(NetworkCapabilities nc, int callerPid, int callerUid) {
    final NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (!checkSettingsPermission(callerPid, callerUid)) {
        newNc.setUids(null);
        newNc.setSSID(null);
    }
    if (newNc.getNetworkSpecifier() != null) {
        newNc.setNetworkSpecifier(newNc.getNetworkSpecifier().redact());
    }
    return newNc;
}
#end_block

#method_before
void systemReady() {
    mProxyTracker.loadGlobalProxy();
    registerNetdEventCallback();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Create network requests for always-on networks.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_ALWAYS_ON_NETWORKS));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#method_after
void systemReady() {
    mProxyTracker.loadGlobalProxy();
    registerNetdEventCallback();
    mTethering.systemReady();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Create network requests for always-on networks.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_ALWAYS_ON_NETWORKS));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#end_block

#method_before
private void updateTcpBufferSizes(String tcpBufferSizes) {
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        final String prefix = "/sys/kernel/ipv4/tcp_";
        FileUtils.stringToFile(prefix + "rmem_min", values[0]);
        FileUtils.stringToFile(prefix + "rmem_def", values[1]);
        FileUtils.stringToFile(prefix + "rmem_max", values[2]);
        FileUtils.stringToFile(prefix + "wmem_min", values[3]);
        FileUtils.stringToFile(prefix + "wmem_def", values[4]);
        FileUtils.stringToFile(prefix + "wmem_max", values[5]);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (IOException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#method_after
private void updateTcpBufferSizes(String tcpBufferSizes) {
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        String rmemValues = String.join(" ", values[0], values[1], values[2]);
        String wmemValues = String.join(" ", values[3], values[4], values[5]);
        mNetd.setTcpRWmemorySize(rmemValues, wmemValues);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (RemoteException | ServiceSpecificException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#end_block

#method_before
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mName);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#method_after
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid)
                        handleFreshlyValidatedNetwork(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid)
                        handleFreshlyValidatedNetwork(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#end_block

#method_before
private boolean networkRequiresValidation(NetworkAgentInfo nai) {
    return NetworkMonitor.isValidationRequired(mDefaultRequest.networkCapabilities, nai.networkCapabilities);
}
#method_after
private boolean networkRequiresValidation(NetworkAgentInfo nai) {
    return isValidationRequired(mDefaultRequest.networkCapabilities, nai.networkCapabilities);
}
#end_block

#method_before
private void handlePerNetworkPrivateDnsConfig(NetworkAgentInfo nai, PrivateDnsConfig cfg) {
    // Internet access and therefore also require validation.
    if (!networkRequiresValidation(nai))
        return;
    // Notify the NetworkMonitor thread in case it needs to cancel or
    // schedule DNS resolutions. If a DNS resolution is required the
    // result will be sent back to us.
    nai.networkMonitor.notifyPrivateDnsSettingsChanged(cfg);
    // With Private DNS bypass support, we can proceed to update the
    // Private DNS config immediately, even if we're in strict mode
    // and have not yet resolved the provider name into a set of IPs.
    updatePrivateDns(nai, cfg);
}
#method_after
private void handlePerNetworkPrivateDnsConfig(NetworkAgentInfo nai, PrivateDnsConfig cfg) {
    // Internet access and therefore also require validation.
    if (!networkRequiresValidation(nai))
        return;
    // result will be sent back to us.
    try {
        nai.networkMonitor().notifyPrivateDnsChanged(cfg.toParcel());
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    // With Private DNS bypass support, we can proceed to update the
    // Private DNS config immediately, even if we're in strict mode
    // and have not yet resolved the provider name into a set of IPs.
    updatePrivateDns(nai, cfg);
}
#end_block

#method_before
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#method_after
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#end_block

#method_before
@Override
public void startCaptivePortalApp(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.post(() -> {
        NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai == null)
            return;
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
            return;
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_LAUNCH_CAPTIVE_PORTAL_APP);
    });
}
#method_after
@Override
public void startCaptivePortalApp(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.post(() -> {
        NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai == null)
            return;
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
            return;
        try {
            nai.networkMonitor().launchCaptivePortalApp();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
    });
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                final Pair<NetworkAgentInfo, INetworkMonitor> arg = (Pair<NetworkAgentInfo, INetworkMonitor>) msg.obj;
                handleRegisterNetworkAgent(arg.first, arg.second);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    // this several times is fine.
                    try {
                        nai.networkMonitor().notifySystemReady();
                    } catch (RemoteException e) {
                        e.rethrowFromSystemServer();
                    }
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
    }
}
#end_block

#method_before
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    nai.networkMonitor.forceReevaluation(uid);
}
#method_after
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    try {
        nai.networkMonitor().forceReevaluation(uid);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Override
public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown, List<String> lockdownWhitelist) {
    enforceConnectivityInternalPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        // Can't set always-on VPN if legacy VPN is already in lockdown mode.
        if (LockdownVpnTracker.isEnabled()) {
            return false;
        }
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return false;
        }
        if (!vpn.setAlwaysOnPackage(packageName, lockdown, lockdownWhitelist)) {
            return false;
        }
        if (!startAlwaysOnVpn(userId)) {
            vpn.setAlwaysOnPackage(null, false, null);
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown, List<String> lockdownWhitelist) {
    enforceControlAlwaysOnVpnPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        // Can't set always-on VPN if legacy VPN is already in lockdown mode.
        if (LockdownVpnTracker.isEnabled()) {
            return false;
        }
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return false;
        }
        if (!vpn.setAlwaysOnPackage(packageName, lockdown, lockdownWhitelist)) {
            return false;
        }
        if (!startAlwaysOnVpn(userId)) {
            vpn.setAlwaysOnPackage(null, false, null);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public String getAlwaysOnVpnPackage(int userId) {
    enforceConnectivityInternalPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return null;
        }
        return vpn.getAlwaysOnPackage();
    }
}
#method_after
@Override
public String getAlwaysOnVpnPackage(int userId) {
    enforceControlAlwaysOnVpnPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return null;
        }
        return vpn.getAlwaysOnPackage();
    }
}
#end_block

#method_before
private void onPackageRemoved(String packageName, int uid) {
    if (TextUtils.isEmpty(packageName) || uid < 0) {
        Slog.wtf(TAG, "Invalid package in onPackageRemoved: " + packageName + " | " + uid);
        return;
    }
    mPermissionMonitor.onPackageRemoved(uid);
}
#method_after
private void onPackageRemoved(String packageName, int uid, boolean isReplacing) {
    if (TextUtils.isEmpty(packageName) || uid < 0) {
        Slog.wtf(TAG, "Invalid package in onPackageRemoved: " + packageName + " | " + uid);
        return;
    }
    mPermissionMonitor.onPackageRemoved(uid);
    final int userId = UserHandle.getUserId(uid);
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            return;
        }
        // Legacy always-on VPN won't be affected since the package name is not set.
        if (TextUtils.equals(vpn.getAlwaysOnPackage(), packageName) && !isReplacing) {
            Slog.d(TAG, "Removing always-on VPN package " + packageName + " for user " + userId);
            vpn.setAlwaysOnPackage(null, false, null);
        }
    }
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, name);
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        mContext.getSystemService(NetworkStack.class).makeNetworkMonitor(nai.network, name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#end_block

#method_before
private void handleRegisterNetworkAgent(NetworkAgentInfo nai) {
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#method_after
private void handleRegisterNetworkAgent(NetworkAgentInfo nai, INetworkMonitor networkMonitor) {
    nai.onNetworkMonitorCreated(networkMonitor);
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    synchronized (this) {
        if (mSystemReady) {
            try {
                networkMonitor.notifySystemReady();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
        }
    }
    try {
        networkMonitor.start();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop clat accordingly to network state.
        networkAgent.updateClat(mNMS);
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop clat accordingly to network state.
        networkAgent.updateClat(mNMS);
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            try {
                networkAgent.networkMonitor().notifyLinkPropertiesChanged();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                // For this notification, arg1 contains the blocked status.
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_BLK_CHANGED:
            {
                maybeLogBlockedStatusChanged(nri, networkAgent.network, arg1 != 0);
                msg.arg1 = arg1;
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                // For this notification, arg1 contains the blocked status.
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_BLK_CHANGED:
            {
                maybeLogBlockedStatusChanged(nri, networkAgent.network, arg1 != 0);
                msg.arg1 = arg1;
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#method_after
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            mProxyTracker.setDefaultProxyEnabled(false);
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            mProxyTracker.setDefaultProxyEnabled(true);
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            networkAgent.networkMonitor().notifyNetworkConnected();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            mProxyTracker.setDefaultProxyEnabled(false);
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            mProxyTracker.setDefaultProxyEnabled(true);
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitor.getCaptivePortalServerHttpUrl(mContext);
}
#method_after
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitorUtils.getCaptivePortalServerHttpUrl(mContext);
}
#end_block

#method_before
private Vpn enforceActiveVpnOrNetworkStackPermission() {
    if (checkNetworkStackPermission()) {
        return null;
    }
    final int uid = Binder.getCallingUid();
    final int user = UserHandle.getUserId(uid);
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(user);
        try {
            if (vpn.getVpnInfo().ownerUid == uid)
                return vpn;
        } catch (NullPointerException e) {
        /* vpn is null, or VPN is not connected and getVpnInfo() is null. */
        }
    }
    throw new SecurityException("App must either be an active VPN or have the NETWORK_STACK " + "permission");
}
#method_after
private Vpn enforceActiveVpnOrNetworkStackPermission() {
    if (checkNetworkStackPermission()) {
        return null;
    }
    synchronized (mVpns) {
        Vpn vpn = getVpnIfOwner();
        if (vpn != null) {
            return vpn;
        }
    }
    throw new SecurityException("App must either be an active VPN or have the NETWORK_STACK " + "permission");
}
#end_block

#method_before
@Override
public boolean onStartJob(JobParameters params) {
    if (mWorkManagerImpl == null) {
        Logger.get().debug(TAG, "WorkManager is not initialized; requesting retry.");
        jobFinished(params, true);
        return false;
    }
    PersistableBundle extras = params.getExtras();
    String workSpecId = extras.getString(SystemJobInfoConverter.EXTRA_WORK_SPEC_ID);
    if (TextUtils.isEmpty(workSpecId)) {
        Logger.get().error(TAG, "WorkSpec id not found!");
        return false;
    }
    synchronized (mJobParameters) {
        if (mJobParameters.containsKey(workSpecId)) {
            // This condition may happen due to our workaround for an undesired behavior in API
            // 23.  See the documentation in {@link SystemJobScheduler#schedule}.
            Logger.get().debug(TAG, String.format("Job is already being executed by SystemJobService: %s", workSpecId));
            return false;
        }
        // We don't need to worry about the case where JobParams#isOverrideDeadlineExpired()
        // returns true. This is because JobScheduler ensures that for PeriodicWork, constraints
        // are actually met irrespective.
        Logger.get().debug(TAG, String.format("onStartJob for %s", workSpecId));
        mJobParameters.put(workSpecId, params);
    }
    WorkerParameters.RuntimeExtras runtimeExtras = null;
    if (Build.VERSION.SDK_INT >= 24) {
        runtimeExtras = new WorkerParameters.RuntimeExtras();
        if (params.getTriggeredContentUris() != null) {
            runtimeExtras.triggeredContentUris = Arrays.asList(params.getTriggeredContentUris());
        }
        if (params.getTriggeredContentAuthorities() != null) {
            runtimeExtras.triggeredContentAuthorities = Arrays.asList(params.getTriggeredContentAuthorities());
        }
        if (Build.VERSION.SDK_INT >= 28) {
            runtimeExtras.network = params.getNetwork();
        }
    }
    // It is important that we return true, and hang on this onStartJob() request.
    // The call to startWork() may no-op because the WorkRequest could have been picked up
    // by the GreedyScheduler, and was already being executed. GreedyScheduler does not
    // handle retries, and the Processor notifies all Schedulers about an intent to reschedule.
    // In such cases, we rely on SystemJobService to ask for a reschedule by calling
    // jobFinished(params, true);
    mWorkManagerImpl.startWork(workSpecId, runtimeExtras);
    return true;
}
#method_after
@Override
public boolean onStartJob(JobParameters params) {
    if (mWorkManagerImpl == null) {
        Logger.get().debug(TAG, "WorkManager is not initialized; requesting retry.");
        jobFinished(params, true);
        return false;
    }
    PersistableBundle extras = params.getExtras();
    String workSpecId = extras.getString(SystemJobInfoConverter.EXTRA_WORK_SPEC_ID);
    if (TextUtils.isEmpty(workSpecId)) {
        Logger.get().error(TAG, "WorkSpec id not found!");
        return false;
    }
    synchronized (mJobParameters) {
        if (mJobParameters.containsKey(workSpecId)) {
            // This condition may happen due to our workaround for an undesired behavior in API
            // 23.  See the documentation in {@link SystemJobScheduler#schedule}.
            Logger.get().debug(TAG, String.format("Job is already being executed by SystemJobService: %s", workSpecId));
            return false;
        }
        // We don't need to worry about the case where JobParams#isOverrideDeadlineExpired()
        // returns true. This is because JobScheduler ensures that for PeriodicWork, constraints
        // are actually met irrespective.
        Logger.get().debug(TAG, String.format("onStartJob for %s", workSpecId));
        mJobParameters.put(workSpecId, params);
    }
    WorkerParameters.RuntimeExtras runtimeExtras = null;
    if (Build.VERSION.SDK_INT >= 24) {
        runtimeExtras = new WorkerParameters.RuntimeExtras();
        if (params.getTriggeredContentUris() != null) {
            runtimeExtras.triggeredContentUris = Arrays.asList(params.getTriggeredContentUris());
        }
        if (params.getTriggeredContentAuthorities() != null) {
            runtimeExtras.triggeredContentAuthorities = Arrays.asList(params.getTriggeredContentAuthorities());
        }
        if (Build.VERSION.SDK_INT >= 28) {
            runtimeExtras.network = params.getNetwork();
        }
    }
    // It is important that we return true, and hang on this onStartJob() request.
    // The call to startWork() may no-op because the WorkRequest could have been picked up
    // by the GreedyScheduler, and was already being executed. GreedyScheduler does not
    // handle retries, and the Processor notifies all Schedulers about an intent to reschedule.
    // In such cases, we rely on SystemJobService to ask for a reschedule by calling
    // jobFinished(params, true) in onExecuted(...);
    // For more information look at b/123211993
    mWorkManagerImpl.startWork(workSpecId, runtimeExtras);
    return true;
}
#end_block

#method_before
private void authenticateInternal(@NonNull PromptInfo info, @Nullable CryptoObject crypto) {
    final Bundle bundle = info.getBundle();
    final FragmentManager fragmentManager = mFragmentActivity.getSupportFragmentManager();
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
        // Create the fragment that wraps BiometricPrompt once.
        if (mBiometricFragment == null) {
            mBiometricFragment = BiometricFragment.newInstance(bundle);
            mBiometricFragment.setCallbacks(mExecutor, mNegativeButtonListener, mAuthenticationCallback);
        }
        // Set the crypto object.
        mBiometricFragment.setCryptoObject(crypto);
        if (fragmentManager.findFragmentByTag(BIOMETRIC_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mBiometricFragment, BIOMETRIC_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mBiometricFragment).commit();
        }
    } else {
        // Create the UI
        if (mFingerprintDialogFragment == null) {
            mFingerprintDialogFragment = FingerprintDialogFragment.newInstance(bundle);
            mFingerprintDialogFragment.setNegativeButtonListener(mNegativeButtonListener);
        }
        mFingerprintDialogFragment.show(fragmentManager, DIALOG_FRAGMENT_TAG);
        // Create the connection to FingerprintManager
        if (mFingerprintHelperFragment == null) {
            mFingerprintHelperFragment = FingerprintHelperFragment.newInstance();
            mFingerprintHelperFragment.setCallback(mExecutor, mAuthenticationCallback);
        }
        mFingerprintHelperFragment.setHandler(mFingerprintDialogFragment.getHandler());
        mFingerprintHelperFragment.setCryptoObject(crypto);
        if (fragmentManager.findFragmentByTag(FINGERPRINT_HELPER_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mFingerprintHelperFragment, FINGERPRINT_HELPER_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mFingerprintHelperFragment).commit();
        }
    }
    // For the case when onResume() is being called right authenticate,
    // we need to make sure that all fragment transactions have been committed.
    fragmentManager.executePendingTransactions();
}
#method_after
private void authenticateInternal(@NonNull PromptInfo info, @Nullable CryptoObject crypto) {
    final Bundle bundle = info.getBundle();
    final FragmentManager fragmentManager = mFragmentActivity.getSupportFragmentManager();
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
        // Create the fragment that wraps BiometricPrompt once.
        if (mBiometricFragment == null) {
            mBiometricFragment = BiometricFragment.newInstance(bundle);
            mBiometricFragment.setCallbacks(mExecutor, mNegativeButtonListener, mAuthenticationCallback);
        }
        // Set the crypto object.
        mBiometricFragment.setCryptoObject(crypto);
        if (fragmentManager.findFragmentByTag(BIOMETRIC_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mBiometricFragment, BIOMETRIC_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mBiometricFragment).commit();
        }
    } else {
        // Create the UI
        if (mFingerprintDialogFragment == null) {
            mFingerprintDialogFragment = FingerprintDialogFragment.newInstance(bundle);
            mFingerprintDialogFragment.setNegativeButtonListener(mNegativeButtonListener);
        }
        mFingerprintDialogFragment.show(fragmentManager, DIALOG_FRAGMENT_TAG);
        // Create the connection to FingerprintManager
        if (mFingerprintHelperFragment == null) {
            mFingerprintHelperFragment = FingerprintHelperFragment.newInstance();
            mFingerprintHelperFragment.setCallback(mExecutor, mAuthenticationCallback);
        }
        mFingerprintHelperFragment.setHandler(mFingerprintDialogFragment.getHandler());
        mFingerprintHelperFragment.setCryptoObject(crypto);
        if (fragmentManager.findFragmentByTag(FINGERPRINT_HELPER_FRAGMENT_TAG) == null) {
            // If the fragment hasn't been added before, add it. It will also start the
            // authentication.
            fragmentManager.beginTransaction().add(mFingerprintHelperFragment, FINGERPRINT_HELPER_FRAGMENT_TAG).commit();
        } else {
            // If it's been added before, just re-attach it.
            fragmentManager.beginTransaction().attach(mFingerprintHelperFragment).commit();
        }
    }
    // For the case when onResume() is being called right after authenticate,
    // we need to make sure that all fragment transactions have been committed.
    fragmentManager.executePendingTransactions();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj, msg.arg1);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_TIMEOUT_MSG:
            {
                mServices.serviceForegroundTimeout((ServiceRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_CRASH_MSG:
            {
                mServices.serviceForegroundCrash((ProcessRecord) msg.obj, msg.getData().getCharSequence(SERVICE_RECORD_KEY));
            }
            break;
        case DISPATCH_PENDING_INTENT_CANCEL_MSG:
            {
                RemoteCallbackList<IResultReceiver> callbacks = (RemoteCallbackList<IResultReceiver>) msg.obj;
                int N = callbacks.beginBroadcast();
                for (int i = 0; i < N; i++) {
                    try {
                        callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);
                    } catch (RemoteException e) {
                    }
                }
                callbacks.finishBroadcast();
                // We have to clean up the RemoteCallbackList here, because otherwise it will
                // needlessly hold the enclosed callbacks until the remote process dies.
                callbacks.kill();
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                ProxyInfo proxy = (ProxyInfo) msg.obj;
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        // ConnectivityManager and don't have network privileges anyway.
                        if (r.thread != null && !r.isolated) {
                            try {
                                r.thread.setHttpProxy();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final int appId = msg.arg1;
                    final int userId = msg.arg2;
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appId, false, false, true, false, false, userId, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context, SystemNotificationChannels.HEAVY_WEIGHT_APP).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_POWER_USE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked();
                    removeMessages(CHECK_EXCESSIVE_POWER_USE_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
                    sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case UPDATE_TIME_PREFERENCE_MSG:
            {
                // For convenience we re-use the Intent extra values.
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build();
                try {
                    inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_DUMP_HEAP_NOTIFICATION, notification, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case IDLE_UIDS_MSG:
            {
                idleUids();
            }
            break;
        case VR_MODE_CHANGE_MSG:
            {
                if (!mVrController.onVrModeChanged((ActivityRecord) msg.obj)) {
                    return;
                }
                synchronized (ActivityManagerService.this) {
                    final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();
                    mWindowManager.disableNonVrUi(disableNonVrUi);
                    if (disableNonVrUi) {
                        // If we are in a VR mode where Picture-in-Picture mode is unsupported,
                        // then remove the pinned stack.
                        mStackSupervisor.removeStacksInWindowingModes(WINDOWING_MODE_PINNED);
                    }
                }
            }
            break;
        case DISPATCH_SCREEN_AWAKE_MSG:
            {
                final boolean isAwake = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onAwakeStateChanged(isAwake);
                }
            }
            break;
        case DISPATCH_SCREEN_KEYGUARD_MSG:
            {
                final boolean isShowing = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onKeyguardStateChanged(isShowing);
                }
            }
            break;
        case HANDLE_TRUST_STORAGE_UPDATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.handleTrustStorageUpdate();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to handle trust storage update for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj, msg.arg1);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_TIMEOUT_MSG:
            {
                mServices.serviceForegroundTimeout((ServiceRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_CRASH_MSG:
            {
                mServices.serviceForegroundCrash((ProcessRecord) msg.obj, msg.getData().getCharSequence(SERVICE_RECORD_KEY));
            }
            break;
        case DISPATCH_PENDING_INTENT_CANCEL_MSG:
            {
                RemoteCallbackList<IResultReceiver> callbacks = (RemoteCallbackList<IResultReceiver>) msg.obj;
                int N = callbacks.beginBroadcast();
                for (int i = 0; i < N; i++) {
                    try {
                        callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);
                    } catch (RemoteException e) {
                    }
                }
                callbacks.finishBroadcast();
                // We have to clean up the RemoteCallbackList here, because otherwise it will
                // needlessly hold the enclosed callbacks until the remote process dies.
                callbacks.kill();
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        // ConnectivityManager and don't have network privileges anyway.
                        if (r.thread != null && !r.isolated) {
                            try {
                                r.thread.updateHttpProxy();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final int appId = msg.arg1;
                    final int userId = msg.arg2;
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appId, false, false, true, false, false, userId, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context, SystemNotificationChannels.HEAVY_WEIGHT_APP).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_POWER_USE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked();
                    removeMessages(CHECK_EXCESSIVE_POWER_USE_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
                    sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case UPDATE_TIME_PREFERENCE_MSG:
            {
                // For convenience we re-use the Intent extra values.
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build();
                try {
                    inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_DUMP_HEAP_NOTIFICATION, notification, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case IDLE_UIDS_MSG:
            {
                idleUids();
            }
            break;
        case VR_MODE_CHANGE_MSG:
            {
                if (!mVrController.onVrModeChanged((ActivityRecord) msg.obj)) {
                    return;
                }
                synchronized (ActivityManagerService.this) {
                    final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();
                    mWindowManager.disableNonVrUi(disableNonVrUi);
                    if (disableNonVrUi) {
                        // If we are in a VR mode where Picture-in-Picture mode is unsupported,
                        // then remove the pinned stack.
                        mStackSupervisor.removeStacksInWindowingModes(WINDOWING_MODE_PINNED);
                    }
                }
            }
            break;
        case DISPATCH_SCREEN_AWAKE_MSG:
            {
                final boolean isAwake = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onAwakeStateChanged(isAwake);
                }
            }
            break;
        case DISPATCH_SCREEN_KEYGUARD_MSG:
            {
                final boolean isShowing = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onKeyguardStateChanged(isShowing);
                }
            }
            break;
        case HANDLE_TRUST_STORAGE_UPDATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.handleTrustStorageUpdate();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to handle trust storage update for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
    }
}
#end_block

#method_before
@Override
public final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
    final String reason = "startActivities";
    enforceNotIsolatedCaller(reason);
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, reason, null);
    // TODO: Switch to user app stacks here.
    int ret = mActivityStartController.startActivities(caller, -1, callingPackage, intents, resolvedTypes, resultTo, SafeActivityOptions.fromBundle(bOptions), userId, reason);
    return ret;
}
#method_after
@Override
public final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
    final String reason = "startActivities";
    enforceNotIsolatedCaller(reason);
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, reason, null);
    // TODO: Switch to user app stacks here.
    int ret = mActivityStartController.startActivities(caller, -1, callingPackage, intents, resolvedTypes, resultTo, SafeActivityOptions.fromBundle(bOptions), userId, reason, null);
    return ret;
}
#end_block

#method_before
final void finishBooting() {
    synchronized (this) {
        if (!mBootAnimationComplete) {
            mCallFinishBooting = true;
            return;
        }
        mCallFinishBooting = false;
    }
    ArraySet<String> completedIsas = new ArraySet<String>();
    for (String abi : Build.SUPPORTED_ABIS) {
        zygoteProcess.establishZygoteConnectionForAbi(abi);
        final String instructionSet = VMRuntime.getInstructionSet(abi);
        if (!completedIsas.contains(instructionSet)) {
            try {
                mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));
            } catch (InstallerException e) {
                if (!VMRuntime.didPruneDalvikCache()) {
                    // This is technically not the right filter, as different zygotes may
                    // have made different pruning decisions. But the log is best effort,
                    // anyways.
                    Slog.w(TAG, "Unable to mark boot complete for abi: " + abi + " (" + e.getMessage() + ")");
                }
            }
            completedIsas.add(instructionSet);
        }
    }
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
            if (pkgs != null) {
                for (String pkg : pkgs) {
                    synchronized (ActivityManagerService.this) {
                        if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, "query restart")) {
                            setResultCode(Activity.RESULT_OK);
                            return;
                        }
                    }
                }
            }
        }
    }, pkgFilter);
    IntentFilter dumpheapFilter = new IntentFilter();
    dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) {
                mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5 * 60 * 1000);
            } else {
                mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
            }
        }
    }, dumpheapFilter);
    // Let system services know.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);
    synchronized (this) {
        // Ensure that any processes we had put on hold are now started
        // up.
        final int NP = mProcessesOnHold.size();
        if (NP > 0) {
            ArrayList<ProcessRecord> procs = new ArrayList<ProcessRecord>(mProcessesOnHold);
            for (int ip = 0; ip < NP; ip++) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG_PROCESSES, "Starting process on hold: " + procs.get(ip));
                startProcessLocked(procs.get(ip), "on-hold", null);
            }
        }
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            return;
        }
        // Start looking for apps that are abusing wake locks.
        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
        mHandler.sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
        // Tell anyone interested that we are done booting!
        SystemProperties.set("sys.boot_completed", "1");
        // And trigger dev.bootcomplete if we are not showing encryption progress
        if (!"trigger_restart_min_framework".equals(SystemProperties.get("vold.decrypt")) || "".equals(SystemProperties.get("vold.encrypt_progress"))) {
            SystemProperties.set("dev.bootcomplete", "1");
        }
        mUserController.sendBootCompleted(new IIntentReceiver.Stub() {

            @Override
            public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
            }
        });
        mUserController.scheduleStartProfiles();
    }
}
#method_after
final void finishBooting() {
    synchronized (this) {
        if (!mBootAnimationComplete) {
            mCallFinishBooting = true;
            return;
        }
        mCallFinishBooting = false;
    }
    ArraySet<String> completedIsas = new ArraySet<String>();
    for (String abi : Build.SUPPORTED_ABIS) {
        zygoteProcess.establishZygoteConnectionForAbi(abi);
        final String instructionSet = VMRuntime.getInstructionSet(abi);
        if (!completedIsas.contains(instructionSet)) {
            try {
                mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));
            } catch (InstallerException e) {
                if (!VMRuntime.didPruneDalvikCache()) {
                    // This is technically not the right filter, as different zygotes may
                    // have made different pruning decisions. But the log is best effort,
                    // anyways.
                    Slog.w(TAG, "Unable to mark boot complete for abi: " + abi + " (" + e.getMessage() + ")");
                }
            }
            completedIsas.add(instructionSet);
        }
    }
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
            if (pkgs != null) {
                for (String pkg : pkgs) {
                    synchronized (ActivityManagerService.this) {
                        if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, "query restart")) {
                            setResultCode(Activity.RESULT_OK);
                            return;
                        }
                    }
                }
            }
        }
    }, pkgFilter);
    IntentFilter dumpheapFilter = new IntentFilter();
    dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) {
                mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5 * 60 * 1000);
            } else {
                mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
            }
        }
    }, dumpheapFilter);
    // Let system services know.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);
    synchronized (this) {
        // Ensure that any processes we had put on hold are now started
        // up.
        final int NP = mProcessesOnHold.size();
        if (NP > 0) {
            ArrayList<ProcessRecord> procs = new ArrayList<ProcessRecord>(mProcessesOnHold);
            for (int ip = 0; ip < NP; ip++) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG_PROCESSES, "Starting process on hold: " + procs.get(ip));
                startProcessLocked(procs.get(ip), "on-hold", null);
            }
        }
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            return;
        }
        // Start looking for apps that are abusing wake locks.
        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
        mHandler.sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
        // Tell anyone interested that we are done booting!
        SystemProperties.set("sys.boot_completed", "1");
        // And trigger dev.bootcomplete if we are not showing encryption progress
        if (!"trigger_restart_min_framework".equals(VoldProperties.decrypt().orElse("")) || "".equals(VoldProperties.encrypt_progress().orElse(""))) {
            SystemProperties.set("dev.bootcomplete", "1");
        }
        mUserController.sendBootCompleted(new IIntentReceiver.Stub() {

            @Override
            public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
            }
        });
        mUserController.scheduleStartProfiles();
    }
}
#end_block

#method_before
@Deprecated
@Override
public void requestBugReport(int bugreportType) {
    String extraOptions = null;
    switch(bugreportType) {
        case ActivityManager.BUGREPORT_OPTION_FULL:
            // Default options.
            break;
        case ActivityManager.BUGREPORT_OPTION_INTERACTIVE:
            extraOptions = "bugreportplus";
            break;
        case ActivityManager.BUGREPORT_OPTION_REMOTE:
            extraOptions = "bugreportremote";
            break;
        case ActivityManager.BUGREPORT_OPTION_WEAR:
            extraOptions = "bugreportwear";
            break;
        case ActivityManager.BUGREPORT_OPTION_TELEPHONY:
            extraOptions = "bugreporttelephony";
            break;
        case ActivityManager.BUGREPORT_OPTION_WIFI:
            extraOptions = "bugreportwifi";
            break;
        default:
            throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
    }
    // Always log caller, even if it does not have permission to dump.
    String type = extraOptions == null ? "bugreport" : extraOptions;
    Slog.i(TAG, type + " requested by UID " + Binder.getCallingUid());
    enforceCallingPermission(android.Manifest.permission.DUMP, "requestBugReport");
    if (extraOptions != null) {
        SystemProperties.set("dumpstate.options", extraOptions);
    }
    SystemProperties.set("ctl.start", "bugreport");
}
#method_after
@Deprecated
@Override
public void requestBugReport(int bugreportType) {
    String extraOptions = null;
    switch(bugreportType) {
        case ActivityManager.BUGREPORT_OPTION_FULL:
            extraOptions = "bugreportfull";
            break;
        case ActivityManager.BUGREPORT_OPTION_INTERACTIVE:
            extraOptions = "bugreportplus";
            break;
        case ActivityManager.BUGREPORT_OPTION_REMOTE:
            extraOptions = "bugreportremote";
            break;
        case ActivityManager.BUGREPORT_OPTION_WEAR:
            extraOptions = "bugreportwear";
            break;
        case ActivityManager.BUGREPORT_OPTION_TELEPHONY:
            extraOptions = "bugreporttelephony";
            break;
        case ActivityManager.BUGREPORT_OPTION_WIFI:
            extraOptions = "bugreportwifi";
            break;
        default:
            throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
    }
    // Always log caller, even if it does not have permission to dump.
    String type = extraOptions == null ? "bugreport" : extraOptions;
    Slog.i(TAG, type + " requested by UID " + Binder.getCallingUid());
    enforceCallingPermission(android.Manifest.permission.DUMP, "requestBugReport");
    if (extraOptions != null) {
        SystemProperties.set("dumpstate.options", extraOptions);
    }
    SystemProperties.set("ctl.start", "bugreport");
}
#end_block

#method_before
@GuardedBy("this")
final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
    intent = new Intent(intent);
    final boolean callerInstantApp = isInstantApp(callerApp, callerPackage, callingUid);
    // Instant Apps cannot use FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
    if (callerInstantApp) {
        intent.setFlags(intent.getFlags() & ~Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
    }
    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    // If we have not finished booting, don't allow this to launch new processes.
    if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    if (DEBUG_BROADCAST_LIGHT)
        Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered=" + ordered + " userid=" + userId);
    if ((resultTo != null) && !ordered) {
        Slog.w(TAG, "Broadcast " + intent + " not ordered but result callback requested!");
    }
    userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_NON_FULL, "broadcast", callerPackage);
    // If not, we will just skip it. Make an exception for shutdown broadcasts, upgrade steps.
    if (userId != UserHandle.USER_ALL && !mUserController.isUserOrItsParentRunning(userId)) {
        if ((callingUid != SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
            Slog.w(TAG, "Skipping broadcast of " + intent + ": user " + userId + " and its parent (if any) are stopped");
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        }
    }
    final String action = intent.getAction();
    BroadcastOptions brOptions = null;
    if (bOptions != null) {
        brOptions = new BroadcastOptions(bOptions);
        if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
            // PendingIntent), because that who is actually supplied the arguments.
            if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST, Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {
                String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        }
        if (brOptions.isDontSendToRestrictedApps() && !isUidActiveLocked(callingUid) && isBackgroundRestrictedNoCheck(callingUid, callerPackage)) {
            Slog.i(TAG, "Not sending broadcast " + action + " - app " + callerPackage + " has background restrictions");
            return ActivityManager.START_CANCELED;
        }
    }
    // Verify that protected broadcasts are only being sent by system code,
    // and that system code is only sending protected broadcasts.
    final boolean isProtectedBroadcast;
    try {
        isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);
    } catch (RemoteException e) {
        Slog.w(TAG, "Remote exception", e);
        return ActivityManager.BROADCAST_SUCCESS;
    }
    final boolean isCallerSystem;
    switch(UserHandle.getAppId(callingUid)) {
        case ROOT_UID:
        case SYSTEM_UID:
        case PHONE_UID:
        case BLUETOOTH_UID:
        case NFC_UID:
        case SE_UID:
            isCallerSystem = true;
            break;
        default:
            isCallerSystem = (callerApp != null) && callerApp.persistent;
            break;
    }
    // sending protected broadcasts.
    if (!isCallerSystem) {
        if (isProtectedBroadcast) {
            String msg = "Permission Denial: not allowed to send broadcast " + action + " from pid=" + callingPid + ", uid=" + callingUid;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        } else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
            // just limit it to the caller.
            if (callerPackage == null) {
                String msg = "Permission Denial: not allowed to send broadcast " + action + " from unknown caller.";
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            } else if (intent.getComponent() != null) {
                // it is being sent to the calling app.
                if (!intent.getComponent().getPackageName().equals(callerPackage)) {
                    String msg = "Permission Denial: not allowed to send broadcast " + action + " to " + intent.getComponent().getPackageName() + " from " + callerPackage;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
            } else {
                // Limit broadcast to their own package.
                intent.setPackage(callerPackage);
            }
        }
    }
    if (action != null) {
        if (getBackgroundLaunchBroadcasts().contains(action)) {
            if (DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, "Broadcast action " + action + " forcing include-background");
            }
            intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        }
        switch(action) {
            case Intent.ACTION_UID_REMOVED:
            case Intent.ACTION_PACKAGE_REMOVED:
            case Intent.ACTION_PACKAGE_CHANGED:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
            case Intent.ACTION_PACKAGES_SUSPENDED:
            case Intent.ACTION_PACKAGES_UNSUSPENDED:
                // its activities from the history stack.
                if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED, callingPid, callingUid, -1, true) != PackageManager.PERMISSION_GRANTED) {
                    String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                switch(action) {
                    case Intent.ACTION_UID_REMOVED:
                        final int uid = getUidFromIntent(intent);
                        if (uid >= 0) {
                            mBatteryStatsService.removeUid(uid);
                            mAppOpsService.uidRemoved(uid);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
                        // If resources are unavailable just force stop all those packages
                        // and flush the attribute cache as well.
                        String[] list = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        if (list != null && list.length > 0) {
                            for (int i = 0; i < list.length; i++) {
                                forceStopPackageLocked(list[i], -1, false, true, true, false, false, userId, "storage unmount");
                            }
                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                            sendPackageBroadcastLocked(ApplicationThreadConstants.EXTERNAL_STORAGE_UNAVAILABLE, list, userId);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                        break;
                    case Intent.ACTION_PACKAGE_REMOVED:
                    case Intent.ACTION_PACKAGE_CHANGED:
                        Uri data = intent.getData();
                        String ssp;
                        if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
                            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
                            final boolean fullUninstall = removed && !replacing;
                            if (removed) {
                                if (killProcess) {
                                    forceStopPackageLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, fullUninstall, userId, removed ? "pkg removed" : "pkg changed");
                                }
                                final int cmd = killProcess ? ApplicationThreadConstants.PACKAGE_REMOVED : ApplicationThreadConstants.PACKAGE_REMOVED_DONT_KILL;
                                sendPackageBroadcastLocked(cmd, new String[] { ssp }, userId);
                                if (fullUninstall) {
                                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                                    // Remove all permissions granted from/to this package
                                    removeUriPermissionsForPackageLocked(ssp, userId, true, false);
                                    mRecentTasks.removeTasksByPackageName(ssp, userId);
                                    mServices.forceStopPackageLocked(ssp, userId);
                                    mAppWarnings.onPackageUninstalled(ssp);
                                    mCompatModePackages.handlePackageUninstalledLocked(ssp);
                                    mBatteryStatsService.notePackageUninstalled(ssp);
                                }
                            } else {
                                if (killProcess) {
                                    killPackageProcessesLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), userId, ProcessList.INVALID_ADJ, false, true, true, false, "change " + ssp);
                                }
                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess, intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
                            }
                        }
                        break;
                    case Intent.ACTION_PACKAGES_SUSPENDED:
                    case Intent.ACTION_PACKAGES_UNSUSPENDED:
                        final boolean suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
                        final String[] packageNames = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
                        synchronized (ActivityManagerService.this) {
                            mRecentTasks.onPackagesSuspendedChanged(packageNames, suspended, userHandle);
                        }
                        break;
                }
                break;
            case Intent.ACTION_PACKAGE_REPLACED:
                {
                    final Uri data = intent.getData();
                    final String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        ApplicationInfo aInfo = null;
                        try {
                            aInfo = AppGlobals.getPackageManager().getApplicationInfo(ssp, STOCK_PM_FLAGS, userId);
                        } catch (RemoteException ignore) {
                        }
                        if (aInfo == null) {
                            Slog.w(TAG, "Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:" + " ssp=" + ssp + " data=" + data);
                            return ActivityManager.BROADCAST_SUCCESS;
                        }
                        mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
                        mServices.updateServiceApplicationInfoLocked(aInfo);
                        sendPackageBroadcastLocked(ApplicationThreadConstants.PACKAGE_REPLACED, new String[] { ssp }, userId);
                    }
                    break;
                }
            case Intent.ACTION_PACKAGE_ADDED:
                {
                    // Special case for adding a package: by default turn on compatibility mode.
                    Uri data = intent.getData();
                    String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                        mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
                        try {
                            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, STOCK_PM_FLAGS, 0);
                            mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0);
                        } catch (RemoteException e) {
                        }
                    }
                    break;
                }
            case Intent.ACTION_PACKAGE_DATA_CLEARED:
                {
                    Uri data = intent.getData();
                    String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        mCompatModePackages.handlePackageDataClearedLocked(ssp);
                        mAppWarnings.onPackageDataCleared(ssp);
                    }
                    break;
                }
            case Intent.ACTION_TIMEZONE_CHANGED:
                // If this is the time zone changed action, queue up a message that will reset
                // the timezone of all currently running processes. This message will get
                // queued up before the broadcast happens.
                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
                break;
            case Intent.ACTION_TIME_CHANGED:
                // EXTRA_TIME_PREF_24_HOUR_FORMAT is optional so we must distinguish between
                // the tri-state value it may contain and "unknown".
                // For convenience we re-use the Intent extra values.
                final int NO_EXTRA_VALUE_FOUND = -1;
                final int timeFormatPreferenceMsgValue = intent.getIntExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, NO_EXTRA_VALUE_FOUND);
                // Only send a message if the time preference is available.
                if (timeFormatPreferenceMsgValue != NO_EXTRA_VALUE_FOUND) {
                    Message updateTimePreferenceMsg = mHandler.obtainMessage(UPDATE_TIME_PREFERENCE_MSG, timeFormatPreferenceMsgValue, 0);
                    mHandler.sendMessage(updateTimePreferenceMsg);
                }
                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    stats.noteCurrentTimeChangedLocked();
                }
                break;
            case Intent.ACTION_CLEAR_DNS_CACHE:
                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
                break;
            case Proxy.PROXY_CHANGE_ACTION:
                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
                break;
            case android.hardware.Camera.ACTION_NEW_PICTURE:
            case android.hardware.Camera.ACTION_NEW_VIDEO:
                // In N we just turned these off; in O we are turing them back on partly,
                // only for registered receivers.  This will still address the main problem
                // (a spam of apps waking up when a picture is taken putting significant
                // memory pressure on the system at a bad point), while still allowing apps
                // that are already actively running to know about this happening.
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                break;
            case android.security.KeyChain.ACTION_TRUST_STORE_CHANGED:
                mHandler.sendEmptyMessage(HANDLE_TRUST_STORAGE_UPDATE_MSG);
                break;
            case "com.android.launcher.action.INSTALL_SHORTCUT":
                // As of O, we no longer support this broadcasts, even for pre-O apps.
                // Apps should now be using ShortcutManager.pinRequestShortcut().
                Log.w(TAG, "Broadcast " + action + " no longer supported. It will not be delivered.");
                return ActivityManager.BROADCAST_SUCCESS;
        }
        if (Intent.ACTION_PACKAGE_ADDED.equals(action) || Intent.ACTION_PACKAGE_REMOVED.equals(action) || Intent.ACTION_PACKAGE_REPLACED.equals(action)) {
            final int uid = getUidFromIntent(intent);
            if (uid != -1) {
                final UidRecord uidRec = mActiveUids.get(uid);
                if (uidRec != null) {
                    uidRec.updateHasInternetPermission();
                }
            }
        }
    }
    // Add to the sticky list if requested.
    if (sticky) {
        if (checkPermission(android.Manifest.permission.BROADCAST_STICKY, callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid=" + callingUid + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        if (requiredPermissions != null && requiredPermissions.length > 0) {
            Slog.w(TAG, "Can't broadcast sticky intent " + intent + " and enforce permissions " + Arrays.toString(requiredPermissions));
            return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
        }
        if (intent.getComponent() != null) {
            throw new SecurityException("Sticky broadcasts can't target a specific component");
        }
        // as a separate set of sticky broadcasts.
        if (userId != UserHandle.USER_ALL) {
            // But first, if this is not a broadcast to all users, then
            // make sure it doesn't conflict with an existing broadcast to
            // all users.
            ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(UserHandle.USER_ALL);
            if (stickies != null) {
                ArrayList<Intent> list = stickies.get(intent.getAction());
                if (list != null) {
                    int N = list.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        if (intent.filterEquals(list.get(i))) {
                            throw new IllegalArgumentException("Sticky broadcast " + intent + " for user " + userId + " conflicts with existing global broadcast");
                        }
                    }
                }
            }
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies == null) {
            stickies = new ArrayMap<>();
            mStickyBroadcasts.put(userId, stickies);
        }
        ArrayList<Intent> list = stickies.get(intent.getAction());
        if (list == null) {
            list = new ArrayList<>();
            stickies.put(intent.getAction(), list);
        }
        final int stickiesCount = list.size();
        int i;
        for (i = 0; i < stickiesCount; i++) {
            if (intent.filterEquals(list.get(i))) {
                // This sticky already exists, replace it.
                list.set(i, new Intent(intent));
                break;
            }
        }
        if (i >= stickiesCount) {
            list.add(new Intent(intent));
        }
    }
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        // Caller wants broadcast to go to all started users.
        users = mUserController.getStartedUserArray();
    } else {
        // Caller wants broadcast to go to one specific user.
        users = new int[] { userId };
    }
    // Figure out who all will receive this broadcast.
    List receivers = null;
    List<BroadcastFilter> registeredReceivers = null;
    // Need to resolve the intent to interested receivers...
    if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
    }
    if (intent.getComponent() == null) {
        if (userId == UserHandle.USER_ALL && callingUid == SHELL_UID) {
            // Query one target user at a time, excluding shell-restricted users
            for (int i = 0; i < users.length; i++) {
                if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) {
                    continue;
                }
                List<BroadcastFilter> registeredReceiversForUser = mReceiverResolver.queryIntent(intent, resolvedType, false, /*defaultOnly*/
                users[i]);
                if (registeredReceivers == null) {
                    registeredReceivers = registeredReceiversForUser;
                } else if (registeredReceiversForUser != null) {
                    registeredReceivers.addAll(registeredReceiversForUser);
                }
            }
        } else {
            registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false, /*defaultOnly*/
            userId);
        }
    }
    final boolean replacePending = (intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Enqueueing broadcast: " + intent.getAction() + " replacePending=" + replacePending);
    int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
    if (!ordered && NR > 0) {
        // components to be launched.
        if (isCallerSystem) {
            checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid, isProtectedBroadcast, registeredReceivers);
        }
        final BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, callerInstantApp, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r);
        final boolean replaced = replacePending && (queue.replaceParallelBroadcastLocked(r) != null);
        // Note: We assume resultTo is null for non-ordered broadcasts.
        if (!replaced) {
            queue.enqueueParallelBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
        registeredReceivers = null;
        NR = 0;
    }
    // Merge into one list.
    int ir = 0;
    if (receivers != null) {
        // A special case for PACKAGE_ADDED: do not allow the package
        // being added to see this broadcast.  This prevents them from
        // using this as a back door to get run as soon as they are
        // installed.  Maybe in the future we want to have a special install
        // broadcast or such for apps, but we'd like to deliberately make
        // this decision.
        String[] skipPackages = null;
        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
            Uri data = intent.getData();
            if (data != null) {
                String pkgName = data.getSchemeSpecificPart();
                if (pkgName != null) {
                    skipPackages = new String[] { pkgName };
                }
            }
        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
        }
        if (skipPackages != null && (skipPackages.length > 0)) {
            for (String skipPackage : skipPackages) {
                if (skipPackage != null) {
                    int NT = receivers.size();
                    for (int it = 0; it < NT; it++) {
                        ResolveInfo curt = (ResolveInfo) receivers.get(it);
                        if (curt.activityInfo.packageName.equals(skipPackage)) {
                            receivers.remove(it);
                            it--;
                            NT--;
                        }
                    }
                }
            }
        }
        int NT = receivers != null ? receivers.size() : 0;
        int it = 0;
        ResolveInfo curt = null;
        BroadcastFilter curr = null;
        while (it < NT && ir < NR) {
            if (curt == null) {
                curt = (ResolveInfo) receivers.get(it);
            }
            if (curr == null) {
                curr = registeredReceivers.get(ir);
            }
            if (curr.getPriority() >= curt.priority) {
                // Insert this broadcast record into the final list.
                receivers.add(it, curr);
                ir++;
                curr = null;
                it++;
                NT++;
            } else {
                // Skip to the next ResolveInfo in the final list.
                it++;
                curt = null;
            }
        }
    }
    while (ir < NR) {
        if (receivers == null) {
            receivers = new ArrayList();
        }
        receivers.add(registeredReceivers.get(ir));
        ir++;
    }
    if (isCallerSystem) {
        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid, isProtectedBroadcast, receivers);
    }
    if ((receivers != null && receivers.size() > 0) || resultTo != null) {
        BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, callerInstantApp, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size());
        if (DEBUG_BROADCAST)
            Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction());
        final BroadcastRecord oldRecord = replacePending ? queue.replaceOrderedBroadcastLocked(r) : null;
        if (oldRecord != null) {
            // Replaced, fire the result-to receiver.
            if (oldRecord.resultTo != null) {
                final BroadcastQueue oldQueue = broadcastQueueForIntent(oldRecord.intent);
                try {
                    oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo, oldRecord.intent, Activity.RESULT_CANCELED, null, null, false, false, oldRecord.userId);
                } catch (RemoteException e) {
                    Slog.w(TAG, "Failure [" + queue.mQueueName + "] sending broadcast result of " + intent, e);
                }
            }
        } else {
            queue.enqueueOrderedBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
    } else {
        // that it happened.
        if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
            // This was an implicit broadcast... let's record it for posterity.
            addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0);
        }
    }
    return ActivityManager.BROADCAST_SUCCESS;
}
#method_after
@GuardedBy("this")
final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
    intent = new Intent(intent);
    final boolean callerInstantApp = isInstantApp(callerApp, callerPackage, callingUid);
    // Instant Apps cannot use FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
    if (callerInstantApp) {
        intent.setFlags(intent.getFlags() & ~Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
    }
    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    // If we have not finished booting, don't allow this to launch new processes.
    if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    if (DEBUG_BROADCAST_LIGHT)
        Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered=" + ordered + " userid=" + userId);
    if ((resultTo != null) && !ordered) {
        Slog.w(TAG, "Broadcast " + intent + " not ordered but result callback requested!");
    }
    userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_NON_FULL, "broadcast", callerPackage);
    // If not, we will just skip it. Make an exception for shutdown broadcasts, upgrade steps.
    if (userId != UserHandle.USER_ALL && !mUserController.isUserOrItsParentRunning(userId)) {
        if ((callingUid != SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
            Slog.w(TAG, "Skipping broadcast of " + intent + ": user " + userId + " and its parent (if any) are stopped");
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        }
    }
    final String action = intent.getAction();
    BroadcastOptions brOptions = null;
    if (bOptions != null) {
        brOptions = new BroadcastOptions(bOptions);
        if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
            // PendingIntent), because that who is actually supplied the arguments.
            if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST, Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {
                String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        }
        if (brOptions.isDontSendToRestrictedApps() && !isUidActiveLocked(callingUid) && isBackgroundRestrictedNoCheck(callingUid, callerPackage)) {
            Slog.i(TAG, "Not sending broadcast " + action + " - app " + callerPackage + " has background restrictions");
            return ActivityManager.START_CANCELED;
        }
    }
    // Verify that protected broadcasts are only being sent by system code,
    // and that system code is only sending protected broadcasts.
    final boolean isProtectedBroadcast;
    try {
        isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);
    } catch (RemoteException e) {
        Slog.w(TAG, "Remote exception", e);
        return ActivityManager.BROADCAST_SUCCESS;
    }
    final boolean isCallerSystem;
    switch(UserHandle.getAppId(callingUid)) {
        case ROOT_UID:
        case SYSTEM_UID:
        case PHONE_UID:
        case BLUETOOTH_UID:
        case NFC_UID:
        case SE_UID:
        case NETWORK_STACK_UID:
            isCallerSystem = true;
            break;
        default:
            isCallerSystem = (callerApp != null) && callerApp.persistent;
            break;
    }
    // sending protected broadcasts.
    if (!isCallerSystem) {
        if (isProtectedBroadcast) {
            String msg = "Permission Denial: not allowed to send broadcast " + action + " from pid=" + callingPid + ", uid=" + callingUid;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        } else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
            // just limit it to the caller.
            if (callerPackage == null) {
                String msg = "Permission Denial: not allowed to send broadcast " + action + " from unknown caller.";
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            } else if (intent.getComponent() != null) {
                // it is being sent to the calling app.
                if (!intent.getComponent().getPackageName().equals(callerPackage)) {
                    String msg = "Permission Denial: not allowed to send broadcast " + action + " to " + intent.getComponent().getPackageName() + " from " + callerPackage;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
            } else {
                // Limit broadcast to their own package.
                intent.setPackage(callerPackage);
            }
        }
    }
    if (action != null) {
        if (getBackgroundLaunchBroadcasts().contains(action)) {
            if (DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, "Broadcast action " + action + " forcing include-background");
            }
            intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        }
        switch(action) {
            case Intent.ACTION_UID_REMOVED:
            case Intent.ACTION_PACKAGE_REMOVED:
            case Intent.ACTION_PACKAGE_CHANGED:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
            case Intent.ACTION_PACKAGES_SUSPENDED:
            case Intent.ACTION_PACKAGES_UNSUSPENDED:
                // its activities from the history stack.
                if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED, callingPid, callingUid, -1, true) != PackageManager.PERMISSION_GRANTED) {
                    String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                switch(action) {
                    case Intent.ACTION_UID_REMOVED:
                        final int uid = getUidFromIntent(intent);
                        if (uid >= 0) {
                            mBatteryStatsService.removeUid(uid);
                            mAppOpsService.uidRemoved(uid);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
                        // If resources are unavailable just force stop all those packages
                        // and flush the attribute cache as well.
                        String[] list = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        if (list != null && list.length > 0) {
                            for (int i = 0; i < list.length; i++) {
                                forceStopPackageLocked(list[i], -1, false, true, true, false, false, userId, "storage unmount");
                            }
                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                            sendPackageBroadcastLocked(ApplicationThreadConstants.EXTERNAL_STORAGE_UNAVAILABLE, list, userId);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                        break;
                    case Intent.ACTION_PACKAGE_REMOVED:
                    case Intent.ACTION_PACKAGE_CHANGED:
                        Uri data = intent.getData();
                        String ssp;
                        if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
                            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
                            final boolean fullUninstall = removed && !replacing;
                            if (removed) {
                                if (killProcess) {
                                    forceStopPackageLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, fullUninstall, userId, removed ? "pkg removed" : "pkg changed");
                                }
                                final int cmd = killProcess ? ApplicationThreadConstants.PACKAGE_REMOVED : ApplicationThreadConstants.PACKAGE_REMOVED_DONT_KILL;
                                sendPackageBroadcastLocked(cmd, new String[] { ssp }, userId);
                                if (fullUninstall) {
                                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                                    // Remove all permissions granted from/to this package
                                    removeUriPermissionsForPackageLocked(ssp, userId, true, false);
                                    mRecentTasks.removeTasksByPackageName(ssp, userId);
                                    mServices.forceStopPackageLocked(ssp, userId);
                                    mAppWarnings.onPackageUninstalled(ssp);
                                    mCompatModePackages.handlePackageUninstalledLocked(ssp);
                                    mBatteryStatsService.notePackageUninstalled(ssp);
                                }
                            } else {
                                if (killProcess) {
                                    killPackageProcessesLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), userId, ProcessList.INVALID_ADJ, false, true, true, false, "change " + ssp);
                                }
                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess, intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
                            }
                        }
                        break;
                    case Intent.ACTION_PACKAGES_SUSPENDED:
                    case Intent.ACTION_PACKAGES_UNSUSPENDED:
                        final boolean suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
                        final String[] packageNames = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
                        synchronized (ActivityManagerService.this) {
                            mRecentTasks.onPackagesSuspendedChanged(packageNames, suspended, userHandle);
                        }
                        break;
                }
                break;
            case Intent.ACTION_PACKAGE_REPLACED:
                {
                    final Uri data = intent.getData();
                    final String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        ApplicationInfo aInfo = null;
                        try {
                            aInfo = AppGlobals.getPackageManager().getApplicationInfo(ssp, STOCK_PM_FLAGS, userId);
                        } catch (RemoteException ignore) {
                        }
                        if (aInfo == null) {
                            Slog.w(TAG, "Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:" + " ssp=" + ssp + " data=" + data);
                            return ActivityManager.BROADCAST_SUCCESS;
                        }
                        mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
                        mServices.updateServiceApplicationInfoLocked(aInfo);
                        sendPackageBroadcastLocked(ApplicationThreadConstants.PACKAGE_REPLACED, new String[] { ssp }, userId);
                    }
                    break;
                }
            case Intent.ACTION_PACKAGE_ADDED:
                {
                    // Special case for adding a package: by default turn on compatibility mode.
                    Uri data = intent.getData();
                    String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                        mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
                        try {
                            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, STOCK_PM_FLAGS, 0);
                            mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0);
                        } catch (RemoteException e) {
                        }
                    }
                    break;
                }
            case Intent.ACTION_PACKAGE_DATA_CLEARED:
                {
                    Uri data = intent.getData();
                    String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        mCompatModePackages.handlePackageDataClearedLocked(ssp);
                        mAppWarnings.onPackageDataCleared(ssp);
                    }
                    break;
                }
            case Intent.ACTION_TIMEZONE_CHANGED:
                // If this is the time zone changed action, queue up a message that will reset
                // the timezone of all currently running processes. This message will get
                // queued up before the broadcast happens.
                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
                break;
            case Intent.ACTION_TIME_CHANGED:
                // EXTRA_TIME_PREF_24_HOUR_FORMAT is optional so we must distinguish between
                // the tri-state value it may contain and "unknown".
                // For convenience we re-use the Intent extra values.
                final int NO_EXTRA_VALUE_FOUND = -1;
                final int timeFormatPreferenceMsgValue = intent.getIntExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, NO_EXTRA_VALUE_FOUND);
                // Only send a message if the time preference is available.
                if (timeFormatPreferenceMsgValue != NO_EXTRA_VALUE_FOUND) {
                    Message updateTimePreferenceMsg = mHandler.obtainMessage(UPDATE_TIME_PREFERENCE_MSG, timeFormatPreferenceMsgValue, 0);
                    mHandler.sendMessage(updateTimePreferenceMsg);
                }
                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    stats.noteCurrentTimeChangedLocked();
                }
                break;
            case Intent.ACTION_CLEAR_DNS_CACHE:
                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
                break;
            case Proxy.PROXY_CHANGE_ACTION:
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG));
                break;
            case android.hardware.Camera.ACTION_NEW_PICTURE:
            case android.hardware.Camera.ACTION_NEW_VIDEO:
                // In N we just turned these off; in O we are turing them back on partly,
                // only for registered receivers.  This will still address the main problem
                // (a spam of apps waking up when a picture is taken putting significant
                // memory pressure on the system at a bad point), while still allowing apps
                // that are already actively running to know about this happening.
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                break;
            case android.security.KeyChain.ACTION_TRUST_STORE_CHANGED:
                mHandler.sendEmptyMessage(HANDLE_TRUST_STORAGE_UPDATE_MSG);
                break;
            case "com.android.launcher.action.INSTALL_SHORTCUT":
                // As of O, we no longer support this broadcasts, even for pre-O apps.
                // Apps should now be using ShortcutManager.pinRequestShortcut().
                Log.w(TAG, "Broadcast " + action + " no longer supported. It will not be delivered.");
                return ActivityManager.BROADCAST_SUCCESS;
        }
        if (Intent.ACTION_PACKAGE_ADDED.equals(action) || Intent.ACTION_PACKAGE_REMOVED.equals(action) || Intent.ACTION_PACKAGE_REPLACED.equals(action)) {
            final int uid = getUidFromIntent(intent);
            if (uid != -1) {
                final UidRecord uidRec = mActiveUids.get(uid);
                if (uidRec != null) {
                    uidRec.updateHasInternetPermission();
                }
            }
        }
    }
    // Add to the sticky list if requested.
    if (sticky) {
        if (checkPermission(android.Manifest.permission.BROADCAST_STICKY, callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid=" + callingUid + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        if (requiredPermissions != null && requiredPermissions.length > 0) {
            Slog.w(TAG, "Can't broadcast sticky intent " + intent + " and enforce permissions " + Arrays.toString(requiredPermissions));
            return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
        }
        if (intent.getComponent() != null) {
            throw new SecurityException("Sticky broadcasts can't target a specific component");
        }
        // as a separate set of sticky broadcasts.
        if (userId != UserHandle.USER_ALL) {
            // But first, if this is not a broadcast to all users, then
            // make sure it doesn't conflict with an existing broadcast to
            // all users.
            ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(UserHandle.USER_ALL);
            if (stickies != null) {
                ArrayList<Intent> list = stickies.get(intent.getAction());
                if (list != null) {
                    int N = list.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        if (intent.filterEquals(list.get(i))) {
                            throw new IllegalArgumentException("Sticky broadcast " + intent + " for user " + userId + " conflicts with existing global broadcast");
                        }
                    }
                }
            }
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies == null) {
            stickies = new ArrayMap<>();
            mStickyBroadcasts.put(userId, stickies);
        }
        ArrayList<Intent> list = stickies.get(intent.getAction());
        if (list == null) {
            list = new ArrayList<>();
            stickies.put(intent.getAction(), list);
        }
        final int stickiesCount = list.size();
        int i;
        for (i = 0; i < stickiesCount; i++) {
            if (intent.filterEquals(list.get(i))) {
                // This sticky already exists, replace it.
                list.set(i, new Intent(intent));
                break;
            }
        }
        if (i >= stickiesCount) {
            list.add(new Intent(intent));
        }
    }
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        // Caller wants broadcast to go to all started users.
        users = mUserController.getStartedUserArray();
    } else {
        // Caller wants broadcast to go to one specific user.
        users = new int[] { userId };
    }
    // Figure out who all will receive this broadcast.
    List receivers = null;
    List<BroadcastFilter> registeredReceivers = null;
    // Need to resolve the intent to interested receivers...
    if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
    }
    if (intent.getComponent() == null) {
        if (userId == UserHandle.USER_ALL && callingUid == SHELL_UID) {
            // Query one target user at a time, excluding shell-restricted users
            for (int i = 0; i < users.length; i++) {
                if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) {
                    continue;
                }
                List<BroadcastFilter> registeredReceiversForUser = mReceiverResolver.queryIntent(intent, resolvedType, false, /*defaultOnly*/
                users[i]);
                if (registeredReceivers == null) {
                    registeredReceivers = registeredReceiversForUser;
                } else if (registeredReceiversForUser != null) {
                    registeredReceivers.addAll(registeredReceiversForUser);
                }
            }
        } else {
            registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false, /*defaultOnly*/
            userId);
        }
    }
    final boolean replacePending = (intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Enqueueing broadcast: " + intent.getAction() + " replacePending=" + replacePending);
    int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
    if (!ordered && NR > 0) {
        // components to be launched.
        if (isCallerSystem) {
            checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid, isProtectedBroadcast, registeredReceivers);
        }
        final BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, callerInstantApp, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r);
        final boolean replaced = replacePending && (queue.replaceParallelBroadcastLocked(r) != null);
        // Note: We assume resultTo is null for non-ordered broadcasts.
        if (!replaced) {
            queue.enqueueParallelBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
        registeredReceivers = null;
        NR = 0;
    }
    // Merge into one list.
    int ir = 0;
    if (receivers != null) {
        // A special case for PACKAGE_ADDED: do not allow the package
        // being added to see this broadcast.  This prevents them from
        // using this as a back door to get run as soon as they are
        // installed.  Maybe in the future we want to have a special install
        // broadcast or such for apps, but we'd like to deliberately make
        // this decision.
        String[] skipPackages = null;
        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
            Uri data = intent.getData();
            if (data != null) {
                String pkgName = data.getSchemeSpecificPart();
                if (pkgName != null) {
                    skipPackages = new String[] { pkgName };
                }
            }
        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
        }
        if (skipPackages != null && (skipPackages.length > 0)) {
            for (String skipPackage : skipPackages) {
                if (skipPackage != null) {
                    int NT = receivers.size();
                    for (int it = 0; it < NT; it++) {
                        ResolveInfo curt = (ResolveInfo) receivers.get(it);
                        if (curt.activityInfo.packageName.equals(skipPackage)) {
                            receivers.remove(it);
                            it--;
                            NT--;
                        }
                    }
                }
            }
        }
        int NT = receivers != null ? receivers.size() : 0;
        int it = 0;
        ResolveInfo curt = null;
        BroadcastFilter curr = null;
        while (it < NT && ir < NR) {
            if (curt == null) {
                curt = (ResolveInfo) receivers.get(it);
            }
            if (curr == null) {
                curr = registeredReceivers.get(ir);
            }
            if (curr.getPriority() >= curt.priority) {
                // Insert this broadcast record into the final list.
                receivers.add(it, curr);
                ir++;
                curr = null;
                it++;
                NT++;
            } else {
                // Skip to the next ResolveInfo in the final list.
                it++;
                curt = null;
            }
        }
    }
    while (ir < NR) {
        if (receivers == null) {
            receivers = new ArrayList();
        }
        receivers.add(registeredReceivers.get(ir));
        ir++;
    }
    if (isCallerSystem) {
        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid, isProtectedBroadcast, receivers);
    }
    if ((receivers != null && receivers.size() > 0) || resultTo != null) {
        BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, callerInstantApp, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size());
        if (DEBUG_BROADCAST)
            Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction());
        final BroadcastRecord oldRecord = replacePending ? queue.replaceOrderedBroadcastLocked(r) : null;
        if (oldRecord != null) {
            // Replaced, fire the result-to receiver.
            if (oldRecord.resultTo != null) {
                final BroadcastQueue oldQueue = broadcastQueueForIntent(oldRecord.intent);
                try {
                    oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo, oldRecord.intent, Activity.RESULT_CANCELED, null, null, false, false, oldRecord.userId);
                } catch (RemoteException e) {
                    Slog.w(TAG, "Failure [" + queue.mQueueName + "] sending broadcast result of " + intent, e);
                }
            }
        } else {
            queue.enqueueOrderedBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
    } else {
        // that it happened.
        if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
            // This was an implicit broadcast... let's record it for posterity.
            addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0);
        }
    }
    return ActivityManager.BROADCAST_SUCCESS;
}
#end_block

#method_before
private final boolean computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
    if (mAdjSeq == app.adjSeq) {
        if (app.adjSeq == app.completedAdjSeq) {
            // This adjustment has already been computed successfully.
            return false;
        } else {
            // The process is being computed, so there is a cycle. We cannot
            // rely on this process's state.
            app.containsCycle = true;
            return false;
        }
    }
    if (app.thread == null) {
        app.adjSeq = mAdjSeq;
        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ;
        app.completedAdjSeq = app.adjSeq;
        return false;
    }
    app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
    app.adjSource = null;
    app.adjTarget = null;
    app.empty = false;
    app.cached = false;
    final int activitiesSize = app.activities.size();
    final int appUid = app.info.uid;
    final int logUid = mCurOomAdjUid;
    int prevAppAdj = app.curAdj;
    int prevProcState = app.curProcState;
    if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
        // below foreground, so it is not worth doing work for it.
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making fixed: " + app);
        }
        app.adjType = "fixed";
        app.adjSeq = mAdjSeq;
        app.curRawAdj = app.maxAdj;
        app.foregroundActivities = false;
        app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;
        // System processes can do UI, and when they do we want to have
        // them trim their memory after the user leaves the UI.  To
        // facilitate this, here we need to determine whether or not it
        // is currently showing UI.
        app.systemNoUi = true;
        if (app == TOP_APP) {
            app.systemNoUi = false;
            app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            app.adjType = "pers-top-activity";
        } else if (app.hasTopUi) {
            // sched group/proc state adjustment is below
            app.systemNoUi = false;
            app.adjType = "pers-top-ui";
        } else if (activitiesSize > 0) {
            for (int j = 0; j < activitiesSize; j++) {
                final ActivityRecord r = app.activities.get(j);
                if (r.visible) {
                    app.systemNoUi = false;
                }
            }
        }
        if (!app.systemNoUi) {
            if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE) {
                // screen on, promote UI
                app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;
                app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            } else {
                // screen off, restrict UI scheduling
                app.curProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                app.curSchedGroup = ProcessList.SCHED_GROUP_RESTRICTED;
            }
        }
        app.curAdj = app.maxAdj;
        app.completedAdjSeq = app.adjSeq;
        // if curAdj is less than prevAppAdj, then this process was promoted
        return app.curAdj < prevAppAdj;
    }
    app.systemNoUi = false;
    final int PROCESS_STATE_CUR_TOP = mTopProcessState;
    // Determine the importance of the process, starting with most
    // important to least, and assign an appropriate OOM adjustment.
    int adj;
    int schedGroup;
    int procState;
    int cachedAdjSeq;
    boolean foregroundActivities = false;
    mTmpBroadcastQueue.clear();
    if (PROCESS_STATE_CUR_TOP == ActivityManager.PROCESS_STATE_TOP && app == TOP_APP) {
        // The last app on the list is the foreground app.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
        app.adjType = "top-activity";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making top: " + app);
        }
    } else if (app.runningRemoteAnimation) {
        adj = ProcessList.VISIBLE_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
        app.adjType = "running-remote-anim";
        procState = PROCESS_STATE_CUR_TOP;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making running remote anim: " + app);
        }
    } else if (app.instr != null) {
        // Don't want to kill running instrumentation.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.adjType = "instrumentation";
        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making instrumentation: " + app);
        }
    } else if (isReceivingBroadcastLocked(app, mTmpBroadcastQueue)) {
        // An app that is currently receiving a broadcast also
        // counts as being in the foreground for OOM killer purposes.
        // It's placed in a sched group based on the nature of the
        // broadcast as reflected by which queue it's active in.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = (mTmpBroadcastQueue.contains(mFgBroadcastQueue)) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "broadcast";
        procState = ActivityManager.PROCESS_STATE_RECEIVER;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making broadcast: " + app);
        }
    } else if (app.executingServices.size() > 0) {
        // An app that is currently executing a service callback also
        // counts as being in the foreground.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "exec-service";
        procState = ActivityManager.PROCESS_STATE_SERVICE;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making exec-service: " + app);
        }
    // Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
    } else if (app == TOP_APP) {
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "top-sleeping";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making top (sleeping): " + app);
        }
    } else {
        // As far as we know the process is empty.  We may change our mind later.
        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        // At this point we don't actually know the adjustment.  Use the cached adj
        // value that the caller wants us to.
        adj = cachedAdj;
        procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.cached = true;
        app.empty = true;
        app.adjType = "cch-empty";
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making empty: " + app);
        }
    }
    // Examine all activities if not already foreground.
    if (!foregroundActivities && activitiesSize > 0) {
        int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;
        for (int j = 0; j < activitiesSize; j++) {
            final ActivityRecord r = app.activities.get(j);
            if (r.app != app) {
                Log.e(TAG, "Found activity " + r + " in proc activity list using " + r.app + " instead of expected " + app);
                if (r.app == null || (r.app.uid == app.uid)) {
                    // Only fix things up when they look sane
                    r.setProcess(app);
                } else {
                    continue;
                }
            }
            if (r.visible) {
                // App has a visible activity; only upgrade adjustment.
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                    adj = ProcessList.VISIBLE_APP_ADJ;
                    app.adjType = "vis-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to vis-activity: " + app);
                    }
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                    app.adjType = "vis-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to vis-activity (top): " + app);
                    }
                }
                if (schedGroup < ProcessList.SCHED_GROUP_DEFAULT) {
                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
                final TaskRecord task = r.getTask();
                if (task != null && minLayer > 0) {
                    final int layer = task.mLayerRank;
                    if (layer >= 0 && minLayer > layer) {
                        minLayer = layer;
                    }
                }
                break;
            } else if (r.isState(ActivityState.PAUSING, ActivityState.PAUSED)) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "pause-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to pause-activity: " + app);
                    }
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                    app.adjType = "pause-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to pause-activity (top): " + app);
                    }
                }
                if (schedGroup < ProcessList.SCHED_GROUP_DEFAULT) {
                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else if (r.isState(ActivityState.STOPPING)) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "stop-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to stop-activity: " + app);
                    }
                }
                // processes and they should soon all go into the cached state.
                if (!r.finishing) {
                    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
                        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
                        app.adjType = "stop-activity";
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to stop-activity: " + app);
                        }
                    }
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                    procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
                    app.adjType = "cch-act";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to cached activity: " + app);
                    }
                }
            }
        }
        if (adj == ProcessList.VISIBLE_APP_ADJ) {
            adj += minLayer;
        }
    }
    if (procState > ActivityManager.PROCESS_STATE_CACHED_RECENT && app.recentTasks.size() > 0) {
        procState = ActivityManager.PROCESS_STATE_CACHED_RECENT;
        app.adjType = "cch-rec";
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to cached recent: " + app);
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
        if (app.foregroundServices) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
            app.cached = false;
            app.adjType = "fg-service";
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to fg service: " + app);
            }
        } else if (app.hasOverlayUi) {
            // The process is display an overlay UI.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            app.cached = false;
            app.adjType = "has-overlay-ui";
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to overlay ui: " + app);
            }
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
        if (app.forcingToImportant != null) {
            // This is currently used for toasts...  they are not interactive, and
            // we don't want them to cause the app to become fully foreground (and
            // thus out of background check), so we yes the best background level we can.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
            app.cached = false;
            app.adjType = "force-imp";
            app.adjSource = app.forcingToImportant;
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to force imp: " + app);
            }
        }
    }
    if (app == mHeavyWeightProcess) {
        if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
            // We don't want to kill the current heavy-weight process.
            adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "heavy";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to heavy: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
            procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
            app.adjType = "heavy";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to heavy: " + app);
            }
        }
    }
    if (app == mHomeProcess) {
        if (adj > ProcessList.HOME_APP_ADJ) {
            // This process is hosting what we currently consider to be the
            // home app, so we don't want to let it go into the background.
            adj = ProcessList.HOME_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "home";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to home: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_HOME) {
            procState = ActivityManager.PROCESS_STATE_HOME;
            app.adjType = "home";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to home: " + app);
            }
        }
    }
    if (app == mPreviousProcess && app.activities.size() > 0) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            // This was the previous process that showed UI to the user.
            // We want to try to keep it around more aggressively, to give
            // a good experience around switching between two apps.
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "previous";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to prev: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
            app.adjType = "previous";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to prev: " + app);
            }
        }
    }
    if (false)
        Slog.i(TAG, "OOM " + app + ": initial adj=" + adj + " reason=" + app.adjType);
    // By default, we use the computed adjustment.  It may be changed if
    // there are applications dependent on our services or providers, but
    // this gives us a baseline and makes sure we don't get into an
    // infinite recursion.
    app.curRawAdj = adj;
    app.hasStartedServices = false;
    app.adjSeq = mAdjSeq;
    if (mBackupTarget != null && app == mBackupTarget.app) {
        // If possible we want to avoid killing apps while they're being backed up
        if (adj > ProcessList.BACKUP_APP_ADJ) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
            adj = ProcessList.BACKUP_APP_ADJ;
            if (procState > ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
                procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
            }
            app.adjType = "backup";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to backup: " + app);
            }
            app.cached = false;
        }
        if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
            procState = ActivityManager.PROCESS_STATE_BACKUP;
            app.adjType = "backup";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to backup: " + app);
            }
        }
    }
    boolean mayBeTop = false;
    String mayBeTopType = null;
    Object mayBeTopSource = null;
    Object mayBeTopTarget = null;
    for (int is = app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
        ServiceRecord s = app.services.valueAt(is);
        if (s.startRequested) {
            app.hasStartedServices = true;
            if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
                procState = ActivityManager.PROCESS_STATE_SERVICE;
                app.adjType = "started-services";
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to started service: " + app);
                }
            }
            if (app.hasShownUi && app != mHomeProcess) {
                // debug and understand what is going on.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-ui-services";
                }
            } else {
                if (now < (s.lastActivity + mConstants.MAX_SERVICE_INACTIVITY)) {
                    // of the background processes.
                    if (adj > ProcessList.SERVICE_ADJ) {
                        adj = ProcessList.SERVICE_ADJ;
                        app.adjType = "started-services";
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to started service: " + app);
                        }
                        app.cached = false;
                    }
                }
                // even though the service no longer has an impact.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-services";
                }
            }
        }
        for (int conni = s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
            ArrayList<ConnectionRecord> clist = s.connections.valueAt(conni);
            for (int i = 0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
                // XXX should compute this based on the max of
                // all connected clients.
                ConnectionRecord cr = clist.get(i);
                if (cr.binding.client == app) {
                    // Binding to ourself is not interesting.
                    continue;
                }
                if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
                    ProcessRecord client = cr.binding.client;
                    computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    if (client.containsCycle) {
                        // We've detected a cycle. We should retry computeOomAdjLocked later in
                        // case a later-checked connection from a client  would raise its
                        // priority legitimately.
                        app.containsCycle = true;
                        // better state in the next iteration.
                        if (client.completedAdjSeq < mAdjSeq) {
                            continue;
                        }
                    }
                    int clientAdj = client.curRawAdj;
                    int clientProcState = client.curProcState;
                    if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                        // If the other app is cached for any reason, for purposes here
                        // we are going to consider it empty.  The specific cached state
                        // doesn't propagate except under certain conditions.
                        clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    }
                    String adjType = null;
                    if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
                        // this guy more like a started service.
                        if (app.hasShownUi && app != mHomeProcess) {
                            // debug and understand what is going on.
                            if (adj > clientAdj) {
                                adjType = "cch-bound-ui-services";
                            }
                            app.cached = false;
                            clientAdj = adj;
                            clientProcState = procState;
                        } else {
                            if (now >= (s.lastActivity + mConstants.MAX_SERVICE_INACTIVITY)) {
                                // to help debug and undertand what is going on.
                                if (adj > clientAdj) {
                                    adjType = "cch-bound-services";
                                }
                                clientAdj = adj;
                            }
                        }
                    }
                    if (adj > clientAdj) {
                        // memory.
                        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                            if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
                                adjType = "cch-bound-ui-services";
                            }
                        } else {
                            int newAdj;
                            if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                                if (clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ) {
                                    newAdj = clientAdj;
                                } else {
                                    // make this service persistent
                                    newAdj = ProcessList.PERSISTENT_SERVICE_ADJ;
                                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                                    procState = ActivityManager.PROCESS_STATE_PERSISTENT;
                                }
                            } else if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                                newAdj = ProcessList.PERCEPTIBLE_APP_ADJ;
                            } else if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                                newAdj = clientAdj;
                            } else {
                                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                                    newAdj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);
                                } else {
                                    newAdj = adj;
                                }
                            }
                            if (!client.cached) {
                                app.cached = false;
                            }
                            if (adj > newAdj) {
                                adj = newAdj;
                                adjType = "service";
                            }
                        }
                    }
                    if ((cr.flags & (Context.BIND_NOT_FOREGROUND | Context.BIND_IMPORTANT_BACKGROUND)) == 0) {
                        // foreground work.
                        if (client.curSchedGroup > schedGroup) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = client.curSchedGroup;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                            if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                                // Special handling of clients who are in the top state.
                                // We *may* want to consider this process to be in the
                                // top state as well, but only if there is not another
                                // reason for it to be running.  Being on the top is a
                                // special state, meaning you are specifically running
                                // for the current top app.  If the process is already
                                // running in the background for some other reason, it
                                // is more important to continue considering it to be
                                // in the background state.
                                mayBeTop = true;
                                mayBeTopType = "service";
                                mayBeTopSource = cr.binding.client;
                                mayBeTopTarget = s.name;
                                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                            } else {
                                // give them the best state after that.
                                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else {
                                    clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                                }
                            }
                        }
                    } else if ((cr.flags & Context.BIND_IMPORTANT_BACKGROUND) == 0) {
                        if (clientProcState < ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
                        }
                    } else {
                        if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                        if (adjType == null) {
                            adjType = "service";
                        }
                    }
                    if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
                        app.pendingUiClean = true;
                    }
                    if (adjType != null) {
                        app.adjType = adjType;
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = cr.binding.client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = s.name;
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to " + adjType + ": " + app + ", due to " + cr.binding.client + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                        }
                    }
                }
                if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                    app.treatLikeActivity = true;
                }
                final ActivityRecord a = cr.activity;
                if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
                    if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.isState(ActivityState.RESUMED, ActivityState.PAUSING))) {
                        adj = ProcessList.FOREGROUND_APP_ADJ;
                        if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        app.cached = false;
                        app.adjType = "service";
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = a;
                        app.adjSourceProcState = procState;
                        app.adjTarget = s.name;
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to service w/activity: " + app);
                        }
                    }
                }
            }
        }
    }
    for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(provi);
        for (int i = cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
            ContentProviderConnection conn = cpr.connections.get(i);
            ProcessRecord client = conn.client;
            if (client == app) {
                // Being our own client is not interesting.
                continue;
            }
            computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
            if (client.containsCycle) {
                // We've detected a cycle. We should retry computeOomAdjLocked later in
                // case a later-checked connection from a client  would raise its
                // priority legitimately.
                app.containsCycle = true;
                // better state in the next iteration.
                if (client.completedAdjSeq < mAdjSeq) {
                    continue;
                }
            }
            int clientAdj = client.curRawAdj;
            int clientProcState = client.curProcState;
            if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                // If the other app is cached for any reason, for purposes here
                // we are going to consider it empty.
                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
            }
            String adjType = null;
            if (adj > clientAdj) {
                if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adjType = "cch-ui-provider";
                } else {
                    adj = clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
                    adjType = "provider";
                }
                app.cached &= client.cached;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                    // Special handling of clients who are in the top state.
                    // We *may* want to consider this process to be in the
                    // top state as well, but only if there is not another
                    // reason for it to be running.  Being on the top is a
                    // special state, meaning you are specifically running
                    // for the current top app.  If the process is already
                    // running in the background for some other reason, it
                    // is more important to continue considering it to be
                    // in the background state.
                    mayBeTop = true;
                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    mayBeTopType = adjType = "provider-top";
                    mayBeTopSource = client;
                    mayBeTopTarget = cpr.name;
                } else {
                    // Special handling for above-top states (persistent
                    // processes).  These should not bring the current process
                    // into the top state, since they are not on top.  Instead
                    // give them the best state after that.
                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                    if (adjType == null) {
                        adjType = "provider";
                    }
                }
            }
            if (procState > clientProcState) {
                procState = clientProcState;
            }
            if (client.curSchedGroup > schedGroup) {
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            }
            if (adjType != null) {
                app.adjType = adjType;
                app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
                app.adjSource = client;
                app.adjSourceProcState = clientProcState;
                app.adjTarget = cpr.name;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to " + adjType + ": " + app + ", due to " + client + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                }
            }
        }
        // FOREGROUND_APP_ADJ.
        if (cpr.hasExternalProcessHandles()) {
            if (adj > ProcessList.FOREGROUND_APP_ADJ) {
                adj = ProcessList.FOREGROUND_APP_ADJ;
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.adjType = "ext-provider";
                app.adjTarget = cpr.name;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to external provider: " + app);
                }
            }
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to external provider: " + app);
            }
        }
    }
    if (app.lastProviderTime > 0 && (app.lastProviderTime + mConstants.CONTENT_PROVIDER_RETAIN_TIME) > now) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "recent-provider";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to recent provider: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
            app.adjType = "recent-provider";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to recent provider: " + app);
            }
        }
    }
    if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
        // to the top state.
        switch(procState) {
            case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
            case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
                // Something else is keeping it at this level, just leave it.
                break;
            case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
            case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_SERVICE:
                // These all are longer-term states, so pull them up to the top
                // of the background states, but not all the way to the top state.
                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                app.adjType = mayBeTopType;
                app.adjSource = mayBeTopSource;
                app.adjTarget = mayBeTopTarget;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "May be top raise to " + mayBeTopType + ": " + app + ", due to " + mayBeTopSource + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                }
                break;
            default:
                // Otherwise, top is a better choice, so take it.
                procState = ActivityManager.PROCESS_STATE_TOP;
                app.adjType = mayBeTopType;
                app.adjSource = mayBeTopSource;
                app.adjTarget = mayBeTopTarget;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "May be top raise to " + mayBeTopType + ": " + app + ", due to " + mayBeTopSource + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                }
                break;
        }
    }
    if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
        if (app.hasClientActivities) {
            // This is a cached process, but with client activities.  Mark it so.
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
            app.adjType = "cch-client-act";
        } else if (app.treatLikeActivity) {
            // This is a cached process, but somebody wants us to treat it like it has
            // an activity, okay!
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
            app.adjType = "cch-as-act";
        }
    }
    if (adj == ProcessList.SERVICE_ADJ) {
        if (doingAll) {
            app.serviceb = mNewNumAServiceProcs > (mNumServiceProcs / 3);
            mNewNumServiceProcs++;
            // Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
            if (!app.serviceb) {
                // keep launcher over it.
                if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                // Slog.i(TAG, "ADJ " + app + " high ram!");
                } else {
                    mNewNumAServiceProcs++;
                // Slog.i(TAG, "ADJ " + app + " not high ram!");
                }
            } else {
                app.serviceHighRam = false;
            }
        }
        if (app.serviceb) {
            adj = ProcessList.SERVICE_B_ADJ;
        }
    }
    app.curRawAdj = adj;
    // " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);
    if (adj > app.maxAdj) {
        adj = app.maxAdj;
        if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    // restrictions on screen off
    if (procState >= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE && mWakefulness != PowerManagerInternal.WAKEFULNESS_AWAKE) {
        if (schedGroup > ProcessList.SCHED_GROUP_RESTRICTED) {
            schedGroup = ProcessList.SCHED_GROUP_RESTRICTED;
        }
    }
    // Do final modification to adj.  Everything we do between here and applying
    // the final setAdj must be done in this function, because we will also use
    // it when computing the final cached adj later.  Note that we don't need to
    // worry about this for max adj above, since max adj will always be used to
    // keep it out of the cached vaues.
    app.curAdj = app.modifyRawOomAdj(adj);
    app.curSchedGroup = schedGroup;
    app.curProcState = procState;
    app.foregroundActivities = foregroundActivities;
    app.completedAdjSeq = mAdjSeq;
    // if curAdj or curProcState improved, then this process was promoted
    return app.curAdj < prevAppAdj || app.curProcState < prevProcState;
}
#method_after
private final boolean computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
    if (mAdjSeq == app.adjSeq) {
        if (app.adjSeq == app.completedAdjSeq) {
            // This adjustment has already been computed successfully.
            return false;
        } else {
            // The process is being computed, so there is a cycle. We cannot
            // rely on this process's state.
            app.containsCycle = true;
            return false;
        }
    }
    if (app.thread == null) {
        app.adjSeq = mAdjSeq;
        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ;
        app.completedAdjSeq = app.adjSeq;
        return false;
    }
    app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
    app.adjSource = null;
    app.adjTarget = null;
    app.empty = false;
    app.cached = false;
    final int activitiesSize = app.activities.size();
    final int appUid = app.info.uid;
    final int logUid = mCurOomAdjUid;
    int prevAppAdj = app.curAdj;
    int prevProcState = app.curProcState;
    if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
        // below foreground, so it is not worth doing work for it.
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making fixed: " + app);
        }
        app.adjType = "fixed";
        app.adjSeq = mAdjSeq;
        app.curRawAdj = app.maxAdj;
        app.foregroundActivities = false;
        app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;
        // System processes can do UI, and when they do we want to have
        // them trim their memory after the user leaves the UI.  To
        // facilitate this, here we need to determine whether or not it
        // is currently showing UI.
        app.systemNoUi = true;
        if (app == TOP_APP) {
            app.systemNoUi = false;
            app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            app.adjType = "pers-top-activity";
        } else if (app.hasTopUi) {
            // sched group/proc state adjustment is below
            app.systemNoUi = false;
            app.adjType = "pers-top-ui";
        } else if (activitiesSize > 0) {
            for (int j = 0; j < activitiesSize; j++) {
                final ActivityRecord r = app.activities.get(j);
                if (r.visible) {
                    app.systemNoUi = false;
                }
            }
        }
        if (!app.systemNoUi) {
            if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE) {
                // screen on, promote UI
                app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;
                app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            } else {
                // screen off, restrict UI scheduling
                app.curProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                app.curSchedGroup = ProcessList.SCHED_GROUP_RESTRICTED;
            }
        }
        app.curAdj = app.maxAdj;
        app.completedAdjSeq = app.adjSeq;
        // if curAdj is less than prevAppAdj, then this process was promoted
        return app.curAdj < prevAppAdj;
    }
    app.systemNoUi = false;
    final int PROCESS_STATE_CUR_TOP = mTopProcessState;
    // Determine the importance of the process, starting with most
    // important to least, and assign an appropriate OOM adjustment.
    int adj;
    int schedGroup;
    int procState;
    int cachedAdjSeq;
    boolean foregroundActivities = false;
    mTmpBroadcastQueue.clear();
    if (PROCESS_STATE_CUR_TOP == ActivityManager.PROCESS_STATE_TOP && app == TOP_APP) {
        // The last app on the list is the foreground app.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
        app.adjType = "top-activity";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making top: " + app);
        }
    } else if (app.runningRemoteAnimation) {
        adj = ProcessList.VISIBLE_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
        app.adjType = "running-remote-anim";
        procState = PROCESS_STATE_CUR_TOP;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making running remote anim: " + app);
        }
    } else if (app.instr != null) {
        // Don't want to kill running instrumentation.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.adjType = "instrumentation";
        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making instrumentation: " + app);
        }
    } else if (isReceivingBroadcastLocked(app, mTmpBroadcastQueue)) {
        // An app that is currently receiving a broadcast also
        // counts as being in the foreground for OOM killer purposes.
        // It's placed in a sched group based on the nature of the
        // broadcast as reflected by which queue it's active in.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = (mTmpBroadcastQueue.contains(mFgBroadcastQueue)) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "broadcast";
        procState = ActivityManager.PROCESS_STATE_RECEIVER;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making broadcast: " + app);
        }
    } else if (app.executingServices.size() > 0) {
        // An app that is currently executing a service callback also
        // counts as being in the foreground.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "exec-service";
        procState = ActivityManager.PROCESS_STATE_SERVICE;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making exec-service: " + app);
        }
    // Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
    } else if (app == TOP_APP) {
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "top-sleeping";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making top (sleeping): " + app);
        }
    } else {
        // As far as we know the process is empty.  We may change our mind later.
        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        // At this point we don't actually know the adjustment.  Use the cached adj
        // value that the caller wants us to.
        adj = cachedAdj;
        procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.cached = true;
        app.empty = true;
        app.adjType = "cch-empty";
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making empty: " + app);
        }
    }
    // Examine all activities if not already foreground.
    if (!foregroundActivities && activitiesSize > 0) {
        int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;
        for (int j = 0; j < activitiesSize; j++) {
            final ActivityRecord r = app.activities.get(j);
            if (r.app != app) {
                Log.e(TAG, "Found activity " + r + " in proc activity list using " + r.app + " instead of expected " + app);
                if (r.app == null || (r.app.uid == app.uid)) {
                    // Only fix things up when they look sane
                    r.setProcess(app);
                } else {
                    continue;
                }
            }
            if (r.visible) {
                // App has a visible activity; only upgrade adjustment.
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                    adj = ProcessList.VISIBLE_APP_ADJ;
                    app.adjType = "vis-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to vis-activity: " + app);
                    }
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                    app.adjType = "vis-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to vis-activity (top): " + app);
                    }
                }
                if (schedGroup < ProcessList.SCHED_GROUP_DEFAULT) {
                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
                final TaskRecord task = r.getTask();
                if (task != null && minLayer > 0) {
                    final int layer = task.mLayerRank;
                    if (layer >= 0 && minLayer > layer) {
                        minLayer = layer;
                    }
                }
                break;
            } else if (r.isState(ActivityState.PAUSING, ActivityState.PAUSED)) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "pause-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to pause-activity: " + app);
                    }
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                    app.adjType = "pause-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to pause-activity (top): " + app);
                    }
                }
                if (schedGroup < ProcessList.SCHED_GROUP_DEFAULT) {
                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else if (r.isState(ActivityState.STOPPING)) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "stop-activity";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to stop-activity: " + app);
                    }
                }
                // processes and they should soon all go into the cached state.
                if (!r.finishing) {
                    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
                        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
                        app.adjType = "stop-activity";
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to stop-activity: " + app);
                        }
                    }
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                    procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
                    app.adjType = "cch-act";
                    if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                        reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to cached activity: " + app);
                    }
                }
            }
        }
        if (adj == ProcessList.VISIBLE_APP_ADJ) {
            adj += minLayer;
        }
    }
    if (procState > ActivityManager.PROCESS_STATE_CACHED_RECENT && app.recentTasks.size() > 0) {
        procState = ActivityManager.PROCESS_STATE_CACHED_RECENT;
        app.adjType = "cch-rec";
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to cached recent: " + app);
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
        if (app.foregroundServices) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
            app.cached = false;
            app.adjType = "fg-service";
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to fg service: " + app);
            }
        } else if (app.hasOverlayUi) {
            // The process is display an overlay UI.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            app.cached = false;
            app.adjType = "has-overlay-ui";
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to overlay ui: " + app);
            }
        }
    }
    // services so that it can finish performing any persistence/processing of in-memory state.
    if (app.foregroundServices && adj > ProcessList.PERCEPTIBLE_RECENT_FOREGROUND_APP_ADJ && (app.lastTopTime + mConstants.TOP_TO_FGS_GRACE_DURATION > now || app.setProcState <= ActivityManager.PROCESS_STATE_TOP)) {
        adj = ProcessList.PERCEPTIBLE_RECENT_FOREGROUND_APP_ADJ;
        app.adjType = "fg-service-act";
        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to recent fg: " + app);
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
        if (app.forcingToImportant != null) {
            // This is currently used for toasts...  they are not interactive, and
            // we don't want them to cause the app to become fully foreground (and
            // thus out of background check), so we yes the best background level we can.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
            app.cached = false;
            app.adjType = "force-imp";
            app.adjSource = app.forcingToImportant;
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to force imp: " + app);
            }
        }
    }
    if (app == mHeavyWeightProcess) {
        if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
            // We don't want to kill the current heavy-weight process.
            adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "heavy";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to heavy: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
            procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
            app.adjType = "heavy";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to heavy: " + app);
            }
        }
    }
    if (app == mHomeProcess) {
        if (adj > ProcessList.HOME_APP_ADJ) {
            // This process is hosting what we currently consider to be the
            // home app, so we don't want to let it go into the background.
            adj = ProcessList.HOME_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "home";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to home: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_HOME) {
            procState = ActivityManager.PROCESS_STATE_HOME;
            app.adjType = "home";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to home: " + app);
            }
        }
    }
    if (app == mPreviousProcess && app.activities.size() > 0) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            // This was the previous process that showed UI to the user.
            // We want to try to keep it around more aggressively, to give
            // a good experience around switching between two apps.
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "previous";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to prev: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
            app.adjType = "previous";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to prev: " + app);
            }
        }
    }
    if (false)
        Slog.i(TAG, "OOM " + app + ": initial adj=" + adj + " reason=" + app.adjType);
    // By default, we use the computed adjustment.  It may be changed if
    // there are applications dependent on our services or providers, but
    // this gives us a baseline and makes sure we don't get into an
    // infinite recursion.
    app.curRawAdj = adj;
    app.hasStartedServices = false;
    app.adjSeq = mAdjSeq;
    if (mBackupTarget != null && app == mBackupTarget.app) {
        // If possible we want to avoid killing apps while they're being backed up
        if (adj > ProcessList.BACKUP_APP_ADJ) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
            adj = ProcessList.BACKUP_APP_ADJ;
            if (procState > ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
                procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
            }
            app.adjType = "backup";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to backup: " + app);
            }
            app.cached = false;
        }
        if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
            procState = ActivityManager.PROCESS_STATE_BACKUP;
            app.adjType = "backup";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to backup: " + app);
            }
        }
    }
    boolean mayBeTop = false;
    String mayBeTopType = null;
    Object mayBeTopSource = null;
    Object mayBeTopTarget = null;
    for (int is = app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
        ServiceRecord s = app.services.valueAt(is);
        if (s.startRequested) {
            app.hasStartedServices = true;
            if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
                procState = ActivityManager.PROCESS_STATE_SERVICE;
                app.adjType = "started-services";
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to started service: " + app);
                }
            }
            if (app.hasShownUi && app != mHomeProcess) {
                // debug and understand what is going on.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-ui-services";
                }
            } else {
                if (now < (s.lastActivity + mConstants.MAX_SERVICE_INACTIVITY)) {
                    // of the background processes.
                    if (adj > ProcessList.SERVICE_ADJ) {
                        adj = ProcessList.SERVICE_ADJ;
                        app.adjType = "started-services";
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to started service: " + app);
                        }
                        app.cached = false;
                    }
                }
                // even though the service no longer has an impact.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-services";
                }
            }
        }
        for (int conni = s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
            ArrayList<ConnectionRecord> clist = s.connections.valueAt(conni);
            for (int i = 0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
                // XXX should compute this based on the max of
                // all connected clients.
                ConnectionRecord cr = clist.get(i);
                if (cr.binding.client == app) {
                    // Binding to ourself is not interesting.
                    continue;
                }
                if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
                    ProcessRecord client = cr.binding.client;
                    computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    if (client.containsCycle) {
                        // We've detected a cycle. We should retry computeOomAdjLocked later in
                        // case a later-checked connection from a client  would raise its
                        // priority legitimately.
                        app.containsCycle = true;
                        // better state in the next iteration.
                        if (client.completedAdjSeq < mAdjSeq) {
                            continue;
                        }
                    }
                    int clientAdj = client.curRawAdj;
                    int clientProcState = client.curProcState;
                    if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                        // If the other app is cached for any reason, for purposes here
                        // we are going to consider it empty.  The specific cached state
                        // doesn't propagate except under certain conditions.
                        clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    }
                    String adjType = null;
                    if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
                        // this guy more like a started service.
                        if (app.hasShownUi && app != mHomeProcess) {
                            // debug and understand what is going on.
                            if (adj > clientAdj) {
                                adjType = "cch-bound-ui-services";
                            }
                            app.cached = false;
                            clientAdj = adj;
                            clientProcState = procState;
                        } else {
                            if (now >= (s.lastActivity + mConstants.MAX_SERVICE_INACTIVITY)) {
                                // to help debug and undertand what is going on.
                                if (adj > clientAdj) {
                                    adjType = "cch-bound-services";
                                }
                                clientAdj = adj;
                            }
                        }
                    }
                    if (adj > clientAdj) {
                        // memory.
                        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                            if (adj >= ProcessList.CACHED_APP_MIN_ADJ) {
                                adjType = "cch-bound-ui-services";
                            }
                        } else {
                            int newAdj;
                            if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                                if (clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ) {
                                    newAdj = clientAdj;
                                } else {
                                    // make this service persistent
                                    newAdj = ProcessList.PERSISTENT_SERVICE_ADJ;
                                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                                    procState = ActivityManager.PROCESS_STATE_PERSISTENT;
                                }
                            } else if ((cr.flags & Context.BIND_ADJUST_BELOW_PERCEPTIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ + 1) {
                                newAdj = ProcessList.PERCEPTIBLE_APP_ADJ + 1;
                            } else if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                                newAdj = ProcessList.PERCEPTIBLE_APP_ADJ;
                            } else if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                                newAdj = clientAdj;
                            } else {
                                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                                    newAdj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);
                                } else {
                                    newAdj = adj;
                                }
                            }
                            if (!client.cached) {
                                app.cached = false;
                            }
                            if (adj > newAdj) {
                                adj = newAdj;
                                adjType = "service";
                            }
                        }
                    }
                    if ((cr.flags & (Context.BIND_NOT_FOREGROUND | Context.BIND_IMPORTANT_BACKGROUND)) == 0) {
                        // foreground work.
                        if (client.curSchedGroup > schedGroup) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = client.curSchedGroup;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                            if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                                // Special handling of clients who are in the top state.
                                // We *may* want to consider this process to be in the
                                // top state as well, but only if there is not another
                                // reason for it to be running.  Being on the top is a
                                // special state, meaning you are specifically running
                                // for the current top app.  If the process is already
                                // running in the background for some other reason, it
                                // is more important to continue considering it to be
                                // in the background state.
                                mayBeTop = true;
                                mayBeTopType = "service";
                                mayBeTopSource = cr.binding.client;
                                mayBeTopTarget = s.name;
                                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                            } else {
                                // give them the best state after that.
                                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else {
                                    clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                                }
                            }
                        }
                    } else if ((cr.flags & Context.BIND_IMPORTANT_BACKGROUND) == 0) {
                        if (clientProcState < ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;
                        }
                    } else {
                        if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                        if (adjType == null) {
                            adjType = "service";
                        }
                    }
                    if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
                        app.pendingUiClean = true;
                    }
                    if (adjType != null) {
                        app.adjType = adjType;
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = cr.binding.client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = s.name;
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to " + adjType + ": " + app + ", due to " + cr.binding.client + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                        }
                    }
                }
                if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                    app.treatLikeActivity = true;
                }
                final ActivityRecord a = cr.activity;
                if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
                    if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.isState(ActivityState.RESUMED, ActivityState.PAUSING))) {
                        adj = ProcessList.FOREGROUND_APP_ADJ;
                        if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        app.cached = false;
                        app.adjType = "service";
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = a;
                        app.adjSourceProcState = procState;
                        app.adjTarget = s.name;
                        if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                            reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to service w/activity: " + app);
                        }
                    }
                }
            }
        }
    }
    for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(provi);
        for (int i = cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
            ContentProviderConnection conn = cpr.connections.get(i);
            ProcessRecord client = conn.client;
            if (client == app) {
                // Being our own client is not interesting.
                continue;
            }
            computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
            if (client.containsCycle) {
                // We've detected a cycle. We should retry computeOomAdjLocked later in
                // case a later-checked connection from a client  would raise its
                // priority legitimately.
                app.containsCycle = true;
                // better state in the next iteration.
                if (client.completedAdjSeq < mAdjSeq) {
                    continue;
                }
            }
            int clientAdj = client.curRawAdj;
            int clientProcState = client.curProcState;
            if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                // If the other app is cached for any reason, for purposes here
                // we are going to consider it empty.
                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
            }
            String adjType = null;
            if (adj > clientAdj) {
                if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adjType = "cch-ui-provider";
                } else {
                    adj = clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
                    adjType = "provider";
                }
                app.cached &= client.cached;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                    // Special handling of clients who are in the top state.
                    // We *may* want to consider this process to be in the
                    // top state as well, but only if there is not another
                    // reason for it to be running.  Being on the top is a
                    // special state, meaning you are specifically running
                    // for the current top app.  If the process is already
                    // running in the background for some other reason, it
                    // is more important to continue considering it to be
                    // in the background state.
                    mayBeTop = true;
                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    mayBeTopType = adjType = "provider-top";
                    mayBeTopSource = client;
                    mayBeTopTarget = cpr.name;
                } else {
                    // Special handling for above-top states (persistent
                    // processes).  These should not bring the current process
                    // into the top state, since they are not on top.  Instead
                    // give them the best state after that.
                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                    if (adjType == null) {
                        adjType = "provider";
                    }
                }
            }
            if (procState > clientProcState) {
                procState = clientProcState;
            }
            if (client.curSchedGroup > schedGroup) {
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            }
            if (adjType != null) {
                app.adjType = adjType;
                app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
                app.adjSource = client;
                app.adjSourceProcState = clientProcState;
                app.adjTarget = cpr.name;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise to " + adjType + ": " + app + ", due to " + client + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                }
            }
        }
        // FOREGROUND_APP_ADJ.
        if (cpr.hasExternalProcessHandles()) {
            if (adj > ProcessList.FOREGROUND_APP_ADJ) {
                adj = ProcessList.FOREGROUND_APP_ADJ;
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.adjType = "ext-provider";
                app.adjTarget = cpr.name;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to external provider: " + app);
                }
            }
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to external provider: " + app);
            }
        }
    }
    if (app.lastProviderTime > 0 && (app.lastProviderTime + mConstants.CONTENT_PROVIDER_RETAIN_TIME) > now) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "recent-provider";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise adj to recent provider: " + app);
            }
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
            app.adjType = "recent-provider";
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Raise procstate to recent provider: " + app);
            }
        }
    }
    if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
        // to the top state.
        switch(procState) {
            case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
            case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
                // Something else is keeping it at this level, just leave it.
                break;
            case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
            case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_SERVICE:
                // These all are longer-term states, so pull them up to the top
                // of the background states, but not all the way to the top state.
                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                app.adjType = mayBeTopType;
                app.adjSource = mayBeTopSource;
                app.adjTarget = mayBeTopTarget;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "May be top raise to " + mayBeTopType + ": " + app + ", due to " + mayBeTopSource + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                }
                break;
            default:
                // Otherwise, top is a better choice, so take it.
                procState = ActivityManager.PROCESS_STATE_TOP;
                app.adjType = mayBeTopType;
                app.adjSource = mayBeTopSource;
                app.adjTarget = mayBeTopTarget;
                if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                    reportOomAdjMessageLocked(TAG_OOM_ADJ, "May be top raise to " + mayBeTopType + ": " + app + ", due to " + mayBeTopSource + " adj=" + adj + " procState=" + ProcessList.makeProcStateString(procState));
                }
                break;
        }
    }
    if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
        if (app.hasClientActivities) {
            // This is a cached process, but with client activities.  Mark it so.
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
            app.adjType = "cch-client-act";
        } else if (app.treatLikeActivity) {
            // This is a cached process, but somebody wants us to treat it like it has
            // an activity, okay!
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
            app.adjType = "cch-as-act";
        }
    }
    if (adj == ProcessList.SERVICE_ADJ) {
        if (doingAll) {
            app.serviceb = mNewNumAServiceProcs > (mNumServiceProcs / 3);
            mNewNumServiceProcs++;
            // Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
            if (!app.serviceb) {
                // keep launcher over it.
                if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                // Slog.i(TAG, "ADJ " + app + " high ram!");
                } else {
                    mNewNumAServiceProcs++;
                // Slog.i(TAG, "ADJ " + app + " not high ram!");
                }
            } else {
                app.serviceHighRam = false;
            }
        }
        if (app.serviceb) {
            adj = ProcessList.SERVICE_B_ADJ;
        }
    }
    app.curRawAdj = adj;
    // " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);
    if (adj > app.maxAdj) {
        adj = app.maxAdj;
        if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    // restrictions on screen off
    if (procState >= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE && mWakefulness != PowerManagerInternal.WAKEFULNESS_AWAKE) {
        if (schedGroup > ProcessList.SCHED_GROUP_RESTRICTED) {
            schedGroup = ProcessList.SCHED_GROUP_RESTRICTED;
        }
    }
    // Do final modification to adj.  Everything we do between here and applying
    // the final setAdj must be done in this function, because we will also use
    // it when computing the final cached adj later.  Note that we don't need to
    // worry about this for max adj above, since max adj will always be used to
    // keep it out of the cached vaues.
    app.curAdj = app.modifyRawOomAdj(adj);
    app.curSchedGroup = schedGroup;
    app.curProcState = procState;
    app.foregroundActivities = foregroundActivities;
    app.completedAdjSeq = mAdjSeq;
    // if curAdj or curProcState improved, then this process was promoted
    return app.curAdj < prevAppAdj || app.curProcState < prevProcState;
}
#end_block

#method_before
private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
    boolean success = true;
    if (app.curRawAdj != app.setRawAdj) {
        app.setRawAdj = app.curRawAdj;
    }
    int changes = 0;
    if (app.curAdj != app.setAdj) {
        ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.info.uid) {
            String msg = "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType;
            reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
        }
        app.setAdj = app.curAdj;
        app.verifiedAdj = ProcessList.INVALID_ADJ;
    }
    if (app.setSchedGroup != app.curSchedGroup) {
        int oldSchedGroup = app.setSchedGroup;
        app.setSchedGroup = app.curSchedGroup;
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
            String msg = "Setting sched group of " + app.processName + " to " + app.curSchedGroup + ": " + app.adjType;
            reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
        }
        if (app.waitingToKill != null && app.curReceivers.isEmpty() && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
            app.kill(app.waitingToKill, true);
            success = false;
        } else {
            int processGroup;
            switch(app.curSchedGroup) {
                case ProcessList.SCHED_GROUP_BACKGROUND:
                    processGroup = THREAD_GROUP_BG_NONINTERACTIVE;
                    break;
                case ProcessList.SCHED_GROUP_TOP_APP:
                case ProcessList.SCHED_GROUP_TOP_APP_BOUND:
                    processGroup = THREAD_GROUP_TOP_APP;
                    break;
                case ProcessList.SCHED_GROUP_RESTRICTED:
                    processGroup = THREAD_GROUP_RESTRICTED;
                    break;
                default:
                    processGroup = THREAD_GROUP_DEFAULT;
                    break;
            }
            long oldId = Binder.clearCallingIdentity();
            try {
                setProcessGroup(app.pid, processGroup);
                if (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
                    // do nothing if we already switched to RT
                    if (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                        mVrController.onTopProcChangedLocked(app);
                        if (mUseFifoUiScheduling) {
                            // Switch UI pipeline for app to SCHED_FIFO
                            app.savedPriority = Process.getThreadPriority(app.pid);
                            scheduleAsFifoPriority(app.pid, /* suppressLogs */
                            true);
                            if (app.renderThreadTid != 0) {
                                scheduleAsFifoPriority(app.renderThreadTid, /* suppressLogs */
                                true);
                                if (DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Set RenderThread (TID " + app.renderThreadTid + ") to FIFO");
                                }
                            } else {
                                if (DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Not setting RenderThread TID");
                                }
                            }
                        } else {
                            // Boost priority for top app UI and render threads
                            setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
                            if (app.renderThreadTid != 0) {
                                try {
                                    setThreadPriority(app.renderThreadTid, TOP_APP_PRIORITY_BOOST);
                                } catch (IllegalArgumentException e) {
                                // thread died, ignore
                                }
                            }
                        }
                    }
                } else if (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP && app.curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                    mVrController.onTopProcChangedLocked(app);
                    if (mUseFifoUiScheduling) {
                        try {
                            // Reset UI pipeline to SCHED_OTHER
                            setThreadScheduler(app.pid, SCHED_OTHER, 0);
                            setThreadPriority(app.pid, app.savedPriority);
                            if (app.renderThreadTid != 0) {
                                setThreadScheduler(app.renderThreadTid, SCHED_OTHER, 0);
                                setThreadPriority(app.renderThreadTid, -4);
                            }
                        } catch (IllegalArgumentException e) {
                            Slog.w(TAG, "Failed to set scheduling policy, thread does not exist:\n" + e);
                        } catch (SecurityException e) {
                            Slog.w(TAG, "Failed to set scheduling policy, not allowed:\n" + e);
                        }
                    } else {
                        // Reset priority for top app UI and render threads
                        setThreadPriority(app.pid, 0);
                        if (app.renderThreadTid != 0) {
                            setThreadPriority(app.renderThreadTid, 0);
                        }
                    }
                }
            } catch (Exception e) {
                if (false) {
                    Slog.w(TAG, "Failed setting process group of " + app.pid + " to " + app.curSchedGroup);
                    Slog.w(TAG, "at location", e);
                }
            } finally {
                Binder.restoreCallingIdentity(oldId);
            }
        }
    }
    if (app.repForegroundActivities != app.foregroundActivities) {
        app.repForegroundActivities = app.foregroundActivities;
        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
    }
    if (app.repProcState != app.curProcState) {
        app.repProcState = app.curProcState;
        if (app.thread != null) {
            try {
                if (false) {
                    // RuntimeException h = new RuntimeException("here");
                    Slog.i(TAG, "Sending new process state " + app.repProcState + " to " + app);
                }
                app.thread.setProcessState(app.repProcState);
            } catch (RemoteException e) {
            }
        }
    }
    if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
        if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
            // Experimental code to more aggressively collect pss while
            // running test...  the problem is that this tends to collect
            // the data right when a process is transitioning between process
            // states, which will tend to give noisy data.
            long start = SystemClock.uptimeMillis();
            long startTime = SystemClock.currentThreadTimeMillis();
            long pss = Debug.getPss(app.pid, mTmpLong, null);
            long endTime = SystemClock.currentThreadTimeMillis();
            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[0], mTmpLong[1], mTmpLong[2], ProcessStats.ADD_PSS_INTERNAL_SINGLE, endTime - startTime, now);
            mPendingPssProcesses.remove(app);
            Slog.i(TAG, "Recorded pss for " + app + " state " + app.setProcState + " to " + app.curProcState + ": " + (SystemClock.uptimeMillis() - start) + "ms");
        }
        app.lastStateTime = now;
        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, app.procStateMemTracker, mTestPssMode, isSleepingLocked(), now);
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
    } else {
        if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
            if (requestPssLocked(app, app.setProcState)) {
                app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, app.procStateMemTracker, mTestPssMode, isSleepingLocked(), now);
            }
        } else if (false && DEBUG_PSS)
            Slog.d(TAG_PSS, "Not requesting pss of " + app + ": next=" + (app.nextPssTime - now));
    }
    if (app.setProcState != app.curProcState) {
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
            String msg = "Proc state change of " + app.processName + " to " + ProcessList.makeProcStateString(app.curProcState) + " (" + app.curProcState + ")" + ": " + app.adjType;
            reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
        }
        boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
        boolean curImportant = app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
        if (setImportant && !curImportant) {
            // This app is no longer something we consider important enough to allow to
            // use arbitrary amounts of battery power.  Note
            // its current CPU time to later know to kill it if
            // it is not behaving well.
            app.whenUnimportant = now;
            app.lastCpuTime = 0;
        }
        // Inform UsageStats of important process state change
        // Must be called before updating setProcState
        maybeUpdateUsageStatsLocked(app, nowElapsed);
        app.setProcState = app.curProcState;
        if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
            app.notCachedSinceIdle = false;
        }
        if (!doingAll) {
            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
        } else {
            app.procStateChanged = true;
        }
    } else if (app.reportedInteraction && (nowElapsed - app.interactionEventTime) > mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
        // For apps that sit around for a long time in the interactive state, we need
        // to report this at least once a day so they don't go idle.
        maybeUpdateUsageStatsLocked(app, nowElapsed);
    }
    if (changes != 0) {
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
        int i = mPendingProcessChanges.size() - 1;
        ProcessChangeItem item = null;
        while (i >= 0) {
            item = mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                break;
            }
            i--;
        }
        if (i < 0) {
            // No existing item in pending changes; need a new one.
            final int NA = mAvailProcessChanges.size();
            if (NA > 0) {
                item = mAvailProcessChanges.remove(NA - 1);
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
            } else {
                item = new ProcessChangeItem();
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
            }
            item.changes = 0;
            item.pid = app.pid;
            item.uid = app.info.uid;
            if (mPendingProcessChanges.size() == 0) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
            }
            mPendingProcessChanges.add(item);
        }
        item.changes |= changes;
        item.foregroundActivities = app.repForegroundActivities;
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
    }
    return success;
}
#method_after
private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
    boolean success = true;
    if (app.curRawAdj != app.setRawAdj) {
        app.setRawAdj = app.curRawAdj;
    }
    int changes = 0;
    if (app.curAdj != app.setAdj) {
        ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.info.uid) {
            String msg = "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType;
            reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
        }
        app.setAdj = app.curAdj;
        app.verifiedAdj = ProcessList.INVALID_ADJ;
    }
    if (app.setSchedGroup != app.curSchedGroup) {
        int oldSchedGroup = app.setSchedGroup;
        app.setSchedGroup = app.curSchedGroup;
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
            String msg = "Setting sched group of " + app.processName + " to " + app.curSchedGroup + ": " + app.adjType;
            reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
        }
        if (app.waitingToKill != null && app.curReceivers.isEmpty() && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
            app.kill(app.waitingToKill, true);
            success = false;
        } else {
            int processGroup;
            switch(app.curSchedGroup) {
                case ProcessList.SCHED_GROUP_BACKGROUND:
                    processGroup = THREAD_GROUP_BG_NONINTERACTIVE;
                    break;
                case ProcessList.SCHED_GROUP_TOP_APP:
                case ProcessList.SCHED_GROUP_TOP_APP_BOUND:
                    processGroup = THREAD_GROUP_TOP_APP;
                    break;
                case ProcessList.SCHED_GROUP_RESTRICTED:
                    processGroup = THREAD_GROUP_RESTRICTED;
                    break;
                default:
                    processGroup = THREAD_GROUP_DEFAULT;
                    break;
            }
            long oldId = Binder.clearCallingIdentity();
            try {
                setProcessGroup(app.pid, processGroup);
                if (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
                    // do nothing if we already switched to RT
                    if (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                        mVrController.onTopProcChangedLocked(app);
                        if (mUseFifoUiScheduling) {
                            // Switch UI pipeline for app to SCHED_FIFO
                            app.savedPriority = Process.getThreadPriority(app.pid);
                            scheduleAsFifoPriority(app.pid, /* suppressLogs */
                            true);
                            if (app.renderThreadTid != 0) {
                                scheduleAsFifoPriority(app.renderThreadTid, /* suppressLogs */
                                true);
                                if (DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Set RenderThread (TID " + app.renderThreadTid + ") to FIFO");
                                }
                            } else {
                                if (DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Not setting RenderThread TID");
                                }
                            }
                        } else {
                            // Boost priority for top app UI and render threads
                            setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
                            if (app.renderThreadTid != 0) {
                                try {
                                    setThreadPriority(app.renderThreadTid, TOP_APP_PRIORITY_BOOST);
                                } catch (IllegalArgumentException e) {
                                // thread died, ignore
                                }
                            }
                        }
                    }
                } else if (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP && app.curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                    mVrController.onTopProcChangedLocked(app);
                    if (mUseFifoUiScheduling) {
                        try {
                            // Reset UI pipeline to SCHED_OTHER
                            setThreadScheduler(app.pid, SCHED_OTHER, 0);
                            setThreadPriority(app.pid, app.savedPriority);
                            if (app.renderThreadTid != 0) {
                                setThreadScheduler(app.renderThreadTid, SCHED_OTHER, 0);
                                setThreadPriority(app.renderThreadTid, -4);
                            }
                        } catch (IllegalArgumentException e) {
                            Slog.w(TAG, "Failed to set scheduling policy, thread does not exist:\n" + e);
                        } catch (SecurityException e) {
                            Slog.w(TAG, "Failed to set scheduling policy, not allowed:\n" + e);
                        }
                    } else {
                        // Reset priority for top app UI and render threads
                        setThreadPriority(app.pid, 0);
                        if (app.renderThreadTid != 0) {
                            setThreadPriority(app.renderThreadTid, 0);
                        }
                    }
                }
            } catch (Exception e) {
                if (false) {
                    Slog.w(TAG, "Failed setting process group of " + app.pid + " to " + app.curSchedGroup);
                    Slog.w(TAG, "at location", e);
                }
            } finally {
                Binder.restoreCallingIdentity(oldId);
            }
        }
    }
    if (app.repForegroundActivities != app.foregroundActivities) {
        app.repForegroundActivities = app.foregroundActivities;
        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
    }
    if (app.repProcState != app.curProcState) {
        app.repProcState = app.curProcState;
        if (app.thread != null) {
            try {
                if (false) {
                    // RuntimeException h = new RuntimeException("here");
                    Slog.i(TAG, "Sending new process state " + app.repProcState + " to " + app);
                }
                app.thread.setProcessState(app.repProcState);
            } catch (RemoteException e) {
            }
        }
    }
    if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
        if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
            // Experimental code to more aggressively collect pss while
            // running test...  the problem is that this tends to collect
            // the data right when a process is transitioning between process
            // states, which will tend to give noisy data.
            long start = SystemClock.uptimeMillis();
            long startTime = SystemClock.currentThreadTimeMillis();
            long pss = Debug.getPss(app.pid, mTmpLong, null);
            long endTime = SystemClock.currentThreadTimeMillis();
            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[0], mTmpLong[1], mTmpLong[2], ProcessStats.ADD_PSS_INTERNAL_SINGLE, endTime - startTime, now);
            mPendingPssProcesses.remove(app);
            Slog.i(TAG, "Recorded pss for " + app + " state " + app.setProcState + " to " + app.curProcState + ": " + (SystemClock.uptimeMillis() - start) + "ms");
        }
        app.lastStateTime = now;
        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, app.procStateMemTracker, mTestPssMode, isSleepingLocked(), now);
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
    } else {
        if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
            if (requestPssLocked(app, app.setProcState)) {
                app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, app.procStateMemTracker, mTestPssMode, isSleepingLocked(), now);
            }
        } else if (false && DEBUG_PSS)
            Slog.d(TAG_PSS, "Not requesting pss of " + app + ": next=" + (app.nextPssTime - now));
    }
    if (app.setProcState != app.curProcState) {
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
            String msg = "Proc state change of " + app.processName + " to " + ProcessList.makeProcStateString(app.curProcState) + " (" + app.curProcState + ")" + ": " + app.adjType;
            reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
        }
        boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
        boolean curImportant = app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
        if (setImportant && !curImportant) {
            // This app is no longer something we consider important enough to allow to
            // use arbitrary amounts of battery power.  Note
            // its current CPU time to later know to kill it if
            // it is not behaving well.
            app.whenUnimportant = now;
            app.lastCpuTime = 0;
        }
        // Inform UsageStats of important process state change
        // Must be called before updating setProcState
        maybeUpdateUsageStatsLocked(app, nowElapsed);
        maybeUpdateLastTopTime(app, now);
        app.setProcState = app.curProcState;
        if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
            app.notCachedSinceIdle = false;
        }
        if (!doingAll) {
            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
        } else {
            app.procStateChanged = true;
        }
    } else if (app.reportedInteraction && (nowElapsed - app.interactionEventTime) > mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
        // For apps that sit around for a long time in the interactive state, we need
        // to report this at least once a day so they don't go idle.
        maybeUpdateUsageStatsLocked(app, nowElapsed);
    }
    if (changes != 0) {
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
        int i = mPendingProcessChanges.size() - 1;
        ProcessChangeItem item = null;
        while (i >= 0) {
            item = mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                break;
            }
            i--;
        }
        if (i < 0) {
            // No existing item in pending changes; need a new one.
            final int NA = mAvailProcessChanges.size();
            if (NA > 0) {
                item = mAvailProcessChanges.remove(NA - 1);
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
            } else {
                item = new ProcessChangeItem();
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
            }
            item.changes = 0;
            item.pid = app.pid;
            item.uid = app.info.uid;
            if (mPendingProcessChanges.size() == 0) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
            }
            mPendingProcessChanges.add(item);
        }
        item.changes |= changes;
        item.foregroundActivities = app.repForegroundActivities;
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
    }
    return success;
}
#end_block

#method_before
@Override
public int startActivitiesAsPackage(String packageName, int userId, Intent[] intents, Bundle bOptions) {
    Preconditions.checkNotNull(intents, "intents");
    final String[] resolvedTypes = new String[intents.length];
    // UID of the package on user userId.
    // "= 0" is needed because otherwise catch(RemoteException) would make it look like
    // packageUid may not be initialized.
    int packageUid = 0;
    final long ident = Binder.clearCallingIdentity();
    try {
        for (int i = 0; i < intents.length; i++) {
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(mContext.getContentResolver());
        }
        packageUid = AppGlobals.getPackageManager().getPackageUid(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId);
    } catch (RemoteException e) {
    // Shouldn't happen.
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    synchronized (ActivityManagerService.this) {
        return mActivityStartController.startActivitiesInPackage(packageUid, packageName, intents, resolvedTypes, null, /* resultTo */
        SafeActivityOptions.fromBundle(bOptions), userId, false);
    }
}
#method_after
@Override
public int startActivitiesAsPackage(String packageName, int userId, Intent[] intents, Bundle bOptions) {
    Preconditions.checkNotNull(intents, "intents");
    final String[] resolvedTypes = new String[intents.length];
    // UID of the package on user userId.
    // "= 0" is needed because otherwise catch(RemoteException) would make it look like
    // packageUid may not be initialized.
    int packageUid = 0;
    final long ident = Binder.clearCallingIdentity();
    try {
        for (int i = 0; i < intents.length; i++) {
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(mContext.getContentResolver());
        }
        packageUid = AppGlobals.getPackageManager().getPackageUid(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId);
    } catch (RemoteException e) {
    // Shouldn't happen.
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    synchronized (ActivityManagerService.this) {
        return mActivityStartController.startActivitiesInPackage(packageUid, packageName, intents, resolvedTypes, null, /* resultTo */
        SafeActivityOptions.fromBundle(bOptions), userId, false, /* validateIncomingUser */
        null);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return "VpnInfo{" + "ownerUid=" + ownerUid + ", vpnIface='" + vpnIface + '\'' + ", primaryUnderlyingIface='" + primaryUnderlyingIface + '\'' + ", vpnProxy='" + vpnProxyHost + ":" + vpnProxyPort + "'\''" + '}';
}
#method_after
@Override
public String toString() {
    return "VpnInfo{" + "ownerUid=" + ownerUid + ", vpnIface='" + vpnIface + '\'' + ", primaryUnderlyingIface='" + primaryUnderlyingIface + '\'' + '}';
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(ownerUid);
    dest.writeString(vpnIface);
    dest.writeString(primaryUnderlyingIface);
    dest.writeString(vpnProxyHost);
    dest.writeInt(vpnProxyPort);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(ownerUid);
    dest.writeString(vpnIface);
    dest.writeString(primaryUnderlyingIface);
}
#end_block

#method_before
String codeToString(int code) {
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return "BIND_APPLICATION";
            case EXIT_APPLICATION:
                return "EXIT_APPLICATION";
            case RECEIVER:
                return "RECEIVER";
            case CREATE_SERVICE:
                return "CREATE_SERVICE";
            case SERVICE_ARGS:
                return "SERVICE_ARGS";
            case STOP_SERVICE:
                return "STOP_SERVICE";
            case CONFIGURATION_CHANGED:
                return "CONFIGURATION_CHANGED";
            case CLEAN_UP_CONTEXT:
                return "CLEAN_UP_CONTEXT";
            case GC_WHEN_IDLE:
                return "GC_WHEN_IDLE";
            case BIND_SERVICE:
                return "BIND_SERVICE";
            case UNBIND_SERVICE:
                return "UNBIND_SERVICE";
            case DUMP_SERVICE:
                return "DUMP_SERVICE";
            case LOW_MEMORY:
                return "LOW_MEMORY";
            case PROFILER_CONTROL:
                return "PROFILER_CONTROL";
            case CREATE_BACKUP_AGENT:
                return "CREATE_BACKUP_AGENT";
            case DESTROY_BACKUP_AGENT:
                return "DESTROY_BACKUP_AGENT";
            case SUICIDE:
                return "SUICIDE";
            case REMOVE_PROVIDER:
                return "REMOVE_PROVIDER";
            case ENABLE_JIT:
                return "ENABLE_JIT";
            case DISPATCH_PACKAGE_BROADCAST:
                return "DISPATCH_PACKAGE_BROADCAST";
            case SCHEDULE_CRASH:
                return "SCHEDULE_CRASH";
            case DUMP_HEAP:
                return "DUMP_HEAP";
            case DUMP_ACTIVITY:
                return "DUMP_ACTIVITY";
            case SLEEPING:
                return "SLEEPING";
            case SET_CORE_SETTINGS:
                return "SET_CORE_SETTINGS";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return "UPDATE_PACKAGE_COMPATIBILITY_INFO";
            case DUMP_PROVIDER:
                return "DUMP_PROVIDER";
            case UNSTABLE_PROVIDER_DIED:
                return "UNSTABLE_PROVIDER_DIED";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return "REQUEST_ASSIST_CONTEXT_EXTRAS";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return "TRANSLUCENT_CONVERSION_COMPLETE";
            case INSTALL_PROVIDER:
                return "INSTALL_PROVIDER";
            case ON_NEW_ACTIVITY_OPTIONS:
                return "ON_NEW_ACTIVITY_OPTIONS";
            case ENTER_ANIMATION_COMPLETE:
                return "ENTER_ANIMATION_COMPLETE";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return "LOCAL_VOICE_INTERACTION_STARTED";
            case ATTACH_AGENT:
                return "ATTACH_AGENT";
            case APPLICATION_INFO_CHANGED:
                return "APPLICATION_INFO_CHANGED";
            case RUN_ISOLATED_ENTRY_POINT:
                return "RUN_ISOLATED_ENTRY_POINT";
            case EXECUTE_TRANSACTION:
                return "EXECUTE_TRANSACTION";
            case RELAUNCH_ACTIVITY:
                return "RELAUNCH_ACTIVITY";
        }
    }
    return Integer.toString(code);
}
#method_after
String codeToString(int code) {
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return "BIND_APPLICATION";
            case EXIT_APPLICATION:
                return "EXIT_APPLICATION";
            case RECEIVER:
                return "RECEIVER";
            case CREATE_SERVICE:
                return "CREATE_SERVICE";
            case SERVICE_ARGS:
                return "SERVICE_ARGS";
            case STOP_SERVICE:
                return "STOP_SERVICE";
            case CONFIGURATION_CHANGED:
                return "CONFIGURATION_CHANGED";
            case CLEAN_UP_CONTEXT:
                return "CLEAN_UP_CONTEXT";
            case GC_WHEN_IDLE:
                return "GC_WHEN_IDLE";
            case BIND_SERVICE:
                return "BIND_SERVICE";
            case UNBIND_SERVICE:
                return "UNBIND_SERVICE";
            case DUMP_SERVICE:
                return "DUMP_SERVICE";
            case LOW_MEMORY:
                return "LOW_MEMORY";
            case PROFILER_CONTROL:
                return "PROFILER_CONTROL";
            case CREATE_BACKUP_AGENT:
                return "CREATE_BACKUP_AGENT";
            case DESTROY_BACKUP_AGENT:
                return "DESTROY_BACKUP_AGENT";
            case SUICIDE:
                return "SUICIDE";
            case REMOVE_PROVIDER:
                return "REMOVE_PROVIDER";
            case ENABLE_JIT:
                return "ENABLE_JIT";
            case DISPATCH_PACKAGE_BROADCAST:
                return "DISPATCH_PACKAGE_BROADCAST";
            case SCHEDULE_CRASH:
                return "SCHEDULE_CRASH";
            case DUMP_HEAP:
                return "DUMP_HEAP";
            case DUMP_ACTIVITY:
                return "DUMP_ACTIVITY";
            case SLEEPING:
                return "SLEEPING";
            case SET_CORE_SETTINGS:
                return "SET_CORE_SETTINGS";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return "UPDATE_PACKAGE_COMPATIBILITY_INFO";
            case DUMP_PROVIDER:
                return "DUMP_PROVIDER";
            case UNSTABLE_PROVIDER_DIED:
                return "UNSTABLE_PROVIDER_DIED";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return "REQUEST_ASSIST_CONTEXT_EXTRAS";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return "TRANSLUCENT_CONVERSION_COMPLETE";
            case INSTALL_PROVIDER:
                return "INSTALL_PROVIDER";
            case ON_NEW_ACTIVITY_OPTIONS:
                return "ON_NEW_ACTIVITY_OPTIONS";
            case ENTER_ANIMATION_COMPLETE:
                return "ENTER_ANIMATION_COMPLETE";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return "LOCAL_VOICE_INTERACTION_STARTED";
            case ATTACH_AGENT:
                return "ATTACH_AGENT";
            case APPLICATION_INFO_CHANGED:
                return "APPLICATION_INFO_CHANGED";
            case RUN_ISOLATED_ENTRY_POINT:
                return "RUN_ISOLATED_ENTRY_POINT";
            case EXECUTE_TRANSACTION:
                return "EXECUTE_TRANSACTION";
            case RELAUNCH_ACTIVITY:
                return "RELAUNCH_ACTIVITY";
            case PURGE_RESOURCES:
                return "PURGE_RESOURCES";
        }
    }
    return Integer.toString(code);
}
#end_block

#method_before
public void handleMessage(Message msg) {
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "broadcastReceiveComp");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ("serviceCreate: " + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceBind");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceUnbind");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ("serviceStart: " + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceStop");
            handleStopService((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "lowMemory");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "backupCreateAgent");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "backupDestroyAgent");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "providerRemove");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "broadcastPackage");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "sleeping");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "setCoreSettings");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "<<< done: " + codeToString(msg.what));
}
#method_after
public void handleMessage(Message msg) {
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "broadcastReceiveComp");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ("serviceCreate: " + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceBind");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceUnbind");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ("serviceStart: " + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceStop");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "lowMemory");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "backupCreateAgent");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "backupDestroyAgent");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "providerRemove");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "broadcastPackage");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "sleeping");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "setCoreSettings");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "<<< done: " + codeToString(msg.what));
}
#end_block

#method_before
@Override
public final boolean queueIdle() {
    doGcIfNeeded();
    return false;
}
#method_after
@Override
public final boolean queueIdle() {
    doGcIfNeeded();
    nPurgePendingResources();
    return false;
}
#end_block

#method_before
@UnsupportedAppUsage
private void handleReceiver(ReceiverData data) {
    // If we are getting ready to gc after going to the background, well
    // we are back active so skip it.
    unscheduleGcIdler();
    String component = data.intent.getComponent().getClassName();
    LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);
    IActivityManager mgr = ActivityManager.getService();
    Application app;
    BroadcastReceiver receiver;
    ContextImpl context;
    try {
        app = packageInfo.makeApplication(false, mInstrumentation);
        context = (ContextImpl) app.getBaseContext();
        if (data.info.splitName != null) {
            context = (ContextImpl) context.createContextForSplit(data.info.splitName);
        }
        java.lang.ClassLoader cl = context.getClassLoader();
        data.intent.setExtrasClassLoader(cl);
        data.intent.prepareToEnterProcess();
        data.setExtrasClassLoader(cl);
        receiver = packageInfo.getAppFactory().instantiateReceiver(cl, data.info.name, data.intent);
    } catch (Exception e) {
        if (DEBUG_BROADCAST)
            Slog.i(TAG, "Finishing failed broadcast to " + data.intent.getComponent());
        data.sendFinished(mgr);
        throw new RuntimeException("Unable to instantiate receiver " + component + ": " + e.toString(), e);
    }
    try {
        if (localLOGV)
            Slog.v(TAG, "Performing receive of " + data.intent + ": app=" + app + ", appName=" + app.getPackageName() + ", pkg=" + packageInfo.getPackageName() + ", comp=" + data.intent.getComponent().toShortString() + ", dir=" + packageInfo.getAppDir());
        sCurrentBroadcastIntent.set(data.intent);
        receiver.setPendingResult(data);
        receiver.onReceive(context.getReceiverRestrictedContext(), data.intent);
    } catch (Exception e) {
        if (DEBUG_BROADCAST)
            Slog.i(TAG, "Finishing failed broadcast to " + data.intent.getComponent());
        data.sendFinished(mgr);
        if (!mInstrumentation.onException(receiver, e)) {
            throw new RuntimeException("Unable to start receiver " + component + ": " + e.toString(), e);
        }
    } finally {
        sCurrentBroadcastIntent.set(null);
    }
    if (receiver.getPendingResult() != null) {
        data.finish();
    }
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
private void handleReceiver(ReceiverData data) {
    // If we are getting ready to gc after going to the background, well
    // we are back active so skip it.
    unscheduleGcIdler();
    String component = data.intent.getComponent().getClassName();
    LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);
    IActivityManager mgr = ActivityManager.getService();
    Application app;
    BroadcastReceiver receiver;
    ContextImpl context;
    try {
        app = packageInfo.makeApplication(false, mInstrumentation);
        context = (ContextImpl) app.getBaseContext();
        if (data.info.splitName != null) {
            context = (ContextImpl) context.createContextForSplit(data.info.splitName);
        }
        java.lang.ClassLoader cl = context.getClassLoader();
        data.intent.setExtrasClassLoader(cl);
        data.intent.prepareToEnterProcess();
        data.setExtrasClassLoader(cl);
        receiver = packageInfo.getAppFactory().instantiateReceiver(cl, data.info.name, data.intent);
    } catch (Exception e) {
        if (DEBUG_BROADCAST)
            Slog.i(TAG, "Finishing failed broadcast to " + data.intent.getComponent());
        data.sendFinished(mgr);
        throw new RuntimeException("Unable to instantiate receiver " + component + ": " + e.toString(), e);
    }
    try {
        if (localLOGV)
            Slog.v(TAG, "Performing receive of " + data.intent + ": app=" + app + ", appName=" + app.getPackageName() + ", pkg=" + packageInfo.getPackageName() + ", comp=" + data.intent.getComponent().toShortString() + ", dir=" + packageInfo.getAppDir());
        sCurrentBroadcastIntent.set(data.intent);
        receiver.setPendingResult(data);
        receiver.onReceive(context.getReceiverRestrictedContext(), data.intent);
    } catch (Exception e) {
        if (DEBUG_BROADCAST)
            Slog.i(TAG, "Finishing failed broadcast to " + data.intent.getComponent());
        data.sendFinished(mgr);
        if (!mInstrumentation.onException(receiver, e)) {
            throw new RuntimeException("Unable to start receiver " + component + ": " + e.toString(), e);
        }
    } finally {
        sCurrentBroadcastIntent.set(null);
    }
    if (receiver.getPendingResult() != null) {
        data.finish();
    }
}
#end_block

#method_before
ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) {
    ActivityClientRecord r = mActivities.get(token);
    Class<? extends Activity> activityClass = null;
    if (localLOGV)
        Slog.v(TAG, "Performing finish of " + r);
    if (r != null) {
        activityClass = r.activity.getClass();
        r.activity.mConfigChangeFlags |= configChanges;
        if (finishing) {
            r.activity.mFinished = true;
        }
        performPauseActivityIfNeeded(r, "destroy");
        if (!r.stopped) {
            callActivityOnStop(r, false, /* saveState */
            "destroy");
        }
        if (getNonConfigInstance) {
            try {
                r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to retain activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
        }
        try {
            r.activity.mCalled = false;
            mInstrumentation.callActivityOnDestroy(r.activity);
            if (!r.activity.mCalled) {
                throw new SuperNotCalledException("Activity " + safeToComponentShortString(r.intent) + " did not call through to super.onDestroy()");
            }
            if (r.window != null) {
                r.window.closeAllPanels();
            }
        } catch (SuperNotCalledException e) {
            throw e;
        } catch (Exception e) {
            if (!mInstrumentation.onException(r.activity, e)) {
                throw new RuntimeException("Unable to destroy activity " + safeToComponentShortString(r.intent) + ": " + e.toString(), e);
            }
        }
        r.setState(ON_DESTROY);
    }
    mActivities.remove(token);
    StrictMode.decrementExpectedActivityCount(activityClass);
    return r;
}
#method_after
ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) {
    ActivityClientRecord r = mActivities.get(token);
    Class<? extends Activity> activityClass = null;
    if (localLOGV)
        Slog.v(TAG, "Performing finish of " + r);
    if (r != null) {
        activityClass = r.activity.getClass();
        r.activity.mConfigChangeFlags |= configChanges;
        if (finishing) {
            r.activity.mFinished = true;
        }
        performPauseActivityIfNeeded(r, "destroy");
        if (!r.stopped) {
            callActivityOnStop(r, false, /* saveState */
            "destroy");
        }
        if (getNonConfigInstance) {
            try {
                r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to retain activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
        }
        try {
            r.activity.mCalled = false;
            mInstrumentation.callActivityOnDestroy(r.activity);
            if (!r.activity.mCalled) {
                throw new SuperNotCalledException("Activity " + safeToComponentShortString(r.intent) + " did not call through to super.onDestroy()");
            }
            if (r.window != null) {
                r.window.closeAllPanels();
            }
        } catch (SuperNotCalledException e) {
            throw e;
        } catch (Exception e) {
            if (!mInstrumentation.onException(r.activity, e)) {
                throw new RuntimeException("Unable to destroy activity " + safeToComponentShortString(r.intent) + ": " + e.toString(), e);
            }
        }
        r.setState(ON_DESTROY);
    }
    schedulePurgeIdler();
    mActivities.remove(token);
    StrictMode.decrementExpectedActivityCount(activityClass);
    return r;
}
#end_block

#method_before
@UnsupportedAppUsage
private void handleBindApplication(AppBindData data) {
    // Register the UI Thread as a sensitive thread to the runtime.
    VMRuntime.registerSensitiveThread();
    if (data.trackAllocation) {
        DdmVmInternal.enableRecentAllocations(true);
    }
    // Note when this process has started.
    Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);
    mProfiler = new Profiler();
    String agent = null;
    if (data.initProfilerInfo != null) {
        mProfiler.profileFile = data.initProfilerInfo.profileFile;
        mProfiler.profileFd = data.initProfilerInfo.profileFd;
        mProfiler.samplingInterval = data.initProfilerInfo.samplingInterval;
        mProfiler.autoStopProfiler = data.initProfilerInfo.autoStopProfiler;
        mProfiler.streamingOutput = data.initProfilerInfo.streamingOutput;
        if (data.initProfilerInfo.attachAgentDuringBind) {
            agent = data.initProfilerInfo.agent;
        }
    }
    // send up app name; do this *before* waiting for debugger
    Process.setArgV0(data.processName);
    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());
    VMRuntime.setProcessPackageName(data.appInfo.packageName);
    if (mProfiler.profileFd != null) {
        mProfiler.startProfiling();
    }
    // main thread so the main looper is set right.
    if (data.appInfo.targetSdkVersion <= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) {
        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }
    Message.updateCheckRecycle(data.appInfo.targetSdkVersion);
    // Prior to P, internal calls to decode Bitmaps used BitmapFactory,
    // which may scale up to account for density. In P, we switched to
    // ImageDecoder, which skips the upscale to save memory. ImageDecoder
    // needs to still scale up in older apps, in case they rely on the
    // size of the Bitmap without considering its density.
    ImageDecoder.sApiLevel = data.appInfo.targetSdkVersion;
    /*
         * Before spawning a new process, reset the time zone to be the system time zone.
         * This needs to be done because the system time zone could have changed after the
         * the spawning of this process. Without doing this this process would have the incorrect
         * system time zone.
         */
    TimeZone.setDefault(null);
    /*
         * Set the LocaleList. This may change once we create the App Context.
         */
    LocaleList.setDefault(data.config.getLocales());
    synchronized (mResourcesManager) {
        /*
             * Update the system configuration since its preloaded and might not
             * reflect configuration changes. The configuration object passed
             * in AppBindData can be safely assumed to be up to date
             */
        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);
        mCurDefaultDisplayDpi = data.config.densityDpi;
        // This calls mResourcesManager so keep it within the synchronized block.
        applyCompatConfiguration(mCurDefaultDisplayDpi);
    }
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    if (agent != null) {
        handleAttachAgent(agent, data.info);
    }
    /**
     * Switch this process to density compatibility mode if needed.
     */
    if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
        mDensityCompatMode = true;
        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
    }
    updateDefaultDensity();
    final String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24);
    Boolean is24Hr = null;
    if (use24HourSetting != null) {
        is24Hr = "24".equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE;
    }
    // null : use locale default for 12/24 hour formatting,
    // false : use 12 hour format,
    // true : use 24 hour format.
    DateFormat.set24HourTimePref(is24Hr);
    View.mDebugViewAttributes = mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0;
    StrictMode.initThreadDefaults(data.appInfo);
    StrictMode.initVmDefaults(data.appInfo);
    // before any app code has been loaded.
    try {
        Field field = Build.class.getDeclaredField("SERIAL");
        field.setAccessible(true);
        field.set(Build.class, data.buildSerial);
    } catch (NoSuchFieldException | IllegalAccessException e) {
    /* ignore */
    }
    if (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) {
        // XXX should have option to change the port.
        Debug.changeDebugPort(8100);
        if (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) {
            Slog.w(TAG, "Application " + data.info.getPackageName() + " is waiting for the debugger on port 8100...");
            IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.showWaitingForDebugger(mAppThread, true);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            Debug.waitForDebugger();
            try {
                mgr.showWaitingForDebugger(mAppThread, false);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        } else {
            Slog.w(TAG, "Application " + data.info.getPackageName() + " can be debugged on port 8100...");
        }
    }
    // Allow application-generated systrace messages if we're debuggable.
    boolean isAppDebuggable = (data.appInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    Trace.setAppTracingAllowed(isAppDebuggable);
    ThreadedRenderer.setDebuggingEnabled(isAppDebuggable || Build.IS_DEBUGGABLE);
    if (isAppDebuggable && data.enableBinderTracking) {
        Binder.enableTracing();
    }
    /**
     * Initialize the default http proxy in this process for the reasons we set the time zone.
     */
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Setup proxies");
    final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
    if (b != null) {
        // In pre-boot mode (doing initial launch to collect password), not
        // all system is up.  This includes the connectivity service, so don't
        // crash if we can't get it.
        final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
        try {
            Proxy.setHttpProxySystemProperty(service.getProxyForNetwork(null));
        } catch (RemoteException e) {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            throw e.rethrowFromSystemServer();
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Instrumentation info affects the class loader, so load it before
    // setting up the app context.
    final InstrumentationInfo ii;
    if (data.instrumentationName != null) {
        try {
            ii = new ApplicationPackageManager(null, getPackageManager()).getInstrumentationInfo(data.instrumentationName, 0);
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException("Unable to find instrumentation info for: " + data.instrumentationName);
        }
        // Warn of potential ABI mismatches.
        if (!Objects.equals(data.appInfo.primaryCpuAbi, ii.primaryCpuAbi) || !Objects.equals(data.appInfo.secondaryCpuAbi, ii.secondaryCpuAbi)) {
            Slog.w(TAG, "Package uses different ABI(s) than its instrumentation: " + "package[" + data.appInfo.packageName + "]: " + data.appInfo.primaryCpuAbi + ", " + data.appInfo.secondaryCpuAbi + " instrumentation[" + ii.packageName + "]: " + ii.primaryCpuAbi + ", " + ii.secondaryCpuAbi);
        }
        mInstrumentationPackageName = ii.packageName;
        mInstrumentationAppDir = ii.sourceDir;
        mInstrumentationSplitAppDirs = ii.splitSourceDirs;
        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);
        mInstrumentedAppDir = data.info.getAppDir();
        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();
        mInstrumentedLibDir = data.info.getLibDir();
    } else {
        ii = null;
    }
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales());
    if (!Process.isIsolated()) {
        final int oldMask = StrictMode.allowThreadDiskWritesMask();
        try {
            setupGraphicsSupport(appContext);
        } finally {
            StrictMode.setThreadPolicyMask(oldMask);
        }
    } else {
        ThreadedRenderer.setIsolatedProcess(true);
    }
    // complete application startup.
    if (SystemProperties.getBoolean("dalvik.vm.usejitprofiles", false)) {
        BaseDexClassLoader.setReporter(DexLoadReporter.getInstance());
    }
    // Install the Network Security Config Provider. This must happen before the application
    // code is loaded to prevent issues with instances of TLS objects being created before
    // the provider is installed.
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "NetworkSecurityConfigProvider.install");
    NetworkSecurityConfigProvider.install(appContext);
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Continue loading instrumentation.
    if (ii != null) {
        ApplicationInfo instrApp;
        try {
            instrApp = getPackageManager().getApplicationInfo(ii.packageName, 0, UserHandle.myUserId());
        } catch (RemoteException e) {
            instrApp = null;
        }
        if (instrApp == null) {
            instrApp = new ApplicationInfo();
        }
        ii.copyTo(instrApp);
        instrApp.initForUser(UserHandle.myUserId());
        final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false);
        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);
        try {
            final ClassLoader cl = instrContext.getClassLoader();
            mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Unable to instantiate instrumentation " + data.instrumentationName + ": " + e.toString(), e);
        }
        final ComponentName component = new ComponentName(ii.packageName, ii.name);
        mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection);
        if (mProfiler.profileFile != null && !ii.handleProfiling && mProfiler.profileFd == null) {
            mProfiler.handlingProfiling = true;
            final File file = new File(mProfiler.profileFile);
            file.getParentFile().mkdirs();
            Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);
        }
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }
    if ((data.appInfo.flags & ApplicationInfo.FLAG_LARGE_HEAP) != 0) {
        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();
    } else {
        // Small heap, clamp to the current growth limit and let the heap release
        // pages after the growth limit to the non growth limit capacity. b/18387825
        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();
    }
    // Allow disk access during application and provider setup. This could
    // block processing ordered broadcasts, but later processing would
    // probably end up doing the same disk access.
    Application app;
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();
    final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();
    try {
        // If the app is being launched for full backup or restore, bring it up in
        // a restricted environment with the base application class.
        app = data.info.makeApplication(data.restrictedBackupMode, null);
        // Propagate autofill compat state
        app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled);
        mInitialApplication = app;
        // app's custom Application class
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                installContentProviders(app, data.providers);
                // For process that contains content providers, we want to
                // ensure that the JIT is enabled "at some point".
                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10 * 1000);
            }
        }
        // test thread at this point, and we don't want that racing.
        try {
            mInstrumentation.onCreate(data.instrumentationArgs);
        } catch (Exception e) {
            throw new RuntimeException("Exception thrown in onCreate() of " + data.instrumentationName + ": " + e.toString(), e);
        }
        try {
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
            if (!mInstrumentation.onException(app, e)) {
                throw new RuntimeException("Unable to create application " + app.getClass().getName() + ": " + e.toString(), e);
            }
        }
    } finally {
        // during startup, clobber the policy to maintain behavior of b/36951662
        if (data.appInfo.targetSdkVersion < Build.VERSION_CODES.O_MR1 || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) {
            StrictMode.setThreadPolicy(savedPolicy);
        }
    }
    // Preload fonts resources
    FontsContract.setApplicationContextForResources(appContext);
    if (!Process.isIsolated()) {
        try {
            final ApplicationInfo info = getPackageManager().getApplicationInfo(data.appInfo.packageName, PackageManager.GET_META_DATA, /*flags*/
            UserHandle.myUserId());
            if (info.metaData != null) {
                final int preloadedFontsResource = info.metaData.getInt(ApplicationInfo.METADATA_PRELOADED_FONTS, 0);
                if (preloadedFontsResource != 0) {
                    data.info.getResources().preloadFonts(preloadedFontsResource);
                }
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#method_after
@UnsupportedAppUsage
private void handleBindApplication(AppBindData data) {
    // Register the UI Thread as a sensitive thread to the runtime.
    VMRuntime.registerSensitiveThread();
    if (data.trackAllocation) {
        DdmVmInternal.enableRecentAllocations(true);
    }
    // Note when this process has started.
    Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);
    mProfiler = new Profiler();
    String agent = null;
    if (data.initProfilerInfo != null) {
        mProfiler.profileFile = data.initProfilerInfo.profileFile;
        mProfiler.profileFd = data.initProfilerInfo.profileFd;
        mProfiler.samplingInterval = data.initProfilerInfo.samplingInterval;
        mProfiler.autoStopProfiler = data.initProfilerInfo.autoStopProfiler;
        mProfiler.streamingOutput = data.initProfilerInfo.streamingOutput;
        if (data.initProfilerInfo.attachAgentDuringBind) {
            agent = data.initProfilerInfo.agent;
        }
    }
    // send up app name; do this *before* waiting for debugger
    Process.setArgV0(data.processName);
    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());
    VMRuntime.setProcessPackageName(data.appInfo.packageName);
    if (mProfiler.profileFd != null) {
        mProfiler.startProfiling();
    }
    // main thread so the main looper is set right.
    if (data.appInfo.targetSdkVersion <= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) {
        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }
    Message.updateCheckRecycle(data.appInfo.targetSdkVersion);
    // Prior to P, internal calls to decode Bitmaps used BitmapFactory,
    // which may scale up to account for density. In P, we switched to
    // ImageDecoder, which skips the upscale to save memory. ImageDecoder
    // needs to still scale up in older apps, in case they rely on the
    // size of the Bitmap without considering its density.
    ImageDecoder.sApiLevel = data.appInfo.targetSdkVersion;
    /*
         * Before spawning a new process, reset the time zone to be the system time zone.
         * This needs to be done because the system time zone could have changed after the
         * the spawning of this process. Without doing this this process would have the incorrect
         * system time zone.
         */
    TimeZone.setDefault(null);
    /*
         * Set the LocaleList. This may change once we create the App Context.
         */
    LocaleList.setDefault(data.config.getLocales());
    synchronized (mResourcesManager) {
        /*
             * Update the system configuration since its preloaded and might not
             * reflect configuration changes. The configuration object passed
             * in AppBindData can be safely assumed to be up to date
             */
        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);
        mCurDefaultDisplayDpi = data.config.densityDpi;
        // This calls mResourcesManager so keep it within the synchronized block.
        applyCompatConfiguration(mCurDefaultDisplayDpi);
    }
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    if (agent != null) {
        handleAttachAgent(agent, data.info);
    }
    /**
     * Switch this process to density compatibility mode if needed.
     */
    if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
        mDensityCompatMode = true;
        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
    }
    updateDefaultDensity();
    final String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24);
    Boolean is24Hr = null;
    if (use24HourSetting != null) {
        is24Hr = "24".equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE;
    }
    // null : use locale default for 12/24 hour formatting,
    // false : use 12 hour format,
    // true : use 24 hour format.
    DateFormat.set24HourTimePref(is24Hr);
    View.mDebugViewAttributes = mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0;
    StrictMode.initThreadDefaults(data.appInfo);
    StrictMode.initVmDefaults(data.appInfo);
    // before any app code has been loaded.
    try {
        Field field = Build.class.getDeclaredField("SERIAL");
        field.setAccessible(true);
        field.set(Build.class, data.buildSerial);
    } catch (NoSuchFieldException | IllegalAccessException e) {
    /* ignore */
    }
    if (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) {
        // XXX should have option to change the port.
        Debug.changeDebugPort(8100);
        if (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) {
            Slog.w(TAG, "Application " + data.info.getPackageName() + " is waiting for the debugger on port 8100...");
            IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.showWaitingForDebugger(mAppThread, true);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            Debug.waitForDebugger();
            try {
                mgr.showWaitingForDebugger(mAppThread, false);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        } else {
            Slog.w(TAG, "Application " + data.info.getPackageName() + " can be debugged on port 8100...");
        }
    }
    // Allow application-generated systrace messages if we're debuggable.
    boolean isAppDebuggable = (data.appInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    Trace.setAppTracingAllowed(isAppDebuggable);
    ThreadedRenderer.setDebuggingEnabled(isAppDebuggable || Build.IS_DEBUGGABLE);
    if (isAppDebuggable && data.enableBinderTracking) {
        Binder.enableTracing();
    }
    /**
     * Initialize the default http proxy in this process for the reasons we set the time zone.
     */
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Setup proxies");
    final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
    if (b != null) {
        // In pre-boot mode (doing initial launch to collect password), not
        // all system is up.  This includes the connectivity service, so don't
        // crash if we can't get it.
        final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
        try {
            Proxy.setHttpProxySystemProperty(service.getProxyForNetwork(null));
        } catch (RemoteException e) {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            throw e.rethrowFromSystemServer();
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Instrumentation info affects the class loader, so load it before
    // setting up the app context.
    final InstrumentationInfo ii;
    if (data.instrumentationName != null) {
        try {
            ii = new ApplicationPackageManager(null, getPackageManager()).getInstrumentationInfo(data.instrumentationName, 0);
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException("Unable to find instrumentation info for: " + data.instrumentationName);
        }
        // Warn of potential ABI mismatches.
        if (!Objects.equals(data.appInfo.primaryCpuAbi, ii.primaryCpuAbi) || !Objects.equals(data.appInfo.secondaryCpuAbi, ii.secondaryCpuAbi)) {
            Slog.w(TAG, "Package uses different ABI(s) than its instrumentation: " + "package[" + data.appInfo.packageName + "]: " + data.appInfo.primaryCpuAbi + ", " + data.appInfo.secondaryCpuAbi + " instrumentation[" + ii.packageName + "]: " + ii.primaryCpuAbi + ", " + ii.secondaryCpuAbi);
        }
        mInstrumentationPackageName = ii.packageName;
        mInstrumentationAppDir = ii.sourceDir;
        mInstrumentationSplitAppDirs = ii.splitSourceDirs;
        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);
        mInstrumentedAppDir = data.info.getAppDir();
        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();
        mInstrumentedLibDir = data.info.getLibDir();
    } else {
        ii = null;
    }
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales());
    if (!Process.isIsolated()) {
        final int oldMask = StrictMode.allowThreadDiskWritesMask();
        try {
            setupGraphicsSupport(appContext);
        } finally {
            StrictMode.setThreadPolicyMask(oldMask);
        }
    } else {
        ThreadedRenderer.setIsolatedProcess(true);
    }
    // Install the Network Security Config Provider. This must happen before the application
    // code is loaded to prevent issues with instances of TLS objects being created before
    // the provider is installed.
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "NetworkSecurityConfigProvider.install");
    NetworkSecurityConfigProvider.install(appContext);
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Continue loading instrumentation.
    if (ii != null) {
        ApplicationInfo instrApp;
        try {
            instrApp = getPackageManager().getApplicationInfo(ii.packageName, 0, UserHandle.myUserId());
        } catch (RemoteException e) {
            instrApp = null;
        }
        if (instrApp == null) {
            instrApp = new ApplicationInfo();
        }
        ii.copyTo(instrApp);
        instrApp.initForUser(UserHandle.myUserId());
        final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false);
        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);
        try {
            final ClassLoader cl = instrContext.getClassLoader();
            mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Unable to instantiate instrumentation " + data.instrumentationName + ": " + e.toString(), e);
        }
        final ComponentName component = new ComponentName(ii.packageName, ii.name);
        mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection);
        if (mProfiler.profileFile != null && !ii.handleProfiling && mProfiler.profileFd == null) {
            mProfiler.handlingProfiling = true;
            final File file = new File(mProfiler.profileFile);
            file.getParentFile().mkdirs();
            Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);
        }
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }
    if ((data.appInfo.flags & ApplicationInfo.FLAG_LARGE_HEAP) != 0) {
        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();
    } else {
        // Small heap, clamp to the current growth limit and let the heap release
        // pages after the growth limit to the non growth limit capacity. b/18387825
        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();
    }
    // Allow disk access during application and provider setup. This could
    // block processing ordered broadcasts, but later processing would
    // probably end up doing the same disk access.
    Application app;
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();
    final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();
    try {
        // If the app is being launched for full backup or restore, bring it up in
        // a restricted environment with the base application class.
        app = data.info.makeApplication(data.restrictedBackupMode, null);
        // Propagate autofill compat state
        app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled);
        mInitialApplication = app;
        // app's custom Application class
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                installContentProviders(app, data.providers);
                // For process that contains content providers, we want to
                // ensure that the JIT is enabled "at some point".
                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10 * 1000);
            }
        }
        // test thread at this point, and we don't want that racing.
        try {
            mInstrumentation.onCreate(data.instrumentationArgs);
        } catch (Exception e) {
            throw new RuntimeException("Exception thrown in onCreate() of " + data.instrumentationName + ": " + e.toString(), e);
        }
        try {
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
            if (!mInstrumentation.onException(app, e)) {
                throw new RuntimeException("Unable to create application " + app.getClass().getName() + ": " + e.toString(), e);
            }
        }
    } finally {
        // during startup, clobber the policy to maintain behavior of b/36951662
        if (data.appInfo.targetSdkVersion < Build.VERSION_CODES.O_MR1 || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) {
            StrictMode.setThreadPolicy(savedPolicy);
        }
    }
    // Preload fonts resources
    FontsContract.setApplicationContextForResources(appContext);
    if (!Process.isIsolated()) {
        try {
            final ApplicationInfo info = getPackageManager().getApplicationInfo(data.appInfo.packageName, PackageManager.GET_META_DATA, /*flags*/
            UserHandle.myUserId());
            if (info.metaData != null) {
                final int preloadedFontsResource = info.metaData.getInt(ApplicationInfo.METADATA_PRELOADED_FONTS, 0);
                if (preloadedFontsResource != 0) {
                    data.info.getResources().preloadFonts(preloadedFontsResource);
                }
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
@UnsupportedAppUsage
private void attach(boolean system, long startSeq) {
    sCurrentActivityThread = this;
    mSystemThread = system;
    if (!system) {
        ViewRootImpl.addFirstDrawHandler(new Runnable() {

            @Override
            public void run() {
                ensureJitEnabled();
            }
        });
        android.ddm.DdmHandleAppName.setAppName("<pre-initialized>", UserHandle.myUserId());
        RuntimeInit.setApplicationObject(mAppThread.asBinder());
        final IActivityManager mgr = ActivityManager.getService();
        try {
            mgr.attachApplication(mAppThread, startSeq);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
        // Watch for getting close to heap limit.
        BinderInternal.addGcWatcher(new Runnable() {

            @Override
            public void run() {
                if (!mSomeActivitiesChanged) {
                    return;
                }
                Runtime runtime = Runtime.getRuntime();
                long dalvikMax = runtime.maxMemory();
                long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();
                if (dalvikUsed > ((3 * dalvikMax) / 4)) {
                    if (DEBUG_MEMORY_TRIM)
                        Slog.d(TAG, "Dalvik max=" + (dalvikMax / 1024) + " total=" + (runtime.totalMemory() / 1024) + " used=" + (dalvikUsed / 1024));
                    mSomeActivitiesChanged = false;
                    try {
                        mgr.releaseSomeActivities(mAppThread);
                    } catch (RemoteException e) {
                        throw e.rethrowFromSystemServer();
                    }
                }
            }
        });
    } else {
        // Don't set application object here -- if the system crashes,
        // we can't display an alert, we just want to die die die.
        android.ddm.DdmHandleAppName.setAppName("system_process", UserHandle.myUserId());
        try {
            mInstrumentation = new Instrumentation();
            mInstrumentation.basicInit(this);
            ContextImpl context = ContextImpl.createAppContext(this, getSystemContext().mPackageInfo);
            mInitialApplication = context.mPackageInfo.makeApplication(true, null);
            mInitialApplication.onCreate();
        } catch (Exception e) {
            throw new RuntimeException("Unable to instantiate Application():" + e.toString(), e);
        }
    }
    // add dropbox logging to libcore
    DropBox.setReporter(new DropBoxReporter());
    ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -> {
        synchronized (mResourcesManager) {
            // the view hierarchy will be informed about it.
            if (mResourcesManager.applyConfigurationToResourcesLocked(globalConfig, null)) {
                updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(), mResourcesManager.getConfiguration().getLocales());
                // This actually changed the resources! Tell everyone about it.
                if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(globalConfig)) {
                    mPendingConfiguration = globalConfig;
                    sendMessage(H.CONFIGURATION_CHANGED, globalConfig);
                }
            }
        }
    };
    ViewRootImpl.addConfigCallback(configChangedCallback);
}
#method_after
@UnsupportedAppUsage
private void attach(boolean system, long startSeq) {
    sCurrentActivityThread = this;
    mSystemThread = system;
    if (!system) {
        ViewRootImpl.addFirstDrawHandler(new Runnable() {

            @Override
            public void run() {
                ensureJitEnabled();
            }
        });
        android.ddm.DdmHandleAppName.setAppName("<pre-initialized>", UserHandle.myUserId());
        RuntimeInit.setApplicationObject(mAppThread.asBinder());
        final IActivityManager mgr = ActivityManager.getService();
        try {
            mgr.attachApplication(mAppThread, startSeq);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
        // Watch for getting close to heap limit.
        BinderInternal.addGcWatcher(new Runnable() {

            @Override
            public void run() {
                if (!mSomeActivitiesChanged) {
                    return;
                }
                Runtime runtime = Runtime.getRuntime();
                long dalvikMax = runtime.maxMemory();
                long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();
                if (dalvikUsed > ((3 * dalvikMax) / 4)) {
                    if (DEBUG_MEMORY_TRIM)
                        Slog.d(TAG, "Dalvik max=" + (dalvikMax / 1024) + " total=" + (runtime.totalMemory() / 1024) + " used=" + (dalvikUsed / 1024));
                    mSomeActivitiesChanged = false;
                    try {
                        mgr.releaseSomeActivities(mAppThread);
                    } catch (RemoteException e) {
                        throw e.rethrowFromSystemServer();
                    }
                }
            }
        });
    } else {
        // Don't set application object here -- if the system crashes,
        // we can't display an alert, we just want to die die die.
        android.ddm.DdmHandleAppName.setAppName("system_process", UserHandle.myUserId());
        try {
            mInstrumentation = new Instrumentation();
            mInstrumentation.basicInit(this);
            ContextImpl context = ContextImpl.createAppContext(this, getSystemContext().mPackageInfo);
            mInitialApplication = context.mPackageInfo.makeApplication(true, null);
            mInitialApplication.onCreate();
        } catch (Exception e) {
            throw new RuntimeException("Unable to instantiate Application():" + e.toString(), e);
        }
    }
    ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -> {
        synchronized (mResourcesManager) {
            // the view hierarchy will be informed about it.
            if (mResourcesManager.applyConfigurationToResourcesLocked(globalConfig, null)) {
                updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(), mResourcesManager.getConfiguration().getLocales());
                // This actually changed the resources! Tell everyone about it.
                if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(globalConfig)) {
                    mPendingConfiguration = globalConfig;
                    sendMessage(H.CONFIGURATION_CHANGED, globalConfig);
                }
            }
        }
    };
    ViewRootImpl.addConfigCallback(configChangedCallback);
}
#end_block

#method_before
public static void main(String[] args) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");
    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);
    Environment.initForCurrentUser();
    // Set the reporter for event logging in libcore
    EventLogger.setReporter(new EventLoggingReporter());
    // Make sure TrustedCertificateStore looks in the right place for CA certificates
    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
    TrustedCertificateStore.setDefaultUserDirectory(configDir);
    Process.setArgV0("<pre-initialized>");
    Looper.prepareMainLooper();
    // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.
    // It will be in the format "seq=114"
    long startSeq = 0;
    if (args != null) {
        for (int i = args.length - 1; i >= 0; --i) {
            if (args[i] != null && args[i].startsWith(PROC_START_SEQ_IDENT)) {
                startSeq = Long.parseLong(args[i].substring(PROC_START_SEQ_IDENT.length()));
            }
        }
    }
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    if (false) {
        Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread"));
    }
    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
#method_after
public static void main(String[] args) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");
    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);
    Environment.initForCurrentUser();
    // Make sure TrustedCertificateStore looks in the right place for CA certificates
    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
    TrustedCertificateStore.setDefaultUserDirectory(configDir);
    Process.setArgV0("<pre-initialized>");
    Looper.prepareMainLooper();
    // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.
    // It will be in the format "seq=114"
    long startSeq = 0;
    if (args != null) {
        for (int i = args.length - 1; i >= 0; --i) {
            if (args[i] != null && args[i].startsWith(PROC_START_SEQ_IDENT)) {
                startSeq = Long.parseLong(args[i].substring(PROC_START_SEQ_IDENT.length()));
            }
        }
    }
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    if (false) {
        Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread"));
    }
    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
#end_block

#method_before
public boolean getLockdown() {
    return mLockdown;
}
#method_after
public synchronized boolean getLockdown() {
    return mLockdown;
}
#end_block

#method_before
@GuardedBy("this")
private boolean setAlwaysOnPackageInternal(String packageName, boolean lockdown) {
    if (VpnConfig.LEGACY_VPN.equals(packageName)) {
        Log.w(TAG, "Not setting legacy VPN \"" + packageName + "\" as always-on.");
        return false;
    }
    if (packageName != null) {
        // Pre-authorize new always-on VPN package.
        if (!setPackageAuthorization(packageName, true)) {
            return false;
        }
        mAlwaysOn = true;
    } else {
        packageName = VpnConfig.LEGACY_VPN;
        mAlwaysOn = false;
    }
    mLockdown = (mAlwaysOn && lockdown);
    if (isCurrentPreparedPackage(packageName)) {
        updateAlwaysOnNotification(mNetworkInfo.getDetailedState());
    } else {
        // Prepare this app. The notification will update as a side-effect of updateState().
        prepareInternal(packageName);
    }
    maybeRegisterPackageChangeReceiverLocked(packageName);
    setVpnForcedLocked(mLockdown);
    return true;
}
#method_after
@GuardedBy("this")
private boolean setAlwaysOnPackageInternal(String packageName, boolean lockdown) {
    if (VpnConfig.LEGACY_VPN.equals(packageName)) {
        Log.w(TAG, "Not setting legacy VPN \"" + packageName + "\" as always-on.");
        return false;
    }
    if (packageName != null) {
        // Pre-authorize new always-on VPN package.
        if (!setPackageAuthorization(packageName, true)) {
            return false;
        }
        mAlwaysOn = true;
    } else {
        packageName = VpnConfig.LEGACY_VPN;
        mAlwaysOn = false;
    }
    mLockdown = (mAlwaysOn && lockdown);
    if (isCurrentPreparedPackage(packageName)) {
        updateAlwaysOnNotification(mNetworkInfo.getDetailedState());
    } else {
        // Prepare this app. The notification will update as a side-effect of updateState().
        prepareInternal(packageName);
    }
    setVpnForcedLocked(mLockdown);
    return true;
}
#end_block

#method_before
private LinkProperties makeLinkProperties() {
    boolean allowIPv4 = mConfig.allowIPv4;
    boolean allowIPv6 = mConfig.allowIPv6;
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(mInterface);
    if (mConfig.addresses != null) {
        for (LinkAddress address : mConfig.addresses) {
            lp.addLinkAddress(address);
            allowIPv4 |= address.getAddress() instanceof Inet4Address;
            allowIPv6 |= address.getAddress() instanceof Inet6Address;
        }
    }
    if (mConfig.routes != null) {
        for (RouteInfo route : mConfig.routes) {
            lp.addRoute(route);
            InetAddress address = route.getDestination().getAddress();
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    if (mConfig.dnsServers != null) {
        for (String dnsServer : mConfig.dnsServers) {
            InetAddress address = InetAddress.parseNumericAddress(dnsServer);
            lp.addDnsServer(address);
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    if (mConfig.proxyInfo != null) {
        lp.setHttpProxy(mConfig.proxyInfo);
    }
    if (!allowIPv4) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet4Address.ANY, 0), RTN_UNREACHABLE));
    }
    if (!allowIPv6) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet6Address.ANY, 0), RTN_UNREACHABLE));
    }
    // Concatenate search domains into a string.
    StringBuilder buffer = new StringBuilder();
    if (mConfig.searchDomains != null) {
        for (String domain : mConfig.searchDomains) {
            buffer.append(domain).append(' ');
        }
    }
    lp.setDomains(buffer.toString().trim());
    return lp;
}
#method_after
private LinkProperties makeLinkProperties() {
    boolean allowIPv4 = mConfig.allowIPv4;
    boolean allowIPv6 = mConfig.allowIPv6;
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(mInterface);
    if (mConfig.addresses != null) {
        for (LinkAddress address : mConfig.addresses) {
            lp.addLinkAddress(address);
            allowIPv4 |= address.getAddress() instanceof Inet4Address;
            allowIPv6 |= address.getAddress() instanceof Inet6Address;
        }
    }
    if (mConfig.routes != null) {
        for (RouteInfo route : mConfig.routes) {
            lp.addRoute(route);
            InetAddress address = route.getDestination().getAddress();
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    if (mConfig.dnsServers != null) {
        for (String dnsServer : mConfig.dnsServers) {
            InetAddress address = InetAddress.parseNumericAddress(dnsServer);
            lp.addDnsServer(address);
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    lp.setHttpProxy(mConfig.proxyInfo);
    if (!allowIPv4) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet4Address.ANY, 0), RTN_UNREACHABLE));
    }
    if (!allowIPv6) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet6Address.ANY, 0), RTN_UNREACHABLE));
    }
    // Concatenate search domains into a string.
    StringBuilder buffer = new StringBuilder();
    if (mConfig.searchDomains != null) {
        for (String domain : mConfig.searchDomains) {
            buffer.append(domain).append(' ');
        }
    }
    lp.setDomains(buffer.toString().trim());
    return lp;
}
#end_block

#method_before
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdown(false);
    mAlwaysOn = false;
    unregisterPackageChangeReceiverLocked();
    // Quit any active connections
    agentDisconnect();
}
#method_after
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdown(false);
    mAlwaysOn = false;
    // Quit any active connections
    agentDisconnect();
}
#end_block

#method_before
private NetworkCapabilities networkCapabilitiesRestrictedForCallerPermissions(NetworkCapabilities nc, int callerPid, int callerUid) {
    final NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (!checkSettingsPermission(callerPid, callerUid)) {
        newNc.setUids(null);
        newNc.setSSID(null);
    }
    return newNc;
}
#method_after
private NetworkCapabilities networkCapabilitiesRestrictedForCallerPermissions(NetworkCapabilities nc, int callerPid, int callerUid) {
    final NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (!checkSettingsPermission(callerPid, callerUid)) {
        newNc.setUids(null);
        newNc.setSSID(null);
    }
    if (newNc.getNetworkSpecifier() != null) {
        newNc.setNetworkSpecifier(newNc.getNetworkSpecifier().redact());
    }
    return newNc;
}
#end_block

#method_before
void systemReady() {
    mProxyTracker.loadGlobalProxy();
    registerNetdEventCallback();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Create network requests for always-on networks.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_ALWAYS_ON_NETWORKS));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#method_after
void systemReady() {
    mProxyTracker.loadGlobalProxy();
    registerNetdEventCallback();
    mTethering.systemReady();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Create network requests for always-on networks.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_ALWAYS_ON_NETWORKS));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#end_block

#method_before
private void updateTcpBufferSizes(String tcpBufferSizes) {
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        final String prefix = "/sys/kernel/ipv4/tcp_";
        FileUtils.stringToFile(prefix + "rmem_min", values[0]);
        FileUtils.stringToFile(prefix + "rmem_def", values[1]);
        FileUtils.stringToFile(prefix + "rmem_max", values[2]);
        FileUtils.stringToFile(prefix + "wmem_min", values[3]);
        FileUtils.stringToFile(prefix + "wmem_def", values[4]);
        FileUtils.stringToFile(prefix + "wmem_max", values[5]);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (IOException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#method_after
private void updateTcpBufferSizes(String tcpBufferSizes) {
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        String rmemValues = String.join(" ", values[0], values[1], values[2]);
        String wmemValues = String.join(" ", values[3], values[4], values[5]);
        mNetd.setTcpRWmemorySize(rmemValues, wmemValues);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (RemoteException | ServiceSpecificException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#end_block

#method_before
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mName);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#method_after
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid)
                        handleFreshlyValidatedNetwork(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid)
                        handleFreshlyValidatedNetwork(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#end_block

#method_before
private boolean networkRequiresValidation(NetworkAgentInfo nai) {
    return NetworkMonitor.isValidationRequired(mDefaultRequest.networkCapabilities, nai.networkCapabilities);
}
#method_after
private boolean networkRequiresValidation(NetworkAgentInfo nai) {
    return isValidationRequired(nai.networkCapabilities);
}
#end_block

#method_before
private void handlePerNetworkPrivateDnsConfig(NetworkAgentInfo nai, PrivateDnsConfig cfg) {
    // Internet access and therefore also require validation.
    if (!networkRequiresValidation(nai))
        return;
    // Notify the NetworkMonitor thread in case it needs to cancel or
    // schedule DNS resolutions. If a DNS resolution is required the
    // result will be sent back to us.
    nai.networkMonitor.notifyPrivateDnsSettingsChanged(cfg);
    // With Private DNS bypass support, we can proceed to update the
    // Private DNS config immediately, even if we're in strict mode
    // and have not yet resolved the provider name into a set of IPs.
    updatePrivateDns(nai, cfg);
}
#method_after
private void handlePerNetworkPrivateDnsConfig(NetworkAgentInfo nai, PrivateDnsConfig cfg) {
    // Internet access and therefore also require validation.
    if (!networkRequiresValidation(nai))
        return;
    // result will be sent back to us.
    try {
        nai.networkMonitor().notifyPrivateDnsChanged(cfg.toParcel());
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    // With Private DNS bypass support, we can proceed to update the
    // Private DNS config immediately, even if we're in strict mode
    // and have not yet resolved the provider name into a set of IPs.
    updatePrivateDns(nai, cfg);
}
#end_block

#method_before
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
        // As the active or bound network changes for apps, broadcast the default proxy, as
        // apps may need to update their proxy data.
        mProxyTracker.sendProxyBroadcast();
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#method_after
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#end_block

#method_before
@Override
public void startCaptivePortalApp(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.post(() -> {
        NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai == null)
            return;
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
            return;
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_LAUNCH_CAPTIVE_PORTAL_APP);
    });
}
#method_after
@Override
public void startCaptivePortalApp(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.post(() -> {
        NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai == null)
            return;
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
            return;
        try {
            nai.networkMonitor().launchCaptivePortalApp();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
    });
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                final Pair<NetworkAgentInfo, INetworkMonitor> arg = (Pair<NetworkAgentInfo, INetworkMonitor>) msg.obj;
                handleRegisterNetworkAgent(arg.first, arg.second);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    // this several times is fine.
                    try {
                        nai.networkMonitor().notifySystemReady();
                    } catch (RemoteException e) {
                        e.rethrowFromSystemServer();
                    }
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
    }
}
#end_block

#method_before
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    nai.networkMonitor.forceReevaluation(uid);
}
#method_after
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    try {
        nai.networkMonitor().forceReevaluation(uid);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Override
public ProxyInfo getProxyForNetwork(Network network) {
    final ProxyInfo globalProxy = mProxyTracker.getGlobalProxy();
    if (globalProxy != null)
        return globalProxy;
    NetworkAgentInfo nai;
    if (network == null) {
        // Get the network associated with the calling UID.
        Network activeNetwork = getActiveNetworkForUidInternal(Binder.getCallingUid(), false);
        if (activeNetwork != null) {
            nai = getNetworkAgentInfoForNetwork(activeNetwork);
            synchronized (nai) {
                if (nai != null) {
                    return nai.linkProperties.getHttpProxy();
                }
            }
        }
        // on the network link.
        return mProxyTracker.getDefaultProxy();
    } else if (!NetworkUtils.queryUserAccess(Binder.getCallingUid(), network.netId)) {
        // No proxy info available if the calling UID does not have network access.
        return null;
    }
    // Don't call getLinkProperties() as it requires ACCESS_NETWORK_STATE permission, which
    // caller may not have.
    nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null)
        return null;
    synchronized (nai) {
        final ProxyInfo proxyInfo = nai.linkProperties.getHttpProxy();
        if (proxyInfo == null)
            return null;
        return new ProxyInfo(proxyInfo);
    }
}
#method_after
@Override
public ProxyInfo getProxyForNetwork(Network network) {
    final ProxyInfo globalProxy = mProxyTracker.getGlobalProxy();
    if (globalProxy != null)
        return globalProxy;
    if (network == null) {
        // Get the network associated with the calling UID.
        final Network activeNetwork = getActiveNetworkForUidInternal(Binder.getCallingUid(), true);
        if (activeNetwork == null) {
            return null;
        }
        return getLinkPropertiesProxyInfo(activeNetwork);
    } else if (queryUserAccess(Binder.getCallingUid(), network.netId)) {
        // caller may not have.
        return getLinkPropertiesProxyInfo(network);
    }
    // No proxy info available if the calling UID does not have network access.
    return null;
}
#end_block

#method_before
// If the proxy has changed from oldLp to newLp, resend proxy broadcast with default proxy.
// This method gets called when any network changes proxy, but the broadcast only ever contains
// the default proxy (even if it hasn't changed).
// TODO: Deprecate the broadcast extras as they aren't necessarily applicable in a multi-network
// world where an app might be bound to a non-default network. The broadcast extras are broken
private void updateProxy(LinkProperties newLp, LinkProperties oldLp) {
    ProxyInfo newProxyInfo = newLp == null ? null : newLp.getHttpProxy();
    ProxyInfo oldProxyInfo = oldLp == null ? null : oldLp.getHttpProxy();
    if (!ProxyTracker.proxyInfoEqual(newProxyInfo, oldProxyInfo)) {
        mProxyTracker.sendProxyBroadcast();
    }
}
#method_after
// If the proxy has changed from oldLp to newLp, resend proxy broadcast. This method gets called
// when any network changes proxy.
// TODO: Remove usage of broadcast extras as they are deprecated and not applicable in a
private void updateProxy(LinkProperties newLp, LinkProperties oldLp) {
    ProxyInfo newProxyInfo = newLp == null ? null : newLp.getHttpProxy();
    ProxyInfo oldProxyInfo = oldLp == null ? null : oldLp.getHttpProxy();
    if (!ProxyTracker.proxyInfoEqual(newProxyInfo, oldProxyInfo)) {
        mProxyTracker.sendProxyBroadcast();
    }
}
#end_block

#method_before
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNetwork = getDefaultNetwork();
        if (defaultNetwork != null && defaultNetwork.linkProperties != null) {
            info.primaryUnderlyingIface = getDefaultNetwork().linkProperties.getInterfaceName();
            if (defaultNetwork.isVPN()) {
                ProxyInfo vpnProxyInfo = defaultNetwork.linkProperties.getHttpProxy();
                info.vpnProxyHost = vpnProxyInfo.getHost();
                info.vpnProxyPort = vpnProxyInfo.getPort();
            }
        }
    } else if (underlyingNetworks.length > 0) {
        LinkProperties linkProperties = getLinkProperties(underlyingNetworks[0]);
        if (linkProperties != null) {
            info.primaryUnderlyingIface = linkProperties.getInterfaceName();
        }
    }
    return info.primaryUnderlyingIface == null ? null : info;
}
#method_after
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNetwork = getDefaultNetwork();
        if (defaultNetwork != null && defaultNetwork.linkProperties != null) {
            info.primaryUnderlyingIface = getDefaultNetwork().linkProperties.getInterfaceName();
        }
    } else if (underlyingNetworks.length > 0) {
        LinkProperties linkProperties = getLinkProperties(underlyingNetworks[0]);
        if (linkProperties != null) {
            info.primaryUnderlyingIface = linkProperties.getInterfaceName();
        }
    }
    return info.primaryUnderlyingIface == null ? null : info;
}
#end_block

#method_before
private void onPackageRemoved(String packageName, int uid) {
    if (TextUtils.isEmpty(packageName) || uid < 0) {
        Slog.wtf(TAG, "Invalid package in onPackageRemoved: " + packageName + " | " + uid);
        return;
    }
    mPermissionMonitor.onPackageRemoved(uid);
}
#method_after
private void onPackageRemoved(String packageName, int uid, boolean isReplacing) {
    if (TextUtils.isEmpty(packageName) || uid < 0) {
        Slog.wtf(TAG, "Invalid package in onPackageRemoved: " + packageName + " | " + uid);
        return;
    }
    mPermissionMonitor.onPackageRemoved(uid);
    final int userId = UserHandle.getUserId(uid);
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            return;
        }
        // Legacy always-on VPN won't be affected since the package name is not set.
        if (TextUtils.equals(vpn.getAlwaysOnPackage(), packageName) && !isReplacing) {
            Slog.d(TAG, "Removing always-on VPN package " + packageName + " for user " + userId);
            vpn.setAlwaysOnPackage(null, false);
        }
    }
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, name);
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        mContext.getSystemService(NetworkStack.class).makeNetworkMonitor(nai.network, name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#end_block

#method_before
private void handleRegisterNetworkAgent(NetworkAgentInfo nai) {
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#method_after
private void handleRegisterNetworkAgent(NetworkAgentInfo nai, INetworkMonitor networkMonitor) {
    nai.onNetworkMonitorCreated(networkMonitor);
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    synchronized (this) {
        if (mSystemReady) {
            try {
                networkMonitor.notifySystemReady();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
        }
    }
    try {
        networkMonitor.start();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop clat accordingly to network state.
        networkAgent.updateClat(mNMS);
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop clat accordingly to network state.
        networkAgent.updateClat(mNMS);
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            try {
                networkAgent.networkMonitor().notifyLinkPropertiesChanged();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                // For this notification, arg1 contains the blocked status.
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_BLK_CHANGED:
            {
                maybeLogBlockedStatusChanged(nri, networkAgent.network, arg1 != 0);
                msg.arg1 = arg1;
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                // For this notification, arg1 contains the blocked status.
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_BLK_CHANGED:
            {
                maybeLogBlockedStatusChanged(nri, networkAgent.network, arg1 != 0);
                msg.arg1 = arg1;
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#method_after
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            networkAgent.networkMonitor().notifyNetworkConnected();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitor.getCaptivePortalServerHttpUrl(mContext);
}
#method_after
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitorUtils.getCaptivePortalServerHttpUrl(mContext);
}
#end_block

#method_before
private Vpn enforceActiveVpnOrNetworkStackPermission() {
    if (checkNetworkStackPermission()) {
        return null;
    }
    final int uid = Binder.getCallingUid();
    final int user = UserHandle.getUserId(uid);
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(user);
        try {
            if (vpn.getVpnInfo().ownerUid == uid)
                return vpn;
        } catch (NullPointerException e) {
        /* vpn is null, or VPN is not connected and getVpnInfo() is null. */
        }
    }
    throw new SecurityException("App must either be an active VPN or have the NETWORK_STACK " + "permission");
}
#method_after
private Vpn enforceActiveVpnOrNetworkStackPermission() {
    if (checkNetworkStackPermission()) {
        return null;
    }
    synchronized (mVpns) {
        Vpn vpn = getVpnIfOwner();
        if (vpn != null) {
            return vpn;
        }
    }
    throw new SecurityException("App must either be an active VPN or have the NETWORK_STACK " + "permission");
}
#end_block

#method_before
public void sendProxyBroadcast() {
    final ProxyInfo defaultProxy = getDefaultProxy();
    final ProxyInfo proxyInfo = null != defaultProxy ? defaultProxy : new ProxyInfo("", 0, "");
    if (mPacManager.setCurrentProxyScriptUrl(proxyInfo))
        return;
    if (DBG)
        Slog.d(TAG, "sending Proxy Broadcast for " + proxyInfo);
    Intent intent = new Intent(Proxy.PROXY_CHANGE_ACTION);
    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(Proxy.EXTRA_PROXY_INFO, proxyInfo);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
public void sendProxyBroadcast() {
    final ProxyInfo defaultProxy = getDefaultProxy();
    final ProxyInfo proxyInfo = null != defaultProxy ? defaultProxy : new ProxyInfo("", 0, "");
    if (mPacManager.setCurrentProxyScriptUrl(proxyInfo) == PacManager.ToSendOrNotToSendBroadcast.DONT_SEND_BROADCAST) {
        return;
    }
    if (DBG)
        Slog.d(TAG, "sending Proxy Broadcast for " + proxyInfo);
    Intent intent = new Intent(Proxy.PROXY_CHANGE_ACTION);
    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(Proxy.EXTRA_PROXY_INFO, proxyInfo);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Test
@SmallTest
public void testChangeSIMProperty() {
    int dataRoaming = 1;
    int iconTint = 1;
    String disName = "TESTING";
    String disNum = "12345";
    boolean isOpportunistic = true;
    boolean isMetered = false;
    testInsertSim();
    /* Get SUB ID */
    int[] subIds = mSubscriptionControllerUT.getActiveSubIdList();
    assertTrue(subIds != null && subIds.length != 0);
    int subID = subIds[0];
    /* Getting, there is no direct getter function for each fields of property */
    SubscriptionInfo subInfo = mSubscriptionControllerUT.getActiveSubscriptionInfo(subID, mCallingPackage);
    // isMetered should initialize as true
    assertTrue(subInfo.isMetered());
    /* Setting */
    mSubscriptionControllerUT.setDisplayName(disName, subID);
    mSubscriptionControllerUT.setDataRoaming(dataRoaming, subID);
    mSubscriptionControllerUT.setDisplayNumber(disNum, subID);
    mSubscriptionControllerUT.setIconTint(iconTint, subID);
    mSubscriptionControllerUT.setOpportunistic(isOpportunistic, subID);
    mSubscriptionControllerUT.setMetered(isMetered, subID);
    subInfo = mSubscriptionControllerUT.getActiveSubscriptionInfo(subID, mCallingPackage);
    assertNotNull(subInfo);
    assertEquals(dataRoaming, subInfo.getDataRoaming());
    assertEquals(disName, subInfo.getDisplayName());
    assertEquals(iconTint, subInfo.getIconTint());
    assertEquals(disNum, subInfo.getNumber());
    assertEquals(isOpportunistic, subInfo.isOpportunistic());
    assertEquals(isMetered, subInfo.isMetered());
    /* verify broadcast intent */
    ArgumentCaptor<Intent> captorIntent = ArgumentCaptor.forClass(Intent.class);
    verify(mContext, atLeast(1)).sendBroadcast(captorIntent.capture());
    assertEquals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED, captorIntent.getValue().getAction());
}
#method_after
@Test
@SmallTest
public void testChangeSIMProperty() {
    int dataRoaming = 1;
    int iconTint = 1;
    String disName = "TESTING";
    String disNum = "12345";
    boolean isOpportunistic = true;
    boolean isMetered = false;
    testInsertSim();
    /* Get SUB ID */
    int[] subIds = mSubscriptionControllerUT.getActiveSubIdList();
    assertTrue(subIds != null && subIds.length != 0);
    int subID = subIds[0];
    /* Getting, there is no direct getter function for each fields of property */
    SubscriptionInfo subInfo = mSubscriptionControllerUT.getActiveSubscriptionInfo(subID, mCallingPackage);
    // isMetered should initialize as true
    assertTrue(subInfo.isMetered());
    /* Setting */
    mSubscriptionControllerUT.setDisplayName(disName, subID);
    mSubscriptionControllerUT.setDataRoaming(dataRoaming, subID);
    mSubscriptionControllerUT.setDisplayNumber(disNum, subID);
    mSubscriptionControllerUT.setIconTint(iconTint, subID);
    mSubscriptionControllerUT.setOpportunistic(isOpportunistic, subID, mCallingPackage);
    mSubscriptionControllerUT.setMetered(isMetered, subID, mCallingPackage);
    subInfo = mSubscriptionControllerUT.getActiveSubscriptionInfo(subID, mCallingPackage);
    assertNotNull(subInfo);
    assertEquals(dataRoaming, subInfo.getDataRoaming());
    assertEquals(disName, subInfo.getDisplayName());
    assertEquals(iconTint, subInfo.getIconTint());
    assertEquals(disNum, subInfo.getNumber());
    assertEquals(isOpportunistic, subInfo.isOpportunistic());
    assertEquals(isMetered, subInfo.isMetered());
    /* verify broadcast intent */
    ArgumentCaptor<Intent> captorIntent = ArgumentCaptor.forClass(Intent.class);
    verify(mContext, atLeast(1)).sendBroadcast(captorIntent.capture());
    assertEquals(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED, captorIntent.getValue().getAction());
}
#end_block

#method_before
@Test
@SmallTest
public void testOpptSubInfoListChanged() throws Exception {
    registerMockTelephonyRegistry();
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    testInsertSim();
    mSubscriptionControllerUT.addSubInfoRecord("test2", 0);
    // Neither sub1 or sub2 are opportunistic. So getOpportunisticSubscriptions
    // should return empty list and no callback triggered.
    List<SubscriptionInfo> opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(mCallingPackage);
    assertTrue(opptSubList.isEmpty());
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    // Setting sub2 as opportunistic should trigger callback.
    mSubscriptionControllerUT.setOpportunistic(true, 2);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(mCallingPackage);
    assertEquals(1, opptSubList.size());
    assertEquals("test2", opptSubList.get(0).getIccId());
    // Changing non-opportunistic sub1 shouldn't trigger callback.
    mSubscriptionControllerUT.setDisplayName("DisplayName", 1);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    mSubscriptionControllerUT.setDisplayName("DisplayName", 2);
    verify(mTelephonyRegisteryMock, times(2)).notifyOpportunisticSubscriptionInfoChanged();
}
#method_after
@Test
@SmallTest
public void testOpptSubInfoListChanged() throws Exception {
    registerMockTelephonyRegistry();
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    testInsertSim();
    mSubscriptionControllerUT.addSubInfoRecord("test2", 0);
    // Neither sub1 or sub2 are opportunistic. So getOpportunisticSubscriptions
    // should return empty list and no callback triggered.
    List<SubscriptionInfo> opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(mCallingPackage);
    assertTrue(opptSubList.isEmpty());
    verify(mTelephonyRegisteryMock, times(0)).notifyOpportunisticSubscriptionInfoChanged();
    // Setting sub2 as opportunistic should trigger callback.
    mSubscriptionControllerUT.setOpportunistic(true, 2, mCallingPackage);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    opptSubList = mSubscriptionControllerUT.getOpportunisticSubscriptions(mCallingPackage);
    assertEquals(1, opptSubList.size());
    assertEquals("test2", opptSubList.get(0).getIccId());
    // Changing non-opportunistic sub1 shouldn't trigger callback.
    mSubscriptionControllerUT.setDisplayName("DisplayName", 1);
    verify(mTelephonyRegisteryMock, times(1)).notifyOpportunisticSubscriptionInfoChanged();
    mSubscriptionControllerUT.setDisplayName("DisplayName", 2);
    verify(mTelephonyRegisteryMock, times(2)).notifyOpportunisticSubscriptionInfoChanged();
}
#end_block

#method_before
@Test
@SmallTest
public void testSetSubscriptionGroupWithCarrierPrivilegePermission() throws Exception {
    testInsertSim();
    // Adding a second profile and mark as embedded.
    mSubscriptionControllerUT.addSubInfoRecord("test2", 1);
    ContentValues values = new ContentValues();
    values.put(SubscriptionManager.IS_EMBEDDED, 1);
    mFakeTelephonyProvider.update(SubscriptionManager.CONTENT_URI, values, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + 2, null);
    mSubscriptionControllerUT.refreshCachedActiveSubscriptionInfoList();
    mContextFixture.removeCallingOrSelfPermission(ContextFixture.PERMISSION_ENABLE_ALL);
    mContextFixture.addCallingOrSelfPermission(Manifest.permission.READ_PHONE_STATE);
    int[] subIdList = new int[] { 1, 2 };
    // It should fail since it has no permission.
    try {
        mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
        fail("setSubscriptionGroup should fail with no permission.");
    } catch (SecurityException e) {
    // Expected result.
    }
    doReturn(true).when(mTelephonyManager).hasCarrierPrivileges(1);
    try {
        mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
        fail("setSubscriptionGroup should fail with no permission on sub 2.");
    } catch (SecurityException e) {
    // Expected result.
    }
    doReturn(true).when(mTelephonyManager).hasCarrierPrivileges(2);
    String groupId = mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
    assertNotEquals(null, groupId);
    List<SubscriptionInfo> subInfoList = mSubscriptionControllerUT.getActiveSubscriptionInfoList(mContext.getOpPackageName());
    // Put sub3 into slot 1 to make sub2 inactive.
    mContextFixture.addCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE);
    mSubscriptionControllerUT.addSubInfoRecord("test3", 1);
    mContextFixture.removeCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE);
    // As sub2 is inactive, it will checks carrier privilege against access rules in the db.
    doReturn(true).when(mSubscriptionManager).canManageSubscription(eq(subInfoList.get(1)), anyString());
    String newGroupId = mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
    assertNotEquals(null, newGroupId);
    assertNotEquals(groupId, newGroupId);
}
#method_after
@Test
@SmallTest
public void testSetSubscriptionGroupWithCarrierPrivilegePermission() throws Exception {
    testInsertSim();
    // Adding a second profile and mark as embedded.
    // TODO b/123300875 slot index 1 is not expected to be valid
    mSubscriptionControllerUT.addSubInfoRecord("test2", 1);
    ContentValues values = new ContentValues();
    values.put(SubscriptionManager.IS_EMBEDDED, 1);
    mFakeTelephonyProvider.update(SubscriptionManager.CONTENT_URI, values, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + 2, null);
    mSubscriptionControllerUT.refreshCachedActiveSubscriptionInfoList();
    mContextFixture.removeCallingOrSelfPermission(ContextFixture.PERMISSION_ENABLE_ALL);
    mContextFixture.addCallingOrSelfPermission(Manifest.permission.READ_PHONE_STATE);
    int[] subIdList = new int[] { 1, 2 };
    // It should fail since it has no permission.
    try {
        mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
        fail("setSubscriptionGroup should fail with no permission.");
    } catch (SecurityException e) {
    // Expected result.
    }
    doReturn(true).when(mTelephonyManager).hasCarrierPrivileges(1);
    try {
        mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
        fail("setSubscriptionGroup should fail with no permission on sub 2.");
    } catch (SecurityException e) {
    // Expected result.
    }
    doReturn(true).when(mTelephonyManager).hasCarrierPrivileges(2);
    String groupId = mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
    assertNotEquals(null, groupId);
    List<SubscriptionInfo> subInfoList = mSubscriptionControllerUT.getActiveSubscriptionInfoList(mContext.getOpPackageName());
    // Put sub3 into slot 1 to make sub2 inactive.
    mContextFixture.addCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE);
    // TODO b/123300875 slot index 1 is not expected to be valid
    mSubscriptionControllerUT.addSubInfoRecord("test3", 1);
    mContextFixture.removeCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE);
    // As sub2 is inactive, it will checks carrier privilege against access rules in the db.
    doReturn(true).when(mSubscriptionManager).canManageSubscription(eq(subInfoList.get(1)), anyString());
    String newGroupId = mSubscriptionControllerUT.setSubscriptionGroup(subIdList, mContext.getOpPackageName());
    assertNotEquals(null, newGroupId);
    assertNotEquals(groupId, newGroupId);
}
#end_block

#method_before
@Test
@SmallTest
public void testGetActiveSubIdList() throws Exception {
    // sub 1
    mSubscriptionControllerUT.addSubInfoRecord("123", 1);
    // sub 2
    mSubscriptionControllerUT.addSubInfoRecord("456", 0);
    // Make sure the return sub ids are sorted by slot index
    assertTrue("active sub ids = " + mSubscriptionControllerUT.getActiveSubIdList(), Arrays.equals(mSubscriptionControllerUT.getActiveSubIdList(), new int[] { 2, 1 }));
}
#method_after
@Test
@SmallTest
public void testGetActiveSubIdList() throws Exception {
    // TODO b/123300875 slot index 1 is not expected to be valid
    // sub 1
    mSubscriptionControllerUT.addSubInfoRecord("123", 1);
    // sub 2
    mSubscriptionControllerUT.addSubInfoRecord("456", 0);
    // Make sure the return sub ids are sorted by slot index
    assertTrue("active sub ids = " + mSubscriptionControllerUT.getActiveSubIdList(), Arrays.equals(mSubscriptionControllerUT.getActiveSubIdList(), new int[] { 2, 1 }));
}
#end_block

#method_before
@Override
@Deprecated
public int[] getSubId(int slotIndex) {
    if (VDBG)
        printStackTrace("[getSubId]+ slotIndex=" + slotIndex);
    // getDefaultSubId which makes a best guess.
    if (slotIndex == SubscriptionManager.DEFAULT_SIM_SLOT_INDEX) {
        slotIndex = getSlotIndex(getDefaultSubId());
        if (VDBG)
            logd("[getSubId] map default slotIndex=" + slotIndex);
    }
    // Check if we've got any SubscriptionInfo records using slotIndexToSubId as a surrogate.
    int size = sSlotIndexToSubIds.size();
    if (size == 0) {
        if (VDBG) {
            logd("[getSubId]- sSlotIndexToSubId.size == 0, return null slotIndex=" + slotIndex);
        }
        return null;
    }
    // Convert ArrayList to array
    ArrayList<Integer> subIds = sSlotIndexToSubIds.get(slotIndex);
    if (subIds != null && subIds.size() > 0) {
        int[] subIdArr = new int[subIds.size()];
        for (int i = 0; i < subIds.size(); i++) {
            subIdArr[i] = subIds.get(i);
        }
        if (VDBG)
            logd("[getSubId]- subIdArr=" + subIdArr);
        return subIdArr;
    } else {
        if (DBG)
            logd("[getSubId]- numSubIds == 0, return null slotIndex=" + slotIndex);
        return null;
    }
}
#method_after
@Override
@Deprecated
public int[] getSubId(int slotIndex) {
    if (VDBG)
        printStackTrace("[getSubId]+ slotIndex=" + slotIndex);
    // getDefaultSubId which makes a best guess.
    if (slotIndex == SubscriptionManager.DEFAULT_SIM_SLOT_INDEX) {
        slotIndex = getSlotIndex(getDefaultSubId());
        if (VDBG)
            logd("[getSubId] map default slotIndex=" + slotIndex);
    }
    // TODO b/123300875 This check should probably be removed once tests are fixed
    if (!SubscriptionManager.isValidSlotIndex(slotIndex)) {
        if (DBG)
            logd("[getSubId]- invalid slotIndex=" + slotIndex);
        return null;
    }
    // Check if we've got any SubscriptionInfo records using slotIndexToSubId as a surrogate.
    int size = sSlotIndexToSubIds.size();
    if (size == 0) {
        if (VDBG) {
            logd("[getSubId]- sSlotIndexToSubIds.size == 0, return null slotIndex=" + slotIndex);
        }
        return null;
    }
    // Convert ArrayList to array
    ArrayList<Integer> subIds = sSlotIndexToSubIds.get(slotIndex);
    if (subIds != null && subIds.size() > 0) {
        int[] subIdArr = new int[subIds.size()];
        for (int i = 0; i < subIds.size(); i++) {
            subIdArr[i] = subIds.get(i);
        }
        if (VDBG)
            logd("[getSubId]- subIdArr=" + subIdArr);
        return subIdArr;
    } else {
        if (DBG)
            logd("[getSubId]- numSubIds == 0, return null slotIndex=" + slotIndex);
        return null;
    }
}
#end_block

#method_before
private synchronized ArrayList<Integer> getActiveSubIdArrayList() {
    // TODO (randolphs): Sort the subIds by slot index
    ArrayList<Integer> allSubs = new ArrayList<>();
    for (int i : sSlotIndexToSubIds.keySet()) {
        allSubs.addAll(sSlotIndexToSubIds.get(i));
    }
    return allSubs;
}
#method_after
private synchronized ArrayList<Integer> getActiveSubIdArrayList() {
    // Clone the sub id list so it can't change out from under us while iterating
    List<Entry<Integer, ArrayList<Integer>>> simInfoList = new ArrayList<>(sSlotIndexToSubIds.entrySet());
    // Put the set of sub ids in slot index order
    Collections.sort(simInfoList, (x, y) -> x.getKey().compareTo(y.getKey()));
    // Collect the sub ids for each slot in turn
    ArrayList<Integer> allSubs = new ArrayList<>();
    for (Entry<Integer, ArrayList<Integer>> slot : simInfoList) {
        allSubs.addAll(slot.getValue());
    }
    return allSubs;
}
#end_block

#method_before
@Override
public int setOpportunistic(boolean opportunistic, int subId) {
    return setSubscriptionProperty(subId, SubscriptionManager.IS_OPPORTUNISTIC, String.valueOf(opportunistic ? 1 : 0));
}
#method_after
@Override
public int setOpportunistic(boolean opportunistic, int subId, String callingPackage) {
    try {
        TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mContext, subId, callingPackage);
    } catch (SecurityException e) {
        // The subscription may be inactive eSIM profile. If so, check the access rule in
        // database.
        enforceCarrierPrivilegeOnInactiveSub(subId, callingPackage, "Caller requires permission on sub " + subId);
    }
    long token = Binder.clearCallingIdentity();
    try {
        int ret = setSubscriptionProperty(subId, SubscriptionManager.IS_OPPORTUNISTIC, String.valueOf(opportunistic ? 1 : 0));
        if (ret != 0)
            notifySubscriptionInfoChanged();
        return ret;
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Override
public int setMetered(boolean isMetered, int subId) {
    return setSubscriptionProperty(subId, SubscriptionManager.IS_METERED, String.valueOf(isMetered ? 1 : 0));
}
#method_after
@Override
public int setMetered(boolean isMetered, int subId, String callingPackage) {
    try {
        TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mContext, subId, callingPackage);
    } catch (SecurityException e) {
        // The subscription may be inactive eSIM profile. If so, check the access rule in
        // database.
        enforceCarrierPrivilegeOnInactiveSub(subId, callingPackage, "Caller requires permission on sub " + subId);
    }
    long token = Binder.clearCallingIdentity();
    try {
        int ret = setSubscriptionProperty(subId, SubscriptionManager.IS_METERED, String.valueOf(isMetered ? 1 : 0));
        if (ret != 0)
            notifySubscriptionInfoChanged();
        return ret;
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
public void setTitleIconStartMargin(@Px int margin) {
    MarginLayoutParams marginParams = (MarginLayoutParams) mTitleIconView.getLayoutParams();
    marginParams.setMarginStart(margin);
}
#method_after
public void setTitleIconStartMargin(@Px int margin) {
    MarginLayoutParams marginParams = (MarginLayoutParams) mTitleIconView.getLayoutParams();
    marginParams.setMarginStart(margin);
    requestLayout();
}
#end_block

#method_before
public void setTitleIconEndMargin(@Px int margin) {
    MarginLayoutParams marginParams = (MarginLayoutParams) mTitleIconView.getLayoutParams();
    marginParams.setMarginEnd(margin);
}
#method_after
public void setTitleIconEndMargin(@Px int margin) {
    MarginLayoutParams marginParams = (MarginLayoutParams) mTitleIconView.getLayoutParams();
    marginParams.setMarginEnd(margin);
    requestLayout();
}
#end_block

#method_before
@Test
public void testSetTitleIconStartMargin() throws Throwable {
    int startMargin = 100;
    int navIconWidth = 100;
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIconContainerWidth(navIconWidth);
        mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
        mToolbar.setTitleIconStartMargin(startMargin);
    });
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin)));
}
#method_after
@Test
public void testSetTitleIconStartMargin() throws Throwable {
    int startMargin = 100;
    int navIconWidth = 100;
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIconContainerWidth(navIconWidth);
        mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
        mToolbar.setTitleIconStartMargin(startMargin);
    });
    onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin)));
}
#end_block

#method_before
@Test
public void testSetTitleIconEndMargin() throws Throwable {
    int endMargin = 100;
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setTitle("Test");
        mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
        mToolbar.setTitleIconEndMargin(endMargin);
    });
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    int iconEnd = mActivity.findViewById(R.id.title_icon).getRight();
    onView(withId(R.id.title)).check(matches(withLeft(iconEnd + endMargin)));
}
#method_after
@Test
public void testSetTitleIconEndMargin() throws Throwable {
    int endMargin = 100;
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
        mToolbar.setTitleIconEndMargin(endMargin);
        mToolbar.setTitle("title");
    });
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    int iconEnd = mActivity.findViewById(R.id.title_icon).getRight();
    onView(withId(R.id.title)).check(matches(withLeft(iconEnd + endMargin)));
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startDiscovery() {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startDiscovery() {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery(getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public List<Integer> getSupportedProfiles() {
    final ArrayList<Integer> supportedProfiles = new ArrayList<Integer>();
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                final long supportedProfilesBitMask = mService.getSupportedProfiles();
                for (int i = 0; i <= BluetoothProfile.MAX_PROFILE_ID; i++) {
                    if ((supportedProfilesBitMask & (1 << i)) != 0) {
                        supportedProfiles.add(i);
                    }
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getSupportedProfiles:", e);
    }
    return supportedProfiles;
}
#method_after
public List<Integer> getSupportedProfiles() {
    final ArrayList<Integer> supportedProfiles = new ArrayList<Integer>();
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                final long supportedProfilesBitMask = mService.getSupportedProfiles();
                for (int i = 0; i <= BluetoothProfile.MAX_PROFILE_ID; i++) {
                    if ((supportedProfilesBitMask & (1 << i)) != 0) {
                        supportedProfiles.add(i);
                    }
                }
            } else {
                // Bluetooth is disabled. Just fill in known supported Profiles
                if (isHearingAidProfileSupported()) {
                    supportedProfiles.add(BluetoothProfile.HEARING_AID);
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getSupportedProfiles:", e);
    }
    return supportedProfiles;
}
#end_block

#method_before
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        Log.e(TAG, "getProfileProxy(): BluetoothHealth is deprecated");
        return false;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        if (isHearingAidProfileSupported()) {
            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        }
        return false;
    } else {
        return false;
    }
}
#end_block

#method_before
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}
#method_after
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}
#end_block

#method_before
public List<Integer> getSupportedProfiles() {
    final ArrayList<Integer> supportedProfiles = new ArrayList<Integer>();
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                final long supportedProfilesBitMask = mService.getSupportedProfiles();
                for (int i = 0; i <= BluetoothProfile.MAX_PROFILE_ID; i++) {
                    if ((supportedProfilesBitMask & (1 << i)) != 0) {
                        supportedProfiles.add(i);
                    }
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getSupportedProfiles:", e);
    }
    return supportedProfiles;
}
#method_after
public List<Integer> getSupportedProfiles() {
    final ArrayList<Integer> supportedProfiles = new ArrayList<Integer>();
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                final long supportedProfilesBitMask = mService.getSupportedProfiles();
                for (int i = 0; i <= BluetoothProfile.MAX_PROFILE_ID; i++) {
                    if ((supportedProfilesBitMask & (1 << i)) != 0) {
                        supportedProfiles.add(i);
                    }
                }
            } else {
                // Bluetooth is disabled. Just fill in known supported Profiles
                if (isHearingAidProfileSupported()) {
                    supportedProfiles.add(BluetoothProfile.HEARING_AID);
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getSupportedProfiles:", e);
    }
    return supportedProfiles;
}
#end_block

#method_before
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        Log.e(TAG, "getProfileProxy(): BluetoothHealth is deprecated");
        return false;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        if (isHearingAidProfileSupported()) {
            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        }
        return false;
    } else {
        return false;
    }
}
#end_block

#method_before
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}
#method_after
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}
#end_block

#method_before
@Override
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(int callingUidUnused, String callingPackage, FileDescriptor bugreportFd, FileDescriptor screenshotFd, int bugreportMode, IDumpstateListener listener) throws RemoteException {
    int callingUid = Binder.getCallingUid();
    // TODO(b/111441001): validate all arguments & ensure primary user
    validate(bugreportMode);
    mAppOps.checkPackage(callingUid, callingPackage);
    mDs = getDumpstateService();
    if (mDs == null) {
        Slog.w(TAG, "Unable to get bugreport service");
        // TODO(b/111441001): pass error on listener
        return;
    }
    mDs.startBugreport(callingUid, callingPackage, bugreportFd, screenshotFd, bugreportMode, listener);
}
#method_after
// TODO(b/111441001): Intercept onFinished here in system server and shutdown
@Override
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(int callingUidUnused, String callingPackage, FileDescriptor bugreportFd, FileDescriptor screenshotFd, int bugreportMode, IDumpstateListener listener) throws RemoteException {
    int callingUid = Binder.getCallingUid();
    // TODO(b/111441001): validate all arguments & ensure primary user
    validate(bugreportMode);
    mAppOps.checkPackage(callingUid, callingPackage);
    mDs = getDumpstateService();
    if (mDs == null) {
        Slog.w(TAG, "Unable to get bugreport service");
        // TODO(b/111441001): pass error on listener
        return;
    }
    mDs.startBugreport(callingUid, callingPackage, bugreportFd, screenshotFd, bugreportMode, listener);
}
#end_block

#method_before
public void systemReady() {
    try {
        ServiceManager.addService(mNetdListener.SERVICE_NAME, mNetdListener);
    } catch (Exception e) {
        Slog.d(TAG, "Netd event service adding failed " + e);
    }
    registerNetdEventCallback();
    if (DBG) {
        final long start = System.currentTimeMillis();
        prepareNativeDaemon();
        final long delta = System.currentTimeMillis() - start;
        Slog.d(TAG, "Prepared in " + delta + "ms");
        return;
    } else {
        prepareNativeDaemon();
    }
}
#method_after
public void systemReady() {
    if (DBG) {
        final long start = System.currentTimeMillis();
        prepareNativeDaemon();
        final long delta = System.currentTimeMillis() - start;
        Slog.d(TAG, "Prepared in " + delta + "ms");
        return;
    } else {
        prepareNativeDaemon();
    }
}
#end_block

#method_before
@Override
public void tetherLimitReached(ITetheringStatsProvider provider) {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    synchronized (mTetheringStatsProviders) {
        if (!mTetheringStatsProviders.containsKey(provider)) {
            return;
        }
        // No current code examines the interface parameter in a global alert. Just pass null.
        notifyLimitReached(LIMIT_GLOBAL_ALERT, null);
    }
}
#method_after
@Override
public void tetherLimitReached(ITetheringStatsProvider provider) {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    synchronized (mTetheringStatsProviders) {
        if (!mTetheringStatsProviders.containsKey(provider)) {
            return;
        }
        // No current code examines the interface parameter in a global alert. Just pass null.
        mDaemonHandler.post(() -> notifyLimitReached(LIMIT_GLOBAL_ALERT, null));
    }
}
#end_block

#method_before
private void connectNativeNetdService() {
    mNetdService = mServices.getNetd();
}
#method_after
private void connectNativeNetdService() {
    mNetdService = mServices.getNetd();
    try {
        mNetdService.registerUnsolicitedEventListener(mNetdUnsolicitedEventListener);
        if (DBG)
            Slog.d(TAG, "Register unsolicited event listener");
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Failed to set Netd unsolicited event listener " + e);
    }
}
#end_block

#method_before
private void prepareNativeDaemon() {
    mBandwidthControlEnabled = false;
    // only enable bandwidth control when support exists
    final boolean hasKernelSupport = new File("/proc/net/xt_qtaguid/ctrl").exists();
    // push any existing quota or UID rules
    synchronized (mQuotaLock) {
        if (hasKernelSupport) {
            Slog.d(TAG, "enabling bandwidth control");
            try {
                mConnector.execute("bandwidth", "enable");
                mBandwidthControlEnabled = true;
            } catch (NativeDaemonConnectorException e) {
                Log.wtf(TAG, "problem enabling bandwidth controls", e);
            }
        } else {
            Slog.i(TAG, "not enabling bandwidth control");
        }
        SystemProperties.set(PROP_QTAGUID_ENABLED, mBandwidthControlEnabled ? "1" : "0");
        mStrictEnabled = true;
        setDataSaverModeEnabled(mDataSaverMode);
        int size = mActiveQuotas.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active quota rules");
            final HashMap<String, Long> activeQuotas = mActiveQuotas;
            mActiveQuotas = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeQuotas.entrySet()) {
                setInterfaceQuota(entry.getKey(), entry.getValue());
            }
        }
        size = mActiveAlerts.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active alert rules");
            final HashMap<String, Long> activeAlerts = mActiveAlerts;
            mActiveAlerts = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeAlerts.entrySet()) {
                setInterfaceAlert(entry.getKey(), entry.getValue());
            }
        }
        SparseBooleanArray uidRejectOnQuota = null;
        SparseBooleanArray uidAcceptOnQuota = null;
        synchronized (mRulesLock) {
            size = mUidRejectOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered blacklist rules");
                uidRejectOnQuota = mUidRejectOnMetered;
                mUidRejectOnMetered = new SparseBooleanArray();
            }
            size = mUidAllowOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered whitelist rules");
                uidAcceptOnQuota = mUidAllowOnMetered;
                mUidAllowOnMetered = new SparseBooleanArray();
            }
        }
        if (uidRejectOnQuota != null) {
            for (int i = 0; i < uidRejectOnQuota.size(); i++) {
                setUidMeteredNetworkBlacklist(uidRejectOnQuota.keyAt(i), uidRejectOnQuota.valueAt(i));
            }
        }
        if (uidAcceptOnQuota != null) {
            for (int i = 0; i < uidAcceptOnQuota.size(); i++) {
                setUidMeteredNetworkWhitelist(uidAcceptOnQuota.keyAt(i), uidAcceptOnQuota.valueAt(i));
            }
        }
        size = mUidCleartextPolicy.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active UID cleartext policies");
            final SparseIntArray local = mUidCleartextPolicy;
            mUidCleartextPolicy = new SparseIntArray();
            for (int i = 0; i < local.size(); i++) {
                setUidCleartextNetworkPolicy(local.keyAt(i), local.valueAt(i));
            }
        }
        setFirewallEnabled(mFirewallEnabled);
        syncFirewallChainLocked(FIREWALL_CHAIN_NONE, "");
        syncFirewallChainLocked(FIREWALL_CHAIN_STANDBY, "standby ");
        syncFirewallChainLocked(FIREWALL_CHAIN_DOZABLE, "dozable ");
        syncFirewallChainLocked(FIREWALL_CHAIN_POWERSAVE, "powersave ");
        final int[] chains = { FIREWALL_CHAIN_STANDBY, FIREWALL_CHAIN_DOZABLE, FIREWALL_CHAIN_POWERSAVE };
        for (int chain : chains) {
            if (getFirewallChainState(chain)) {
                setFirewallChainEnabled(chain, true);
            }
        }
    }
    if (mBandwidthControlEnabled) {
        try {
            getBatteryStats().noteNetworkStatsEnabled();
        } catch (RemoteException e) {
        }
    }
}
#method_after
private void prepareNativeDaemon() {
    // push any existing quota or UID rules
    synchronized (mQuotaLock) {
        // Netd unconditionally enable bandwidth control
        SystemProperties.set(PROP_QTAGUID_ENABLED, "1");
        mStrictEnabled = true;
        setDataSaverModeEnabled(mDataSaverMode);
        int size = mActiveQuotas.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active quota rules");
            final HashMap<String, Long> activeQuotas = mActiveQuotas;
            mActiveQuotas = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeQuotas.entrySet()) {
                setInterfaceQuota(entry.getKey(), entry.getValue());
            }
        }
        size = mActiveAlerts.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active alert rules");
            final HashMap<String, Long> activeAlerts = mActiveAlerts;
            mActiveAlerts = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeAlerts.entrySet()) {
                setInterfaceAlert(entry.getKey(), entry.getValue());
            }
        }
        SparseBooleanArray uidRejectOnQuota = null;
        SparseBooleanArray uidAcceptOnQuota = null;
        synchronized (mRulesLock) {
            size = mUidRejectOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered blacklist rules");
                uidRejectOnQuota = mUidRejectOnMetered;
                mUidRejectOnMetered = new SparseBooleanArray();
            }
            size = mUidAllowOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered whitelist rules");
                uidAcceptOnQuota = mUidAllowOnMetered;
                mUidAllowOnMetered = new SparseBooleanArray();
            }
        }
        if (uidRejectOnQuota != null) {
            for (int i = 0; i < uidRejectOnQuota.size(); i++) {
                setUidMeteredNetworkBlacklist(uidRejectOnQuota.keyAt(i), uidRejectOnQuota.valueAt(i));
            }
        }
        if (uidAcceptOnQuota != null) {
            for (int i = 0; i < uidAcceptOnQuota.size(); i++) {
                setUidMeteredNetworkWhitelist(uidAcceptOnQuota.keyAt(i), uidAcceptOnQuota.valueAt(i));
            }
        }
        size = mUidCleartextPolicy.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active UID cleartext policies");
            final SparseIntArray local = mUidCleartextPolicy;
            mUidCleartextPolicy = new SparseIntArray();
            for (int i = 0; i < local.size(); i++) {
                setUidCleartextNetworkPolicy(local.keyAt(i), local.valueAt(i));
            }
        }
        setFirewallEnabled(mFirewallEnabled);
        syncFirewallChainLocked(FIREWALL_CHAIN_NONE, "");
        syncFirewallChainLocked(FIREWALL_CHAIN_STANDBY, "standby ");
        syncFirewallChainLocked(FIREWALL_CHAIN_DOZABLE, "dozable ");
        syncFirewallChainLocked(FIREWALL_CHAIN_POWERSAVE, "powersave ");
        final int[] chains = { FIREWALL_CHAIN_STANDBY, FIREWALL_CHAIN_DOZABLE, FIREWALL_CHAIN_POWERSAVE };
        for (int chain : chains) {
            if (getFirewallChainState(chain)) {
                setFirewallChainEnabled(chain, true);
            }
        }
    }
    try {
        getBatteryStats().noteNetworkStatsEnabled();
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
@Override
public boolean onEvent(int code, String raw, String[] cooked) {
    String errorMessage = String.format("Invalid event from daemon (%s)", raw);
    switch(code) {
        case NetdResponseCode.InterfaceChange:
            /*
                     * a network interface change occured
                     * Format: "NNN Iface added <name>"
                     *         "NNN Iface removed <name>"
                     *         "NNN Iface changed <name> <up/down>"
                     *         "NNN Iface linkstatus <name> <up/down>"
                     */
            if (cooked.length < 4 || !cooked[1].equals("Iface")) {
                throw new IllegalStateException(errorMessage);
            }
            if (cooked[2].equals("added")) {
                notifyInterfaceAdded(cooked[3]);
                return true;
            } else if (cooked[2].equals("removed")) {
                notifyInterfaceRemoved(cooked[3]);
                return true;
            } else if (cooked[2].equals("changed") && cooked.length == 5) {
                notifyInterfaceStatusChanged(cooked[3], cooked[4].equals("up"));
                return true;
            } else if (cooked[2].equals("linkstate") && cooked.length == 5) {
                notifyInterfaceLinkStateChanged(cooked[3], cooked[4].equals("up"));
                return true;
            }
            throw new IllegalStateException(errorMessage);
        // break;
        case NetdResponseCode.BandwidthControl:
            /*
                     * Bandwidth control needs some attention
                     * Format: "NNN limit alert <alertName> <ifaceName>"
                     */
            if (cooked.length < 5 || !cooked[1].equals("limit")) {
                throw new IllegalStateException(errorMessage);
            }
            if (cooked[2].equals("alert")) {
                notifyLimitReached(cooked[3], cooked[4]);
                return true;
            }
            throw new IllegalStateException(errorMessage);
        // break;
        case NetdResponseCode.InterfaceClassActivity:
            /*
                     * An network interface class state changed (active/idle)
                     * Format: "NNN IfaceClass <active/idle> <label>"
                     */
            if (cooked.length < 4 || !cooked[1].equals("IfaceClass")) {
                throw new IllegalStateException(errorMessage);
            }
            long timestampNanos = 0;
            int processUid = -1;
            if (cooked.length >= 5) {
                try {
                    timestampNanos = Long.parseLong(cooked[4]);
                    if (cooked.length == 6) {
                        processUid = Integer.parseInt(cooked[5]);
                    }
                } catch (NumberFormatException ne) {
                }
            } else {
                timestampNanos = SystemClock.elapsedRealtimeNanos();
            }
            boolean isActive = cooked[2].equals("active");
            notifyInterfaceClassActivity(Integer.parseInt(cooked[3]), isActive ? DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH : DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, timestampNanos, processUid, false);
            return true;
        // break;
        case NetdResponseCode.InterfaceAddressChange:
            /*
                     * A network address change occurred
                     * Format: "NNN Address updated <addr> <iface> <flags> <scope>"
                     *         "NNN Address removed <addr> <iface> <flags> <scope>"
                     */
            if (cooked.length < 7 || !cooked[1].equals("Address")) {
                throw new IllegalStateException(errorMessage);
            }
            String iface = cooked[4];
            LinkAddress address;
            try {
                int flags = Integer.parseInt(cooked[5]);
                int scope = Integer.parseInt(cooked[6]);
                address = new LinkAddress(cooked[3], flags, scope);
            } catch (NumberFormatException e) {
                // Non-numeric lifetime or scope.
                throw new IllegalStateException(errorMessage, e);
            } catch (IllegalArgumentException e) {
                // Malformed/invalid IP address.
                throw new IllegalStateException(errorMessage, e);
            }
            if (cooked[2].equals("updated")) {
                notifyAddressUpdated(iface, address);
            } else {
                notifyAddressRemoved(iface, address);
            }
            return true;
        // break;
        case NetdResponseCode.InterfaceDnsServerInfo:
            /*
                     * Information about available DNS servers has been received.
                     * Format: "NNN DnsInfo servers <interface> <lifetime> <servers>"
                     */
            // Actually a 32-bit unsigned integer.
            long lifetime;
            if (cooked.length == 6 && cooked[1].equals("DnsInfo") && cooked[2].equals("servers")) {
                try {
                    lifetime = Long.parseLong(cooked[4]);
                } catch (NumberFormatException e) {
                    throw new IllegalStateException(errorMessage);
                }
                String[] servers = cooked[5].split(",");
                notifyInterfaceDnsServerInfo(cooked[3], lifetime, servers);
            }
            return true;
        // break;
        case NetdResponseCode.RouteChange:
            /*
                     * A route has been updated or removed.
                     * Format: "NNN Route <updated|removed> <dst> [via <gateway] [dev <iface>]"
                     */
            if (!cooked[1].equals("Route") || cooked.length < 6) {
                throw new IllegalStateException(errorMessage);
            }
            String via = null;
            String dev = null;
            boolean valid = true;
            for (int i = 4; (i + 1) < cooked.length && valid; i += 2) {
                if (cooked[i].equals("dev")) {
                    if (dev == null) {
                        dev = cooked[i + 1];
                    } else {
                        // Duplicate interface.
                        valid = false;
                    }
                } else if (cooked[i].equals("via")) {
                    if (via == null) {
                        via = cooked[i + 1];
                    } else {
                        // Duplicate gateway.
                        valid = false;
                    }
                } else {
                    // Unknown syntax.
                    valid = false;
                }
            }
            if (valid) {
                try {
                    // InetAddress.parseNumericAddress(null) inexplicably returns ::1.
                    boolean updated = cooked[2].equals("updated");
                    InetAddress gateway = null;
                    if (via != null)
                        gateway = InetAddress.parseNumericAddress(via);
                    RouteInfo route = new RouteInfo(new IpPrefix(cooked[3]), gateway, dev);
                    notifyRouteChange(updated, route);
                    return true;
                } catch (IllegalArgumentException e) {
                }
            }
            throw new IllegalStateException(errorMessage);
        // break;
        case NetdResponseCode.StrictCleartext:
            final int uid = Integer.parseInt(cooked[1]);
            final byte[] firstPacket = HexDump.hexStringToByteArray(cooked[2]);
            try {
                ActivityManager.getService().notifyCleartextNetwork(uid, firstPacket);
            } catch (RemoteException ignored) {
            }
            break;
        default:
            break;
    }
    return false;
}
#method_after
@Override
public boolean onEvent(int code, String raw, String[] cooked) {
    String errorMessage = String.format("Invalid event from daemon (%s)", raw);
    switch(code) {
        case NetdResponseCode.InterfaceChange:
            /*
                     * a network interface change occured
                     * Format: "NNN Iface added <name>"
                     *         "NNN Iface removed <name>"
                     *         "NNN Iface changed <name> <up/down>"
                     *         "NNN Iface linkstatus <name> <up/down>"
                     */
            if (cooked.length < 4 || !cooked[1].equals("Iface")) {
                throw new IllegalStateException(errorMessage);
            }
            if (cooked[2].equals("added")) {
                notifyInterfaceAdded(cooked[3]);
                return true;
            } else if (cooked[2].equals("removed")) {
                notifyInterfaceRemoved(cooked[3]);
                return true;
            } else if (cooked[2].equals("changed") && cooked.length == 5) {
                notifyInterfaceStatusChanged(cooked[3], cooked[4].equals("up"));
                return true;
            } else if (cooked[2].equals("linkstate") && cooked.length == 5) {
                notifyInterfaceLinkStateChanged(cooked[3], cooked[4].equals("up"));
                return true;
            }
            throw new IllegalStateException(errorMessage);
        // break;
        case NetdResponseCode.BandwidthControl:
            /*
                     * Bandwidth control needs some attention
                     * Format: "NNN limit alert <alertName> <ifaceName>"
                     */
            if (cooked.length < 5 || !cooked[1].equals("limit")) {
                throw new IllegalStateException(errorMessage);
            }
            if (cooked[2].equals("alert")) {
                notifyLimitReached(cooked[3], cooked[4]);
                return true;
            }
            throw new IllegalStateException(errorMessage);
        // break;
        case NetdResponseCode.InterfaceClassActivity:
            /*
                     * An network interface class state changed (active/idle)
                     * Format: "NNN IfaceClass <active/idle> <label>"
                     */
            if (cooked.length < 4 || !cooked[1].equals("IfaceClass")) {
                throw new IllegalStateException(errorMessage);
            }
            long timestampNanos = 0;
            int processUid = -1;
            if (cooked.length >= 5) {
                try {
                    timestampNanos = Long.parseLong(cooked[4]);
                    if (cooked.length == 6) {
                        processUid = Integer.parseInt(cooked[5]);
                    }
                } catch (NumberFormatException ne) {
                }
            } else {
                timestampNanos = SystemClock.elapsedRealtimeNanos();
            }
            boolean isActive = cooked[2].equals("active");
            notifyInterfaceClassActivity(Integer.parseInt(cooked[3]), isActive ? DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH : DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, timestampNanos, processUid, false);
            return true;
        // break;
        case NetdResponseCode.InterfaceAddressChange:
            /*
                     * A network address change occurred
                     * Format: "NNN Address updated <addr> <iface> <flags> <scope>"
                     *         "NNN Address removed <addr> <iface> <flags> <scope>"
                     */
            if (cooked.length < 7 || !cooked[1].equals("Address")) {
                throw new IllegalStateException(errorMessage);
            }
            String iface = cooked[4];
            LinkAddress address;
            try {
                int flags = Integer.parseInt(cooked[5]);
                int scope = Integer.parseInt(cooked[6]);
                address = new LinkAddress(cooked[3], flags, scope);
            } catch (NumberFormatException e) {
                // Non-numeric lifetime or scope.
                throw new IllegalStateException(errorMessage, e);
            } catch (IllegalArgumentException e) {
                // Malformed/invalid IP address.
                throw new IllegalStateException(errorMessage, e);
            }
            if (cooked[2].equals("updated")) {
                notifyAddressUpdated(iface, address);
            } else {
                notifyAddressRemoved(iface, address);
            }
            return true;
        // break;
        case NetdResponseCode.InterfaceDnsServerInfo:
            /*
                     * Information about available DNS servers has been received.
                     * Format: "NNN DnsInfo servers <interface> <lifetime> <servers>"
                     */
            // Actually a 32-bit unsigned integer.
            long lifetime;
            if (cooked.length == 6 && cooked[1].equals("DnsInfo") && cooked[2].equals("servers")) {
                try {
                    lifetime = Long.parseLong(cooked[4]);
                } catch (NumberFormatException e) {
                    throw new IllegalStateException(errorMessage);
                }
                String[] servers = cooked[5].split(",");
                notifyInterfaceDnsServerInfo(cooked[3], lifetime, servers);
            }
            return true;
        // break;
        case NetdResponseCode.RouteChange:
            /*
                     * A route has been updated or removed.
                     * Format: "NNN Route <updated|removed> <dst> [via <gateway] [dev <iface>]"
                     */
            if (!cooked[1].equals("Route") || cooked.length < 6) {
                throw new IllegalStateException(errorMessage);
            }
            String via = null;
            String dev = null;
            boolean valid = true;
            for (int i = 4; (i + 1) < cooked.length && valid; i += 2) {
                if (cooked[i].equals("dev")) {
                    if (dev == null) {
                        dev = cooked[i + 1];
                    } else {
                        // Duplicate interface.
                        valid = false;
                    }
                } else if (cooked[i].equals("via")) {
                    if (via == null) {
                        via = cooked[i + 1];
                    } else {
                        // Duplicate gateway.
                        valid = false;
                    }
                } else {
                    // Unknown syntax.
                    valid = false;
                }
            }
            if (valid) {
                try {
                    // InetAddress.parseNumericAddress(null) inexplicably returns ::1.
                    InetAddress gateway = null;
                    if (via != null)
                        gateway = InetAddress.parseNumericAddress(via);
                    RouteInfo route = new RouteInfo(new IpPrefix(cooked[3]), gateway, dev);
                    notifyRouteChange(cooked[2].equals("updated"), route);
                    return true;
                } catch (IllegalArgumentException e) {
                }
            }
            throw new IllegalStateException(errorMessage);
        // break;
        case NetdResponseCode.StrictCleartext:
            final int uid = Integer.parseInt(cooked[1]);
            final byte[] firstPacket = HexDump.hexStringToByteArray(cooked[2]);
            try {
                ActivityManager.getService().notifyCleartextNetwork(uid, firstPacket);
            } catch (RemoteException ignored) {
            }
            break;
        default:
            break;
    }
    return false;
}
#end_block

#method_before
@Override
public String[] listInterfaces() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return NativeDaemonEvent.filterMessageList(mConnector.executeForList("interface", "list"), InterfaceListResult);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
// 
// INetworkManagementService members
@Override
public String[] listInterfaces() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return mNetdService.interfaceGetList();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public InterfaceConfiguration getInterfaceConfig(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final NativeDaemonEvent event;
    try {
        event = mConnector.execute("interface", "getcfg", iface);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
    event.checkCode(InterfaceGetCfgResult);
    // Rsp: 213 xx:xx:xx:xx:xx:xx yyy.yyy.yyy.yyy zzz flag1 flag2 flag3
    final StringTokenizer st = new StringTokenizer(event.getMessage());
    InterfaceConfiguration cfg;
    try {
        cfg = new InterfaceConfiguration();
        cfg.setHardwareAddress(st.nextToken(" "));
        InetAddress addr = null;
        int prefixLength = 0;
        try {
            addr = NetworkUtils.numericToInetAddress(st.nextToken());
        } catch (IllegalArgumentException iae) {
            Slog.e(TAG, "Failed to parse ipaddr", iae);
        }
        try {
            prefixLength = Integer.parseInt(st.nextToken());
        } catch (NumberFormatException nfe) {
            Slog.e(TAG, "Failed to parse prefixLength", nfe);
        }
        cfg.setLinkAddress(new LinkAddress(addr, prefixLength));
        while (st.hasMoreTokens()) {
            cfg.setFlag(st.nextToken());
        }
    } catch (NoSuchElementException nsee) {
        throw new IllegalStateException("Invalid response from daemon: " + event);
    }
    return cfg;
}
#method_after
@Override
public InterfaceConfiguration getInterfaceConfig(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final InterfaceConfigurationParcel result;
    try {
        result = mNetdService.interfaceGetCfg(iface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
    try {
        final InterfaceConfiguration cfg = InterfaceConfiguration.fromParcel(result);
        return cfg;
    } catch (IllegalArgumentException iae) {
        throw new IllegalStateException("Invalid InterfaceConfigurationParcel", iae);
    }
}
#end_block

#method_before
@Override
public void setInterfaceConfig(String iface, InterfaceConfiguration cfg) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    LinkAddress linkAddr = cfg.getLinkAddress();
    if (linkAddr == null || linkAddr.getAddress() == null) {
        throw new IllegalStateException("Null LinkAddress given");
    }
    final Command cmd = new Command("interface", "setcfg", iface, linkAddr.getAddress().getHostAddress(), linkAddr.getPrefixLength());
    for (String flag : cfg.getFlags()) {
        cmd.appendArg(flag);
    }
    try {
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setInterfaceConfig(String iface, InterfaceConfiguration cfg) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    LinkAddress linkAddr = cfg.getLinkAddress();
    if (linkAddr == null || linkAddr.getAddress() == null) {
        throw new IllegalStateException("Null LinkAddress given");
    }
    final InterfaceConfigurationParcel cfgParcel = cfg.toParcel(iface);
    try {
        mNetdService.interfaceSetCfg(cfgParcel);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setInterfaceIpv6PrivacyExtensions(String iface, boolean enable) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("interface", "ipv6privacyextensions", iface, enable ? "enable" : "disable");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setInterfaceIpv6PrivacyExtensions(String iface, boolean enable) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.interfaceSetIPv6PrivacyExtensions(iface, enable);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void clearInterfaceAddresses(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("interface", "clearaddrs", iface);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void clearInterfaceAddresses(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.interfaceClearAddrs(iface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void enableIpv6(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("interface", "ipv6", iface, "enable");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void enableIpv6(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.interfaceSetEnableIPv6(iface, true);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void disableIpv6(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("interface", "ipv6", iface, "disable");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void disableIpv6(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.interfaceSetEnableIPv6(iface, false);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void addRoute(int netId, RouteInfo route) {
    modifyRoute("add", "" + netId, route);
}
#method_after
@Override
public void addRoute(int netId, RouteInfo route) {
    modifyRoute(MODIFY_OPERATION_ADD, netId, route);
}
#end_block

#method_before
@Override
public void removeRoute(int netId, RouteInfo route) {
    modifyRoute("remove", "" + netId, route);
}
#method_after
@Override
public void removeRoute(int netId, RouteInfo route) {
    modifyRoute(MODIFY_OPERATION_REMOVE, netId, route);
}
#end_block

#method_before
private void modifyRoute(String action, String netId, RouteInfo route) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final Command cmd = new Command("network", "route", action, netId);
    // create triplet: interface dest-ip-addr/prefixlength gateway-ip-addr
    cmd.appendArg(route.getInterface());
    cmd.appendArg(route.getDestination().toString());
    switch(route.getType()) {
        case RouteInfo.RTN_UNICAST:
            if (route.hasGateway()) {
                cmd.appendArg(route.getGateway().getHostAddress());
            }
            break;
        case RouteInfo.RTN_UNREACHABLE:
            cmd.appendArg("unreachable");
            break;
        case RouteInfo.RTN_THROW:
            cmd.appendArg("throw");
            break;
    }
    try {
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
private void modifyRoute(boolean add, int netId, RouteInfo route) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final String ifName = route.getInterface();
    final String dst = route.getDestination().toString();
    final String nextHop;
    switch(route.getType()) {
        case RouteInfo.RTN_UNICAST:
            if (route.hasGateway()) {
                nextHop = route.getGateway().getHostAddress();
            } else {
                nextHop = INetd.NEXTHOP_NONE;
            }
            break;
        case RouteInfo.RTN_UNREACHABLE:
            nextHop = INetd.NEXTHOP_UNREACHABLE;
            break;
        case RouteInfo.RTN_THROW:
            nextHop = INetd.NEXTHOP_THROW;
            break;
        default:
            nextHop = INetd.NEXTHOP_NONE;
            break;
    }
    try {
        if (add) {
            mNetdService.networkAddRoute(netId, ifName, dst, nextHop);
        } else {
            mNetdService.networkRemoveRoute(netId, ifName, dst, nextHop);
        }
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setMtu(String iface, int mtu) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final NativeDaemonEvent event;
    try {
        event = mConnector.execute("interface", "setmtu", iface, mtu);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setMtu(String iface, int mtu) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.interfaceSetMtu(iface, mtu);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void startTethering(String[] dhcpRange) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // cmd is "tether start first_start first_stop second_start second_stop ..."
    // an odd number of addrs will fail
    final Command cmd = new Command("tether", "start");
    for (String d : dhcpRange) {
        cmd.appendArg(d);
    }
    try {
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void startTethering(String[] dhcpRange) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.tetherStart(dhcpRange);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void stopTethering() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("tether", "stop");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void stopTethering() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.tetherStop();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public boolean isTetheringStarted() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final NativeDaemonEvent event;
    try {
        event = mConnector.execute("tether", "status");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
    // 210 Tethering services started
    event.checkCode(TetherStatusResult);
    return event.getMessage().endsWith("started");
}
#method_after
@Override
public boolean isTetheringStarted() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        final boolean isEnabled = mNetdService.tetherIsEnabled();
        return isEnabled;
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void tetherInterface(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("tether", "interface", "add", iface);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
    List<RouteInfo> routes = new ArrayList<>();
    // The RouteInfo constructor truncates the LinkAddress to a network prefix, thus making it
    // suitable to use as a route destination.
    routes.add(new RouteInfo(getInterfaceConfig(iface).getLinkAddress(), null, iface));
    addInterfaceToLocalNetwork(iface, routes);
}
#method_after
@Override
public void tetherInterface(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.tetherInterfaceAdd(iface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
    List<RouteInfo> routes = new ArrayList<>();
    // The RouteInfo constructor truncates the LinkAddress to a network prefix, thus making it
    // suitable to use as a route destination.
    routes.add(new RouteInfo(getInterfaceConfig(iface).getLinkAddress(), null, iface));
    addInterfaceToLocalNetwork(iface, routes);
}
#end_block

#method_before
@Override
public void untetherInterface(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("tether", "interface", "remove", iface);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    } finally {
        removeInterfaceFromLocalNetwork(iface);
    }
}
#method_after
@Override
public void untetherInterface(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.tetherInterfaceRemove(iface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    } finally {
        removeInterfaceFromLocalNetwork(iface);
    }
}
#end_block

#method_before
@Override
public String[] listTetheredInterfaces() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return NativeDaemonEvent.filterMessageList(mConnector.executeForList("tether", "interface", "list"), TetherInterfaceListResult);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public String[] listTetheredInterfaces() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return mNetdService.tetherInterfaceList();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setDnsForwarders(Network network, String[] dns) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    int netId = (network != null) ? network.netId : ConnectivityManager.NETID_UNSET;
    final Command cmd = new Command("tether", "dns", "set", netId);
    for (String s : dns) {
        cmd.appendArg(NetworkUtils.numericToInetAddress(s).getHostAddress());
    }
    try {
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setDnsForwarders(Network network, String[] dns) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    int netId = (network != null) ? network.netId : ConnectivityManager.NETID_UNSET;
    try {
        mNetdService.tetherDnsSet(netId, dns);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public String[] getDnsForwarders() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return NativeDaemonEvent.filterMessageList(mConnector.executeForList("tether", "dns", "list"), TetherDnsFwdTgtListResult);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public String[] getDnsForwarders() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return mNetdService.tetherDnsList();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void enableNat(String internalInterface, String externalInterface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        modifyNat("enable", internalInterface, externalInterface);
    } catch (SocketException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public void enableNat(String internalInterface, String externalInterface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.tetherAddForward(internalInterface, externalInterface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void disableNat(String internalInterface, String externalInterface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        modifyNat("disable", internalInterface, externalInterface);
    } catch (SocketException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public void disableNat(String internalInterface, String externalInterface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.tetherRemoveForward(internalInterface, externalInterface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void addIdleTimer(String iface, int timeout, final int type) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Adding idletimer");
    synchronized (mIdleTimerLock) {
        IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params != null) {
            // the interface already has idletimer, update network count
            params.networkCount++;
            return;
        }
        try {
            mNetdService.idletimerAddInterface(iface, timeout, Integer.toString(type));
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        mActiveIdleTimers.put(iface, new IdleTimerParams(timeout, type));
        // Networks start up.
        if (ConnectivityManager.isNetworkTypeMobile(type)) {
            mNetworkActive = false;
        }
        mDaemonHandler.post(new Runnable() {

            @Override
            public void run() {
                notifyInterfaceClassActivity(type, DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH, SystemClock.elapsedRealtimeNanos(), -1, false);
            }
        });
    }
}
#method_after
@Override
public void addIdleTimer(String iface, int timeout, final int type) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Adding idletimer");
    synchronized (mIdleTimerLock) {
        IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params != null) {
            // the interface already has idletimer, update network count
            params.networkCount++;
            return;
        }
        try {
            mNetdService.idletimerAddInterface(iface, timeout, Integer.toString(type));
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        mActiveIdleTimers.put(iface, new IdleTimerParams(timeout, type));
        // Networks start up.
        if (ConnectivityManager.isNetworkTypeMobile(type)) {
            mNetworkActive = false;
        }
        mDaemonHandler.post(() -> notifyInterfaceClassActivity(type, DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH, SystemClock.elapsedRealtimeNanos(), -1, false));
    }
}
#end_block

#method_before
@Override
public void removeIdleTimer(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Removing idletimer");
    synchronized (mIdleTimerLock) {
        final IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params == null || --(params.networkCount) > 0) {
            return;
        }
        try {
            mNetdService.idletimerRemoveInterface(iface, params.timeout, Integer.toString(params.type));
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        mActiveIdleTimers.remove(iface);
        mDaemonHandler.post(new Runnable() {

            @Override
            public void run() {
                notifyInterfaceClassActivity(params.type, DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, SystemClock.elapsedRealtimeNanos(), -1, false);
            }
        });
    }
}
#method_after
@Override
public void removeIdleTimer(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Removing idletimer");
    synchronized (mIdleTimerLock) {
        final IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params == null || --(params.networkCount) > 0) {
            return;
        }
        try {
            mNetdService.idletimerRemoveInterface(iface, params.timeout, Integer.toString(params.type));
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        mActiveIdleTimers.remove(iface);
        mDaemonHandler.post(() -> notifyInterfaceClassActivity(params.type, DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, SystemClock.elapsedRealtimeNanos(), -1, false));
    }
}
#end_block

#method_before
@Override
public void setInterfaceQuota(String iface, long quotaBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // TODO: eventually migrate to be always enabled
    if (!mBandwidthControlEnabled)
        return;
    synchronized (mQuotaLock) {
        if (mActiveQuotas.containsKey(iface)) {
            throw new IllegalStateException("iface " + iface + " already has quota");
        }
        try {
            // TODO: support quota shared across interfaces
            mConnector.execute("bandwidth", "setiquota", iface, quotaBytes);
            mActiveQuotas.put(iface, quotaBytes);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
        synchronized (mTetheringStatsProviders) {
            for (ITetheringStatsProvider provider : mTetheringStatsProviders.keySet()) {
                try {
                    provider.setInterfaceQuota(iface, quotaBytes);
                } catch (RemoteException e) {
                    Log.e(TAG, "Problem setting tethering data limit on provider " + mTetheringStatsProviders.get(provider) + ": " + e);
                }
            }
        }
    }
}
#method_after
@Override
public void setInterfaceQuota(String iface, long quotaBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    synchronized (mQuotaLock) {
        if (mActiveQuotas.containsKey(iface)) {
            throw new IllegalStateException("iface " + iface + " already has quota");
        }
        try {
            // TODO: support quota shared across interfaces
            mNetdService.bandwidthSetInterfaceQuota(iface, quotaBytes);
            mActiveQuotas.put(iface, quotaBytes);
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        synchronized (mTetheringStatsProviders) {
            for (ITetheringStatsProvider provider : mTetheringStatsProviders.keySet()) {
                try {
                    provider.setInterfaceQuota(iface, quotaBytes);
                } catch (RemoteException e) {
                    Log.e(TAG, "Problem setting tethering data limit on provider " + mTetheringStatsProviders.get(provider) + ": " + e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void removeInterfaceQuota(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // TODO: eventually migrate to be always enabled
    if (!mBandwidthControlEnabled)
        return;
    synchronized (mQuotaLock) {
        if (!mActiveQuotas.containsKey(iface)) {
            // TODO: eventually consider throwing
            return;
        }
        mActiveQuotas.remove(iface);
        mActiveAlerts.remove(iface);
        try {
            // TODO: support quota shared across interfaces
            mConnector.execute("bandwidth", "removeiquota", iface);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
        synchronized (mTetheringStatsProviders) {
            for (ITetheringStatsProvider provider : mTetheringStatsProviders.keySet()) {
                try {
                    provider.setInterfaceQuota(iface, ITetheringStatsProvider.QUOTA_UNLIMITED);
                } catch (RemoteException e) {
                    Log.e(TAG, "Problem removing tethering data limit on provider " + mTetheringStatsProviders.get(provider) + ": " + e);
                }
            }
        }
    }
}
#method_after
@Override
public void removeInterfaceQuota(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    synchronized (mQuotaLock) {
        if (!mActiveQuotas.containsKey(iface)) {
            // TODO: eventually consider throwing
            return;
        }
        mActiveQuotas.remove(iface);
        mActiveAlerts.remove(iface);
        try {
            // TODO: support quota shared across interfaces
            mNetdService.bandwidthRemoveInterfaceQuota(iface);
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        synchronized (mTetheringStatsProviders) {
            for (ITetheringStatsProvider provider : mTetheringStatsProviders.keySet()) {
                try {
                    provider.setInterfaceQuota(iface, ITetheringStatsProvider.QUOTA_UNLIMITED);
                } catch (RemoteException e) {
                    Log.e(TAG, "Problem removing tethering data limit on provider " + mTetheringStatsProviders.get(provider) + ": " + e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void setInterfaceAlert(String iface, long alertBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // TODO: eventually migrate to be always enabled
    if (!mBandwidthControlEnabled)
        return;
    // quick sanity check
    if (!mActiveQuotas.containsKey(iface)) {
        throw new IllegalStateException("setting alert requires existing quota on iface");
    }
    synchronized (mQuotaLock) {
        if (mActiveAlerts.containsKey(iface)) {
            throw new IllegalStateException("iface " + iface + " already has alert");
        }
        try {
            // TODO: support alert shared across interfaces
            mConnector.execute("bandwidth", "setinterfacealert", iface, alertBytes);
            mActiveAlerts.put(iface, alertBytes);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
    }
}
#method_after
@Override
public void setInterfaceAlert(String iface, long alertBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // quick sanity check
    if (!mActiveQuotas.containsKey(iface)) {
        throw new IllegalStateException("setting alert requires existing quota on iface");
    }
    synchronized (mQuotaLock) {
        if (mActiveAlerts.containsKey(iface)) {
            throw new IllegalStateException("iface " + iface + " already has alert");
        }
        try {
            // TODO: support alert shared across interfaces
            mNetdService.bandwidthSetInterfaceAlert(iface, alertBytes);
            mActiveAlerts.put(iface, alertBytes);
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
    }
}
#end_block

#method_before
@Override
public void removeInterfaceAlert(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // TODO: eventually migrate to be always enabled
    if (!mBandwidthControlEnabled)
        return;
    synchronized (mQuotaLock) {
        if (!mActiveAlerts.containsKey(iface)) {
            // TODO: eventually consider throwing
            return;
        }
        try {
            // TODO: support alert shared across interfaces
            mConnector.execute("bandwidth", "removeinterfacealert", iface);
            mActiveAlerts.remove(iface);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
    }
}
#method_after
@Override
public void removeInterfaceAlert(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    synchronized (mQuotaLock) {
        if (!mActiveAlerts.containsKey(iface)) {
            // TODO: eventually consider throwing
            return;
        }
        try {
            // TODO: support alert shared across interfaces
            mNetdService.bandwidthRemoveInterfaceAlert(iface);
            mActiveAlerts.remove(iface);
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
    }
}
#end_block

#method_before
@Override
public void setGlobalAlert(long alertBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // TODO: eventually migrate to be always enabled
    if (!mBandwidthControlEnabled)
        return;
    try {
        mConnector.execute("bandwidth", "setglobalalert", alertBytes);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setGlobalAlert(long alertBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.bandwidthSetGlobalAlert(alertBytes);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private void setUidOnMeteredNetworkList(int uid, boolean blacklist, boolean enable) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    // TODO: eventually migrate to be always enabled
    if (!mBandwidthControlEnabled)
        return;
    final String chain = blacklist ? "naughtyapps" : "niceapps";
    final String suffix = enable ? "add" : "remove";
    synchronized (mQuotaLock) {
        boolean oldEnable;
        SparseBooleanArray quotaList;
        synchronized (mRulesLock) {
            quotaList = blacklist ? mUidRejectOnMetered : mUidAllowOnMetered;
            oldEnable = quotaList.get(uid, false);
        }
        if (oldEnable == enable) {
            // TODO: eventually consider throwing
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "inetd bandwidth");
        try {
            mConnector.execute("bandwidth", suffix + chain, uid);
            synchronized (mRulesLock) {
                if (enable) {
                    quotaList.put(uid, true);
                } else {
                    quotaList.delete(uid);
                }
            }
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#method_after
private void setUidOnMeteredNetworkList(int uid, boolean blacklist, boolean enable) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    synchronized (mQuotaLock) {
        boolean oldEnable;
        SparseBooleanArray quotaList;
        synchronized (mRulesLock) {
            quotaList = blacklist ? mUidRejectOnMetered : mUidAllowOnMetered;
            oldEnable = quotaList.get(uid, false);
        }
        if (oldEnable == enable) {
            // TODO: eventually consider throwing
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "inetd bandwidth");
        try {
            if (blacklist) {
                if (enable) {
                    mNetdService.bandwidthAddNaughtyApp(uid);
                } else {
                    mNetdService.bandwidthRemoveNaughtyApp(uid);
                }
            } else {
                if (enable) {
                    mNetdService.bandwidthAddNiceApp(uid);
                } else {
                    mNetdService.bandwidthRemoveNiceApp(uid);
                }
            }
            synchronized (mRulesLock) {
                if (enable) {
                    quotaList.put(uid, true);
                } else {
                    quotaList.delete(uid);
                }
            }
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#end_block

#method_before
@Override
public boolean isBandwidthControlEnabled() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    return mBandwidthControlEnabled;
}
#method_after
@Override
public boolean isBandwidthControlEnabled() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    return true;
}
#end_block

#method_before
@Override
public NetworkStats getTetherStats(int how) {
    // interface counters.
    if (how != STATS_PER_UID) {
        return new NetworkStats(SystemClock.elapsedRealtime(), 0);
    }
    final PersistableBundle bundle;
    try {
        bundle = mNetdService.tetherGetStats();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException("problem parsing tethering stats: ", e);
    }
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), bundle.size());
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    for (String iface : bundle.keySet()) {
        long[] statsArray = bundle.getLongArray(iface);
        try {
            entry.iface = iface;
            entry.uid = UID_TETHERING;
            entry.set = SET_DEFAULT;
            entry.tag = TAG_NONE;
            entry.rxBytes = statsArray[INetd.TETHER_STATS_RX_BYTES];
            entry.rxPackets = statsArray[INetd.TETHER_STATS_RX_PACKETS];
            entry.txBytes = statsArray[INetd.TETHER_STATS_TX_BYTES];
            entry.txPackets = statsArray[INetd.TETHER_STATS_TX_PACKETS];
            stats.combineValues(entry);
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalStateException("invalid tethering stats for " + iface, e);
        }
    }
    return stats;
}
#method_after
@Override
public NetworkStats getTetherStats(int how) {
    // interface counters.
    if (how != STATS_PER_UID) {
        return new NetworkStats(SystemClock.elapsedRealtime(), 0);
    }
    final TetherStatsParcel[] tetherStatsVec;
    try {
        tetherStatsVec = mNetdService.tetherGetStats();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException("problem parsing tethering stats: ", e);
    }
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), tetherStatsVec.length);
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    for (TetherStatsParcel tetherStats : tetherStatsVec) {
        try {
            entry.iface = tetherStats.iface;
            entry.uid = UID_TETHERING;
            entry.set = SET_DEFAULT;
            entry.tag = TAG_NONE;
            entry.rxBytes = tetherStats.rxBytes;
            entry.rxPackets = tetherStats.rxPackets;
            entry.txBytes = tetherStats.txBytes;
            entry.txPackets = tetherStats.txPackets;
            stats.combineValues(entry);
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalStateException("invalid tethering stats " + e);
        }
    }
    return stats;
}
#end_block

#method_before
@Override
public void addVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    Object[] argv = new Object[3 + MAX_UID_RANGES_PER_COMMAND];
    argv[0] = "users";
    argv[1] = "add";
    argv[2] = netId;
    int argc = 3;
    // Avoid overly long commands by limiting number of UID ranges per command.
    for (int i = 0; i < ranges.length; i++) {
        argv[argc++] = ranges[i].toString();
        if (i == (ranges.length - 1) || argc == argv.length) {
            try {
                mConnector.execute("network", Arrays.copyOf(argv, argc));
            } catch (NativeDaemonConnectorException e) {
                throw e.rethrowAsParcelableException();
            }
            argc = 3;
        }
    }
}
#method_after
@Override
public void addVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkAddUidRanges(netId, ranges);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void removeVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    Object[] argv = new Object[3 + MAX_UID_RANGES_PER_COMMAND];
    argv[0] = "users";
    argv[1] = "remove";
    argv[2] = netId;
    int argc = 3;
    // Avoid overly long commands by limiting number of UID ranges per command.
    for (int i = 0; i < ranges.length; i++) {
        argv[argc++] = ranges[i].toString();
        if (i == (ranges.length - 1) || argc == argv.length) {
            try {
                mConnector.execute("network", Arrays.copyOf(argv, argc));
            } catch (NativeDaemonConnectorException e) {
                throw e.rethrowAsParcelableException();
            }
            argc = 3;
        }
    }
}
#method_after
@Override
public void removeVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkRemoveUidRanges(netId, ranges);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setFirewallEnabled(boolean enabled) {
    enforceSystemUid();
    try {
        mConnector.execute("firewall", "enable", enabled ? "whitelist" : "blacklist");
        mFirewallEnabled = enabled;
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setFirewallEnabled(boolean enabled) {
    enforceSystemUid();
    try {
        mNetdService.firewallSetFirewallType(enabled ? INetd.FIREWALL_WHITELIST : INetd.FIREWALL_BLACKLIST);
        mFirewallEnabled = enabled;
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setFirewallInterfaceRule(String iface, boolean allow) {
    enforceSystemUid();
    Preconditions.checkState(mFirewallEnabled);
    final String rule = allow ? "allow" : "deny";
    try {
        mConnector.execute("firewall", "set_interface_rule", iface, rule);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setFirewallInterfaceRule(String iface, boolean allow) {
    enforceSystemUid();
    Preconditions.checkState(mFirewallEnabled);
    try {
        mNetdService.firewallSetInterfaceRule(iface, allow ? INetd.FIREWALL_RULE_ALLOW : INetd.FIREWALL_RULE_DENY);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private void closeSocketsForFirewallChainLocked(int chain, String chainName) {
    // UID ranges to close sockets on.
    UidRange[] ranges;
    // UID ranges whose sockets we won't touch.
    int[] exemptUids;
    int numUids = 0;
    if (getFirewallType(chain) == FIREWALL_TYPE_WHITELIST) {
        // Close all sockets on all non-system UIDs...
        ranges = new UidRange[] { // specify their ranges here.
        new UidRange(Process.FIRST_APPLICATION_UID, Integer.MAX_VALUE) };
        // ... except for the UIDs that have allow rules.
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            exemptUids = new int[rules.size()];
            for (int i = 0; i < exemptUids.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_ALLOW) {
                    exemptUids[numUids] = rules.keyAt(i);
                    numUids++;
                }
            }
        }
        // fix setFirewallEnabled to grab mQuotaLock and clear rules.
        if (numUids != exemptUids.length) {
            exemptUids = Arrays.copyOf(exemptUids, numUids);
        }
    } else {
        // Close sockets for every UID that has a deny rule...
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            ranges = new UidRange[rules.size()];
            for (int i = 0; i < ranges.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_DENY) {
                    int uid = rules.keyAt(i);
                    ranges[numUids] = new UidRange(uid, uid);
                    numUids++;
                }
            }
        }
        // As above; usually numUids == ranges.length, but not always.
        if (numUids != ranges.length) {
            ranges = Arrays.copyOf(ranges, numUids);
        }
        // ... with no exceptions.
        exemptUids = new int[0];
    }
    try {
        mNetdService.socketDestroy(ranges, exemptUids);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error closing sockets after enabling chain " + chainName + ": " + e);
    }
}
#method_after
private void closeSocketsForFirewallChainLocked(int chain, String chainName) {
    // UID ranges to close sockets on.
    UidRange[] ranges;
    // UID ranges whose sockets we won't touch.
    int[] exemptUids;
    int numUids = 0;
    if (DBG)
        Slog.d(TAG, "Closing sockets after enabling chain " + chainName);
    if (getFirewallType(chain) == FIREWALL_TYPE_WHITELIST) {
        // Close all sockets on all non-system UIDs...
        ranges = new UidRange[] { // specify their ranges here.
        new UidRange(Process.FIRST_APPLICATION_UID, Integer.MAX_VALUE) };
        // ... except for the UIDs that have allow rules.
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            exemptUids = new int[rules.size()];
            for (int i = 0; i < exemptUids.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_ALLOW) {
                    exemptUids[numUids] = rules.keyAt(i);
                    numUids++;
                }
            }
        }
        // fix setFirewallEnabled to grab mQuotaLock and clear rules.
        if (numUids != exemptUids.length) {
            exemptUids = Arrays.copyOf(exemptUids, numUids);
        }
    } else {
        // Close sockets for every UID that has a deny rule...
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            ranges = new UidRange[rules.size()];
            for (int i = 0; i < ranges.length; i++) {
                if (rules.valueAt(i) == NetworkPolicyManager.FIREWALL_RULE_DENY) {
                    int uid = rules.keyAt(i);
                    ranges[numUids] = new UidRange(uid, uid);
                    numUids++;
                }
            }
        }
        // As above; usually numUids == ranges.length, but not always.
        if (numUids != ranges.length) {
            ranges = Arrays.copyOf(ranges, numUids);
        }
        // ... with no exceptions.
        exemptUids = new int[0];
    }
    try {
        mNetdService.socketDestroy(ranges, exemptUids);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error closing sockets after enabling chain " + chainName + ": " + e);
    }
}
#end_block

#method_before
@Override
public void setFirewallChainEnabled(int chain, boolean enable) {
    enforceSystemUid();
    synchronized (mQuotaLock) {
        synchronized (mRulesLock) {
            if (getFirewallChainState(chain) == enable) {
                // chains default detached.
                return;
            }
            setFirewallChainState(chain, enable);
        }
        final String operation = enable ? "enable_chain" : "disable_chain";
        final String chainName;
        switch(chain) {
            case FIREWALL_CHAIN_STANDBY:
                chainName = FIREWALL_CHAIN_NAME_STANDBY;
                break;
            case FIREWALL_CHAIN_DOZABLE:
                chainName = FIREWALL_CHAIN_NAME_DOZABLE;
                break;
            case FIREWALL_CHAIN_POWERSAVE:
                chainName = FIREWALL_CHAIN_NAME_POWERSAVE;
                break;
            default:
                throw new IllegalArgumentException("Bad child chain: " + chain);
        }
        try {
            mConnector.execute("firewall", operation, chainName);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
        // whitelist and blacklist chains allow RSTs through.
        if (enable) {
            if (DBG)
                Slog.d(TAG, "Closing sockets after enabling chain " + chainName);
            closeSocketsForFirewallChainLocked(chain, chainName);
        }
    }
}
#method_after
@Override
public void setFirewallChainEnabled(int chain, boolean enable) {
    enforceSystemUid();
    synchronized (mQuotaLock) {
        synchronized (mRulesLock) {
            if (getFirewallChainState(chain) == enable) {
                // chains default detached.
                return;
            }
            setFirewallChainState(chain, enable);
        }
        final String chainName = getFirewallChainName(chain);
        if (chain == FIREWALL_CHAIN_NONE) {
            throw new IllegalArgumentException("Bad child chain: " + chainName);
        }
        try {
            mNetdService.firewallEnableChildChain(chain, enable);
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        // whitelist and blacklist chains allow RSTs through.
        if (enable) {
            closeSocketsForFirewallChainLocked(chain, chainName);
        }
    }
}
#end_block

#method_before
@NonNull
public String getFirewallChainName(int chain) {
    switch(chain) {
        case FIREWALL_CHAIN_STANDBY:
            return FIREWALL_CHAIN_NAME_STANDBY;
        case FIREWALL_CHAIN_DOZABLE:
            return FIREWALL_CHAIN_NAME_DOZABLE;
        case FIREWALL_CHAIN_POWERSAVE:
            return FIREWALL_CHAIN_NAME_POWERSAVE;
        case FIREWALL_CHAIN_NONE:
            return FIREWALL_CHAIN_NAME_NONE;
        default:
            throw new IllegalArgumentException("Unknown chain:" + chain);
    }
}
#method_after
private String getFirewallChainName(int chain) {
    switch(chain) {
        case FIREWALL_CHAIN_STANDBY:
            return FIREWALL_CHAIN_NAME_STANDBY;
        case FIREWALL_CHAIN_DOZABLE:
            return FIREWALL_CHAIN_NAME_DOZABLE;
        case FIREWALL_CHAIN_POWERSAVE:
            return FIREWALL_CHAIN_NAME_POWERSAVE;
        default:
            throw new IllegalArgumentException("Bad child chain: " + chain);
    }
}
#end_block

#method_before
private void setFirewallUidRuleLocked(int chain, int uid, int rule) {
    if (updateFirewallUidRuleLocked(chain, uid, rule)) {
        try {
            mConnector.execute("firewall", "set_uid_rule", getFirewallChainName(chain), uid, getFirewallRuleName(chain, rule));
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
    }
}
#method_after
private void setFirewallUidRuleLocked(int chain, int uid, int rule) {
    if (updateFirewallUidRuleLocked(chain, uid, rule)) {
        final int ruleType = getFirewallRuleType(chain, rule);
        try {
            mNetdService.firewallSetUidRule(chain, uid, ruleType);
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.println("NetworkManagementService NativeDaemonConnector Log:");
    mConnector.dump(fd, pw, args);
    pw.println();
    pw.print("Bandwidth control enabled: ");
    pw.println(mBandwidthControlEnabled);
    pw.print("mMobileActivityFromRadio=");
    pw.print(mMobileActivityFromRadio);
    pw.print(" mLastPowerStateFromRadio=");
    pw.println(mLastPowerStateFromRadio);
    pw.print("mNetworkActive=");
    pw.println(mNetworkActive);
    synchronized (mQuotaLock) {
        pw.print("Active quota ifaces: ");
        pw.println(mActiveQuotas.toString());
        pw.print("Active alert ifaces: ");
        pw.println(mActiveAlerts.toString());
        pw.print("Data saver mode: ");
        pw.println(mDataSaverMode);
        synchronized (mRulesLock) {
            dumpUidRuleOnQuotaLocked(pw, "blacklist", mUidRejectOnMetered);
            dumpUidRuleOnQuotaLocked(pw, "whitelist", mUidAllowOnMetered);
        }
    }
    synchronized (mRulesLock) {
        dumpUidFirewallRule(pw, "", mUidFirewallRules);
        pw.print("UID firewall standby chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_STANDBY));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_STANDBY, mUidFirewallStandbyRules);
        pw.print("UID firewall dozable chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_DOZABLE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_DOZABLE, mUidFirewallDozableRules);
        pw.println("UID firewall powersave chain enabled: " + getFirewallChainState(FIREWALL_CHAIN_POWERSAVE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_POWERSAVE, mUidFirewallPowerSaveRules);
    }
    synchronized (mIdleTimerLock) {
        pw.println("Idle timers:");
        for (HashMap.Entry<String, IdleTimerParams> ent : mActiveIdleTimers.entrySet()) {
            pw.print("  ");
            pw.print(ent.getKey());
            pw.println(":");
            IdleTimerParams params = ent.getValue();
            pw.print("    timeout=");
            pw.print(params.timeout);
            pw.print(" type=");
            pw.print(params.type);
            pw.print(" networkCount=");
            pw.println(params.networkCount);
        }
    }
    pw.print("Firewall enabled: ");
    pw.println(mFirewallEnabled);
    pw.print("Netd service status: ");
    if (mNetdService == null) {
        pw.println("disconnected");
    } else {
        try {
            final boolean alive = mNetdService.isAlive();
            pw.println(alive ? "alive" : "dead");
        } catch (RemoteException e) {
            pw.println("unreachable");
        }
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.println("NetworkManagementService NativeDaemonConnector Log:");
    mConnector.dump(fd, pw, args);
    pw.println();
    pw.print("mMobileActivityFromRadio=");
    pw.print(mMobileActivityFromRadio);
    pw.print(" mLastPowerStateFromRadio=");
    pw.println(mLastPowerStateFromRadio);
    pw.print("mNetworkActive=");
    pw.println(mNetworkActive);
    synchronized (mQuotaLock) {
        pw.print("Active quota ifaces: ");
        pw.println(mActiveQuotas.toString());
        pw.print("Active alert ifaces: ");
        pw.println(mActiveAlerts.toString());
        pw.print("Data saver mode: ");
        pw.println(mDataSaverMode);
        synchronized (mRulesLock) {
            dumpUidRuleOnQuotaLocked(pw, "blacklist", mUidRejectOnMetered);
            dumpUidRuleOnQuotaLocked(pw, "whitelist", mUidAllowOnMetered);
        }
    }
    synchronized (mRulesLock) {
        dumpUidFirewallRule(pw, "", mUidFirewallRules);
        pw.print("UID firewall standby chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_STANDBY));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_STANDBY, mUidFirewallStandbyRules);
        pw.print("UID firewall dozable chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_DOZABLE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_DOZABLE, mUidFirewallDozableRules);
        pw.println("UID firewall powersave chain enabled: " + getFirewallChainState(FIREWALL_CHAIN_POWERSAVE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_POWERSAVE, mUidFirewallPowerSaveRules);
    }
    synchronized (mIdleTimerLock) {
        pw.println("Idle timers:");
        for (HashMap.Entry<String, IdleTimerParams> ent : mActiveIdleTimers.entrySet()) {
            pw.print("  ");
            pw.print(ent.getKey());
            pw.println(":");
            IdleTimerParams params = ent.getValue();
            pw.print("    timeout=");
            pw.print(params.timeout);
            pw.print(" type=");
            pw.print(params.type);
            pw.print(" networkCount=");
            pw.println(params.networkCount);
        }
    }
    pw.print("Firewall enabled: ");
    pw.println(mFirewallEnabled);
    pw.print("Netd service status: ");
    if (mNetdService == null) {
        pw.println("disconnected");
    } else {
        try {
            final boolean alive = mNetdService.isAlive();
            pw.println(alive ? "alive" : "dead");
        } catch (RemoteException e) {
            pw.println("unreachable");
        }
    }
}
#end_block

#method_before
@Override
public void createPhysicalNetwork(int netId, String permission) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        if (permission != null) {
            mConnector.execute("network", "create", netId, permission);
        } else {
            mConnector.execute("network", "create", netId);
        }
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void createPhysicalNetwork(int netId, int permission) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkCreatePhysical(netId, permission);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void createVirtualNetwork(int netId, boolean hasDNS, boolean secure) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("network", "create", netId, "vpn", hasDNS ? "1" : "0", secure ? "1" : "0");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void createVirtualNetwork(int netId, boolean secure) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkCreateVpn(netId, secure);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void addInterfaceToNetwork(String iface, int netId) {
    modifyInterfaceInNetwork("add", "" + netId, iface);
}
#method_after
@Override
public void addInterfaceToNetwork(String iface, int netId) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_ADD, netId, iface);
}
#end_block

#method_before
@Override
public void removeInterfaceFromNetwork(String iface, int netId) {
    modifyInterfaceInNetwork("remove", "" + netId, iface);
}
#method_after
@Override
public void removeInterfaceFromNetwork(String iface, int netId) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_REMOVE, netId, iface);
}
#end_block

#method_before
private void modifyInterfaceInNetwork(String action, String netId, String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("network", "interface", action, netId, iface);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
private void modifyInterfaceInNetwork(boolean add, int netId, String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        if (add) {
            mNetdService.networkAddInterface(netId, iface);
        } else {
            mNetdService.networkRemoveInterface(netId, iface);
        }
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void addLegacyRouteForNetId(int netId, RouteInfo routeInfo, int uid) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final Command cmd = new Command("network", "route", "legacy", uid, "add", netId);
    // create triplet: interface dest-ip-addr/prefixlength gateway-ip-addr
    final LinkAddress la = routeInfo.getDestinationLinkAddress();
    cmd.appendArg(routeInfo.getInterface());
    cmd.appendArg(la.getAddress().getHostAddress() + "/" + la.getPrefixLength());
    if (routeInfo.hasGateway()) {
        cmd.appendArg(routeInfo.getGateway().getHostAddress());
    }
    try {
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void addLegacyRouteForNetId(int netId, RouteInfo routeInfo, int uid) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final LinkAddress la = routeInfo.getDestinationLinkAddress();
    final String ifName = routeInfo.getInterface();
    final String dst = la.toString();
    final String nextHop;
    if (routeInfo.hasGateway()) {
        nextHop = routeInfo.getGateway().getHostAddress();
    } else {
        nextHop = "";
    }
    try {
        mNetdService.networkAddLegacyRoute(netId, ifName, dst, nextHop, uid);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setDefaultNetId(int netId) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("network", "default", "set", netId);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setDefaultNetId(int netId) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkSetDefault(netId);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void clearDefaultNetId() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("network", "default", "clear");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void clearDefaultNetId() {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkClearDefault();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setNetworkPermission(int netId, String permission) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        if (permission != null) {
            mConnector.execute("network", "permission", "network", "set", permission, netId);
        } else {
            mConnector.execute("network", "permission", "network", "clear", netId);
        }
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setNetworkPermission(int netId, int permission) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkSetPermissionForNetwork(netId, permission);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setPermission(String permission, int[] uids) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    Object[] argv = new Object[4 + MAX_UID_RANGES_PER_COMMAND];
    argv[0] = "permission";
    argv[1] = "user";
    argv[2] = "set";
    argv[3] = permission;
    int argc = 4;
    // Avoid overly long commands by limiting number of UIDs per command.
    for (int i = 0; i < uids.length; ++i) {
        argv[argc++] = uids[i];
        if (i == uids.length - 1 || argc == argv.length) {
            try {
                mConnector.execute("network", Arrays.copyOf(argv, argc));
            } catch (NativeDaemonConnectorException e) {
                throw e.rethrowAsParcelableException();
            }
            argc = 4;
        }
    }
}
#method_after
@Override
public void setPermission(String permission, int[] uids) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkSetPermissionForUser(parsePermission(permission), uids);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void clearPermission(int[] uids) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    Object[] argv = new Object[3 + MAX_UID_RANGES_PER_COMMAND];
    argv[0] = "permission";
    argv[1] = "user";
    argv[2] = "clear";
    int argc = 3;
    // Avoid overly long commands by limiting number of UIDs per command.
    for (int i = 0; i < uids.length; ++i) {
        argv[argc++] = uids[i];
        if (i == uids.length - 1 || argc == argv.length) {
            try {
                mConnector.execute("network", Arrays.copyOf(argv, argc));
            } catch (NativeDaemonConnectorException e) {
                throw e.rethrowAsParcelableException();
            }
            argc = 3;
        }
    }
}
#method_after
@Override
public void clearPermission(int[] uids) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkClearPermissionForUser(uids);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void allowProtect(int uid) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("network", "protect", "allow", uid);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void allowProtect(int uid) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkSetProtectAllow(uid);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void denyProtect(int uid) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("network", "protect", "deny", uid);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void denyProtect(int uid) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkSetProtectDeny(uid);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void addInterfaceToLocalNetwork(String iface, List<RouteInfo> routes) {
    modifyInterfaceInNetwork("add", "local", iface);
    for (RouteInfo route : routes) {
        if (!route.isDefaultRoute()) {
            modifyRoute("add", "local", route);
        }
    }
}
#method_after
@Override
public void addInterfaceToLocalNetwork(String iface, List<RouteInfo> routes) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, iface);
    for (RouteInfo route : routes) {
        if (!route.isDefaultRoute()) {
            modifyRoute(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, route);
        }
    }
}
#end_block

#method_before
@Override
public void removeInterfaceFromLocalNetwork(String iface) {
    modifyInterfaceInNetwork("remove", "local", iface);
}
#method_after
@Override
public void removeInterfaceFromLocalNetwork(String iface) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_REMOVE, INetd.LOCAL_NET_ID, iface);
}
#end_block

#method_before
@Override
public int removeRoutesFromLocalNetwork(List<RouteInfo> routes) {
    int failures = 0;
    for (RouteInfo route : routes) {
        try {
            modifyRoute("remove", "local", route);
        } catch (IllegalStateException e) {
            failures++;
        }
    }
    return failures;
}
#method_after
@Override
public int removeRoutesFromLocalNetwork(List<RouteInfo> routes) {
    int failures = 0;
    for (RouteInfo route : routes) {
        try {
            modifyRoute(MODIFY_OPERATION_REMOVE, INetd.LOCAL_NET_ID, route);
        } catch (IllegalStateException e) {
            failures++;
        }
    }
    return failures;
}
#end_block

#method_before
@NonNull
public static SimpleNavDirections startLogin() {
    return new SimpleNavDirections(foo.R.id.start_login);
}
#method_after
@NonNull
public static NavDirections startLogin() {
    return new ActionOnlyNavDirections(foo.R.id.start_login);
}
#end_block

#method_before
@NonNull
public static SimpleNavDirections actionDone() {
    return LoginDirections.actionDone();
}
#method_after
@NonNull
public static NavDirections actionDone() {
    return LoginDirections.actionDone();
}
#end_block

#method_before
@NonNull
public static SimpleNavDirections startLogin() {
    return new SimpleNavDirections(foo.R.id.start_login);
}
#method_after
@NonNull
public static NavDirections startLogin() {
    return new ActionOnlyNavDirections(foo.R.id.start_login);
}
#end_block

#method_before
@NonNull
public static SimpleNavDirections actionDone() {
    return new SimpleNavDirections(foo.R.id.action_done);
}
#method_after
@NonNull
public static NavDirections actionDone() {
    return new ActionOnlyNavDirections(foo.R.id.action_done);
}
#end_block

#method_before
@NonNull
public static SimpleNavDirections startLogin() {
    return new SimpleNavDirections(foo.R.id.start_login);
}
#method_after
@NonNull
public static NavDirections startLogin() {
    return new ActionOnlyNavDirections(foo.R.id.start_login);
}
#end_block

#method_before
@NonNull
public static SimpleNavDirections register() {
    return new SimpleNavDirections(foo.R.id.register);
}
#method_after
@NonNull
public static NavDirections register() {
    return new ActionOnlyNavDirections(foo.R.id.register);
}
#end_block

#method_before
@NonNull
public static SimpleNavDirections actionDone() {
    return LoginDirections.actionDone();
}
#method_after
@NonNull
public static NavDirections actionDone() {
    return LoginDirections.actionDone();
}
#end_block

#method_before
public void setupDataCallResponse(RadioResponseInfo responseInfo, android.hardware.radio.V1_0.SetupDataCallResult setupDataCallResult) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        DataCallResponse response = RIL.convertDataCallResult(setupDataCallResult);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, response);
        }
        mRil.processResponseDone(rr, responseInfo, response);
    }
}
#method_after
public void setupDataCallResponse(RadioResponseInfo responseInfo, android.hardware.radio.V1_0.SetupDataCallResult setupDataCallResult) {
    responseSetupDataCall(responseInfo, setupDataCallResult);
}
#end_block

#method_before
public void setupDataCallResponse_1_4(RadioResponseInfo responseInfo, android.hardware.radio.V1_4.SetupDataCallResult setupDataCallResult) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        DataCallResponse response = RIL.convertDataCallResult_1_4(setupDataCallResult);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, response);
        }
        mRil.processResponseDone(rr, responseInfo, response);
    }
}
#method_after
public void setupDataCallResponse_1_4(RadioResponseInfo responseInfo, android.hardware.radio.V1_4.SetupDataCallResult setupDataCallResult) {
    responseSetupDataCall(responseInfo, setupDataCallResult);
}
#end_block

#method_before
public void getDataCallListResponse(RadioResponseInfo responseInfo, ArrayList<android.hardware.radio.V1_0.SetupDataCallResult> dataCallResultList) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        ArrayList<DataCallResponse> response = RIL.convertDataCallResultList(dataCallResultList);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, response);
        }
        mRil.processResponseDone(rr, responseInfo, response);
    }
}
#method_after
public void getDataCallListResponse(RadioResponseInfo responseInfo, ArrayList<android.hardware.radio.V1_0.SetupDataCallResult> dataCallResultList) {
    responseDataCallList(responseInfo, dataCallResultList);
}
#end_block

#method_before
public void getDataCallListResponse_1_4(RadioResponseInfo responseInfo, ArrayList<android.hardware.radio.V1_4.SetupDataCallResult> dataCallResultList) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        ArrayList<DataCallResponse> response = RIL.convertDataCallResultList_1_4(dataCallResultList);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, response);
        }
        mRil.processResponseDone(rr, responseInfo, response);
    }
}
#method_after
public void getDataCallListResponse_1_4(RadioResponseInfo responseInfo, ArrayList<android.hardware.radio.V1_4.SetupDataCallResult> dataCallResultList) {
    responseDataCallList(responseInfo, dataCallResultList);
}
#end_block

#method_before
public void setAllowedCarriersResponse(RadioResponseInfo responseInfo, int numAllowed) {
    responseInts(responseInfo, numAllowed);
}
#method_after
public void setAllowedCarriersResponse(RadioResponseInfo responseInfo, int numAllowed) {
    // The number of allowed carriers set correctly is not really useful. Even if one is
    // missing, the operation has failed, as the list should be treated as a single
    // configuration item. So, ignoring the value of numAllowed and considering only the
    // value of the responseInfo.error.
    int ret = TelephonyManager.SET_CARRIER_RESTRICTION_ERROR;
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        mRil.riljLog("setAllowedCarriersResponse - error = " + responseInfo.error);
        if (responseInfo.error == RadioError.NONE) {
            ret = TelephonyManager.SET_CARRIER_RESTRICTION_SUCCESS;
            sendMessageResponse(rr.mResult, ret);
        } else if (responseInfo.error == RadioError.REQUEST_NOT_SUPPORTED) {
            // Handle the case REQUEST_NOT_SUPPORTED as a valid response
            responseInfo.error = RadioError.NONE;
            ret = TelephonyManager.SET_CARRIER_RESTRICTION_NOT_SUPPORTED;
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#end_block

#method_before
public void getAllowedCarriersResponse(RadioResponseInfo responseInfo, boolean allAllowed, CarrierRestrictions carriers) {
    responseCarrierIdentifiers(responseInfo, allAllowed, carriers);
}
#method_after
public void getAllowedCarriersResponse(RadioResponseInfo responseInfo, boolean allAllowed, CarrierRestrictions carriers) {
    CarrierRestrictionsWithPriority carrierRestrictions = new CarrierRestrictionsWithPriority();
    carrierRestrictions.allowedCarriers = carriers.allowedCarriers;
    carrierRestrictions.excludedCarriers = carriers.excludedCarriers;
    carrierRestrictions.allowedCarriersPrioritized = true;
    responseCarrierRestrictions(responseInfo, allAllowed, carrierRestrictions, SimLockMultiSimPolicy.NO_MULTISIM_POLICY);
}
#end_block

#method_before
private void responseSignalStrength(RadioResponseInfo responseInfo, android.hardware.radio.V1_0.SignalStrength signalStrength) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        SignalStrength ret = RIL.convertHalSignalStrength(signalStrength);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#method_after
private void responseSignalStrength(RadioResponseInfo responseInfo, android.hardware.radio.V1_0.SignalStrength signalStrength) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        SignalStrength ret = new SignalStrength(signalStrength);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#end_block

#method_before
private void responseSignalStrength_1_2(RadioResponseInfo responseInfo, android.hardware.radio.V1_2.SignalStrength signalStrength) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        SignalStrength ret = RIL.convertHalSignalStrength_1_2(signalStrength);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#method_after
private void responseSignalStrength_1_2(RadioResponseInfo responseInfo, android.hardware.radio.V1_2.SignalStrength signalStrength) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        SignalStrength ret = new SignalStrength(signalStrength);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#end_block

#method_before
@Override
public void getDataCallList(Message result) {
    resultSuccess(result, new ArrayList<DataCallResponse>(0));
}
#method_after
@Override
public void getDataCallList(Message result) {
    ArrayList<SetupDataCallResult> dcCallList = new ArrayList<SetupDataCallResult>(0);
    SimulatedCommandsVerifier.getInstance().getDataCallList(result);
    if (mSetupDataCallResult != null) {
        dcCallList.add(mSetupDataCallResult);
    }
    resultSuccess(result, dcCallList);
}
#end_block

#method_before
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    SimulatedCommandsVerifier.getInstance().dial(address, clirMode, uusInfo, result);
    simulatedCallState.onDial(address);
    resultSuccess(result, null);
}
#method_after
@Override
public void dial(String address, boolean isEmergencyCall, EmergencyNumber emergencyNumberInfo, int clirMode, Message result) {
    SimulatedCommandsVerifier.getInstance().dial(address, isEmergencyCall, emergencyNumberInfo, clirMode, result);
    simulatedCallState.onDial(address);
    resultSuccess(result, null);
}
#end_block

#method_before
@Override
public void getSignalStrength(Message result) {
    if (mSignalStrength == null) {
        mSignalStrength = new SignalStrength(// gsmSignalStrength
        20, // gsmBitErrorRate
        0, // cdmaDbm
        -1, // cdmaEcio
        -1, // evdoDbm
        -1, // evdoEcio
        -1, // evdoSnr
        -1, // lteSignalStrength
        99, // lteRsrp
        SignalStrength.INVALID, // lteRsrq
        SignalStrength.INVALID, // lteRssnr
        SignalStrength.INVALID, // lteCqi
        SignalStrength.INVALID, // tdScdmaRscp
        SignalStrength.INVALID);
    }
    resultSuccess(result, mSignalStrength);
}
#method_after
@Override
public void getSignalStrength(Message result) {
    if (mSignalStrength == null) {
        mSignalStrength = new SignalStrength(new CellSignalStrengthCdma(), new CellSignalStrengthGsm(20, 0, CellInfo.UNAVAILABLE), new CellSignalStrengthWcdma(), new CellSignalStrengthTdscdma(), new CellSignalStrengthLte());
    }
    resultSuccess(result, mSignalStrength);
}
#end_block

#method_before
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message result, WorkSource workSource) {
    unimplemented(result);
}
#method_after
@Override
public void setAllowedCarriers(CarrierRestrictionRules carrierRestrictionRules, Message result, WorkSource workSource) {
    unimplemented(result);
}
#end_block

#method_before
public void notifySignalStrength() {
    if (mSignalStrength == null) {
        mSignalStrength = new SignalStrength(// gsmSignalStrength
        20, // gsmBitErrorRate
        0, // cdmaDbm
        -1, // cdmaEcio
        -1, // evdoDbm
        -1, // evdoEcio
        -1, // evdoSnr
        -1, // lteSignalStrength
        99, // lteRsrp
        SignalStrength.INVALID, // lteRsrq
        SignalStrength.INVALID, // lteRssnr
        SignalStrength.INVALID, // lteCqi
        SignalStrength.INVALID, // tdScdmaRscp
        SignalStrength.INVALID);
    }
    if (mSignalStrengthRegistrant != null) {
        mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, mSignalStrength, null));
    }
}
#method_after
public void notifySignalStrength() {
    if (mSignalStrength == null) {
        mSignalStrength = new SignalStrength(new CellSignalStrengthCdma(), new CellSignalStrengthGsm(20, 0, CellInfo.UNAVAILABLE), new CellSignalStrengthWcdma(), new CellSignalStrengthTdscdma(), new CellSignalStrengthLte());
    }
    if (mSignalStrengthRegistrant != null) {
        mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, mSignalStrength, null));
    }
}
#end_block

#method_before
private String convertNullToEmptyString(String string) {
    return string != null ? string : "";
}
#method_after
private static String convertNullToEmptyString(String string) {
    return string != null ? string : "";
}
#end_block

#method_before
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DIAL, result, mRILDefaultWorkSource);
        Dial dialInfo = new Dial();
        dialInfo.address = convertNullToEmptyString(address);
        dialInfo.clir = clirMode;
        if (uusInfo != null) {
            UusInfo info = new UusInfo();
            info.uusType = uusInfo.getType();
            info.uusDcs = uusInfo.getDcs();
            info.uusData = new String(uusInfo.getUserData());
            dialInfo.uusInfo.add(info);
        }
        if (RILJ_LOGD) {
            // Do not log function arg for privacy
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.dial(rr.mSerial, dialInfo);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "dial", e);
        }
    }
}
#method_after
@Override
public void dial(String address, boolean isEmergencyCall, EmergencyNumber emergencyNumberInfo, int clirMode, Message result) {
    dial(address, isEmergencyCall, emergencyNumberInfo, clirMode, null, result);
}
#end_block

#method_before
@Override
public void setPreferredNetworkType(int networkType, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " networkType = " + networkType);
        }
        mPreferredNetworkType = networkType;
        mMetrics.writeSetPreferredNetworkType(mPhoneId, networkType);
        try {
            radioProxy.setPreferredNetworkType(rr.mSerial, networkType);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setPreferredNetworkType", e);
        }
    }
}
#method_after
@Override
public void setPreferredNetworkType(int networkType, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " networkType = " + networkType);
        }
        mPreferredNetworkType = networkType;
        mMetrics.writeSetPreferredNetworkType(mPhoneId, networkType);
        if (mRadioVersion.lessOrEqual(RADIO_HAL_VERSION_1_3)) {
            try {
                radioProxy.setPreferredNetworkType(rr.mSerial, networkType);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setPreferredNetworkType", e);
            }
        } else if (mRadioVersion.equals(RADIO_HAL_VERSION_1_4)) {
            android.hardware.radio.V1_4.IRadio radioProxy14 = (android.hardware.radio.V1_4.IRadio) radioProxy;
            try {
                radioProxy14.setPreferredNetworkTypeBitmap(rr.mSerial, RadioAccessFamily.getRafFromNetworkType(networkType));
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setPreferredNetworkTypeBitmap", e);
            }
        }
    }
}
#end_block

#method_before
@Override
public void getPreferredNetworkType(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getPreferredNetworkType(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getPreferredNetworkType", e);
        }
    }
}
#method_after
@Override
public void getPreferredNetworkType(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        if (mRadioVersion.lessOrEqual(RADIO_HAL_VERSION_1_3)) {
            try {
                radioProxy.getPreferredNetworkType(rr.mSerial);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "getPreferredNetworkType", e);
            }
        } else if (mRadioVersion.equals(RADIO_HAL_VERSION_1_4)) {
            android.hardware.radio.V1_4.IRadio radioProxy14 = (android.hardware.radio.V1_4.IRadio) radioProxy;
            try {
                radioProxy14.getPreferredNetworkTypeBitmap(rr.mSerial);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "getPreferredNetworkTypeBitmap", e);
            }
        }
    }
}
#end_block

#method_before
@Override
public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            if (Build.IS_DEBUGGABLE) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " cla = " + cla + " instruction = " + instruction + " p1 = " + p1 + " p2 = " + " p3 = " + p3 + " data = " + data);
            } else {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
        }
        SimApdu msg = createSimApdu(0, cla, instruction, p1, p2, p3, data);
        try {
            radioProxy.iccTransmitApduBasicChannel(rr.mSerial, msg);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccTransmitApduBasicChannel", e);
        }
    }
}
#method_after
@Override
public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            if (Build.IS_DEBUGGABLE) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + String.format(" cla = 0x%02X ins = 0x%02X", cla, instruction) + String.format(" p1 = 0x%02X p2 = 0x%02X p3 = 0x%02X", p1, p2, p3) + " data = " + data);
            } else {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
        }
        SimApdu msg = createSimApdu(0, cla, instruction, p1, p2, p3, data);
        try {
            radioProxy.iccTransmitApduBasicChannel(rr.mSerial, msg);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccTransmitApduBasicChannel", e);
        }
    }
}
#end_block

#method_before
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message result) {
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            if (Build.IS_DEBUGGABLE) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " channel = " + channel + " cla = " + cla + " instruction = " + instruction + " p1 = " + p1 + " p2 = " + " p3 = " + p3 + " data = " + data);
            } else {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
        }
        SimApdu msg = createSimApdu(channel, cla, instruction, p1, p2, p3, data);
        try {
            radioProxy.iccTransmitApduLogicalChannel(rr.mSerial, msg);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccTransmitApduLogicalChannel", e);
        }
    }
}
#method_after
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message result) {
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            if (Build.IS_DEBUGGABLE) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + String.format(" channel = %d", channel) + String.format(" cla = 0x%02X ins = 0x%02X", cla, instruction) + String.format(" p1 = 0x%02X p2 = 0x%02X p3 = 0x%02X", p1, p2, p3) + " data = " + data);
            } else {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
        }
        SimApdu msg = createSimApdu(channel, cla, instruction, p1, p2, p3, data);
        try {
            radioProxy.iccTransmitApduLogicalChannel(rr.mSerial, msg);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccTransmitApduLogicalChannel", e);
        }
    }
}
#end_block

#method_before
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message result, WorkSource workSource) {
    checkNotNull(carriers, "Allowed carriers list cannot be null.");
    workSource = getDeafultWorkSourceIfInvalid(workSource);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_CARRIERS, result, workSource);
        if (RILJ_LOGD) {
            String logStr = "";
            for (int i = 0; i < carriers.size(); i++) {
                logStr = logStr + carriers.get(i) + " ";
            }
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " carriers = " + logStr);
        }
        boolean allAllowed;
        if (carriers.size() == 0) {
            allAllowed = true;
        } else {
            allAllowed = false;
        }
        CarrierRestrictions carrierList = new CarrierRestrictions();
        for (CarrierIdentifier ci : carriers) {
            /* allowed carriers */
            Carrier c = new Carrier();
            c.mcc = convertNullToEmptyString(ci.getMcc());
            c.mnc = convertNullToEmptyString(ci.getMnc());
            int matchType = CarrierIdentifier.MatchType.ALL;
            String matchData = null;
            if (!TextUtils.isEmpty(ci.getSpn())) {
                matchType = CarrierIdentifier.MatchType.SPN;
                matchData = ci.getSpn();
            } else if (!TextUtils.isEmpty(ci.getImsi())) {
                matchType = CarrierIdentifier.MatchType.IMSI_PREFIX;
                matchData = ci.getImsi();
            } else if (!TextUtils.isEmpty(ci.getGid1())) {
                matchType = CarrierIdentifier.MatchType.GID1;
                matchData = ci.getGid1();
            } else if (!TextUtils.isEmpty(ci.getGid2())) {
                matchType = CarrierIdentifier.MatchType.GID2;
                matchData = ci.getGid2();
            }
            c.matchType = matchType;
            c.matchData = convertNullToEmptyString(matchData);
            carrierList.allowedCarriers.add(c);
        }
        try {
            radioProxy.setAllowedCarriers(rr.mSerial, allAllowed, carrierList);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers", e);
        }
    }
}
#method_after
@Override
public void setAllowedCarriers(CarrierRestrictionRules carrierRestrictionRules, Message result, WorkSource workSource) {
    riljLog("RIL.java - setAllowedCarriers");
    checkNotNull(carrierRestrictionRules, "Carrier restriction cannot be null.");
    workSource = getDeafultWorkSourceIfInvalid(workSource);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy == null) {
        return;
    }
    RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_CARRIERS, result, workSource);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " params: " + carrierRestrictionRules);
    }
    // Extract multisim policy
    int policy = SimLockMultiSimPolicy.NO_MULTISIM_POLICY;
    switch(carrierRestrictionRules.getMultiSimPolicy()) {
        case CarrierRestrictionRules.MULTISIM_POLICY_ONE_VALID_SIM_MUST_BE_PRESENT:
            policy = SimLockMultiSimPolicy.ONE_VALID_SIM_MUST_BE_PRESENT;
            break;
    }
    if (mRadioVersion.greaterOrEqual(RADIO_HAL_VERSION_1_4)) {
        riljLog("RIL.java - Using IRadio 1.4 or greater");
        android.hardware.radio.V1_4.IRadio radioProxy14 = (android.hardware.radio.V1_4.IRadio) radioProxy;
        // Prepare structure with allowed list, excluded list and priority
        CarrierRestrictionsWithPriority carrierRestrictions = new CarrierRestrictionsWithPriority();
        carrierRestrictions.allowedCarriers = createCarrierRestrictionList(carrierRestrictionRules.getAllowedCarriers());
        carrierRestrictions.excludedCarriers = createCarrierRestrictionList(carrierRestrictionRules.getExcludedCarriers());
        carrierRestrictions.allowedCarriersPrioritized = (carrierRestrictionRules.getDefaultCarrierRestriction() == CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_NOT_ALLOWED);
        try {
            radioProxy14.setAllowedCarriers_1_4(rr.mSerial, carrierRestrictions, policy);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers_1_4", e);
        }
    } else {
        boolean isAllCarriersAllowed = carrierRestrictionRules.isAllCarriersAllowed();
        boolean supported = (isAllCarriersAllowed || (carrierRestrictionRules.getExcludedCarriers().isEmpty() && (carrierRestrictionRules.getDefaultCarrierRestriction() == CarrierRestrictionRules.CARRIER_RESTRICTION_DEFAULT_NOT_ALLOWED)));
        supported = supported && (policy == SimLockMultiSimPolicy.NO_MULTISIM_POLICY);
        if (!supported) {
            // Feature is not supported by IRadio interface
            riljLoge("setAllowedCarriers does not support excluded list on IRadio version" + " less than 1.4");
            if (result != null) {
                AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
                result.sendToTarget();
            }
            return;
        }
        riljLog("RIL.java - Using IRadio 1.3 or lower");
        // Prepare structure with allowed list
        CarrierRestrictions carrierRestrictions = new CarrierRestrictions();
        carrierRestrictions.allowedCarriers = createCarrierRestrictionList(carrierRestrictionRules.getAllowedCarriers());
        try {
            radioProxy.setAllowedCarriers(rr.mSerial, isAllCarriersAllowed, carrierRestrictions);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers", e);
        }
    }
}
#end_block

#method_before
@Override
public void getAllowedCarriers(Message result, WorkSource workSource) {
    workSource = getDeafultWorkSourceIfInvalid(workSource);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_ALLOWED_CARRIERS, result, workSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.getAllowedCarriers(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getAllowedCarriers", e);
        }
    }
}
#method_after
@Override
public void getAllowedCarriers(Message result, WorkSource workSource) {
    workSource = getDeafultWorkSourceIfInvalid(workSource);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy == null) {
        return;
    }
    RILRequest rr = obtainRequest(RIL_REQUEST_GET_ALLOWED_CARRIERS, result, workSource);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    if (mRadioVersion.greaterOrEqual(RADIO_HAL_VERSION_1_4)) {
        riljLog("RIL.java - Using IRadio 1.4 or greater");
        android.hardware.radio.V1_4.IRadio radioProxy14 = (android.hardware.radio.V1_4.IRadio) radioProxy;
        try {
            radioProxy14.getAllowedCarriers_1_4(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getAllowedCarriers_1_4", e);
        }
    } else {
        riljLog("RIL.java - Using IRadio 1.3 or lower");
        try {
            radioProxy.getAllowedCarriers(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getAllowedCarriers", e);
        }
    }
}
#end_block

#method_before
@VisibleForTesting
public static ArrayList<CellInfo> convertHalCellInfoList(ArrayList<android.hardware.radio.V1_0.CellInfo> records) {
    ArrayList<CellInfo> response = new ArrayList<CellInfo>(records.size());
    for (android.hardware.radio.V1_0.CellInfo record : records) {
        // first convert RIL CellInfo to Parcel
        Parcel p = Parcel.obtain();
        p.writeInt(record.cellInfoType);
        p.writeInt(record.registered ? 1 : 0);
        p.writeLong(SystemClock.elapsedRealtimeNanos());
        p.writeInt(CellInfo.CONNECTION_UNKNOWN);
        switch(record.cellInfoType) {
            case CellInfoType.GSM:
                {
                    CellInfoGsm cellInfoGsm = record.gsm.get(0);
                    writeToParcelForGsm(p, cellInfoGsm.cellIdentityGsm.lac, cellInfoGsm.cellIdentityGsm.cid, cellInfoGsm.cellIdentityGsm.arfcn, Byte.toUnsignedInt(cellInfoGsm.cellIdentityGsm.bsic), cellInfoGsm.cellIdentityGsm.mcc, cellInfoGsm.cellIdentityGsm.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoGsm.signalStrengthGsm.signalStrength, cellInfoGsm.signalStrengthGsm.bitErrorRate, cellInfoGsm.signalStrengthGsm.timingAdvance);
                    break;
                }
            case CellInfoType.CDMA:
                {
                    CellInfoCdma cellInfoCdma = record.cdma.get(0);
                    writeToParcelForCdma(p, cellInfoCdma.cellIdentityCdma.networkId, cellInfoCdma.cellIdentityCdma.systemId, cellInfoCdma.cellIdentityCdma.baseStationId, cellInfoCdma.cellIdentityCdma.longitude, cellInfoCdma.cellIdentityCdma.latitude, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoCdma.signalStrengthCdma.dbm, cellInfoCdma.signalStrengthCdma.ecio, cellInfoCdma.signalStrengthEvdo.dbm, cellInfoCdma.signalStrengthEvdo.ecio, cellInfoCdma.signalStrengthEvdo.signalNoiseRatio);
                    break;
                }
            case CellInfoType.LTE:
                {
                    CellInfoLte cellInfoLte = record.lte.get(0);
                    writeToParcelForLte(p, cellInfoLte.cellIdentityLte.ci, cellInfoLte.cellIdentityLte.pci, cellInfoLte.cellIdentityLte.tac, cellInfoLte.cellIdentityLte.earfcn, Integer.MAX_VALUE, cellInfoLte.cellIdentityLte.mcc, cellInfoLte.cellIdentityLte.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoLte.signalStrengthLte.signalStrength, cellInfoLte.signalStrengthLte.rsrp, cellInfoLte.signalStrengthLte.rsrq, cellInfoLte.signalStrengthLte.rssnr, cellInfoLte.signalStrengthLte.cqi, cellInfoLte.signalStrengthLte.timingAdvance, false);
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    CellInfoWcdma cellInfoWcdma = record.wcdma.get(0);
                    writeToParcelForWcdma(p, cellInfoWcdma.cellIdentityWcdma.lac, cellInfoWcdma.cellIdentityWcdma.cid, cellInfoWcdma.cellIdentityWcdma.psc, cellInfoWcdma.cellIdentityWcdma.uarfcn, cellInfoWcdma.cellIdentityWcdma.mcc, cellInfoWcdma.cellIdentityWcdma.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoWcdma.signalStrengthWcdma.signalStrength, cellInfoWcdma.signalStrengthWcdma.bitErrorRate, Integer.MAX_VALUE, Integer.MAX_VALUE);
                    break;
                }
            case CellInfoType.TD_SCDMA:
                {
                    CellInfoTdscdma cellInfoTdscdma = record.tdscdma.get(0);
                    writeToParcelForTdscdma(p, cellInfoTdscdma.cellIdentityTdscdma.lac, cellInfoTdscdma.cellIdentityTdscdma.cid, cellInfoTdscdma.cellIdentityTdscdma.cpid, Integer.MAX_VALUE, cellInfoTdscdma.cellIdentityTdscdma.mcc, cellInfoTdscdma.cellIdentityTdscdma.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, Integer.MAX_VALUE, Integer.MAX_VALUE, convertTdscdmaRscpTo1_2(cellInfoTdscdma.signalStrengthTdscdma.rscp));
                    break;
                }
            default:
                throw new RuntimeException("unexpected cellinfotype: " + record.cellInfoType);
        }
        p.setDataPosition(0);
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        p.recycle();
        response.add(InfoRec);
    }
    return response;
}
#method_after
@VisibleForTesting
public static ArrayList<CellInfo> convertHalCellInfoList(ArrayList<android.hardware.radio.V1_0.CellInfo> records) {
    ArrayList<CellInfo> response = new ArrayList<CellInfo>(records.size());
    for (android.hardware.radio.V1_0.CellInfo record : records) {
        response.add(CellInfo.create(record));
    }
    return response;
}
#end_block

#method_before
@VisibleForTesting
public static ArrayList<CellInfo> convertHalCellInfoList_1_2(ArrayList<android.hardware.radio.V1_2.CellInfo> records) {
    ArrayList<CellInfo> response = new ArrayList<CellInfo>(records.size());
    for (android.hardware.radio.V1_2.CellInfo record : records) {
        // first convert RIL CellInfo to Parcel
        Parcel p = Parcel.obtain();
        p.writeInt(record.cellInfoType);
        p.writeInt(record.registered ? 1 : 0);
        p.writeLong(SystemClock.elapsedRealtimeNanos());
        p.writeInt(record.connectionStatus);
        switch(record.cellInfoType) {
            case CellInfoType.GSM:
                {
                    android.hardware.radio.V1_2.CellInfoGsm cellInfoGsm = record.gsm.get(0);
                    writeToParcelForGsm(p, cellInfoGsm.cellIdentityGsm.base.lac, cellInfoGsm.cellIdentityGsm.base.cid, cellInfoGsm.cellIdentityGsm.base.arfcn, Byte.toUnsignedInt(cellInfoGsm.cellIdentityGsm.base.bsic), cellInfoGsm.cellIdentityGsm.base.mcc, cellInfoGsm.cellIdentityGsm.base.mnc, cellInfoGsm.cellIdentityGsm.operatorNames.alphaLong, cellInfoGsm.cellIdentityGsm.operatorNames.alphaShort, cellInfoGsm.signalStrengthGsm.signalStrength, cellInfoGsm.signalStrengthGsm.bitErrorRate, cellInfoGsm.signalStrengthGsm.timingAdvance);
                    break;
                }
            case CellInfoType.CDMA:
                {
                    android.hardware.radio.V1_2.CellInfoCdma cellInfoCdma = record.cdma.get(0);
                    writeToParcelForCdma(p, cellInfoCdma.cellIdentityCdma.base.networkId, cellInfoCdma.cellIdentityCdma.base.systemId, cellInfoCdma.cellIdentityCdma.base.baseStationId, cellInfoCdma.cellIdentityCdma.base.longitude, cellInfoCdma.cellIdentityCdma.base.latitude, cellInfoCdma.cellIdentityCdma.operatorNames.alphaLong, cellInfoCdma.cellIdentityCdma.operatorNames.alphaShort, cellInfoCdma.signalStrengthCdma.dbm, cellInfoCdma.signalStrengthCdma.ecio, cellInfoCdma.signalStrengthEvdo.dbm, cellInfoCdma.signalStrengthEvdo.ecio, cellInfoCdma.signalStrengthEvdo.signalNoiseRatio);
                    break;
                }
            case CellInfoType.LTE:
                {
                    android.hardware.radio.V1_2.CellInfoLte cellInfoLte = record.lte.get(0);
                    writeToParcelForLte(p, cellInfoLte.cellIdentityLte.base.ci, cellInfoLte.cellIdentityLte.base.pci, cellInfoLte.cellIdentityLte.base.tac, cellInfoLte.cellIdentityLte.base.earfcn, cellInfoLte.cellIdentityLte.bandwidth, cellInfoLte.cellIdentityLte.base.mcc, cellInfoLte.cellIdentityLte.base.mnc, cellInfoLte.cellIdentityLte.operatorNames.alphaLong, cellInfoLte.cellIdentityLte.operatorNames.alphaShort, cellInfoLte.signalStrengthLte.signalStrength, cellInfoLte.signalStrengthLte.rsrp, cellInfoLte.signalStrengthLte.rsrq, cellInfoLte.signalStrengthLte.rssnr, cellInfoLte.signalStrengthLte.cqi, cellInfoLte.signalStrengthLte.timingAdvance, false);
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    android.hardware.radio.V1_2.CellInfoWcdma cellInfoWcdma = record.wcdma.get(0);
                    writeToParcelForWcdma(p, cellInfoWcdma.cellIdentityWcdma.base.lac, cellInfoWcdma.cellIdentityWcdma.base.cid, cellInfoWcdma.cellIdentityWcdma.base.psc, cellInfoWcdma.cellIdentityWcdma.base.uarfcn, cellInfoWcdma.cellIdentityWcdma.base.mcc, cellInfoWcdma.cellIdentityWcdma.base.mnc, cellInfoWcdma.cellIdentityWcdma.operatorNames.alphaLong, cellInfoWcdma.cellIdentityWcdma.operatorNames.alphaShort, cellInfoWcdma.signalStrengthWcdma.base.signalStrength, cellInfoWcdma.signalStrengthWcdma.base.bitErrorRate, cellInfoWcdma.signalStrengthWcdma.rscp, cellInfoWcdma.signalStrengthWcdma.ecno);
                    break;
                }
            case CellInfoType.TD_SCDMA:
                {
                    android.hardware.radio.V1_2.CellInfoTdscdma cellInfoTdscdma = record.tdscdma.get(0);
                    writeToParcelForTdscdma(p, cellInfoTdscdma.cellIdentityTdscdma.base.lac, cellInfoTdscdma.cellIdentityTdscdma.base.cid, cellInfoTdscdma.cellIdentityTdscdma.base.cpid, cellInfoTdscdma.cellIdentityTdscdma.uarfcn, cellInfoTdscdma.cellIdentityTdscdma.base.mcc, cellInfoTdscdma.cellIdentityTdscdma.base.mnc, cellInfoTdscdma.cellIdentityTdscdma.operatorNames.alphaLong, cellInfoTdscdma.cellIdentityTdscdma.operatorNames.alphaShort, cellInfoTdscdma.signalStrengthTdscdma.signalStrength, cellInfoTdscdma.signalStrengthTdscdma.bitErrorRate, cellInfoTdscdma.signalStrengthTdscdma.rscp);
                    break;
                }
            default:
                throw new RuntimeException("unexpected cellinfotype: " + record.cellInfoType);
        }
        p.setDataPosition(0);
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        p.recycle();
        response.add(InfoRec);
    }
    return response;
}
#method_after
@VisibleForTesting
public static ArrayList<CellInfo> convertHalCellInfoList_1_2(ArrayList<android.hardware.radio.V1_2.CellInfo> records) {
    ArrayList<CellInfo> response = new ArrayList<CellInfo>(records.size());
    for (android.hardware.radio.V1_2.CellInfo record : records) {
        response.add(CellInfo.create(record));
    }
    return response;
}
#end_block

#method_before
@VisibleForTesting
public static DataCallResponse convertDataCallResult(android.hardware.radio.V1_0.SetupDataCallResult dcResult) {
    if (dcResult == null)
        return null;
    // Process address
    String[] addresses = null;
    if (!TextUtils.isEmpty(dcResult.addresses)) {
        addresses = dcResult.addresses.split("\\s+");
    }
    List<LinkAddress> laList = new ArrayList<>();
    if (addresses != null) {
        for (String address : addresses) {
            address = address.trim();
            if (address.isEmpty())
                continue;
            try {
                LinkAddress la;
                // can parse that.
                if (address.split("/").length == 2) {
                    la = new LinkAddress(address);
                } else {
                    InetAddress ia = NetworkUtils.numericToInetAddress(address);
                    la = new LinkAddress(ia, (ia instanceof Inet4Address) ? 32 : 128);
                }
                laList.add(la);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown address: " + address, e);
            }
        }
    }
    // Process dns
    String[] dnses = null;
    if (!TextUtils.isEmpty(dcResult.dnses)) {
        dnses = dcResult.dnses.split("\\s+");
    }
    List<InetAddress> dnsList = new ArrayList<>();
    if (dnses != null) {
        for (String dns : dnses) {
            dns = dns.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(dns);
                dnsList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown dns: " + dns, e);
            }
        }
    }
    // Process gateway
    String[] gateways = null;
    if (!TextUtils.isEmpty(dcResult.gateways)) {
        gateways = dcResult.gateways.split("\\s+");
    }
    List<InetAddress> gatewayList = new ArrayList<>();
    if (gateways != null) {
        for (String gateway : gateways) {
            gateway = gateway.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(gateway);
                gatewayList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown gateway: " + gateway, e);
            }
        }
    }
    return new DataCallResponse(dcResult.status, dcResult.suggestedRetryTime, dcResult.cid, dcResult.active, dcResult.type, dcResult.ifname, laList, dnsList, gatewayList, new ArrayList<>(Arrays.asList(dcResult.pcscf.trim().split("\\s+"))), dcResult.mtu);
}
#method_after
@VisibleForTesting
public static DataCallResponse convertDataCallResult(Object dcResult) {
    if (dcResult == null)
        return null;
    int status, suggestedRetryTime, cid, active, mtu;
    String type, ifname;
    String[] addresses = null;
    String[] dnses = null;
    String[] gateways = null;
    List<String> pcscfs;
    if (dcResult instanceof android.hardware.radio.V1_0.SetupDataCallResult) {
        final android.hardware.radio.V1_0.SetupDataCallResult result = (android.hardware.radio.V1_0.SetupDataCallResult) dcResult;
        status = result.status;
        suggestedRetryTime = result.suggestedRetryTime;
        cid = result.cid;
        active = result.active;
        type = result.type;
        ifname = result.ifname;
        if (!TextUtils.isEmpty(result.addresses)) {
            addresses = result.addresses.split("\\s+");
        }
        if (!TextUtils.isEmpty(result.dnses)) {
            dnses = result.dnses.split("\\s+");
        }
        if (!TextUtils.isEmpty(result.gateways)) {
            gateways = result.gateways.split("\\s+");
        }
        pcscfs = new ArrayList<>(Arrays.asList(result.pcscf.trim().split("\\s+")));
        mtu = result.mtu;
    } else if (dcResult instanceof android.hardware.radio.V1_4.SetupDataCallResult) {
        final android.hardware.radio.V1_4.SetupDataCallResult result = (android.hardware.radio.V1_4.SetupDataCallResult) dcResult;
        status = result.cause;
        suggestedRetryTime = result.suggestedRetryTime;
        cid = result.cid;
        active = result.active;
        type = ApnSetting.getProtocolStringFromInt(result.type);
        ifname = result.ifname;
        addresses = result.addresses.stream().toArray(String[]::new);
        dnses = result.dnses.stream().toArray(String[]::new);
        gateways = result.gateways.stream().toArray(String[]::new);
        pcscfs = result.pcscf;
        mtu = result.mtu;
    } else {
        Rlog.e(RILJ_LOG_TAG, "Unsupported SetupDataCallResult " + dcResult);
        return null;
    }
    // Process address
    List<LinkAddress> laList = new ArrayList<>();
    if (addresses != null) {
        for (String address : addresses) {
            address = address.trim();
            if (address.isEmpty())
                continue;
            try {
                LinkAddress la;
                // can parse that.
                if (address.split("/").length == 2) {
                    la = new LinkAddress(address);
                } else {
                    InetAddress ia = NetworkUtils.numericToInetAddress(address);
                    la = new LinkAddress(ia, (ia instanceof Inet4Address) ? 32 : 128);
                }
                laList.add(la);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown address: " + address, e);
            }
        }
    }
    // Process dns
    List<InetAddress> dnsList = new ArrayList<>();
    if (dnses != null) {
        for (String dns : dnses) {
            dns = dns.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(dns);
                dnsList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown dns: " + dns, e);
            }
        }
    }
    // Process gateway
    List<InetAddress> gatewayList = new ArrayList<>();
    if (gateways != null) {
        for (String gateway : gateways) {
            gateway = gateway.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(gateway);
                gatewayList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown gateway: " + gateway, e);
            }
        }
    }
    return new DataCallResponse(status, suggestedRetryTime, cid, active, type, ifname, laList, dnsList, gatewayList, pcscfs, mtu);
}
#end_block

#method_before
@VisibleForTesting
public static ArrayList<DataCallResponse> convertDataCallResultList(ArrayList<android.hardware.radio.V1_0.SetupDataCallResult> dataCallResultList) {
    ArrayList<DataCallResponse> response = new ArrayList<DataCallResponse>(dataCallResultList.size());
    for (android.hardware.radio.V1_0.SetupDataCallResult dcResult : dataCallResultList) {
        response.add(convertDataCallResult(dcResult));
    }
    return response;
}
#method_after
@VisibleForTesting
public static ArrayList<DataCallResponse> convertDataCallResultList(List<? extends Object> dataCallResultList) {
    ArrayList<DataCallResponse> response = new ArrayList<DataCallResponse>(dataCallResultList.size());
    for (Object obj : dataCallResultList) {
        response.add(convertDataCallResult(obj));
    }
    return response;
}
#end_block

#method_before
@Test
@SmallTest
public void testWriteOnSetupDataCallResponse() throws Exception {
    DataCallResponse response = new DataCallResponse(5, 6, 7, 8, "IPV4V6", FAKE_IFNAME, Arrays.asList(new LinkAddress(NetworkUtils.numericToInetAddress(FAKE_ADDRESS), 0)), Arrays.asList(NetworkUtils.numericToInetAddress(FAKE_DNS)), Arrays.asList(NetworkUtils.numericToInetAddress(FAKE_GATEWAY)), Arrays.asList(FAKE_PCSCF_ADDRESS), 1440);
    mMetrics.writeOnRilSolicitedResponse(mPhone.getPhoneId(), 1, 2, RIL_REQUEST_SETUP_DATA_CALL, response);
    TelephonyLog log = buildProto();
    assertEquals(1, log.events.length);
    assertEquals(0, log.callSessions.length);
    assertEquals(0, log.smsSessions.length);
    assertFalse(log.eventsDropped);
    TelephonyEvent.RilSetupDataCallResponse respProto = log.events[0].setupDataCallResponse;
    assertEquals(5, respProto.status);
    assertEquals(6, respProto.suggestedRetryTimeMillis);
    assertEquals(7, respProto.call.cid);
    assertEquals(PDP_TYPE_IPV4V6, respProto.call.type);
    assertEquals(FAKE_IFNAME, respProto.call.iframe);
}
#method_after
@Test
@SmallTest
public void testWriteOnSetupDataCallResponse() throws Exception {
    DataCallResponse response = new DataCallResponse(5, /* status */
    6, /* suggestedRetryTime */
    7, /* cid */
    8, /* active */
    "IPV4V6", /* type */
    FAKE_IFNAME, /* ifname */
    Arrays.asList(new LinkAddress(NetworkUtils.numericToInetAddress(FAKE_ADDRESS), 0)), /* addresses */
    Arrays.asList(NetworkUtils.numericToInetAddress(FAKE_DNS)), /* dnses */
    Arrays.asList(NetworkUtils.numericToInetAddress(FAKE_GATEWAY)), /* gateways */
    Arrays.asList(FAKE_PCSCF_ADDRESS), /* pcscfs */
    1440);
    mMetrics.writeOnRilSolicitedResponse(mPhone.getPhoneId(), 1, 2, RIL_REQUEST_SETUP_DATA_CALL, response);
    TelephonyLog log = buildProto();
    assertEquals(1, log.events.length);
    assertEquals(0, log.callSessions.length);
    assertEquals(0, log.smsSessions.length);
    assertFalse(log.eventsDropped);
    TelephonyEvent.RilSetupDataCallResponse respProto = log.events[0].setupDataCallResponse;
    assertEquals(5, respProto.status);
    assertEquals(6, respProto.suggestedRetryTimeMillis);
    assertEquals(7, respProto.call.cid);
    assertEquals(PDP_TYPE_IPV4V6, respProto.call.type);
    assertEquals(FAKE_IFNAME, respProto.call.iframe);
}
#end_block

#method_before
private void onDataStateChanged(ArrayList<DataCallResponse> dcsList) {
    final ArrayList<DataConnection> dcListAll;
    final HashMap<Integer, DataConnection> dcListActiveByCid;
    synchronized (mDcListAll) {
        dcListAll = new ArrayList<>(mDcListAll);
        dcListActiveByCid = new HashMap<>(mDcListActiveByCid);
    }
    if (DBG) {
        lr("onDataStateChanged: dcsList=" + dcsList + " dcListActiveByCid=" + dcListActiveByCid);
    }
    if (VDBG) {
        log("onDataStateChanged: mDcListAll=" + dcListAll);
    }
    // Create hashmap of cid to DataCallResponse
    HashMap<Integer, DataCallResponse> dataCallResponseListByCid = new HashMap<Integer, DataCallResponse>();
    for (DataCallResponse dcs : dcsList) {
        dataCallResponseListByCid.put(dcs.getCallId(), dcs);
    }
    // Add a DC that is active but not in the
    // dcsList to the list of DC's to retry
    ArrayList<DataConnection> dcsToRetry = new ArrayList<DataConnection>();
    for (DataConnection dc : dcListActiveByCid.values()) {
        if (dataCallResponseListByCid.get(dc.mCid) == null) {
            if (DBG)
                log("onDataStateChanged: add to retry dc=" + dc);
            dcsToRetry.add(dc);
        }
    }
    if (DBG)
        log("onDataStateChanged: dcsToRetry=" + dcsToRetry);
    // Find which connections have changed state and send a notification or cleanup
    // and any that are in active need to be retried.
    ArrayList<ApnContext> apnsToCleanup = new ArrayList<ApnContext>();
    boolean isAnyDataCallDormant = false;
    boolean isAnyDataCallActive = false;
    for (DataCallResponse newState : dcsList) {
        DataConnection dc = dcListActiveByCid.get(newState.getCallId());
        if (dc == null) {
            // UNSOL_DATA_CALL_LIST_CHANGED arrived before SETUP_DATA_CALL completed.
            loge("onDataStateChanged: no associated DC yet, ignore");
            continue;
        }
        List<ApnContext> apnContexts = dc.getApnContexts();
        if (apnContexts.size() == 0) {
            if (DBG)
                loge("onDataStateChanged: no connected apns, ignore");
        } else {
            // or just a notification should be sent out.
            if (DBG) {
                log("onDataStateChanged: Found ConnId=" + newState.getCallId() + " newState=" + newState.toString());
            }
            if (newState.getActive() == DATA_CONNECTION_INACTIVE) {
                if (mDct.isCleanupRequired.get()) {
                    apnsToCleanup.addAll(apnContexts);
                    mDct.isCleanupRequired.set(false);
                } else {
                    DcFailCause failCause = DcFailCause.fromInt(newState.getStatus());
                    if (failCause.isRadioRestartFailure(mPhone.getContext(), mPhone.getSubId())) {
                        if (DBG) {
                            log("onDataStateChanged: X restart radio, failCause=" + failCause);
                        }
                        mDct.sendRestartRadio();
                    } else if (mDct.isPermanentFailure(failCause)) {
                        if (DBG) {
                            log("onDataStateChanged: inactive, add to cleanup list. " + "failCause=" + failCause);
                        }
                        apnsToCleanup.addAll(apnContexts);
                    } else {
                        if (DBG) {
                            log("onDataStateChanged: inactive, add to retry list. " + "failCause=" + failCause);
                        }
                        dcsToRetry.add(dc);
                    }
                }
            } else {
                // Its active so update the DataConnections link properties
                UpdateLinkPropertyResult result = dc.updateLinkProperty(newState);
                if (result.oldLp.equals(result.newLp)) {
                    if (DBG)
                        log("onDataStateChanged: no change");
                } else {
                    if (result.oldLp.isIdenticalInterfaceName(result.newLp)) {
                        if (!result.oldLp.isIdenticalDnses(result.newLp) || !result.oldLp.isIdenticalRoutes(result.newLp) || !result.oldLp.isIdenticalHttpProxy(result.newLp) || !result.oldLp.isIdenticalAddresses(result.newLp)) {
                            // If the same address type was removed and
                            // added we need to cleanup
                            CompareResult<LinkAddress> car = result.oldLp.compareAddresses(result.newLp);
                            if (DBG) {
                                log("onDataStateChanged: oldLp=" + result.oldLp + " newLp=" + result.newLp + " car=" + car);
                            }
                            boolean needToClean = false;
                            for (LinkAddress added : car.added) {
                                for (LinkAddress removed : car.removed) {
                                    if (NetworkUtils.addressTypeMatches(removed.getAddress(), added.getAddress())) {
                                        needToClean = true;
                                        break;
                                    }
                                }
                            }
                            if (needToClean) {
                                if (DBG) {
                                    log("onDataStateChanged: addr change," + " cleanup apns=" + apnContexts + " oldLp=" + result.oldLp + " newLp=" + result.newLp);
                                }
                                apnsToCleanup.addAll(apnContexts);
                            } else {
                                if (DBG)
                                    log("onDataStateChanged: simple change");
                                for (ApnContext apnContext : apnContexts) {
                                    mPhone.notifyDataConnection(PhoneConstants.REASON_LINK_PROPERTIES_CHANGED, apnContext.getApnType());
                                }
                            }
                        } else {
                            if (DBG) {
                                log("onDataStateChanged: no changes");
                            }
                        }
                    } else {
                        apnsToCleanup.addAll(apnContexts);
                        if (DBG) {
                            log("onDataStateChanged: interface change, cleanup apns=" + apnContexts);
                        }
                    }
                }
            }
        }
        if (newState.getActive() == DATA_CONNECTION_ACTIVE) {
            isAnyDataCallActive = true;
        }
        if (newState.getActive() == DATA_CONNECTION_DORMANT) {
            isAnyDataCallDormant = true;
        }
    }
    if (isAnyDataCallDormant && !isAnyDataCallActive) {
        // calls are active broadcast overall link state as dormant.
        if (DBG) {
            log("onDataStateChanged: Data Activity updated to DORMANT. stopNetStatePoll");
        }
        mDct.sendStopNetStatPoll(DctConstants.Activity.DORMANT);
    } else {
        if (DBG) {
            log("onDataStateChanged: Data Activity updated to NONE. " + "isAnyDataCallActive = " + isAnyDataCallActive + " isAnyDataCallDormant = " + isAnyDataCallDormant);
        }
        if (isAnyDataCallActive) {
            mDct.sendStartNetStatPoll(DctConstants.Activity.NONE);
        }
    }
    if (DBG) {
        lr("onDataStateChanged: dcsToRetry=" + dcsToRetry + " apnsToCleanup=" + apnsToCleanup);
    }
    // Cleanup connections that have changed
    for (ApnContext apnContext : apnsToCleanup) {
        mDct.sendCleanUpConnection(true, apnContext);
    }
    // Retry connections that have disappeared
    for (DataConnection dc : dcsToRetry) {
        if (DBG)
            log("onDataStateChanged: send EVENT_LOST_CONNECTION dc.mTag=" + dc.mTag);
        dc.sendMessage(DataConnection.EVENT_LOST_CONNECTION, dc.mTag);
    }
    if (VDBG)
        log("onDataStateChanged: X");
}
#method_after
private void onDataStateChanged(ArrayList<DataCallResponse> dcsList) {
    final ArrayList<DataConnection> dcListAll;
    final HashMap<Integer, DataConnection> dcListActiveByCid;
    synchronized (mDcListAll) {
        dcListAll = new ArrayList<>(mDcListAll);
        dcListActiveByCid = new HashMap<>(mDcListActiveByCid);
    }
    if (DBG) {
        lr("onDataStateChanged: dcsList=" + dcsList + " dcListActiveByCid=" + dcListActiveByCid);
    }
    if (VDBG) {
        log("onDataStateChanged: mDcListAll=" + dcListAll);
    }
    // Create hashmap of cid to DataCallResponse
    HashMap<Integer, DataCallResponse> dataCallResponseListByCid = new HashMap<Integer, DataCallResponse>();
    for (DataCallResponse dcs : dcsList) {
        dataCallResponseListByCid.put(dcs.getCallId(), dcs);
    }
    // Add a DC that is active but not in the
    // dcsList to the list of DC's to retry
    ArrayList<DataConnection> dcsToRetry = new ArrayList<DataConnection>();
    for (DataConnection dc : dcListActiveByCid.values()) {
        if (dataCallResponseListByCid.get(dc.mCid) == null) {
            if (DBG)
                log("onDataStateChanged: add to retry dc=" + dc);
            dcsToRetry.add(dc);
        }
    }
    if (DBG)
        log("onDataStateChanged: dcsToRetry=" + dcsToRetry);
    // Find which connections have changed state and send a notification or cleanup
    // and any that are in active need to be retried.
    ArrayList<ApnContext> apnsToCleanup = new ArrayList<ApnContext>();
    boolean isAnyDataCallDormant = false;
    boolean isAnyDataCallActive = false;
    for (DataCallResponse newState : dcsList) {
        DataConnection dc = dcListActiveByCid.get(newState.getCallId());
        if (dc == null) {
            // UNSOL_DATA_CALL_LIST_CHANGED arrived before SETUP_DATA_CALL completed.
            loge("onDataStateChanged: no associated DC yet, ignore");
            continue;
        }
        List<ApnContext> apnContexts = dc.getApnContexts();
        if (apnContexts.size() == 0) {
            if (DBG)
                loge("onDataStateChanged: no connected apns, ignore");
        } else {
            // or just a notification should be sent out.
            if (DBG) {
                log("onDataStateChanged: Found ConnId=" + newState.getCallId() + " newState=" + newState.toString());
            }
            if (newState.getActive() == DataConnActiveStatus.INACTIVE) {
                if (mDct.isCleanupRequired.get()) {
                    apnsToCleanup.addAll(apnContexts);
                    mDct.isCleanupRequired.set(false);
                } else {
                    int failCause = DataFailCause.getFailCause(newState.getStatus());
                    if (DataFailCause.isRadioRestartFailure(mPhone.getContext(), failCause, mPhone.getSubId())) {
                        if (DBG) {
                            log("onDataStateChanged: X restart radio, failCause=" + failCause);
                        }
                        mDct.sendRestartRadio();
                    } else if (mDct.isPermanentFailure(failCause)) {
                        if (DBG) {
                            log("onDataStateChanged: inactive, add to cleanup list. " + "failCause=" + failCause);
                        }
                        apnsToCleanup.addAll(apnContexts);
                    } else {
                        if (DBG) {
                            log("onDataStateChanged: inactive, add to retry list. " + "failCause=" + failCause);
                        }
                        dcsToRetry.add(dc);
                    }
                }
            } else {
                // Its active so update the DataConnections link properties
                UpdateLinkPropertyResult result = dc.updateLinkProperty(newState);
                if (result.oldLp.equals(result.newLp)) {
                    if (DBG)
                        log("onDataStateChanged: no change");
                } else {
                    if (result.oldLp.isIdenticalInterfaceName(result.newLp)) {
                        if (!result.oldLp.isIdenticalDnses(result.newLp) || !result.oldLp.isIdenticalRoutes(result.newLp) || !result.oldLp.isIdenticalHttpProxy(result.newLp) || !result.oldLp.isIdenticalAddresses(result.newLp)) {
                            // If the same address type was removed and
                            // added we need to cleanup
                            CompareResult<LinkAddress> car = result.oldLp.compareAddresses(result.newLp);
                            if (DBG) {
                                log("onDataStateChanged: oldLp=" + result.oldLp + " newLp=" + result.newLp + " car=" + car);
                            }
                            boolean needToClean = false;
                            for (LinkAddress added : car.added) {
                                for (LinkAddress removed : car.removed) {
                                    if (NetworkUtils.addressTypeMatches(removed.getAddress(), added.getAddress())) {
                                        needToClean = true;
                                        break;
                                    }
                                }
                            }
                            if (needToClean) {
                                if (DBG) {
                                    log("onDataStateChanged: addr change," + " cleanup apns=" + apnContexts + " oldLp=" + result.oldLp + " newLp=" + result.newLp);
                                }
                                apnsToCleanup.addAll(apnContexts);
                            } else {
                                if (DBG)
                                    log("onDataStateChanged: simple change");
                                for (ApnContext apnContext : apnContexts) {
                                    mPhone.notifyDataConnection(apnContext.getApnType());
                                }
                            }
                        } else {
                            if (DBG) {
                                log("onDataStateChanged: no changes");
                            }
                        }
                    } else {
                        apnsToCleanup.addAll(apnContexts);
                        if (DBG) {
                            log("onDataStateChanged: interface change, cleanup apns=" + apnContexts);
                        }
                    }
                }
            }
        }
        if (newState.getActive() == DataConnActiveStatus.ACTIVE) {
            isAnyDataCallActive = true;
        }
        if (newState.getActive() == DataConnActiveStatus.DORMANT) {
            isAnyDataCallDormant = true;
        }
    }
    if (isAnyDataCallDormant && !isAnyDataCallActive) {
        // calls are active broadcast overall link state as dormant.
        if (DBG) {
            log("onDataStateChanged: Data Activity updated to DORMANT. stopNetStatePoll");
        }
        mDct.sendStopNetStatPoll(DctConstants.Activity.DORMANT);
    } else {
        if (DBG) {
            log("onDataStateChanged: Data Activity updated to NONE. " + "isAnyDataCallActive = " + isAnyDataCallActive + " isAnyDataCallDormant = " + isAnyDataCallDormant);
        }
        if (isAnyDataCallActive) {
            mDct.sendStartNetStatPoll(DctConstants.Activity.NONE);
        }
    }
    if (DBG) {
        lr("onDataStateChanged: dcsToRetry=" + dcsToRetry + " apnsToCleanup=" + apnsToCleanup);
    }
    // Cleanup connections that have changed
    for (ApnContext apnContext : apnsToCleanup) {
        mDct.cleanUpConnection(apnContext);
    }
    // Retry connections that have disappeared
    for (DataConnection dc : dcsToRetry) {
        if (DBG)
            log("onDataStateChanged: send EVENT_LOST_CONNECTION dc.mTag=" + dc.mTag);
        dc.sendMessage(DataConnection.EVENT_LOST_CONNECTION, dc.mTag);
    }
    if (VDBG)
        log("onDataStateChanged: X");
}
#end_block

#method_before
public void currentSignalStrength(int indicationType, android.hardware.radio.V1_0.SignalStrength signalStrength) {
    mRil.processIndication(indicationType);
    SignalStrength ss = RIL.convertHalSignalStrength(signalStrength);
    // Note this is set to "verbose" because it happens frequently
    if (RIL.RILJ_LOGV)
        mRil.unsljLogvRet(RIL_UNSOL_SIGNAL_STRENGTH, ss);
    if (mRil.mSignalStrengthRegistrant != null) {
        mRil.mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ss, null));
    }
}
#method_after
public void currentSignalStrength(int indicationType, android.hardware.radio.V1_0.SignalStrength signalStrength) {
    mRil.processIndication(indicationType);
    SignalStrength ss = new SignalStrength(signalStrength);
    // Note this is set to "verbose" because it happens frequently
    if (RIL.RILJ_LOGV)
        mRil.unsljLogvRet(RIL_UNSOL_SIGNAL_STRENGTH, ss);
    if (mRil.mSignalStrengthRegistrant != null) {
        mRil.mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ss, null));
    }
}
#end_block

#method_before
public void currentSignalStrength_1_2(int indicationType, android.hardware.radio.V1_2.SignalStrength signalStrength) {
    mRil.processIndication(indicationType);
    SignalStrength ss = RIL.convertHalSignalStrength_1_2(signalStrength);
    // Note this is set to "verbose" because it happens frequently
    if (RIL.RILJ_LOGV)
        mRil.unsljLogvRet(RIL_UNSOL_SIGNAL_STRENGTH, ss);
    if (mRil.mSignalStrengthRegistrant != null) {
        mRil.mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ss, null));
    }
}
#method_after
public void currentSignalStrength_1_2(int indicationType, android.hardware.radio.V1_2.SignalStrength signalStrength) {
    mRil.processIndication(indicationType);
    SignalStrength ss = new SignalStrength(signalStrength);
    // Note this is set to "verbose" because it happens frequently
    if (RIL.RILJ_LOGV)
        mRil.unsljLogvRet(RIL_UNSOL_SIGNAL_STRENGTH, ss);
    if (mRil.mSignalStrengthRegistrant != null) {
        mRil.mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ss, null));
    }
}
#end_block

#method_before
public void dataCallListChanged_1_4(int indicationType, ArrayList<android.hardware.radio.V1_4.SetupDataCallResult> dcList) {
    mRil.processIndication(indicationType);
    if (RIL.RILJ_LOGD)
        mRil.unsljLogRet(RIL_UNSOL_DATA_CALL_LIST_CHANGED, dcList);
    ArrayList<DataCallResponse> response = RIL.convertDataCallResultList_1_4(dcList);
    mRil.mDataCallListChangedRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
}
#method_after
public void dataCallListChanged_1_4(int indicationType, ArrayList<android.hardware.radio.V1_4.SetupDataCallResult> dcList) {
    mRil.processIndication(indicationType);
    if (RIL.RILJ_LOGD)
        mRil.unsljLogRet(RIL_UNSOL_DATA_CALL_LIST_CHANGED, dcList);
    ArrayList<DataCallResponse> response = RIL.convertDataCallResultList(dcList);
    mRil.mDataCallListChangedRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
}
#end_block

#method_before
public void rilConnected(int indicationType) {
    mRil.processIndication(indicationType);
    if (RIL.RILJ_LOGD)
        mRil.unsljLog(RIL_UNSOL_RIL_CONNECTED);
    // Initial conditions
    mRil.setRadioPower(false, null);
    mRil.setCdmaSubscriptionSource(mRil.mCdmaSubscription, null);
    mRil.setCellInfoListRate();
    // todo: this should not require a version number now. Setting it to latest RIL version for
    // now.
    mRil.notifyRegistrantsRilConnectionChanged(15);
}
#method_after
public void rilConnected(int indicationType) {
    mRil.processIndication(indicationType);
    if (RIL.RILJ_LOGD)
        mRil.unsljLog(RIL_UNSOL_RIL_CONNECTED);
    // Initial conditions
    mRil.setRadioPower(false, null);
    mRil.setCdmaSubscriptionSource(mRil.mCdmaSubscription, null);
    // todo: this should not require a version number now. Setting it to latest RIL version for
    // now.
    mRil.notifyRegistrantsRilConnectionChanged(15);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForLTE() throws Exception {
    android.hardware.radio.V1_0.CellInfoLte lte = new android.hardware.radio.V1_0.CellInfoLte();
    lte.cellIdentityLte.ci = CI;
    lte.cellIdentityLte.pci = PCI;
    lte.cellIdentityLte.tac = TAC;
    lte.cellIdentityLte.earfcn = EARFCN;
    lte.cellIdentityLte.mcc = MCC_STR;
    lte.cellIdentityLte.mnc = MNC_STR;
    lte.signalStrengthLte.signalStrength = SIGNAL_STRENGTH;
    lte.signalStrengthLte.rsrp = RSRP;
    lte.signalStrengthLte.rsrq = RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, Integer.MAX_VALUE, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoListForLTE() throws Exception {
    android.hardware.radio.V1_0.CellInfoLte lte = new android.hardware.radio.V1_0.CellInfoLte();
    lte.cellIdentityLte.ci = CI;
    lte.cellIdentityLte.pci = PCI;
    lte.cellIdentityLte.tac = TAC;
    lte.cellIdentityLte.earfcn = EARFCN;
    lte.cellIdentityLte.mcc = MCC_STR;
    lte.cellIdentityLte.mnc = MNC_STR;
    lte.signalStrengthLte.signalStrength = RSSI_ASU;
    lte.signalStrengthLte.rsrp = -RSRP;
    lte.signalStrengthLte.rsrq = -RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, Integer.MAX_VALUE, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(RSSI, RSRP, RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForGSM() throws Exception {
    android.hardware.radio.V1_0.CellInfoGsm cellinfo = new android.hardware.radio.V1_0.CellInfoGsm();
    cellinfo.cellIdentityGsm.lac = LAC;
    cellinfo.cellIdentityGsm.cid = CID;
    cellinfo.cellIdentityGsm.bsic = BSIC;
    cellinfo.cellIdentityGsm.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.mcc = MCC_STR;
    cellinfo.cellIdentityGsm.mnc = MNC_STR;
    cellinfo.signalStrengthGsm.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoListForGSM() throws Exception {
    android.hardware.radio.V1_0.CellInfoGsm cellinfo = new android.hardware.radio.V1_0.CellInfoGsm();
    cellinfo.cellIdentityGsm.lac = LAC;
    cellinfo.cellIdentityGsm.cid = CID;
    cellinfo.cellIdentityGsm.bsic = BSIC;
    cellinfo.cellIdentityGsm.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.mcc = MCC_STR;
    cellinfo.cellIdentityGsm.mnc = MNC_STR;
    cellinfo.signalStrengthGsm.signalStrength = RSSI_ASU;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(RSSI, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForWcdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoWcdma cellinfo = new android.hardware.radio.V1_0.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.lac = LAC;
    cellinfo.cellIdentityWcdma.cid = CID;
    cellinfo.cellIdentityWcdma.psc = PSC;
    cellinfo.cellIdentityWcdma.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.mcc = MCC_STR;
    cellinfo.cellIdentityWcdma.mnc = MNC_STR;
    cellinfo.signalStrengthWcdma.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthWcdma.bitErrorRate = BIT_ERROR_RATE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE, Integer.MAX_VALUE, Integer.MAX_VALUE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoListForWcdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoWcdma cellinfo = new android.hardware.radio.V1_0.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.lac = LAC;
    cellinfo.cellIdentityWcdma.cid = CID;
    cellinfo.cellIdentityWcdma.psc = PSC;
    cellinfo.cellIdentityWcdma.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.mcc = MCC_STR;
    cellinfo.cellIdentityWcdma.mnc = MNC_STR;
    cellinfo.signalStrengthWcdma.signalStrength = RSSI_ASU;
    cellinfo.signalStrengthWcdma.bitErrorRate = BIT_ERROR_RATE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(RSSI, BIT_ERROR_RATE, Integer.MAX_VALUE, Integer.MAX_VALUE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForTdscdma() throws Exception {
    android.hardware.radio.V1_2.CellInfoTdscdma cellinfo = new android.hardware.radio.V1_2.CellInfoTdscdma();
    cellinfo.cellIdentityTdscdma.base.lac = LAC;
    cellinfo.cellIdentityTdscdma.base.cid = CID;
    cellinfo.cellIdentityTdscdma.base.cpid = PSC;
    cellinfo.cellIdentityTdscdma.uarfcn = UARFCN;
    cellinfo.cellIdentityTdscdma.base.mcc = MCC_STR;
    cellinfo.cellIdentityTdscdma.base.mnc = MNC_STR;
    cellinfo.signalStrengthTdscdma.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthTdscdma.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthTdscdma.rscp = RSCP;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_TD_SCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.tdscdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList_1_2(records);
    assertEquals(1, ret.size());
    CellInfoTdscdma cellInfoTdscdma = (CellInfoTdscdma) ret.get(0);
    CellInfoTdscdma expected = new CellInfoTdscdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    CellIdentityTdscdma ci = new CellIdentityTdscdma(MCC_STR, MNC_STR, LAC, CID, PSC, UARFCN, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthTdscdma cs = new CellSignalStrengthTdscdma(SIGNAL_STRENGTH, BIT_ERROR_RATE, RSCP);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    // override the timestamp
    cellInfoTdscdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoTdscdma);
}
#method_after
@Test
public void testConvertHalCellInfoListForTdscdma() throws Exception {
    android.hardware.radio.V1_2.CellInfoTdscdma cellinfo = new android.hardware.radio.V1_2.CellInfoTdscdma();
    cellinfo.cellIdentityTdscdma.base.lac = LAC;
    cellinfo.cellIdentityTdscdma.base.cid = CID;
    cellinfo.cellIdentityTdscdma.base.cpid = PSC;
    cellinfo.cellIdentityTdscdma.uarfcn = UARFCN;
    cellinfo.cellIdentityTdscdma.base.mcc = MCC_STR;
    cellinfo.cellIdentityTdscdma.base.mnc = MNC_STR;
    cellinfo.signalStrengthTdscdma.signalStrength = RSSI_ASU;
    cellinfo.signalStrengthTdscdma.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthTdscdma.rscp = RSCP_ASU;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_TD_SCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.tdscdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList_1_2(records);
    assertEquals(1, ret.size());
    CellInfoTdscdma cellInfoTdscdma = (CellInfoTdscdma) ret.get(0);
    CellInfoTdscdma expected = new CellInfoTdscdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    CellIdentityTdscdma ci = new CellIdentityTdscdma(MCC_STR, MNC_STR, LAC, CID, PSC, UARFCN, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthTdscdma cs = new CellSignalStrengthTdscdma(RSSI, BIT_ERROR_RATE, RSCP);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    // override the timestamp
    cellInfoTdscdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoTdscdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForCdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoCdma cellinfo = new android.hardware.radio.V1_0.CellInfoCdma();
    cellinfo.cellIdentityCdma.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.latitude = LATITUDE;
    cellinfo.signalStrengthCdma.dbm = DBM;
    cellinfo.signalStrengthCdma.ecio = ECIO;
    cellinfo.signalStrengthEvdo.dbm = DBM;
    cellinfo.signalStrengthEvdo.ecio = ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOISE_RATIO;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(DBM, ECIO, DBM, ECIO, SIGNAL_NOISE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoCdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoCdma);
}
#method_after
@Test
public void testConvertHalCellInfoListForCdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoCdma cellinfo = new android.hardware.radio.V1_0.CellInfoCdma();
    cellinfo.cellIdentityCdma.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.latitude = LATITUDE;
    cellinfo.signalStrengthCdma.dbm = -DBM;
    cellinfo.signalStrengthCdma.ecio = -ECIO;
    cellinfo.signalStrengthEvdo.dbm = -DBM;
    cellinfo.signalStrengthEvdo.ecio = -ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOISE_RATIO;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(DBM, ECIO, DBM, ECIO, SIGNAL_NOISE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    // override the timestamp
    cellInfoCdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoCdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForLTE() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForLTE() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(RSSI, RSRP, RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2_ForLTEWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2_ForLTEWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(RSSI, RSRP, RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForLTEWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForLTE(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForLTEWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForLTE(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(RSSI, RSRP, RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoLte.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForGSM() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForGSM() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(RSSI, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(RSSI, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForGSM(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    expected.setCellSignalStrength(cs);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForGSM(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm(RSSI, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    expected.setCellSignalStrength(cs);
    // override the timestamp
    cellInfoGsm.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForWcdma() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE, RSCP, ECNO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForWcdma() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(RSSI, BIT_ERROR_RATE, RSCP, ECNO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE, RSCP, ECNO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(RSSI, BIT_ERROR_RATE, RSCP, ECNO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE, RSCP, ECNO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(RSSI, BIT_ERROR_RATE, RSCP, ECNO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    // override the timestamp
    cellInfoWcdma.setTimeStamp(TIMESTAMP);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertDataCallResult() throws Exception {
    android.hardware.radio.V1_0.SetupDataCallResult result = new android.hardware.radio.V1_0.SetupDataCallResult();
    result.status = android.hardware.radio.V1_0.DataCallFailCause.NONE;
    result.suggestedRetryTime = -1;
    result.cid = 1;
    result.active = 1;
    result.type = "IP";
    result.ifname = "eth0";
    result.addresses = "10.0.2.15";
    result.dnses = "10.0.2.3";
    result.gateways = "10.0.2.15 fe80::2";
    result.pcscf = "";
    result.mtu = 1500;
    DataCallResponse response = new DataCallResponse(0, -1, 1, 1, "IP", "eth0", Arrays.asList(new LinkAddress(NetworkUtils.numericToInetAddress("10.0.2.15"), 32)), Arrays.asList(NetworkUtils.numericToInetAddress("10.0.2.3")), Arrays.asList(NetworkUtils.numericToInetAddress("10.0.2.15"), NetworkUtils.numericToInetAddress("fe80::2")), Arrays.asList(""), 1500);
    assertEquals(response, RIL.convertDataCallResult(result));
    result.status = android.hardware.radio.V1_0.DataCallFailCause.NONE;
    result.suggestedRetryTime = -1;
    result.cid = 0;
    result.active = 2;
    result.type = "IPV4V6";
    result.ifname = "ifname";
    result.addresses = "2607:fb90:a620:651d:eabe:f8da:c107:44be/64";
    result.dnses = "fd00:976a::9      fd00:976a::10";
    result.gateways = "fe80::4c61:1832:7b28:d36c    1.2.3.4";
    result.pcscf = "fd00:976a:c206:20::6   fd00:976a:c206:20::9    fd00:976a:c202:1d::9";
    result.mtu = 1500;
    response = new DataCallResponse(0, -1, 0, 2, "IPV4V6", "ifname", Arrays.asList(new LinkAddress("2607:fb90:a620:651d:eabe:f8da:c107:44be/64")), Arrays.asList(NetworkUtils.numericToInetAddress("fd00:976a::9"), NetworkUtils.numericToInetAddress("fd00:976a::10")), Arrays.asList(NetworkUtils.numericToInetAddress("fe80::4c61:1832:7b28:d36c"), NetworkUtils.numericToInetAddress("1.2.3.4")), Arrays.asList("fd00:976a:c206:20::6", "fd00:976a:c206:20::9", "fd00:976a:c202:1d::9"), 1500);
    assertEquals(response, RIL.convertDataCallResult(result));
}
#method_after
@Test
public void testConvertDataCallResult() throws Exception {
    // Test V1.0 SetupDataCallResult
    android.hardware.radio.V1_0.SetupDataCallResult result10 = new android.hardware.radio.V1_0.SetupDataCallResult();
    result10.status = android.hardware.radio.V1_0.DataCallFailCause.NONE;
    result10.suggestedRetryTime = -1;
    result10.cid = 0;
    result10.active = 2;
    result10.type = "IPV4V6";
    result10.ifname = "ifname";
    result10.addresses = "10.0.2.15 2607:fb90:a620:651d:eabe:f8da:c107:44be/64";
    result10.dnses = "10.0.2.3 fd00:976a::9";
    result10.gateways = "10.0.2.15 fe80::2";
    result10.pcscf = "fd00:976a:c206:20::6   fd00:976a:c206:20::9    fd00:976a:c202:1d::9";
    result10.mtu = 1500;
    DataCallResponse response = new DataCallResponse(0, -1, 0, 2, "IPV4V6", "ifname", Arrays.asList(new LinkAddress(NetworkUtils.numericToInetAddress("10.0.2.15"), 32), new LinkAddress("2607:fb90:a620:651d:eabe:f8da:c107:44be/64")), Arrays.asList(NetworkUtils.numericToInetAddress("10.0.2.3"), NetworkUtils.numericToInetAddress("fd00:976a::9")), Arrays.asList(NetworkUtils.numericToInetAddress("10.0.2.15"), NetworkUtils.numericToInetAddress("fe80::2")), Arrays.asList("fd00:976a:c206:20::6", "fd00:976a:c206:20::9", "fd00:976a:c202:1d::9"), 1500);
    assertEquals(response, RIL.convertDataCallResult(result10));
    // Test V1.4 SetupDataCallResult
    android.hardware.radio.V1_4.SetupDataCallResult result14 = new android.hardware.radio.V1_4.SetupDataCallResult();
    result14.cause = android.hardware.radio.V1_4.DataCallFailCause.NONE;
    result14.suggestedRetryTime = -1;
    result14.cid = 0;
    result14.active = android.hardware.radio.V1_4.DataConnActiveStatus.ACTIVE;
    result14.type = android.hardware.radio.V1_4.PdpProtocolType.IPV4V6;
    result14.ifname = "ifname";
    result14.addresses = new ArrayList<>(Arrays.asList("10.0.2.15", "2607:fb90:a620:651d:eabe:f8da:c107:44be/64"));
    result14.dnses = new ArrayList<>(Arrays.asList("10.0.2.3", "fd00:976a::9"));
    result14.gateways = new ArrayList<>(Arrays.asList("10.0.2.15", "fe80::2"));
    result14.pcscf = new ArrayList<>(Arrays.asList("fd00:976a:c206:20::6", "fd00:976a:c206:20::9", "fd00:976a:c202:1d::9"));
    result14.mtu = 1500;
    assertEquals(response, RIL.convertDataCallResult(result14));
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForLTE(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoLte lte = new android.hardware.radio.V1_2.CellInfoLte();
    lte.cellIdentityLte.base.ci = CI;
    lte.cellIdentityLte.base.pci = PCI;
    lte.cellIdentityLte.base.tac = TAC;
    lte.cellIdentityLte.base.earfcn = EARFCN;
    lte.cellIdentityLte.bandwidth = BANDWIDTH;
    lte.cellIdentityLte.base.mcc = mcc;
    lte.cellIdentityLte.base.mnc = mnc;
    lte.cellIdentityLte.operatorNames.alphaLong = alphaLong;
    lte.cellIdentityLte.operatorNames.alphaShort = alphaShort;
    lte.signalStrengthLte.signalStrength = SIGNAL_STRENGTH;
    lte.signalStrengthLte.rsrp = RSRP;
    lte.signalStrengthLte.rsrq = RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForLTE(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoLte lte = new android.hardware.radio.V1_2.CellInfoLte();
    lte.cellIdentityLte.base.ci = CI;
    lte.cellIdentityLte.base.pci = PCI;
    lte.cellIdentityLte.base.tac = TAC;
    lte.cellIdentityLte.base.earfcn = EARFCN;
    lte.cellIdentityLte.bandwidth = BANDWIDTH;
    lte.cellIdentityLte.base.mcc = mcc;
    lte.cellIdentityLte.base.mnc = mnc;
    lte.cellIdentityLte.operatorNames.alphaLong = alphaLong;
    lte.cellIdentityLte.operatorNames.alphaShort = alphaShort;
    lte.signalStrengthLte.signalStrength = RSSI_ASU;
    lte.signalStrengthLte.rsrp = -RSRP;
    lte.signalStrengthLte.rsrq = -RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForGSM(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoGsm cellinfo = new android.hardware.radio.V1_2.CellInfoGsm();
    cellinfo.cellIdentityGsm.base.lac = LAC;
    cellinfo.cellIdentityGsm.base.cid = CID;
    cellinfo.cellIdentityGsm.base.bsic = BSIC;
    cellinfo.cellIdentityGsm.base.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.base.mcc = mcc;
    cellinfo.cellIdentityGsm.base.mnc = mnc;
    cellinfo.cellIdentityGsm.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityGsm.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthGsm.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForGSM(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoGsm cellinfo = new android.hardware.radio.V1_2.CellInfoGsm();
    cellinfo.cellIdentityGsm.base.lac = LAC;
    cellinfo.cellIdentityGsm.base.cid = CID;
    cellinfo.cellIdentityGsm.base.bsic = BSIC;
    cellinfo.cellIdentityGsm.base.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.base.mcc = mcc;
    cellinfo.cellIdentityGsm.base.mnc = mnc;
    cellinfo.cellIdentityGsm.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityGsm.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthGsm.signalStrength = RSSI_ASU;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForWcdma(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoWcdma cellinfo = new android.hardware.radio.V1_2.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.base.lac = LAC;
    cellinfo.cellIdentityWcdma.base.cid = CID;
    cellinfo.cellIdentityWcdma.base.psc = PSC;
    cellinfo.cellIdentityWcdma.base.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.base.mcc = mcc;
    cellinfo.cellIdentityWcdma.base.mnc = mnc;
    cellinfo.cellIdentityWcdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityWcdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthWcdma.base.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthWcdma.base.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthWcdma.rscp = RSCP;
    cellinfo.signalStrengthWcdma.ecno = ECNO;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForWcdma(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoWcdma cellinfo = new android.hardware.radio.V1_2.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.base.lac = LAC;
    cellinfo.cellIdentityWcdma.base.cid = CID;
    cellinfo.cellIdentityWcdma.base.psc = PSC;
    cellinfo.cellIdentityWcdma.base.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.base.mcc = mcc;
    cellinfo.cellIdentityWcdma.base.mnc = mnc;
    cellinfo.cellIdentityWcdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityWcdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthWcdma.base.signalStrength = RSSI_ASU;
    cellinfo.signalStrengthWcdma.base.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthWcdma.rscp = RSCP_ASU;
    cellinfo.signalStrengthWcdma.ecno = ECNO_ASU;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForCdma(String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoCdma cellinfo = new android.hardware.radio.V1_2.CellInfoCdma();
    cellinfo.cellIdentityCdma.base.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.base.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.base.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.base.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.base.latitude = LATITUDE;
    cellinfo.cellIdentityCdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityCdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthCdma.dbm = DBM;
    cellinfo.signalStrengthCdma.ecio = ECIO;
    cellinfo.signalStrengthEvdo.dbm = DBM;
    cellinfo.signalStrengthEvdo.ecio = ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOISE_RATIO;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForCdma(String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoCdma cellinfo = new android.hardware.radio.V1_2.CellInfoCdma();
    cellinfo.cellIdentityCdma.base.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.base.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.base.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.base.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.base.latitude = LATITUDE;
    cellinfo.cellIdentityCdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityCdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthCdma.dbm = -DBM;
    cellinfo.signalStrengthCdma.ecio = -ECIO;
    cellinfo.signalStrengthEvdo.dbm = -DBM;
    cellinfo.signalStrengthEvdo.ecio = -ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOISE_RATIO;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
private synchronized void printAllMetrics(PrintWriter rawWriter) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(rawWriter, "  ");
    pw.println("Telephony metrics proto:");
    pw.println("------------------------------------------");
    pw.println("Telephony events:");
    pw.increaseIndent();
    for (TelephonyEvent event : mTelephonyEvents) {
        pw.print(event.timestampMillis);
        pw.print(" [");
        pw.print(event.phoneId);
        pw.print("] ");
        pw.print("T=");
        if (event.type == TelephonyEvent.Type.RIL_SERVICE_STATE_CHANGED) {
            pw.print(telephonyEventToString(event.type) + "(" + event.serviceState.dataRat + ")");
        } else {
            pw.print(telephonyEventToString(event.type));
        }
        pw.println("");
    }
    pw.decreaseIndent();
    pw.println("Call sessions:");
    pw.increaseIndent();
    for (TelephonyCallSession callSession : mCompletedCallSessions) {
        pw.println("Start time in minutes: " + callSession.startTimeMinutes);
        pw.println("Events dropped: " + callSession.eventsDropped);
        pw.println("Events: ");
        pw.increaseIndent();
        for (TelephonyCallSession.Event event : callSession.events) {
            pw.print(event.delay);
            pw.print(" T=");
            if (event.type == TelephonyCallSession.Event.Type.RIL_SERVICE_STATE_CHANGED) {
                pw.println(callSessionEventToString(event.type) + "(" + event.serviceState.dataRat + ")");
            } else if (event.type == TelephonyCallSession.Event.Type.RIL_CALL_LIST_CHANGED) {
                pw.println(callSessionEventToString(event.type));
                pw.increaseIndent();
                for (RilCall call : event.calls) {
                    pw.println(call.index + ". Type = " + call.type + " State = " + call.state + " End Reason " + call.callEndReason + " isMultiparty = " + call.isMultiparty);
                }
                pw.decreaseIndent();
            } else if (event.type == TelephonyCallSession.Event.Type.AUDIO_CODEC) {
                pw.println(callSessionEventToString(event.type) + "(" + event.audioCodec + ")");
            } else {
                pw.println(callSessionEventToString(event.type));
            }
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println("Sms sessions:");
    pw.increaseIndent();
    int count = 0;
    for (SmsSession smsSession : mCompletedSmsSessions) {
        count++;
        pw.print("[" + count + "] Start time in minutes: " + smsSession.startTimeMinutes);
        if (smsSession.eventsDropped) {
            pw.println(", events dropped: " + smsSession.eventsDropped);
        }
        pw.println("Events: ");
        pw.increaseIndent();
        for (SmsSession.Event event : smsSession.events) {
            pw.print(event.delay);
            pw.print(" T=");
            pw.println(smsSessionEventToString(event.type));
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println("Modem power stats:");
    pw.increaseIndent();
    ModemPowerStats s = new ModemPowerMetrics().buildProto();
    pw.println("Power log duration (battery time) (ms): " + s.loggingDurationMs);
    pw.println("Energy consumed by modem (mAh): " + s.energyConsumedMah);
    pw.println("Number of packets sent (tx): " + s.numPacketsTx);
    pw.println("Amount of time kernel is active because of cellular data (ms): " + s.cellularKernelActiveTimeMs);
    pw.println("Amount of time spent in very poor rx signal level (ms): " + s.timeInVeryPoorRxSignalLevelMs);
    pw.println("Amount of time modem is in sleep (ms): " + s.sleepTimeMs);
    pw.println("Amount of time modem is in idle (ms): " + s.idleTimeMs);
    pw.println("Amount of time modem is in rx (ms): " + s.rxTimeMs);
    pw.println("Amount of time modem is in tx (ms): " + Arrays.toString(s.txTimeMs));
    pw.decreaseIndent();
}
#method_after
private synchronized void printAllMetrics(PrintWriter rawWriter) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(rawWriter, "  ");
    pw.println("Telephony metrics proto:");
    pw.println("------------------------------------------");
    pw.println("Telephony events:");
    pw.increaseIndent();
    for (TelephonyEvent event : mTelephonyEvents) {
        pw.print(event.timestampMillis);
        pw.print(" [");
        pw.print(event.phoneId);
        pw.print("] ");
        pw.print("T=");
        if (event.type == TelephonyEvent.Type.RIL_SERVICE_STATE_CHANGED) {
            pw.print(telephonyEventToString(event.type) + "(" + event.serviceState.dataRat + ")");
        } else {
            pw.print(telephonyEventToString(event.type));
        }
        pw.println("");
    }
    pw.decreaseIndent();
    pw.println("Call sessions:");
    pw.increaseIndent();
    for (TelephonyCallSession callSession : mCompletedCallSessions) {
        pw.println("Start time in minutes: " + callSession.startTimeMinutes);
        pw.println("Events dropped: " + callSession.eventsDropped);
        pw.println("Events: ");
        pw.increaseIndent();
        for (TelephonyCallSession.Event event : callSession.events) {
            pw.print(event.delay);
            pw.print(" T=");
            if (event.type == TelephonyCallSession.Event.Type.RIL_SERVICE_STATE_CHANGED) {
                pw.println(callSessionEventToString(event.type) + "(" + event.serviceState.dataRat + ")");
            } else if (event.type == TelephonyCallSession.Event.Type.RIL_CALL_LIST_CHANGED) {
                pw.println(callSessionEventToString(event.type));
                pw.increaseIndent();
                for (RilCall call : event.calls) {
                    pw.println(call.index + ". Type = " + call.type + " State = " + call.state + " End Reason " + call.callEndReason + " isMultiparty = " + call.isMultiparty);
                }
                pw.decreaseIndent();
            } else if (event.type == TelephonyCallSession.Event.Type.AUDIO_CODEC) {
                pw.println(callSessionEventToString(event.type) + "(" + event.audioCodec + ")");
            } else {
                pw.println(callSessionEventToString(event.type));
            }
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println("Sms sessions:");
    pw.increaseIndent();
    int count = 0;
    for (SmsSession smsSession : mCompletedSmsSessions) {
        count++;
        pw.print("[" + count + "] Start time in minutes: " + smsSession.startTimeMinutes);
        if (smsSession.eventsDropped) {
            pw.println(", events dropped: " + smsSession.eventsDropped);
        }
        pw.println("Events: ");
        pw.increaseIndent();
        for (SmsSession.Event event : smsSession.events) {
            pw.print(event.delay);
            pw.print(" T=");
            pw.println(smsSessionEventToString(event.type));
            // Only show more info for tx/rx sms
            if (event.type == SmsSession.Event.Type.SMS_SEND || event.type == SmsSession.Event.Type.SMS_RECEIVED || event.type == SmsSession.Event.Type.SMS_SEND_RESULT) {
                pw.print(" ReqId=");
                pw.println(event.rilRequestId);
                pw.print(" E=");
                pw.println(event.errorCode);
                pw.print(" RilE=");
                pw.println(event.error);
                pw.print(" ImsE=");
                pw.println(event.imsError);
            }
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println("Modem power stats:");
    pw.increaseIndent();
    ModemPowerStats s = new ModemPowerMetrics().buildProto();
    pw.println("Power log duration (battery time) (ms): " + s.loggingDurationMs);
    pw.println("Energy consumed by modem (mAh): " + s.energyConsumedMah);
    pw.println("Number of packets sent (tx): " + s.numPacketsTx);
    pw.println("Number of bytes sent (tx): " + s.numBytesTx);
    pw.println("Number of packets received (rx): " + s.numPacketsRx);
    pw.println("Number of bytes received (rx): " + s.numBytesRx);
    pw.println("Amount of time kernel is active because of cellular data (ms): " + s.cellularKernelActiveTimeMs);
    pw.println("Amount of time spent in very poor rx signal level (ms): " + s.timeInVeryPoorRxSignalLevelMs);
    pw.println("Amount of time modem is in sleep (ms): " + s.sleepTimeMs);
    pw.println("Amount of time modem is in idle (ms): " + s.idleTimeMs);
    pw.println("Amount of time modem is in rx (ms): " + s.rxTimeMs);
    pw.println("Amount of time modem is in tx (ms): " + Arrays.toString(s.txTimeMs));
    pw.println("Amount of time phone spent in various Radio Access Technologies (ms): " + Arrays.toString(s.timeInRatMs));
    pw.println("Amount of time phone spent in various cellular " + "rx signal strength levels (ms): " + Arrays.toString(s.timeInRxSignalStrengthLevelMs));
    pw.decreaseIndent();
    pw.println("Hardware Version: " + SystemProperties.get("ro.boot.revision", ""));
}
#end_block

#method_before
private synchronized void reset() {
    mTelephonyEvents.clear();
    mCompletedCallSessions.clear();
    mCompletedSmsSessions.clear();
    mTelephonyEventsDropped = false;
    mStartSystemTimeMs = System.currentTimeMillis();
    mStartElapsedTimeMs = SystemClock.elapsedRealtime();
    // base.
    for (int i = 0; i < mLastServiceState.size(); i++) {
        final int key = mLastServiceState.keyAt(i);
        TelephonyEvent event = new TelephonyEventBuilder(mStartElapsedTimeMs, key).setServiceState(mLastServiceState.get(key)).build();
        addTelephonyEvent(event);
    }
    for (int i = 0; i < mLastImsCapabilities.size(); i++) {
        final int key = mLastImsCapabilities.keyAt(i);
        TelephonyEvent event = new TelephonyEventBuilder(mStartElapsedTimeMs, key).setImsCapabilities(mLastImsCapabilities.get(key)).build();
        addTelephonyEvent(event);
    }
    for (int i = 0; i < mLastImsConnectionState.size(); i++) {
        final int key = mLastImsConnectionState.keyAt(i);
        TelephonyEvent event = new TelephonyEventBuilder(mStartElapsedTimeMs, key).setImsConnectionState(mLastImsConnectionState.get(key)).build();
        addTelephonyEvent(event);
    }
}
#method_after
private synchronized void reset() {
    mTelephonyEvents.clear();
    mCompletedCallSessions.clear();
    mCompletedSmsSessions.clear();
    mTelephonyEventsDropped = false;
    mStartSystemTimeMs = System.currentTimeMillis();
    mStartElapsedTimeMs = SystemClock.elapsedRealtime();
    // base.
    for (int i = 0; i < mLastServiceState.size(); i++) {
        final int key = mLastServiceState.keyAt(i);
        TelephonyEvent event = new TelephonyEventBuilder(mStartElapsedTimeMs, key).setServiceState(mLastServiceState.get(key)).build();
        addTelephonyEvent(event);
    }
    for (int i = 0; i < mLastImsCapabilities.size(); i++) {
        final int key = mLastImsCapabilities.keyAt(i);
        TelephonyEvent event = new TelephonyEventBuilder(mStartElapsedTimeMs, key).setImsCapabilities(mLastImsCapabilities.get(key)).build();
        addTelephonyEvent(event);
    }
    for (int i = 0; i < mLastImsConnectionState.size(); i++) {
        final int key = mLastImsConnectionState.keyAt(i);
        TelephonyEvent event = new TelephonyEventBuilder(mStartElapsedTimeMs, key).setImsConnectionState(mLastImsConnectionState.get(key)).build();
        addTelephonyEvent(event);
    }
    for (int i = 0; i < mLastCarrierId.size(); i++) {
        final int key = mLastCarrierId.keyAt(i);
        TelephonyEvent event = new TelephonyEventBuilder(mStartElapsedTimeMs, key).setCarrierIdMatching(mLastCarrierId.get(key)).build();
        addTelephonyEvent(event);
    }
}
#end_block

#method_before
private synchronized TelephonyLog buildProto() {
    TelephonyLog log = new TelephonyLog();
    // Build telephony events
    log.events = new TelephonyEvent[mTelephonyEvents.size()];
    mTelephonyEvents.toArray(log.events);
    log.eventsDropped = mTelephonyEventsDropped;
    // Build call sessions
    log.callSessions = new TelephonyCallSession[mCompletedCallSessions.size()];
    mCompletedCallSessions.toArray(log.callSessions);
    // Build SMS sessions
    log.smsSessions = new SmsSession[mCompletedSmsSessions.size()];
    mCompletedSmsSessions.toArray(log.smsSessions);
    // Build histogram. Currently we only support RIL histograms.
    List<TelephonyHistogram> rilHistograms = RIL.getTelephonyRILTimingHistograms();
    log.histograms = new TelephonyProto.TelephonyHistogram[rilHistograms.size()];
    for (int i = 0; i < rilHistograms.size(); i++) {
        log.histograms[i] = new TelephonyProto.TelephonyHistogram();
        TelephonyHistogram rilHistogram = rilHistograms.get(i);
        TelephonyProto.TelephonyHistogram histogramProto = log.histograms[i];
        histogramProto.category = rilHistogram.getCategory();
        histogramProto.id = rilHistogram.getId();
        histogramProto.minTimeMillis = rilHistogram.getMinTime();
        histogramProto.maxTimeMillis = rilHistogram.getMaxTime();
        histogramProto.avgTimeMillis = rilHistogram.getAverageTime();
        histogramProto.count = rilHistogram.getSampleCount();
        histogramProto.bucketCount = rilHistogram.getBucketCount();
        histogramProto.bucketEndPoints = rilHistogram.getBucketEndPoints();
        histogramProto.bucketCounters = rilHistogram.getBucketCounters();
    }
    // Build modem power metrics
    log.modemPowerStats = new ModemPowerMetrics().buildProto();
    // Log the starting system time
    log.startTime = new TelephonyProto.Time();
    log.startTime.systemTimestampMillis = mStartSystemTimeMs;
    log.startTime.elapsedTimestampMillis = mStartElapsedTimeMs;
    log.endTime = new TelephonyProto.Time();
    log.endTime.systemTimestampMillis = System.currentTimeMillis();
    log.endTime.elapsedTimestampMillis = SystemClock.elapsedRealtime();
    return log;
}
#method_after
private synchronized TelephonyLog buildProto() {
    TelephonyLog log = new TelephonyLog();
    // Build telephony events
    log.events = new TelephonyEvent[mTelephonyEvents.size()];
    mTelephonyEvents.toArray(log.events);
    log.eventsDropped = mTelephonyEventsDropped;
    // Build call sessions
    log.callSessions = new TelephonyCallSession[mCompletedCallSessions.size()];
    mCompletedCallSessions.toArray(log.callSessions);
    // Build SMS sessions
    log.smsSessions = new SmsSession[mCompletedSmsSessions.size()];
    mCompletedSmsSessions.toArray(log.smsSessions);
    // Build histogram. Currently we only support RIL histograms.
    List<TelephonyHistogram> rilHistograms = RIL.getTelephonyRILTimingHistograms();
    log.histograms = new TelephonyProto.TelephonyHistogram[rilHistograms.size()];
    for (int i = 0; i < rilHistograms.size(); i++) {
        log.histograms[i] = new TelephonyProto.TelephonyHistogram();
        TelephonyHistogram rilHistogram = rilHistograms.get(i);
        TelephonyProto.TelephonyHistogram histogramProto = log.histograms[i];
        histogramProto.category = rilHistogram.getCategory();
        histogramProto.id = rilHistogram.getId();
        histogramProto.minTimeMillis = rilHistogram.getMinTime();
        histogramProto.maxTimeMillis = rilHistogram.getMaxTime();
        histogramProto.avgTimeMillis = rilHistogram.getAverageTime();
        histogramProto.count = rilHistogram.getSampleCount();
        histogramProto.bucketCount = rilHistogram.getBucketCount();
        histogramProto.bucketEndPoints = rilHistogram.getBucketEndPoints();
        histogramProto.bucketCounters = rilHistogram.getBucketCounters();
    }
    // Build modem power metrics
    log.modemPowerStats = new ModemPowerMetrics().buildProto();
    // Log the hardware revision
    log.hardwareRevision = SystemProperties.get("ro.boot.revision", "");
    // Log the starting system time
    log.startTime = new TelephonyProto.Time();
    log.startTime.systemTimestampMillis = mStartSystemTimeMs;
    log.startTime.elapsedTimestampMillis = mStartElapsedTimeMs;
    log.endTime = new TelephonyProto.Time();
    log.endTime.systemTimestampMillis = System.currentTimeMillis();
    log.endTime.elapsedTimestampMillis = SystemClock.elapsedRealtime();
    return log;
}
#end_block

#method_before
private int toPdpType(String type) {
    switch(type) {
        case "IP":
            return PDP_TYPE_IP;
        case "IPV6":
            return PDP_TYPE_IPV6;
        case "IPV4V6":
            return PDP_TYPE_IPV4V6;
        case "PPP":
            return PDP_TYPE_PPP;
        case "NON-IP":
            return PDP_TYPE_NON_IP;
        case "ETHERNET":
            return PDP_TYPE_ETHERNET;
        case "UNSTRUCTURED":
            return PDP_TYPE_UNSTRUCTURED;
    }
    Rlog.e(TAG, "Unknown type: " + type);
    return PDP_UNKNOWN;
}
#method_after
private int toPdpType(String type) {
    switch(type) {
        case "IP":
            return PDP_TYPE_IP;
        case "IPV6":
            return PDP_TYPE_IPV6;
        case "IPV4V6":
            return PDP_TYPE_IPV4V6;
        case "PPP":
            return PDP_TYPE_PPP;
        case "NON-IP":
            return PDP_TYPE_NON_IP;
        case "UNSTRUCTURED":
            return PDP_TYPE_UNSTRUCTURED;
    }
    Rlog.e(TAG, "Unknown type: " + type);
    return PDP_UNKNOWN;
}
#end_block

#method_before
public synchronized void writeOnImsServiceSmsSolicitedResponse(int phoneId, @ImsSmsImplBase.SendStatusResult int resultCode, int errorReason) {
    InProgressSmsSession smsSession = mInProgressSmsSessions.get(phoneId);
    if (smsSession == null) {
        Rlog.e(TAG, "SMS session is missing");
    } else {
        smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.SMS_SEND_RESULT_IMS_SERVICE).setImsServiceErrno(resultCode).setErrorCode(errorReason));
        smsSession.decreaseExpectedResponse();
        finishSmsSessionIfNeeded(smsSession);
    }
}
#method_after
public synchronized void writeOnImsServiceSmsSolicitedResponse(int phoneId, @ImsSmsImplBase.SendStatusResult int resultCode, int errorReason) {
    InProgressSmsSession smsSession = mInProgressSmsSessions.get(phoneId);
    if (smsSession == null) {
        Rlog.e(TAG, "SMS session is missing");
    } else {
        smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.SMS_SEND_RESULT).setImsServiceErrno(resultCode).setErrorCode(errorReason));
        smsSession.decreaseExpectedResponse();
        finishSmsSessionIfNeeded(smsSession);
    }
}
#end_block

#method_before
public synchronized void writeImsServiceSendSms(int phoneId, String format) {
    InProgressSmsSession smsSession = startNewSmsSessionIfNeeded(phoneId);
    int formatCode = SmsSession.Event.Format.SMS_FORMAT_UNKNOWN;
    switch(format) {
        case SmsMessage.FORMAT_3GPP:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP;
                break;
            }
        case SmsMessage.FORMAT_3GPP2:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP2;
                break;
            }
    }
    smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.SMS_SEND_IMS_SERVICE).setTech(SmsSession.Event.Tech.SMS_IMS).setFormat(formatCode));
    smsSession.increaseExpectedResponse();
}
#method_after
public synchronized void writeImsServiceSendSms(int phoneId, String format, @ImsSmsImplBase.SendStatusResult int resultCode) {
    InProgressSmsSession smsSession = startNewSmsSessionIfNeeded(phoneId);
    int formatCode = SmsSession.Event.Format.SMS_FORMAT_UNKNOWN;
    switch(format) {
        case SmsMessage.FORMAT_3GPP:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP;
                break;
            }
        case SmsMessage.FORMAT_3GPP2:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP2;
                break;
            }
    }
    smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.SMS_SEND).setTech(SmsSession.Event.Tech.SMS_IMS).setImsServiceErrno(resultCode).setFormat(formatCode));
    smsSession.increaseExpectedResponse();
}
#end_block

#method_before
public synchronized void writeImsServiceNewSms(int phoneId, String format) {
    InProgressSmsSession smsSession = startNewSmsSessionIfNeeded(phoneId);
    int formatCode = SmsSession.Event.Format.SMS_FORMAT_UNKNOWN;
    switch(format) {
        case SmsMessage.FORMAT_3GPP:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP;
                break;
            }
        case SmsMessage.FORMAT_3GPP2:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP2;
                break;
            }
    }
    smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.SMS_RECEIVED_IMS_SERVICE).setTech(SmsSession.Event.Tech.SMS_IMS).setFormat(formatCode));
    finishSmsSessionIfNeeded(smsSession);
}
#method_after
public synchronized void writeImsServiceNewSms(int phoneId, String format, @ImsSmsImplBase.DeliverStatusResult int result) {
    InProgressSmsSession smsSession = startNewSmsSessionIfNeeded(phoneId);
    int formatCode = SmsSession.Event.Format.SMS_FORMAT_UNKNOWN;
    switch(format) {
        case SmsMessage.FORMAT_3GPP:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP;
                break;
            }
        case SmsMessage.FORMAT_3GPP2:
            {
                formatCode = SmsSession.Event.Format.SMS_FORMAT_3GPP2;
                break;
            }
    }
    int smsError = SmsManager.RESULT_ERROR_GENERIC_FAILURE;
    switch(result) {
        case ImsSmsImplBase.DELIVER_STATUS_OK:
            {
                smsError = SmsManager.RESULT_ERROR_NONE;
                break;
            }
        case ImsSmsImplBase.DELIVER_STATUS_ERROR_NO_MEMORY:
            {
                smsError = SmsManager.RESULT_NO_MEMORY;
                break;
            }
        case ImsSmsImplBase.DELIVER_STATUS_ERROR_REQUEST_NOT_SUPPORTED:
            {
                smsError = SmsManager.RESULT_REQUEST_NOT_SUPPORTED;
                break;
            }
        case ImsSmsImplBase.DELIVER_STATUS_ERROR_GENERIC:
            {
                smsError = SmsManager.RESULT_ERROR_GENERIC_FAILURE;
                break;
            }
    }
    smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.SMS_RECEIVED).setTech(SmsSession.Event.Tech.SMS_IMS).setFormat(formatCode).setErrorCode(smsError).setImsServiceErrno(TelephonyProto.ImsServiceErrno.IMS_E_SUCCESS));
    finishSmsSessionIfNeeded(smsSession);
}
#end_block

#method_before
public synchronized void writeNewCBSms(int phoneId, int format, int priority, boolean isCMAS, boolean isETWS, int serviceCategory) {
    InProgressSmsSession smsSession = startNewSmsSessionIfNeeded(phoneId);
    int type;
    if (isCMAS) {
        type = SmsSession.Event.CBMessageType.CMAS;
    } else if (isETWS) {
        type = SmsSession.Event.CBMessageType.ETWS;
    } else {
        type = SmsSession.Event.CBMessageType.OTHER;
    }
    SmsSession.Event.CBMessage cbm = new SmsSession.Event.CBMessage();
    cbm.msgFormat = format;
    cbm.msgPriority = priority + 1;
    cbm.msgType = type;
    cbm.serviceCategory = serviceCategory;
    smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.CB_SMS_RECEIVED).setCellBroadcastMessage(cbm));
    finishSmsSessionIfNeeded(smsSession);
}
#method_after
public synchronized void writeNewCBSms(int phoneId, int format, int priority, boolean isCMAS, boolean isETWS, int serviceCategory, int serialNumber, long deliveredTimestamp) {
    InProgressSmsSession smsSession = startNewSmsSessionIfNeeded(phoneId);
    int type;
    if (isCMAS) {
        type = SmsSession.Event.CBMessageType.CMAS;
    } else if (isETWS) {
        type = SmsSession.Event.CBMessageType.ETWS;
    } else {
        type = SmsSession.Event.CBMessageType.OTHER;
    }
    SmsSession.Event.CBMessage cbm = new SmsSession.Event.CBMessage();
    cbm.msgFormat = format;
    cbm.msgPriority = priority + 1;
    cbm.msgType = type;
    cbm.serviceCategory = serviceCategory;
    cbm.serialNumber = serialNumber;
    cbm.deliveredTimestampMillis = deliveredTimestamp;
    smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.CB_SMS_RECEIVED).setCellBroadcastMessage(cbm));
    finishSmsSessionIfNeeded(smsSession);
}
#end_block

#method_before
public void writeCarrierIdMatchingEvent(int phoneId, int version, int cid, String mccmnc, String gid1) {
    final CarrierIdMatching carrierIdMatching = new CarrierIdMatching();
    final CarrierIdMatchingResult carrierIdMatchingResult = new CarrierIdMatchingResult();
    if (cid != TelephonyManager.UNKNOWN_CARRIER_ID) {
        // Successful matching event if result only has carrierId
        carrierIdMatchingResult.carrierId = cid;
        // Unknown Gid1 event if result only has carrierId, gid1 and mccmnc
        if (gid1 != null) {
            carrierIdMatchingResult.mccmnc = mccmnc;
            carrierIdMatchingResult.gid1 = gid1;
        }
    } else {
        // Unknown mccmnc event if result only has mccmnc
        if (mccmnc != null) {
            carrierIdMatchingResult.mccmnc = mccmnc;
        }
    }
    carrierIdMatching.cidTableVersion = version;
    carrierIdMatching.result = carrierIdMatchingResult;
    TelephonyEvent event = new TelephonyEventBuilder(phoneId).setCarrierIdMatching(carrierIdMatching).build();
    addTelephonyEvent(event);
}
#method_after
public void writeCarrierIdMatchingEvent(int phoneId, int version, int cid, String mccmnc, String gid1) {
    final CarrierIdMatching carrierIdMatching = new CarrierIdMatching();
    final CarrierIdMatchingResult carrierIdMatchingResult = new CarrierIdMatchingResult();
    if (cid != TelephonyManager.UNKNOWN_CARRIER_ID) {
        // Successful matching event if result only has carrierId
        carrierIdMatchingResult.carrierId = cid;
        // Unknown Gid1 event if result only has carrierId, gid1 and mccmnc
        if (gid1 != null) {
            carrierIdMatchingResult.mccmnc = mccmnc;
            carrierIdMatchingResult.gid1 = gid1;
        }
    } else {
        // Unknown mccmnc event if result only has mccmnc
        if (mccmnc != null) {
            carrierIdMatchingResult.mccmnc = mccmnc;
        }
    }
    carrierIdMatching.cidTableVersion = version;
    carrierIdMatching.result = carrierIdMatchingResult;
    TelephonyEvent event = new TelephonyEventBuilder(phoneId).setCarrierIdMatching(carrierIdMatching).build();
    mLastCarrierId.put(phoneId, carrierIdMatching);
    addTelephonyEvent(event);
}
#end_block

#method_before
public boolean canHandleType(@ApnType int type) {
    if (!mCarrierEnabled) {
        return false;
    }
    // DEFAULT can handle HIPRI.
    if (hasApnType(type) || (type == TYPE_HIPRI && hasApnType(TYPE_DEFAULT))) {
        return true;
    }
    return false;
}
#method_after
public boolean canHandleType(@ApnType int type) {
    if (!mCarrierEnabled) {
        return false;
    }
    // DEFAULT can handle HIPRI.
    if (hasApnType(type)) {
        return true;
    }
    return false;
}
#end_block

#method_before
public static NetworkStatsService create(Context context, INetworkManagementService networkManager) {
    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    NetworkStatsService service = new NetworkStatsService(context, networkManager, alarmManager, wakeLock, getDefaultClock(), TelephonyManager.getDefault(), new DefaultNetworkStatsSettings(context), new NetworkStatsObservers(), getDefaultSystemDir(), getDefaultBaseDir());
    HandlerThread handlerThread = new HandlerThread(TAG);
    Handler.Callback callback = new HandlerCallback(service);
    handlerThread.start();
    Handler handler = new Handler(handlerThread.getLooper(), callback);
    service.setHandler(handler, callback);
    return service;
}
#method_after
public static NetworkStatsService create(Context context, INetworkManagementService networkManager) {
    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    NetworkStatsService service = new NetworkStatsService(context, networkManager, alarmManager, wakeLock, getDefaultClock(), TelephonyManager.getDefault(), new DefaultNetworkStatsSettings(context), new NetworkStatsObservers(), getDefaultSystemDir(), getDefaultBaseDir());
    service.registerLocalService();
    HandlerThread handlerThread = new HandlerThread(TAG);
    Handler.Callback callback = new HandlerCallback(service);
    handlerThread.start();
    Handler handler = new Handler(handlerThread.getLooper(), callback);
    service.setHandler(handler, callback);
    return service;
}
#end_block

#method_before
@Override
public DataUsageRequest registerUsageCallback(String callingPackage, DataUsageRequest request, Messenger messenger, IBinder binder) {
    checkNotNull(callingPackage, "calling package is null");
    checkNotNull(request, "DataUsageRequest is null");
    checkNotNull(request.template, "NetworkTemplate is null");
    checkNotNull(messenger, "messenger is null");
    checkNotNull(binder, "binder is null");
    int callingUid = Binder.getCallingUid();
    @NetworkStatsAccess.Level
    int accessLevel = checkAccessLevel(callingPackage);
    DataUsageRequest normalizedRequest;
    final long token = Binder.clearCallingIdentity();
    try {
        normalizedRequest = mStatsObservers.register(request, messenger, binder, callingUid, accessLevel);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // Create baseline stats
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PERFORM_POLL, FLAG_PERSIST_ALL));
    return normalizedRequest;
}
#method_after
@Override
public DataUsageRequest registerUsageCallback(String callingPackage, DataUsageRequest request, Messenger messenger, IBinder binder) {
    checkNotNull(callingPackage, "calling package is null");
    checkNotNull(request, "DataUsageRequest is null");
    checkNotNull(request.template, "NetworkTemplate is null");
    checkNotNull(messenger, "messenger is null");
    checkNotNull(binder, "binder is null");
    int callingUid = Binder.getCallingUid();
    @NetworkStatsAccess.Level
    int accessLevel = checkAccessLevel(callingPackage);
    DataUsageRequest normalizedRequest;
    final long token = Binder.clearCallingIdentity();
    try {
        normalizedRequest = mStatsObservers.register(request, messenger, binder, callingUid, accessLevel);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // Create baseline stats
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PERFORM_POLL));
    return normalizedRequest;
}
#end_block

#method_before
@Override
public long getIfaceStats(String iface, int type) {
    long nativeIfaceStats = nativeGetIfaceStat(iface, type, checkBpfStatsEnable());
    if (nativeIfaceStats == -1) {
        return nativeIfaceStats;
    } else {
        // return all zero NetworkStats when getNetworkStatsTethering(STATS_PER_IFACE)
        return nativeIfaceStats + getTetherStats(iface, type);
    }
}
#method_after
@Override
public long getIfaceStats(String iface, int type) {
    long nativeIfaceStats = nativeGetIfaceStat(iface, type, checkBpfStatsEnable());
    if (nativeIfaceStats == -1) {
        return nativeIfaceStats;
    } else {
        // when called with STATS_PER_IFACE.
        return nativeIfaceStats + getTetherStats(iface, type);
    }
}
#end_block

#method_before
private NetworkStats getNetworkStatsUidDetail(String[] ifaces) throws RemoteException {
    // TODO: remove 464xlat adjustments from NetworkStatsFactory and apply all at once here.
    final NetworkStats uidSnapshot = mNetworkManager.getNetworkStatsUidDetail(UID_ALL, ifaces);
    // fold tethering stats and operations into uid snapshot
    final NetworkStats tetherSnapshot = getNetworkStatsTethering(STATS_PER_UID);
    tetherSnapshot.filter(UID_ALL, ifaces, TAG_ALL);
    NetworkStatsFactory.apply464xlatAdjustments(uidSnapshot, tetherSnapshot);
    uidSnapshot.combineAllValues(tetherSnapshot);
    final TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    // fold video calling data usage stats into uid snapshot
    final NetworkStats vtStats = telephonyManager.getVtDataUsage(STATS_PER_UID);
    if (vtStats != null) {
        vtStats.filter(UID_ALL, ifaces, TAG_ALL);
        NetworkStatsFactory.apply464xlatAdjustments(uidSnapshot, vtStats);
        uidSnapshot.combineAllValues(vtStats);
    }
    uidSnapshot.combineAllValues(mUidOperations);
    return uidSnapshot;
}
#method_after
private NetworkStats getNetworkStatsUidDetail(String[] ifaces) throws RemoteException {
    // TODO: remove 464xlat adjustments from NetworkStatsFactory and apply all at once here.
    final NetworkStats uidSnapshot = mNetworkManager.getNetworkStatsUidDetail(UID_ALL, ifaces);
    // fold tethering stats and operations into uid snapshot
    final NetworkStats tetherSnapshot = getNetworkStatsTethering(STATS_PER_UID);
    tetherSnapshot.filter(UID_ALL, ifaces, TAG_ALL);
    NetworkStatsFactory.apply464xlatAdjustments(uidSnapshot, tetherSnapshot, mUseBpfTrafficStats);
    uidSnapshot.combineAllValues(tetherSnapshot);
    final TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    // fold video calling data usage stats into uid snapshot
    final NetworkStats vtStats = telephonyManager.getVtDataUsage(STATS_PER_UID);
    if (vtStats != null) {
        vtStats.filter(UID_ALL, ifaces, TAG_ALL);
        NetworkStatsFactory.apply464xlatAdjustments(uidSnapshot, vtStats, mUseBpfTrafficStats);
        uidSnapshot.combineAllValues(vtStats);
    }
    uidSnapshot.combineAllValues(mUidOperations);
    return uidSnapshot;
}
#end_block

#method_before
@Override
public boolean handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_PERFORM_POLL:
            {
                final int flags = msg.arg1;
                mService.performPoll(flags);
                return true;
            }
        case MSG_UPDATE_IFACES:
            {
                mService.updateIfaces(null);
                return true;
            }
        case MSG_REGISTER_GLOBAL_ALERT:
            {
                mService.registerGlobalAlert();
                return true;
            }
        default:
            {
                return false;
            }
    }
}
#method_after
@Override
public boolean handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_PERFORM_POLL:
            {
                mService.performPoll(FLAG_PERSIST_ALL);
                return true;
            }
        case MSG_PERFORM_POLL_REGISTER_ALERT:
            {
                mService.performPoll(FLAG_PERSIST_NETWORK);
                mService.registerGlobalAlert();
                return true;
            }
        default:
            {
                return false;
            }
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(@NonNull FileDescriptor bugreportFd, @Nullable FileDescriptor screenshotFd, @NonNull BugreportParams params, @Nullable BugreportListener listener) {
    // TODO(b/111441001): Enforce android.Manifest.permission.DUMP if necessary.
    DumpstateListener dsListener = new DumpstateListener(listener);
    try {
        mBinder.startBugreport(-1, /* mBinder can get it from the binder transaction */
        mContext.getOpPackageName(), bugreportFd, screenshotFd, params.getMode(), dsListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(@NonNull FileDescriptor bugreportFd, @Nullable FileDescriptor screenshotFd, @NonNull BugreportParams params, @Nullable BugreportListener listener) {
    // TODO(b/111441001): Enforce android.Manifest.permission.DUMP if necessary.
    DumpstateListener dsListener = new DumpstateListener(listener);
    try {
        // Note: mBinder can get callingUid from the binder transaction.
        mBinder.startBugreport(-1, /* callingUid */
        mContext.getOpPackageName(), bugreportFd, screenshotFd, params.getMode(), dsListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Override
public void onProgress(int progress) throws RemoteException {
// TODO(b/111441001): implement
}
#method_after
@Override
public void onProgress(int progress) throws RemoteException {
    mListener.onProgress(progress);
}
#end_block

#method_before
@Override
public void onError(int errorCode) throws RemoteException {
// TODO(b/111441001): implement
}
#method_after
@Override
public void onError(int errorCode) throws RemoteException {
    mListener.onError(errorCode);
}
#end_block

#method_before
@Override
public void onFinished(long durationMs, String title, String description) throws RemoteException {
// TODO(b/111441001): implement
}
#method_after
@Override
public void onFinished(long durationMs, String title, String description) throws RemoteException {
    mListener.onFinished(durationMs, title, description);
}
#end_block

#method_before
@Override
public void onProgressUpdated(int progress) throws RemoteException {
// TODO(b/111441001): implement
}
#method_after
@Override
public void onProgressUpdated(int progress) throws RemoteException {
// TODO(b/111441001): remove from interface
}
#end_block

#method_before
@Override
public void onMaxProgressUpdated(int maxProgress) throws RemoteException {
// TODO(b/111441001): implement
}
#method_after
@Override
public void onMaxProgressUpdated(int maxProgress) throws RemoteException {
// TODO(b/111441001): remove from interface
}
#end_block

#method_before
@Override
public void onSectionComplete(String title, int status, int size, int durationMs) throws RemoteException {
// TODO(b/111441001): implement
}
#method_after
@Override
public void onSectionComplete(String title, int status, int size, int durationMs) throws RemoteException {
// TODO(b/111441001): remove from interface
}
#end_block

#method_before
@Override
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(int callingUid, String callingPackage, FileDescriptor bugreportFd, FileDescriptor screenshotFd, int bugreportMode, IDumpstateListener listener) throws RemoteException {
    validate(bugreportMode);
    mDs = getDumpstateService();
    if (mDs == null) {
        Slog.w(TAG, "Unable to get bugreport service");
        // TODO(b/111441001): pass error on listener
        return;
    }
    mDs.startBugreport(Binder.getCallingUid(), callingPackage, bugreportFd, screenshotFd, bugreportMode, listener);
}
#method_after
@Override
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(int callingUidUnused, String callingPackage, FileDescriptor bugreportFd, FileDescriptor screenshotFd, int bugreportMode, IDumpstateListener listener) throws RemoteException {
    int callingUid = Binder.getCallingUid();
    // TODO(b/111441001): validate all arguments & ensure primary user
    validate(bugreportMode);
    mAppOps.checkPackage(callingUid, callingPackage);
    mDs = getDumpstateService();
    if (mDs == null) {
        Slog.w(TAG, "Unable to get bugreport service");
        // TODO(b/111441001): pass error on listener
        return;
    }
    mDs.startBugreport(callingUid, callingPackage, bugreportFd, screenshotFd, bugreportMode, listener);
}
#end_block

#method_before
@Override
public void callQualityChanged(CallQuality callQuality) {
    ImsCall.Listener listener;
    synchronized (ImsCall.this) {
        listener = mListener;
    }
    if (listener != null) {
        try {
            // TODO
            listener.onCallQualityChanged(ImsCall.this, callQuality);
        } catch (Throwable t) {
            loge("callQualityChanged:: ", t);
        }
    }
}
#method_after
@Override
public void callQualityChanged(CallQuality callQuality) {
    ImsCall.Listener listener;
    synchronized (ImsCall.this) {
        listener = mListener;
    }
    if (listener != null) {
        try {
            listener.onCallQualityChanged(ImsCall.this, callQuality);
        } catch (Throwable t) {
            loge("callQualityChanged:: ", t);
        }
    }
}
#end_block

#method_before
private boolean checkListenerPermission(int events, int subId, String callingPackage, String message) {
    if ((events & ENFORCE_COARSE_LOCATION_PERMISSION_MASK) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
        if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
            return false;
        }
    }
    if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
        if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mContext, subId, callingPackage, message)) {
            return false;
        }
    }
    if ((events & PRECISE_PHONE_STATE_PERMISSION_MASK) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRECISE_PHONE_STATE, null);
    }
    if ((events & PhoneStateListener.LISTEN_OEM_HOOK_RAW_EVENT) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
    }
    if ((events & PhoneStateListener.LISTEN_SRVCC_STATE_CHANGED) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
    }
    if ((events & PhoneStateListener.LISTEN_CALL_DISCONNECT_CAUSES) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRECISE_PHONE_STATE, null);
    }
    return true;
}
#method_after
private boolean checkListenerPermission(int events, int subId, String callingPackage, String message) {
    if ((events & ENFORCE_COARSE_LOCATION_PERMISSION_MASK) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
        if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
            return false;
        }
    }
    if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
        if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mContext, subId, callingPackage, message)) {
            return false;
        }
    }
    if ((events & PRECISE_PHONE_STATE_PERMISSION_MASK) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRECISE_PHONE_STATE, null);
    }
    if ((events & PhoneStateListener.LISTEN_OEM_HOOK_RAW_EVENT) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
    }
    if ((events & PhoneStateListener.LISTEN_SRVCC_STATE_CHANGED) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
    }
    if ((events & PhoneStateListener.LISTEN_PREFERRED_DATA_SUBID_CHANGE) != 0) {
        // It can have either READ_PHONE_STATE or READ_PRIVILEGED_PHONE_STATE.
        TelephonyPermissions.checkReadPhoneState(mContext, SubscriptionManager.INVALID_SUBSCRIPTION_ID, Binder.getCallingPid(), Binder.getCallingUid(), callingPackage, "listen to " + "LISTEN_PREFERRED_DATA_SUBID_CHANGE");
    }
    if ((events & PhoneStateListener.LISTEN_CALL_DISCONNECT_CAUSES) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRECISE_PHONE_STATE, null);
    }
    if ((events & PhoneStateListener.LISTEN_CALL_ATTRIBUTES_CHANGED) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRECISE_PHONE_STATE, null);
    }
    return true;
}
#end_block

#method_before
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context) {

        @Override
        public CharSequence getAccessibilityClassName() {
            return "androidx.viewpager.widget.ViewPager";
        }

        @Override
        public void onInitializeAccessibilityEvent(@NonNull AccessibilityEvent event) {
            super.onInitializeAccessibilityEvent(event);
            event.setFromIndex(mCurrentItem);
            event.setToIndex(mCurrentItem);
        }
    };
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    mPageChangeEventDispatcher = new CompositeOnPageChangeCallback(3);
    mScrollEventAdapter.setOnPageChangeCallback(mPageChangeEventDispatcher);
    // Callback that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPx) {
        }

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };
    // Add currentItemUpdater before mExternalPageChangeCallbacks, because we need to update
    // internal state first
    mPageChangeEventDispatcher.addOnPageChangeCallback(currentItemUpdater);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mExternalPageChangeCallbacks);
    // Add mPageTransformerAdapter after mExternalPageChangeCallbacks, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#method_after
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerView(context) {

        @Override
        public CharSequence getAccessibilityClassName() {
            return "androidx.viewpager.widget.ViewPager";
        }

        @Override
        public void onInitializeAccessibilityEvent(@NonNull AccessibilityEvent event) {
            super.onInitializeAccessibilityEvent(event);
            event.setFromIndex(mCurrentItem);
            event.setToIndex(mCurrentItem);
        }
    };
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManager(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    new PagerSnapHelper().attachToRecyclerView(mRecyclerView);
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    mPageChangeEventDispatcher = new CompositeOnPageChangeCallback(3);
    mScrollEventAdapter.setOnPageChangeCallback(mPageChangeEventDispatcher);
    // Callback that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback() {

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }
    };
    // Add currentItemUpdater before mExternalPageChangeCallbacks, because we need to update
    // internal state first
    mPageChangeEventDispatcher.addOnPageChangeCallback(currentItemUpdater);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mExternalPageChangeCallbacks);
    // Add mPageTransformerAdapter after mExternalPageChangeCallbacks, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#end_block

#method_before
public final void setPageTransformer(@NonNull PageTransformer transformer) {
    // TODO: add support for reverseDrawingOrder: b/112892792
    // TODO: add support for pageLayerType: b/112893074
    mPageTransformerAdapter.setPageTransformer(transformer);
}
#method_after
public final void setPageTransformer(@Nullable PageTransformer transformer) {
    // TODO: add support for reverseDrawingOrder: b/112892792
    // TODO: add support for pageLayerType: b/112893074
    mPageTransformerAdapter.setPageTransformer(transformer);
}
#end_block

#method_before
public static void checkWakeLocks() {
    // There is a small chance that while we are checking if all the commands in the queue are
    // drained and wake locks are no longer being held, a new command comes along and we end up
    // with a ConcurrentModificationException. The addition of commands happens on the command
    // processor thread and this check is done on the main thread.
    Set<PowerManager.WakeLock> wakeLocksCopy = new HashSet<>();
    synchronized (sWakeLocks) {
        // Copy the wake lockgit status
        // s - otherwise we can get a ConcurrentModificationException if the
        // garbage collector kicks in and ends up removing something from the master copy while
        // we are iterating over it.
        wakeLocksCopy.addAll(sWakeLocks.keySet());
    }
    for (PowerManager.WakeLock wakeLock : wakeLocksCopy) {
        if (wakeLock.isHeld()) {
            String message = String.format("WakeLock held for %s", sWakeLocks.get(wakeLock));
            Logger.get().warning(TAG, message);
        }
    }
}
#method_after
public static void checkWakeLocks() {
    // There is a small chance that while we are checking if all the commands in the queue are
    // drained and wake locks are no longer being held, a new command comes along and we end up
    // with a ConcurrentModificationException. The addition of commands happens on the command
    // processor thread and this check is done on the main thread.
    Map<PowerManager.WakeLock, String> wakeLocksCopy = new HashMap<>();
    synchronized (sWakeLocks) {
        // Copy the WakeLocks - otherwise we can get a ConcurrentModificationException if the
        // garbage collector kicks in and ends up removing something from the master copy while
        // we are iterating over it.
        wakeLocksCopy.putAll(sWakeLocks);
    }
    for (PowerManager.WakeLock wakeLock : wakeLocksCopy.keySet()) {
        if (wakeLock.isHeld()) {
            String message = String.format("WakeLock held for %s", wakeLocksCopy.get(wakeLock));
            Logger.get().warning(TAG, message);
        }
    }
}
#end_block

#method_before
@Test
public void nullability_defaultConstructor() {
    Destination destination = new Destination();
    assertEquals("", destination.getTitle());
    assertEquals("", destination.getAddress());
    assertNull(destination.getDistance());
    assertNull(destination.getEta());
    assertNull(destination.getLocation());
    assertEquals(Destination.Delay.DELAY_UNKNOWN, destination.getDelay());
}
#method_after
@Test
public void nullability_defaultConstructor() {
    Destination destination = new Destination();
    assertEquals("", destination.getTitle());
    assertEquals("", destination.getAddress());
    assertNull(destination.getDistance());
    assertNull(destination.getEta());
    assertNull(destination.getLocation());
    assertEquals(Destination.Traffic.UNKNOWN, destination.getTraffic());
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void builder_delayCantBeNull() {
    new Destination.Builder().setDelay(null).build();
}
#method_after
@Test(expected = NullPointerException.class)
public void builder_delayCantBeNull() {
    new Destination.Builder().setTraffic(null).build();
}
#end_block

#method_before
@Test
public void builder_emptyMatchesNullAnnotations() {
    Destination destination = new Destination.Builder().build();
    assertEquals("", destination.getTitle());
    assertEquals("", destination.getAddress());
    assertNull(destination.getDistance());
    assertNull(destination.getEta());
    assertNull(destination.getLocation());
    assertEquals(Destination.Delay.DELAY_UNKNOWN, destination.getDelay());
}
#method_after
@Test
public void builder_emptyMatchesNullAnnotations() {
    Destination destination = new Destination.Builder().build();
    assertEquals("", destination.getTitle());
    assertEquals("", destination.getAddress());
    assertNull(destination.getDistance());
    assertNull(destination.getEta());
    assertNull(destination.getLocation());
    assertEquals(Destination.Traffic.UNKNOWN, destination.getTraffic());
}
#end_block

#method_before
public static Destination createSampleDestination() {
    return new Destination.Builder().setAddress(TEST_ADDRESS).setTitle(TEST_TITLE).setDelay(TEST_DELAY).setDistance(TEST_DISTANCE).setEta(TEST_ETA).setLocation(TEST_LOCATION).build();
}
#method_after
public static Destination createSampleDestination() {
    return new Destination.Builder().setAddress(TEST_ADDRESS).setTitle(TEST_TITLE).setTraffic(Destination.Traffic.LOW).setDistance(TEST_DISTANCE).setEta(TEST_ETA).setLocation(TEST_LOCATION).build();
}
#end_block

#method_before
@NonNull
public Destination build() {
    return new Destination(mTitle, mAddress, mDistance, mEta, mLatLng, mDelay);
}
#method_after
@NonNull
public Destination build() {
    return new Destination(mTitle, mAddress, mDistance, mEta, mLatLng, mTraffic);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Destination that = (Destination) o;
    return Objects.equals(getTitle(), that.getTitle()) && Objects.equals(getAddress(), that.getAddress()) && Objects.equals(getDistance(), that.getDistance()) && Objects.equals(getLocation(), that.getLocation()) && Objects.equals(getEta(), that.getEta()) && Objects.equals(getDelay(), that.getDelay());
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Destination that = (Destination) o;
    return Objects.equals(getTitle(), that.getTitle()) && Objects.equals(getAddress(), that.getAddress()) && Objects.equals(getDistance(), that.getDistance()) && Objects.equals(getLocation(), that.getLocation()) && Objects.equals(getEta(), that.getEta()) && Objects.equals(getTraffic(), that.getTraffic());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getTitle(), getAddress(), getDistance(), getLocation(), getEta(), getDelay());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getTitle(), getAddress(), getDistance(), getLocation(), getEta(), getTraffic());
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("{title: %s, address: %s, distance: %s, location: %s, eta: %s, " + "delay: %s}", mTitle, mAddress, mDistance, mLatLng, mEta, mDelay);
}
#method_after
@Override
public String toString() {
    return String.format("{title: %s, address: %s, distance: %s, location: %s, eta: %s, " + "traffic: %s}", mTitle, mAddress, mDistance, mLatLng, mEta, mTraffic);
}
#end_block

#method_before
public void testInstallMinorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000000000ffff), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#method_after
public void testInstallMinorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000000000ffff), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#end_block

#method_before
public void testInstallMajorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ff00000000), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#method_after
public void testInstallMajorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ff00000000), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#end_block

#method_before
public void testInstallUpdateAcrossMinorMajorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000000000ffff), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_00000000ffffffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ff00000000), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ffffffffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#method_after
public void testInstallUpdateAcrossMinorMajorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000000000ffff), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_00000000ffffffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ff00000000), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ffffffffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#end_block

#method_before
public void testInstallDowngradeAcrossMajorMinorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ffffffffff), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    assertEquals("INSTALL_FAILED_VERSION_DOWNGRADE", getDevice().installPackage(mBuildHelper.getTestFile(APK_00000000ffffffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    assertEquals("INSTALL_FAILED_VERSION_DOWNGRADE", getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ff00000000), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    assertEquals("INSTALL_FAILED_VERSION_DOWNGRADE", getDevice().installPackage(mBuildHelper.getTestFile(APK_000000000000ffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runVersionDeviceTests("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#method_after
public void testInstallDowngradeAcrossMajorMinorVersion() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ffffffffff), false, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    assertEquals("INSTALL_FAILED_VERSION_DOWNGRADE", getDevice().installPackage(mBuildHelper.getTestFile(APK_00000000ffffffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    assertEquals("INSTALL_FAILED_VERSION_DOWNGRADE", getDevice().installPackage(mBuildHelper.getTestFile(APK_000000ff00000000), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    assertEquals("INSTALL_FAILED_VERSION_DOWNGRADE", getDevice().installPackage(mBuildHelper.getTestFile(APK_000000000000ffff), true, false));
    assertTrue(getDevice().getInstalledPackageNames().contains(PKG));
    runDeviceTestsAsCurrentUser("testCheckVersion");
    getDevice().uninstallPackage(PKG);
}
#end_block

#method_before
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testAppFailAccessPrivateData() throws Exception {
    Log.i(LOG_TAG, "installing app that attempts to access another app's private data");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        getDevice().uninstallPackage(APP_ACCESS_DATA_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(APP_WITH_DATA_APK), false, options);
        assertNull(String.format("failed to install app with data. Reason: %s", installResult), installResult);
        // run appwithdata's tests to create private data
        runDeviceTests(APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CREATE_METHOD);
        installResult = getDevice().installPackage(getTestAppFile(APP_ACCESS_DATA_APK), false, options);
        assertNull(String.format("failed to install app access data. Reason: %s", installResult), installResult);
        // run appaccessdata's tests which attempt to access appwithdata's private data
        runDeviceTests(APP_ACCESS_DATA_PKG);
    } finally {
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        getDevice().uninstallPackage(APP_ACCESS_DATA_PKG);
    }
}
#method_after
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testAppFailAccessPrivateData() throws Exception {
    Log.i(LOG_TAG, "installing app that attempts to access another app's private data");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        getDevice().uninstallPackage(APP_ACCESS_DATA_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(APP_WITH_DATA_APK), false, options);
        assertNull(String.format("failed to install app with data. Reason: %s", installResult), installResult);
        // run appwithdata's tests to create private data
        runDeviceTestsAsCurrentUser(APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CREATE_METHOD);
        installResult = getDevice().installPackage(getTestAppFile(APP_ACCESS_DATA_APK), false, options);
        assertNull(String.format("failed to install app access data. Reason: %s", installResult), installResult);
        // run appaccessdata's tests which attempt to access appwithdata's private data
        runDeviceTestsAsCurrentUser(APP_ACCESS_DATA_PKG);
    } finally {
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        getDevice().uninstallPackage(APP_ACCESS_DATA_PKG);
    }
}
#end_block

#method_before
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testUninstallRemovesData() throws Exception {
    Log.i(LOG_TAG, "Uninstalling app, verifying data is removed.");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(APP_WITH_DATA_APK), false, options);
        assertNull(String.format("failed to install app with data. Reason: %s", installResult), installResult);
        // run appwithdata's tests to create private data
        runDeviceTests(APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CREATE_METHOD);
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        installResult = getDevice().installPackage(getTestAppFile(APP_WITH_DATA_APK), false, options);
        assertNull(String.format("failed to install app with data second time. Reason: %s", installResult), installResult);
        // run appwithdata's 'check if file exists' test
        runDeviceTests(APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CHECK_NOEXIST_METHOD);
    } finally {
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
    }
}
#method_after
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testUninstallRemovesData() throws Exception {
    Log.i(LOG_TAG, "Uninstalling app, verifying data is removed.");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(APP_WITH_DATA_APK), false, options);
        assertNull(String.format("failed to install app with data. Reason: %s", installResult), installResult);
        // run appwithdata's tests to create private data
        runDeviceTestsAsCurrentUser(APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CREATE_METHOD);
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        installResult = getDevice().installPackage(getTestAppFile(APP_WITH_DATA_APK), false, options);
        assertNull(String.format("failed to install app with data second time. Reason: %s", installResult), installResult);
        // run appwithdata's 'check if file exists' test
        runDeviceTestsAsCurrentUser(APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CHECK_NOEXIST_METHOD);
    } finally {
        getDevice().uninstallPackage(APP_WITH_DATA_PKG);
    }
}
#end_block

#method_before
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testInstrumentationDiffCert() throws Exception {
    Log.i(LOG_TAG, "installing app that attempts to instrument another app");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(TARGET_INSTRUMENT_PKG);
        getDevice().uninstallPackage(INSTRUMENT_DIFF_CERT_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(TARGET_INSTRUMENT_APK), false, options);
        assertNull(String.format("failed to install target instrumentation app. Reason: %s", installResult), installResult);
        // the app will install, but will get error at runtime when starting instrumentation
        installResult = getDevice().installPackage(getTestAppFile(INSTRUMENT_DIFF_CERT_APK), false, options);
        assertNull(String.format("failed to install instrumentation app with diff cert. Reason: %s", installResult), installResult);
        // run INSTRUMENT_DIFF_CERT_PKG tests
        // this test will attempt to call startInstrumentation directly and verify
        // SecurityException is thrown
        runDeviceTests(INSTRUMENT_DIFF_CERT_PKG);
    } finally {
        getDevice().uninstallPackage(TARGET_INSTRUMENT_PKG);
        getDevice().uninstallPackage(INSTRUMENT_DIFF_CERT_PKG);
    }
}
#method_after
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testInstrumentationDiffCert() throws Exception {
    Log.i(LOG_TAG, "installing app that attempts to instrument another app");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(TARGET_INSTRUMENT_PKG);
        getDevice().uninstallPackage(INSTRUMENT_DIFF_CERT_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(TARGET_INSTRUMENT_APK), false, options);
        assertNull(String.format("failed to install target instrumentation app. Reason: %s", installResult), installResult);
        // the app will install, but will get error at runtime when starting instrumentation
        installResult = getDevice().installPackage(getTestAppFile(INSTRUMENT_DIFF_CERT_APK), false, options);
        assertNull(String.format("failed to install instrumentation app with diff cert. Reason: %s", installResult), installResult);
        // run INSTRUMENT_DIFF_CERT_PKG tests
        // this test will attempt to call startInstrumentation directly and verify
        // SecurityException is thrown
        runDeviceTestsAsCurrentUser(INSTRUMENT_DIFF_CERT_PKG);
    } finally {
        getDevice().uninstallPackage(TARGET_INSTRUMENT_PKG);
        getDevice().uninstallPackage(INSTRUMENT_DIFF_CERT_PKG);
    }
}
#end_block

#method_before
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testPermissionDiffCert() throws Exception {
    Log.i(LOG_TAG, "installing app that attempts to use permission of another app");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
        getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
        getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(DECLARE_PERMISSION_APK), false, options);
        assertNull(String.format("failed to install declare permission app. Reason: %s", installResult), installResult);
        installResult = getDevice().installPackage(getTestAppFile(DECLARE_PERMISSION_COMPAT_APK), false, options);
        assertNull(String.format("failed to install declare permission compat app. Reason: %s", installResult), installResult);
        // the app will install, but will get error at runtime
        installResult = getDevice().installPackage(getTestAppFile(PERMISSION_DIFF_CERT_APK), false, options);
        assertNull(String.format("failed to install permission app with diff cert. Reason: %s", installResult), installResult);
        // run PERMISSION_DIFF_CERT_PKG tests which try to access the permission
        runDeviceTests(PERMISSION_DIFF_CERT_PKG);
    } finally {
        getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
        getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
        getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);
    }
}
#method_after
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testPermissionDiffCert() throws Exception {
    Log.i(LOG_TAG, "installing app that attempts to use permission of another app");
    try {
        // cleanup test app that might be installed from previous partial test run
        getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
        getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
        getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);
        String[] options = { AbiUtils.createAbiFlag(getAbi().getName()) };
        String installResult = getDevice().installPackage(getTestAppFile(DECLARE_PERMISSION_APK), false, options);
        assertNull(String.format("failed to install declare permission app. Reason: %s", installResult), installResult);
        installResult = getDevice().installPackage(getTestAppFile(DECLARE_PERMISSION_COMPAT_APK), false, options);
        assertNull(String.format("failed to install declare permission compat app. Reason: %s", installResult), installResult);
        // the app will install, but will get error at runtime
        installResult = getDevice().installPackage(getTestAppFile(PERMISSION_DIFF_CERT_APK), false, options);
        assertNull(String.format("failed to install permission app with diff cert. Reason: %s", installResult), installResult);
        // run PERMISSION_DIFF_CERT_PKG tests which try to access the permission
        runDeviceTestsAsCurrentUser(PERMISSION_DIFF_CERT_PKG);
    } finally {
        getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
        getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
        getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);
    }
}
#end_block

#method_before
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testResolveOrderedActivity() throws Exception {
    getDevice().installPackage(mBuildHelper.getTestFile(TINY_APK), true);
    Utils.runDeviceTests(getDevice(), TINY_PKG, ".PackageResolutionTest", "queryActivityOrdered", getDevice().getCurrentUser());
    getDevice().uninstallPackage(TINY_PKG);
}
#method_after
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testResolveOrderedActivity() throws Exception {
    getDevice().installPackage(mBuildHelper.getTestFile(TINY_APK), true);
    Utils.runDeviceTestsAsCurrentUser(getDevice(), TINY_PKG, ".PackageResolutionTest", "queryActivityOrdered");
    getDevice().uninstallPackage(TINY_PKG);
}
#end_block

#method_before
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testResolveOrderedService() throws Exception {
    getDevice().installPackage(mBuildHelper.getTestFile(TINY_APK), true);
    Utils.runDeviceTests(getDevice(), TINY_PKG, ".PackageResolutionTest", "queryServiceOrdered", getDevice().getCurrentUser());
    getDevice().uninstallPackage(TINY_PKG);
}
#method_after
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testResolveOrderedService() throws Exception {
    getDevice().installPackage(mBuildHelper.getTestFile(TINY_APK), true);
    Utils.runDeviceTestsAsCurrentUser(getDevice(), TINY_PKG, ".PackageResolutionTest", "queryServiceOrdered");
    getDevice().uninstallPackage(TINY_PKG);
}
#end_block

#method_before
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testResolveOrderedReceiver() throws Exception {
    getDevice().installPackage(mBuildHelper.getTestFile(TINY_APK), true);
    Utils.runDeviceTests(getDevice(), TINY_PKG, ".PackageResolutionTest", "queryReceiverOrdered", getDevice().getCurrentUser());
    getDevice().uninstallPackage(TINY_PKG);
}
#method_after
@Test
// TODO: Needs porting to instant
@AppModeFull
public void testResolveOrderedReceiver() throws Exception {
    getDevice().installPackage(mBuildHelper.getTestFile(TINY_APK), true);
    Utils.runDeviceTestsAsCurrentUser(getDevice(), TINY_PKG, ".PackageResolutionTest", "queryReceiverOrdered");
    getDevice().uninstallPackage(TINY_PKG);
}
#end_block

#method_before
private void testSingleBase(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testSingleBase");
}
#method_after
private void testSingleBase(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testSingleBase");
}
#end_block

#method_before
private void testDensitySingle(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_mdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testDensitySingle");
}
#method_after
private void testDensitySingle(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_mdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testDensitySingle");
}
#end_block

#method_before
private void testDensityAll(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_mdpi).addApk(APK_hdpi).addApk(APK_xhdpi).addApk(APK_xxhdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testDensityAll");
}
#method_after
private void testDensityAll(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_mdpi).addApk(APK_hdpi).addApk(APK_xhdpi).addApk(APK_xxhdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testDensityAll");
}
#end_block

#method_before
private void testDensityBest(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_mdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testDensityBest1");
    // Now splice in an additional split which offers better resources
    new InstallMultiple().inheritFrom(PKG).addApk(APK_xxhdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testDensityBest2");
}
#method_after
private void testDensityBest(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_mdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testDensityBest1");
    // Now splice in an additional split which offers better resources
    new InstallMultiple().inheritFrom(PKG).addApk(APK_xxhdpi).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testDensityBest2");
}
#end_block

#method_before
private void testApi(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testApi");
}
#method_after
private void testApi(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testApi");
}
#end_block

#method_before
private void testLocale(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_de).addApk(APK_fr).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testLocale");
}
#method_after
private void testLocale(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_de).addApk(APK_fr).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testLocale");
}
#end_block

#method_before
private void testNativeSingle(boolean instant) throws Exception {
    final String abi = mAbi.getName();
    final String apk = ABI_TO_APK.get(abi);
    assertNotNull("Failed to find APK for ABI " + abi, apk);
    new InstallMultiple().addApk(APK).addApk(apk).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testNative");
}
#method_after
private void testNativeSingle(boolean instant) throws Exception {
    final String abi = mAbi.getName();
    final String apk = ABI_TO_APK.get(abi);
    assertNotNull("Failed to find APK for ABI " + abi, apk);
    new InstallMultiple().addApk(APK).addApk(apk).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testNative");
}
#end_block

#method_before
private void testNativeSingleNatural(boolean instant) throws Exception {
    final String abi = mAbi.getName();
    final String apk = ABI_TO_APK.get(abi);
    assertNotNull("Failed to find APK for ABI " + abi, apk);
    new InstallMultiple().useNaturalAbi().addApk(APK).addApk(apk).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testNative");
}
#method_after
private void testNativeSingleNatural(boolean instant) throws Exception {
    final String abi = mAbi.getName();
    final String apk = ABI_TO_APK.get(abi);
    assertNotNull("Failed to find APK for ABI " + abi, apk);
    new InstallMultiple().useNaturalAbi().addApk(APK).addApk(apk).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testNative");
}
#end_block

#method_before
private void testNativeAll(boolean instant, boolean natural) throws Exception {
    final InstallMultiple inst = new InstallMultiple().addApk(APK);
    for (String apk : ABI_TO_APK.values()) {
        inst.addApk(apk);
    }
    if (instant) {
        inst.addArg("--instant");
    }
    if (natural) {
        inst.useNaturalAbi();
    }
    inst.run();
    runDeviceTests(PKG, CLASS, "testNative");
}
#method_after
private void testNativeAll(boolean instant, boolean natural) throws Exception {
    final InstallMultiple inst = new InstallMultiple().addApk(APK);
    for (String apk : ABI_TO_APK.values()) {
        inst.addApk(apk);
    }
    if (instant) {
        inst.addArg("--instant");
    }
    if (natural) {
        inst.useNaturalAbi();
    }
    inst.run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testNative");
}
#end_block

#method_before
private void testDiffRevision(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_DIFF_REVISION_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testRevision0_12");
}
#method_after
private void testDiffRevision(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_DIFF_REVISION_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testRevision0_12");
}
#end_block

#method_before
private void testDiffRevisionInheritBase(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testRevision0_0");
    new InstallMultiple().inheritFrom(PKG).addApk(APK_DIFF_REVISION_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testRevision0_12");
}
#method_after
private void testDiffRevisionInheritBase(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testRevision0_0");
    new InstallMultiple().inheritFrom(PKG).addApk(APK_DIFF_REVISION_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testRevision0_12");
}
#end_block

#method_before
private void testDiffRevisionInheritSplit(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testRevision0_0");
    new InstallMultiple().inheritFrom(PKG).addApk(APK_DIFF_REVISION).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testRevision12_0");
}
#method_after
private void testDiffRevisionInheritSplit(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testRevision0_0");
    new InstallMultiple().inheritFrom(PKG).addApk(APK_DIFF_REVISION).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testRevision12_0");
}
#end_block

#method_before
private void testFeatureBase(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_FEATURE).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testFeatureBase");
}
#method_after
private void testFeatureBase(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_FEATURE).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testFeatureBase");
}
#end_block

#method_before
private void testFeatureApiInstant(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_FEATURE).addApk(APK_FEATURE_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testFeatureApi");
}
#method_after
private void testFeatureApiInstant(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addApk(APK_FEATURE).addApk(APK_FEATURE_v7).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testFeatureApi");
}
#end_block

#method_before
private void testFeatureWithoutRestart(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).run();
    new InstallMultiple().addApk(APK_NO_RESTART_BASE).addArg(instant ? "--instant" : "").run();
    if (instant) {
        // Poke the full app so it can see the instant app.
        runDeviceTests(PKG_NO_RESTART, CLASS_NO_RESTART, "testPokeFullApp");
    }
    runDeviceTests(PKG, CLASS, "testBaseInstalled");
    new InstallMultiple().addArg(instant ? "--instant" : "").addArg("--dont-kill").inheritFrom(PKG_NO_RESTART).addApk(APK_NO_RESTART_FEATURE).run();
    runDeviceTests(PKG, CLASS, "testFeatureInstalled");
}
#method_after
private void testFeatureWithoutRestart(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).run();
    new InstallMultiple().addApk(APK_NO_RESTART_BASE).addArg(instant ? "--instant" : "").run();
    if (instant) {
        // Poke the full app so it can see the instant app.
        runDeviceTestsAsCurrentUser(PKG_NO_RESTART, CLASS_NO_RESTART, "testPokeFullApp");
    }
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testBaseInstalled");
    new InstallMultiple().addArg(instant ? "--instant" : "").addArg("--dont-kill").inheritFrom(PKG_NO_RESTART).addApk(APK_NO_RESTART_FEATURE).run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testFeatureInstalled");
}
#end_block

#method_before
private void testClearCodeCache(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testCodeCacheWrite");
    new InstallMultiple().addArg("-r").addApk(APK_DIFF_VERSION).addArg(instant ? "--instant" : "").run();
    runDeviceTests(PKG, CLASS, "testCodeCacheRead");
}
#method_after
private void testClearCodeCache(boolean instant) throws Exception {
    new InstallMultiple().addApk(APK).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testCodeCacheWrite");
    new InstallMultiple().addArg("-r").addApk(APK_DIFF_VERSION).addArg(instant ? "--instant" : "").run();
    runDeviceTestsAsCurrentUser(PKG, CLASS, "testCodeCacheRead");
}
#end_block

#method_before
private void runDeviceTestsAsCurrentUser(String packageName, String testClassName, String testMethodName) throws DeviceNotAvailableException {
    Utils.runDeviceTests(getDevice(), packageName, testClassName, testMethodName, getDevice().getCurrentUser());
}
#method_after
private void runDeviceTestsAsCurrentUser(String packageName, String testClassName, String testMethodName) throws DeviceNotAvailableException {
    Utils.runDeviceTestsAsCurrentUser(getDevice(), packageName, testClassName, testMethodName);
}
#end_block

#method_before
public void testUsesLibrary() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK), false, false));
    runDeviceTests(PKG, ".UsesLibraryTest", "testUsesLibrary");
}
#method_after
public void testUsesLibrary() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK), false, false));
    runDeviceTestsAsCurrentUser(PKG, ".UsesLibraryTest", "testUsesLibrary");
}
#end_block

#method_before
public void testMissingLibrary() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK), false, false));
    runDeviceTests(PKG, ".UsesLibraryTest", "testMissingLibrary");
}
#method_after
public void testMissingLibrary() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK), false, false));
    runDeviceTestsAsCurrentUser(PKG, ".UsesLibraryTest", "testMissingLibrary");
}
#end_block

#method_before
public void testDuplicateLibrary() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK), false, false));
    runDeviceTests(PKG, ".UsesLibraryTest", "testDuplicateLibrary");
}
#method_after
public void testDuplicateLibrary() throws Exception {
    assertNull(getDevice().installPackage(mBuildHelper.getTestFile(APK), false, false));
    runDeviceTestsAsCurrentUser(PKG, ".UsesLibraryTest", "testDuplicateLibrary");
}
#end_block

#method_before
private void runDeviceTestsAsCurrentUser(String packageName, String testClassName, String testMethodName) throws DeviceNotAvailableException {
    Utils.runDeviceTests(getDevice(), packageName, testClassName, testMethodName, getDevice().getCurrentUser());
}
#method_after
private void runDeviceTestsAsCurrentUser(String packageName, String testClassName, String testMethodName) throws DeviceNotAvailableException {
    Utils.runDeviceTestsAsCurrentUser(getDevice(), packageName, testClassName, testMethodName);
}
#end_block

#method_before
@Test
public void testTitlesTextColorSetHex() {
    final Toolbar toolbar = mActivity.findViewById(R.id.toolbar_textcolor_hex);
    final int expectedColor = 0xFFFF00FF;
    assertEquals(expectedColor, toolbar.mTitleTextView.getCurrentTextColor());
    assertEquals(expectedColor, toolbar.mSubtitleTextView.getCurrentTextColor());
}
#method_after
@Test
public void testTitlesTextColorSetHex() {
    final Toolbar toolbar = mActivity.findViewById(R.id.toolbar_textcolor_hex);
    final int expectedColor = 0xFFFF00FF;
    assertEquals(expectedColor, toolbar.getTitleTextView().getCurrentTextColor());
    assertEquals(expectedColor, toolbar.getSubtitleTextView().getCurrentTextColor());
}
#end_block

#method_before
@Test
public void testTitlesTextColorSetColorStateList() {
    final Toolbar toolbar = mActivity.findViewById(R.id.toolbar_textcolor_csl);
    final int expectedColor = AppCompatResources.getColorStateList(toolbar.getContext(), R.color.color_state_lilac_alpha).getDefaultColor();
    assertEquals(expectedColor, toolbar.mTitleTextView.getCurrentTextColor());
    assertEquals(expectedColor, toolbar.mSubtitleTextView.getCurrentTextColor());
}
#method_after
@Test
public void testTitlesTextColorSetColorStateList() {
    final Toolbar toolbar = mActivity.findViewById(R.id.toolbar_textcolor_csl);
    final int expectedColor = AppCompatResources.getColorStateList(toolbar.getContext(), R.color.color_state_lilac_alpha).getDefaultColor();
    assertEquals(expectedColor, toolbar.getTitleTextView().getCurrentTextColor());
    assertEquals(expectedColor, toolbar.getSubtitleTextView().getCurrentTextColor());
}
#end_block

#method_before
public boolean handleDeepLink(@Nullable Intent intent) {
    if (intent == null) {
        return false;
    }
    Bundle extras = intent.getExtras();
    int[] deepLink = extras != null ? extras.getIntArray(KEY_DEEP_LINK_IDS) : null;
    Bundle bundle = new Bundle();
    Bundle deepLinkExtras = extras != null ? extras.getBundle(KEY_DEEP_LINK_EXTRAS) : null;
    if (deepLinkExtras != null) {
        bundle.putAll(deepLinkExtras);
    }
    if ((deepLink == null || deepLink.length == 0) && intent.getData() != null) {
        Pair<NavDestination, Bundle> matchingDeepLink = mGraph.matchDeepLink(intent.getData());
        if (matchingDeepLink != null) {
            deepLink = matchingDeepLink.first.buildDeepLinkIds();
            bundle.putAll(matchingDeepLink.second);
        }
    }
    if (deepLink == null || deepLink.length == 0) {
        return false;
    }
    String invalidDestinationDisplayName = findInvalidDestinationDisplayNameInDeepLink(deepLink);
    if (invalidDestinationDisplayName != null) {
        Log.i(TAG, "Could not find destination " + invalidDestinationDisplayName + " in the navigation graph, ignoring the deep link from " + intent);
        return false;
    }
    bundle.putParcelable(KEY_DEEP_LINK_INTENT, intent);
    int flags = intent.getFlags();
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (flags & Intent.FLAG_ACTIVITY_CLEAR_TASK) == 0) {
        // Someone called us with NEW_TASK, but we don't know what state our whole
        // task stack is in, so we need to manually restart the whole stack to
        // ensure we're in a predictably good state.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(mContext).addNextIntentWithParentStack(intent);
        taskStackBuilder.startActivities();
        if (mActivity != null) {
            mActivity.finish();
        }
        return true;
    }
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        // Start with a cleared task starting at our root when we're on our own task
        if (!mBackStack.isEmpty()) {
            popBackStackInternal(mGraph.getId(), true);
        }
        int index = 0;
        while (index < deepLink.length) {
            int destinationId = deepLink[index++];
            NavDestination node = findDestination(destinationId);
            if (node == null) {
                throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
            }
            navigate(node, bundle, new NavOptions.Builder().setEnterAnim(0).setExitAnim(0).build(), null);
        }
        return true;
    }
    // Assume we're on another apps' task and only start the final destination
    NavGraph graph = mGraph;
    for (int i = 0; i < deepLink.length; i++) {
        int destinationId = deepLink[i];
        NavDestination node = i == 0 ? mGraph : graph.findNode(destinationId);
        if (node == null) {
            throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
        }
        if (i != deepLink.length - 1) {
            // We're not at the final NavDestination yet, so keep going through the chain
            graph = (NavGraph) node;
        } else {
            // Navigate to the last NavDestination, clearing any existing destinations
            navigate(node, node.addInDefaultArgs(bundle), new NavOptions.Builder().setPopUpTo(mGraph.getId(), true).setEnterAnim(0).setExitAnim(0).build(), null);
        }
    }
    return true;
}
#method_after
public boolean handleDeepLink(@Nullable Intent intent) {
    if (intent == null) {
        return false;
    }
    Bundle extras = intent.getExtras();
    int[] deepLink = extras != null ? extras.getIntArray(KEY_DEEP_LINK_IDS) : null;
    Bundle bundle = new Bundle();
    Bundle deepLinkExtras = extras != null ? extras.getBundle(KEY_DEEP_LINK_EXTRAS) : null;
    if (deepLinkExtras != null) {
        bundle.putAll(deepLinkExtras);
    }
    if ((deepLink == null || deepLink.length == 0) && intent.getData() != null) {
        Pair<NavDestination, Bundle> matchingDeepLink = mGraph.matchDeepLink(intent.getData());
        if (matchingDeepLink != null) {
            deepLink = matchingDeepLink.first.buildDeepLinkIds();
            bundle.putAll(matchingDeepLink.second);
        }
    }
    if (deepLink == null || deepLink.length == 0) {
        return false;
    }
    String invalidDestinationDisplayName = findInvalidDestinationDisplayNameInDeepLink(deepLink);
    if (invalidDestinationDisplayName != null) {
        Log.i(TAG, "Could not find destination " + invalidDestinationDisplayName + " in the navigation graph, ignoring the deep link from " + intent);
        return false;
    }
    bundle.putParcelable(KEY_DEEP_LINK_INTENT, intent);
    int flags = intent.getFlags();
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (flags & Intent.FLAG_ACTIVITY_CLEAR_TASK) == 0) {
        // Someone called us with NEW_TASK, but we don't know what state our whole
        // task stack is in, so we need to manually restart the whole stack to
        // ensure we're in a predictably good state.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(mContext).addNextIntentWithParentStack(intent);
        taskStackBuilder.startActivities();
        if (mActivity != null) {
            mActivity.finish();
        }
        return true;
    }
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        // Start with a cleared task starting at our root when we're on our own task
        if (!mBackStack.isEmpty()) {
            popBackStackInternal(mGraph.getId(), true);
        }
        int index = 0;
        while (index < deepLink.length) {
            int destinationId = deepLink[index++];
            NavDestination node = findDestination(destinationId);
            if (node == null) {
                throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
            }
            navigate(node, bundle, new NavOptions.Builder().setEnterAnim(0).setExitAnim(0).build(), null);
        }
        return true;
    }
    // Assume we're on another apps' task and only start the final destination
    NavGraph graph = mGraph;
    for (int i = 0; i < deepLink.length; i++) {
        int destinationId = deepLink[i];
        NavDestination node = i == 0 ? mGraph : graph.findNode(destinationId);
        if (node == null) {
            throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
        }
        if (i != deepLink.length - 1) {
            // We're not at the final NavDestination yet, so keep going through the chain
            graph = (NavGraph) node;
            // the start destination is also a NavGraph
            while (graph.findNode(graph.getStartDestination()) instanceof NavGraph) {
                graph = (NavGraph) graph.findNode(graph.getStartDestination());
            }
        } else {
            // Navigate to the last NavDestination, clearing any existing destinations
            navigate(node, node.addInDefaultArgs(bundle), new NavOptions.Builder().setPopUpTo(mGraph.getId(), true).setEnterAnim(0).setExitAnim(0).build(), null);
        }
    }
    return true;
}
#end_block

#method_before
@Nullable
private String findInvalidDestinationDisplayNameInDeepLink(@NonNull int[] deepLink) {
    NavGraph graph = mGraph;
    for (int i = 0; i < deepLink.length; i++) {
        int destinationId = deepLink[i];
        NavDestination node = i == 0 ? mGraph : graph.findNode(destinationId);
        if (node == null) {
            return NavDestination.getDisplayName(mContext, destinationId);
        }
        if (i != deepLink.length - 1) {
            // We're not at the final NavDestination yet, so keep going through the chain
            graph = (NavGraph) node;
        }
    }
    // We found every destination in the deepLink array, yay!
    return null;
}
#method_after
@Nullable
private String findInvalidDestinationDisplayNameInDeepLink(@NonNull int[] deepLink) {
    NavGraph graph = mGraph;
    for (int i = 0; i < deepLink.length; i++) {
        int destinationId = deepLink[i];
        NavDestination node = i == 0 ? mGraph : graph.findNode(destinationId);
        if (node == null) {
            return NavDestination.getDisplayName(mContext, destinationId);
        }
        if (i != deepLink.length - 1) {
            // We're not at the final NavDestination yet, so keep going through the chain
            graph = (NavGraph) node;
            // the start destination is also a NavGraph
            while (graph.findNode(graph.getStartDestination()) instanceof NavGraph) {
                graph = (NavGraph) graph.findNode(graph.getStartDestination());
            }
        }
    }
    // We found every destination in the deepLink array, yay!
    return null;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private void initControllerView(ViewGroup v) {
    mWindowManager = (WindowManager) getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
    mIconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    // Relating to Title Bar View
    mTitleBar = v.findViewById(R.id.title_bar);
    mTitleView = v.findViewById(R.id.title_text);
    mAdExternalLink = v.findViewById(R.id.ad_external_link);
    mBackButton = v.findViewById(R.id.back);
    if (mBackButton != null) {
        mBackButton.setOnClickListener(mBackListener);
        mBackButton.setVisibility(View.GONE);
    }
    mRouteButton = v.findViewById(R.id.cast);
    // Relating to Center View
    mCenterView = v.findViewById(R.id.center_view);
    mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
    mCenterView.addView(mTransportControls);
    // Relating to Minimal Size FullScreen View. This view is visible only when the current
    // size type is Minimal and it is a view that stretches from left to right end
    // and helps locate the fullscreen button at the right end of the screen.
    mMinimalSizeFullScreenView = (LinearLayout) v.findViewById(R.id.minimal_fullscreen_view);
    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) mMinimalSizeFullScreenView.getLayoutParams();
    int iconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    params.setMargins(0, iconSize * (-1), 0, 0);
    mMinimalSizeFullScreenView.setLayoutParams(params);
    mMinimalSizeFullScreenView.setVisibility(View.GONE);
    // Relating to Progress Bar View
    mProgressBar = v.findViewById(R.id.progress_bar);
    mProgress = v.findViewById(R.id.progress);
    if (mProgress != null) {
        if (mProgress instanceof SeekBar) {
            SeekBar seeker = (SeekBar) mProgress;
            seeker.setOnSeekBarChangeListener(mSeekListener);
            seeker.setProgressDrawable(mResources.getDrawable(R.drawable.custom_progress));
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
        }
        mProgress.setMax(MAX_PROGRESS);
    }
    mProgressBuffer = v.findViewById(R.id.progress_buffer);
    mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
    mNextSeekPosition = SEEK_POSITION_NOT_SET;
    // Relating to Bottom Bar View
    mBottomBar = v.findViewById(R.id.bottom_bar);
    // Relating to Bottom Bar Left View
    mBottomBarLeftView = v.findViewById(R.id.bottom_bar_left);
    mTimeView = v.findViewById(R.id.time);
    mEndTime = v.findViewById(R.id.time_end);
    mCurrentTime = v.findViewById(R.id.time_current);
    mAdSkipView = v.findViewById(R.id.ad_skip_time);
    mFormatBuilder = new StringBuilder();
    mFormatter = new Formatter(mFormatBuilder, Locale.getDefault());
    // Relating to Bottom Bar Right View
    mBasicControls = v.findViewById(R.id.basic_controls);
    mExtraControls = v.findViewById(R.id.extra_controls);
    mCustomButtons = v.findViewById(R.id.custom_buttons);
    mSubtitleButton = v.findViewById(R.id.subtitle);
    if (mSubtitleButton != null) {
        mSubtitleButton.setOnClickListener(mSubtitleListener);
    }
    mFullScreenButton = v.findViewById(R.id.fullscreen);
    if (mFullScreenButton != null) {
        mFullScreenButton.setOnClickListener(mFullScreenListener);
    }
    mOverflowShowButton = v.findViewById(R.id.overflow_show);
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setOnClickListener(mOverflowShowListener);
    }
    mOverflowHideButton = v.findViewById(R.id.overflow_hide);
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setOnClickListener(mOverflowHideListener);
    }
    mSettingsButton = v.findViewById(R.id.settings);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
    }
    mVideoQualityButton = v.findViewById(R.id.video_quality);
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setOnClickListener(mVideoQualityListener);
    }
    mAdRemainingView = v.findViewById(R.id.ad_remaining);
    // Relating to Settings List View
    initializeSettingsLists();
    mSettingsListView = (ListView) inflateLayout(getContext(), R.layout.settings_list);
    mSettingsAdapter = new SettingsAdapter(mSettingsMainTextsList, mSettingsSubTextsList, mSettingsIconIdsList);
    mSubSettingsAdapter = new SubSettingsAdapter(null, 0);
    mSettingsListView.setAdapter(mSettingsAdapter);
    mSettingsListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    mSettingsListView.setOnItemClickListener(mSettingsItemClickListener);
    mEmbeddedSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_settings_width);
    mFullSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_full_settings_width);
    mSettingsItemHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_settings_height);
    mSettingsWindowMargin = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_settings_offset);
    mSettingsWindow = new PopupWindow(mSettingsListView, mEmbeddedSettingsItemWidth, LayoutParams.WRAP_CONTENT, true);
    mSettingsWindow.setOnDismissListener(mSettingsDismissListener);
    int titleBarTranslateY = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_title_bar_height);
    float bottomBarHeight = mResources.getDimension(R.dimen.mcv2_bottom_bar_height);
    float progressThumbHeight = mResources.getDimension(R.dimen.mcv2_custom_progress_thumb_size);
    int progressBarHeight = (int) Math.ceil(mResources.getDimension(R.dimen.mcv2_custom_progress_max_size));
    int bottomBarTranslateY = (int) Math.ceil(bottomBarHeight + progressThumbHeight / 2 - progressBarHeight / 2);
    ValueAnimator fadeOutAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    fadeOutAnimator.setInterpolator(new LinearInterpolator());
    fadeOutAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                ScaleDrawable thumb = (ScaleDrawable) seekBar.getThumb();
                if (thumb != null) {
                    thumb.setLevel((int) (MAX_SCALE_LEVEL * alpha));
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.GONE);
            } else if (alpha == 1.0f) {
                setEnabled(false);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    if (mOnFullScreenListener != null) {
                        mFullScreenButton.setVisibility(View.GONE);
                    }
                    mProgressBar.setVisibility(View.GONE);
                }
            }
        }
    });
    ValueAnimator fadeInAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    fadeInAnimator.setInterpolator(new LinearInterpolator());
    fadeInAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                ScaleDrawable thumb = (ScaleDrawable) seekBar.getThumb();
                if (thumb != null) {
                    thumb.setLevel((int) (MAX_SCALE_LEVEL * alpha));
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.VISIBLE);
            } else if (alpha == 1.0f) {
                setEnabled(true);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    if (mOnFullScreenListener != null) {
                        mFullScreenButton.setVisibility(View.VISIBLE);
                    }
                    mProgressBar.setVisibility(View.VISIBLE);
                }
            }
        }
    });
    mHideMainBarsAnimator = new AnimatorSet();
    mHideMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY)).with(fadeOutAnimator);
    mHideMainBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ONLY_PROGRESS_VISIBLE;
        }
    });
    mHideProgressBarAnimator = new AnimatorSet();
    mHideProgressBarAnimator.play(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight));
    mHideProgressBarAnimator.setDuration(HIDE_TIME_MS);
    mHideProgressBarAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mHideAllBarsAnimator = new AnimatorSet();
    mHideAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(fadeOutAnimator);
    mHideAllBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mShowMainBarsAnimator = new AnimatorSet();
    mShowMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, 0)).with(fadeInAnimator);
    mShowMainBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mShowAllBarsAnimator = new AnimatorSet();
    mShowAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(fadeInAnimator);
    mShowAllBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mOverflowShowAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    mOverflowShowAnimator.setDuration(SHOW_TIME_MS);
    mOverflowShowAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowShowAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mExtraControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.GONE);
            mOverflowHideButton.setVisibility(View.VISIBLE);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mBasicControls.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.GONE);
            }
        }
    });
    mOverflowHideAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    mOverflowHideAnimator.setDuration(SHOW_TIME_MS);
    mOverflowHideAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowHideAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mBasicControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.VISIBLE);
            mOverflowHideButton.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mExtraControls.setVisibility(View.GONE);
        }
    });
}
#method_after
@SuppressWarnings("deprecation")
private void initControllerView(ViewGroup v) {
    mWindowManager = (WindowManager) getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
    mIconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    // Relating to Title Bar View
    mTitleBar = v.findViewById(R.id.title_bar);
    mTitleView = v.findViewById(R.id.title_text);
    mAdExternalLink = v.findViewById(R.id.ad_external_link);
    mBackButton = v.findViewById(R.id.back);
    if (mBackButton != null) {
        mBackButton.setOnClickListener(mBackListener);
        mBackButton.setVisibility(View.GONE);
    }
    mRouteButton = v.findViewById(R.id.cast);
    // Relating to Center View
    mCenterView = v.findViewById(R.id.center_view);
    mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
    mCenterView.addView(mTransportControls);
    // Relating to Minimal Size FullScreen View. This view is visible only when the current
    // size type is Minimal and it is a view that stretches from left to right end
    // and helps locate the fullscreen button at the right end of the screen.
    mMinimalSizeFullScreenView = (LinearLayout) v.findViewById(R.id.minimal_fullscreen_view);
    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) mMinimalSizeFullScreenView.getLayoutParams();
    int iconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    params.setMargins(0, iconSize * (-1), 0, 0);
    mMinimalSizeFullScreenView.setLayoutParams(params);
    mMinimalSizeFullScreenView.setVisibility(View.GONE);
    // Relating to Progress Bar View
    mProgressBar = v.findViewById(R.id.progress_bar);
    mProgress = v.findViewById(R.id.progress);
    if (mProgress != null) {
        if (mProgress instanceof SeekBar) {
            SeekBar seeker = (SeekBar) mProgress;
            seeker.setOnSeekBarChangeListener(mSeekListener);
            seeker.setProgressDrawable(mResources.getDrawable(R.drawable.custom_progress));
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
        }
        mProgress.setMax(MAX_PROGRESS);
    }
    mProgressBuffer = v.findViewById(R.id.progress_buffer);
    mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
    mNextSeekPosition = SEEK_POSITION_NOT_SET;
    // Relating to Bottom Bar View
    mBottomBar = v.findViewById(R.id.bottom_bar);
    // Relating to Bottom Bar Left View
    mBottomBarLeftView = v.findViewById(R.id.bottom_bar_left);
    mTimeView = v.findViewById(R.id.time);
    mEndTime = v.findViewById(R.id.time_end);
    mCurrentTime = v.findViewById(R.id.time_current);
    mAdSkipView = v.findViewById(R.id.ad_skip_time);
    mFormatBuilder = new StringBuilder();
    mFormatter = new Formatter(mFormatBuilder, Locale.getDefault());
    // Relating to Bottom Bar Right View
    mBasicControls = v.findViewById(R.id.basic_controls);
    mExtraControls = v.findViewById(R.id.extra_controls);
    mCustomButtons = v.findViewById(R.id.custom_buttons);
    mSubtitleButton = v.findViewById(R.id.subtitle);
    if (mSubtitleButton != null) {
        mSubtitleButton.setOnClickListener(mSubtitleListener);
    }
    mFullScreenButton = v.findViewById(R.id.fullscreen);
    if (mFullScreenButton != null) {
        mFullScreenButton.setOnClickListener(mFullScreenListener);
    }
    mOverflowShowButton = v.findViewById(R.id.overflow_show);
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setOnClickListener(mOverflowShowListener);
    }
    mOverflowHideButton = v.findViewById(R.id.overflow_hide);
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setOnClickListener(mOverflowHideListener);
    }
    mSettingsButton = v.findViewById(R.id.settings);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
    }
    mVideoQualityButton = v.findViewById(R.id.video_quality);
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setOnClickListener(mVideoQualityListener);
    }
    mAdRemainingView = v.findViewById(R.id.ad_remaining);
    // Relating to Settings List View
    initializeSettingsLists();
    mSettingsListView = (ListView) inflateLayout(getContext(), R.layout.settings_list);
    mSettingsAdapter = new SettingsAdapter(mSettingsMainTextsList, mSettingsSubTextsList, mSettingsIconIdsList);
    mSubSettingsAdapter = new SubSettingsAdapter(null, 0);
    mSettingsListView.setAdapter(mSettingsAdapter);
    mSettingsListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    mSettingsListView.setOnItemClickListener(mSettingsItemClickListener);
    mEmbeddedSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_settings_width);
    mFullSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_full_settings_width);
    mSettingsItemHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_settings_height);
    mSettingsWindowMargin = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_settings_offset);
    mSettingsWindow = new PopupWindow(mSettingsListView, mEmbeddedSettingsItemWidth, LayoutParams.WRAP_CONTENT, true);
    mSettingsWindow.setOnDismissListener(mSettingsDismissListener);
    int titleBarTranslateY = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_title_bar_height);
    float bottomBarHeight = mResources.getDimension(R.dimen.mcv2_bottom_bar_height);
    float progressThumbHeight = mResources.getDimension(R.dimen.mcv2_custom_progress_thumb_size);
    float progressBarHeight = mResources.getDimension(R.dimen.mcv2_custom_progress_max_size);
    float bottomBarTranslateY = (float) Math.ceil(bottomBarHeight + progressThumbHeight / 2 - progressBarHeight / 2);
    ValueAnimator fadeOutAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    fadeOutAnimator.setInterpolator(new LinearInterpolator());
    fadeOutAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                ScaleDrawable thumb = (ScaleDrawable) seekBar.getThumb();
                if (thumb != null) {
                    thumb.setLevel((int) (MAX_SCALE_LEVEL * alpha));
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.GONE);
            } else if (alpha == 1.0f) {
                setEnabled(false);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    if (mOnFullScreenListener != null) {
                        mFullScreenButton.setVisibility(View.GONE);
                    }
                    mProgressBar.setVisibility(View.GONE);
                }
            }
        }
    });
    ValueAnimator fadeInAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    fadeInAnimator.setInterpolator(new LinearInterpolator());
    fadeInAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                ScaleDrawable thumb = (ScaleDrawable) seekBar.getThumb();
                if (thumb != null) {
                    thumb.setLevel((int) (MAX_SCALE_LEVEL * alpha));
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.VISIBLE);
            } else if (alpha == 1.0f) {
                setEnabled(true);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    if (mOnFullScreenListener != null) {
                        mFullScreenButton.setVisibility(View.VISIBLE);
                    }
                    mProgressBar.setVisibility(View.VISIBLE);
                }
            }
        }
    });
    mHideMainBarsAnimator = new AnimatorSet();
    mHideMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY)).with(fadeOutAnimator);
    mHideMainBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ONLY_PROGRESS_VISIBLE;
        }
    });
    mHideProgressBarAnimator = new AnimatorSet();
    mHideProgressBarAnimator.play(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight));
    mHideProgressBarAnimator.setDuration(HIDE_TIME_MS);
    mHideProgressBarAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mHideAllBarsAnimator = new AnimatorSet();
    mHideAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(fadeOutAnimator);
    mHideAllBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mShowMainBarsAnimator = new AnimatorSet();
    mShowMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, 0)).with(fadeInAnimator);
    mShowMainBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mShowAllBarsAnimator = new AnimatorSet();
    mShowAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(fadeInAnimator);
    mShowAllBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mOverflowShowAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    mOverflowShowAnimator.setDuration(SHOW_TIME_MS);
    mOverflowShowAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowShowAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mExtraControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.GONE);
            mOverflowHideButton.setVisibility(View.VISIBLE);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mBasicControls.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.GONE);
            }
        }
    });
    mOverflowHideAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    mOverflowHideAnimator.setDuration(SHOW_TIME_MS);
    mOverflowHideAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowHideAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mBasicControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.VISIBLE);
            mOverflowHideButton.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mExtraControls.setVisibility(View.GONE);
        }
    });
}
#end_block

#method_before
@Test
public void testIsOverflowMenuShowing() throws Throwable {
    CarMenuItem overflowItem = new CarMenuItem.Builder().setDisplayBehavior(// Overflow menu item
    CarMenuItem.DisplayBehavior.NEVER).build();
    mActivityRule.runOnUiThread(() -> mToolbar.setMenuItems(Collections.singletonList(overflowItem)));
    // Open overflow menu.
    onView(withId(R.id.overflow_menu)).perform(click());
    assertTrue(mToolbar.isOverflowMenuShowing());
}
#method_after
@Test
public void testIsOverflowMenuShowing() throws Throwable {
    CarMenuItem overflowItem = new CarMenuItem.Builder().setDisplayBehavior(// Overflow menu item
    CarMenuItem.DisplayBehavior.NEVER).build();
    mActivityRule.runOnUiThread(() -> mToolbar.setMenuItems(Collections.singletonList(overflowItem)));
    InstrumentationRegistry.getInstrumentation().waitForIdleSync();
    assertFalse(mToolbar.isOverflowMenuShowing());
    // Open overflow menu.
    onView(withId(R.id.overflow_menu)).perform(click());
    assertTrue(mToolbar.isOverflowMenuShowing());
}
#end_block

#method_before
@Test
public void testShowOverflowMenu() throws Throwable {
    CarMenuItem overflowItem = new CarMenuItem.Builder().setDisplayBehavior(// Overflow menu item
    CarMenuItem.DisplayBehavior.NEVER).build();
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setMenuItems(Collections.singletonList(overflowItem));
        mToolbar.showOverflowMenu();
    });
    assertTrue(mToolbar.isOverflowMenuShowing());
}
#method_after
@Test
public void testShowOverflowMenu() throws Throwable {
    String overflowItemText = "overflow_item_text";
    CarMenuItem overflowItem = new CarMenuItem.Builder().setDisplayBehavior(// Overflow menu item
    CarMenuItem.DisplayBehavior.NEVER).setTitle(overflowItemText).build();
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setMenuItems(Collections.singletonList(overflowItem));
        mToolbar.showOverflowMenu();
    });
    onView(withText(overflowItemText)).inRoot(isDialog()).check(matches(isDisplayed()));
}
#end_block

#method_before
@Test
public void testHideOverflowMenu() throws Throwable {
    CarMenuItem overflowItem = new CarMenuItem.Builder().setDisplayBehavior(// Overflow menu item
    CarMenuItem.DisplayBehavior.NEVER).build();
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setMenuItems(Collections.singletonList(overflowItem));
        mToolbar.showOverflowMenu();
        mToolbar.hideOverflowMenu();
    });
    assertFalse(mToolbar.isOverflowMenuShowing());
}
#method_after
@Test
public void testHideOverflowMenu() throws Throwable {
    String overflowItemText = "overflow_item_text";
    CarMenuItem overflowItem = new CarMenuItem.Builder().setDisplayBehavior(// Overflow menu item
    CarMenuItem.DisplayBehavior.NEVER).setTitle(overflowItemText).build();
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setMenuItems(Collections.singletonList(overflowItem));
        mToolbar.showOverflowMenu();
        mToolbar.hideOverflowMenu();
    });
    onView(withText(overflowItemText)).check(doesNotExist());
}
#end_block

#method_before
public boolean isOverflowMenuShowing() {
    return (mOverflowDialog != null && mOverflowDialog.isShowing());
}
#method_after
public boolean isOverflowMenuShowing() {
    return mOverflowDialog != null && mOverflowDialog.isShowing();
}
#end_block

#method_before
public void testRotation() throws Throwable {
    if (mActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        return;
    }
    // Get a {@link Display} instance before rotation.
    final Display origDisplay = mActivity.getDisplay();
    // Capture the originally reported width and heights
    final Point origSize = new Point();
    origDisplay.getSize(origSize);
    // Change orientation
    mActivity.configurationChangeObserver.startObserving();
    OrientationTestUtils.switchOrientation(mActivity);
    final boolean squareDisplay = (origSize.x == origSize.y);
    // the display is square. In many cases it won't.
    if (!squareDisplay) {
        mActivity.configurationChangeObserver.await();
    }
    final Point newOrigSize = new Point();
    origDisplay.getSize(newOrigSize);
    // Get a {@link Display} instance after rotation.
    final Display updatedDisplay = mActivity.getDisplay();
    final Point updatedSize = new Point();
    updatedDisplay.getSize(updatedSize);
    // For square screens the following assertions do not make sense and will always fail.
    if (!squareDisplay) {
        // Ensure that the width and height of the original instance no longer are the same. Note
        // that this will be false if the device width and height are identical.
        // Note there are cases where width and height may not all be updated, such as on docked
        // devices where the app is letterboxed. However at least one dimension needs to be
        // updated.
        assertFalse("size from original display instance should have changed", origSize.equals(newOrigSize));
    }
    // Ensure that the width and height of the original instance have been updated to match the
    // values that would be found in a new instance.
    assertTrue("size from original display instance should match current", newOrigSize.equals(updatedSize));
}
#method_after
public void testRotation() throws Throwable {
    if (!supportsRotation()) {
        // Skip rotation test if device doesn't support it.
        return;
    }
    // Get a {@link Display} instance before rotation.
    final Display origDisplay = mActivity.getDisplay();
    // Capture the originally reported width and heights
    final Point origSize = new Point();
    origDisplay.getSize(origSize);
    // Change orientation
    mActivity.configurationChangeObserver.startObserving();
    OrientationTestUtils.switchOrientation(mActivity);
    final boolean squareDisplay = (origSize.x == origSize.y);
    // the display is square. In many cases it won't.
    if (!squareDisplay) {
        mActivity.configurationChangeObserver.await();
    }
    final Point newOrigSize = new Point();
    origDisplay.getSize(newOrigSize);
    // Get a {@link Display} instance after rotation.
    final Display updatedDisplay = mActivity.getDisplay();
    final Point updatedSize = new Point();
    updatedDisplay.getSize(updatedSize);
    // For square screens the following assertions do not make sense and will always fail.
    if (!squareDisplay) {
        // Ensure that the width and height of the original instance no longer are the same. Note
        // that this will be false if the device width and height are identical.
        // Note there are cases where width and height may not all be updated, such as on docked
        // devices where the app is letterboxed. However at least one dimension needs to be
        // updated.
        assertFalse("size from original display instance should have changed", origSize.equals(newOrigSize));
    }
    // Ensure that the width and height of the original instance have been updated to match the
    // values that would be found in a new instance.
    assertTrue("size from original display instance should match current", newOrigSize.equals(updatedSize));
}
#end_block

#method_before
@Test
public void testNonFullscreenActivityPermitted() throws Exception {
    if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        // cannot physically rotate the screen on automotive device, skip
        return;
    }
    try (final RotationSession rotationSession = new RotationSession()) {
        rotationSession.set(ROTATION_0);
        launchActivity(SDK26_TRANSLUCENT_LANDSCAPE_ACTIVITY);
        mAmWmState.assertResumedActivity("target SDK <= 26 non-fullscreen activity should be allowed to launch", SDK26_TRANSLUCENT_LANDSCAPE_ACTIVITY);
        assertEquals("non-fullscreen activity requested landscape orientation", 0, /* landscape */
        mAmWmState.getWmState().getLastOrientation());
    }
}
#method_after
@Test
public void testNonFullscreenActivityPermitted() throws Exception {
    if (!supportsRotation()) {
        // cannot physically rotate the screen on automotive device, skip
        return;
    }
    try (final RotationSession rotationSession = new RotationSession()) {
        rotationSession.set(ROTATION_0);
        launchActivity(SDK26_TRANSLUCENT_LANDSCAPE_ACTIVITY);
        mAmWmState.assertResumedActivity("target SDK <= 26 non-fullscreen activity should be allowed to launch", SDK26_TRANSLUCENT_LANDSCAPE_ACTIVITY);
        assertEquals("non-fullscreen activity requested landscape orientation", 0, /* landscape */
        mAmWmState.getWmState().getLastOrientation());
    }
}
#end_block

#method_before
public static void clearSavedTraces() {
    String cmd = "rm -f " + TRACE_DIRECTORY + "trace-*.ctrace";
    Log.v(TAG, "Clearing trace directory: " + cmd);
    try {
        Process rm = exec(cmd);
        if (rm.waitFor() != 0) {
            Log.e(TAG, "clearSavedTraces failed with: " + rm.exitValue());
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public static void clearSavedTraces() {
    String cmd = "rm -f " + TRACE_DIRECTORY + "trace-*.*trace";
    Log.v(TAG, "Clearing trace directory: " + cmd);
    try {
        Process rm = exec(cmd);
        if (rm.waitFor() != 0) {
            Log.e(TAG, "clearSavedTraces failed with: " + rm.exitValue());
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public static String getOutputFilename() {
    String format = "yyyy-MM-dd-HH-mm-ss";
    String now = new SimpleDateFormat(format, Locale.US).format(new Date());
    return String.format("trace-%s-%s-%s.ctrace", Build.BOARD, Build.ID, now);
}
#method_after
public static String getOutputFilename() {
    String format = "yyyy-MM-dd-HH-mm-ss";
    String now = new SimpleDateFormat(format, Locale.US).format(new Date());
    return String.format("trace-%s-%s-%s.%s", Build.BOARD, Build.ID, now, mTraceEngine.getOutputExtension());
}
#end_block

#method_before
public boolean traceStart(Collection<String> tags, int bufferSizeKb, boolean apps) {
    if (isTracingOn()) {
        Log.e(TAG, "Attempting to start perfetto trace but trace is already in progress");
        return false;
    } else {
        // Ensure the temporary trace file is cleared.
        try {
            Files.deleteIfExists(Paths.get(TEMP_TRACE_LOCATION));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    // Build the perfetto config that will be passed on the command line.
    StringBuilder config = new StringBuilder().append("buffers {\n").append("  size_kb: " + bufferSizeKb + "\n").append("  fill_policy: RING_BUFFER\n").append("} \n").append("data_sources {\n").append("  config {\n").append("    name: \"linux.ftrace\"\n").append("    target_buffer: 0\n").append("    ftrace_config {\n");
    for (String tag : tags) {
        config.append("      atrace_categories: \"" + tag + "\"\n");
    }
    if (apps) {
        config.append("      atrace_apps: \"*\"\n");
    }
    // These parameters affect only the kernel trace buffer size and how
    // frequently it gets moved into the userspace buffer defined above.
    config.append("      buffer_size_kb: 4096\n").append("      drain_period_ms: 250\n").append("    }\n").append("  }\n").append("}\n").append(" \n").append("data_sources {\n").append("  config {\n").append("    name: \"linux.process_stats\"\n").append("    target_buffer: 0\n").append("  }\n").append("} \n");
    // Overall duration of trace (not used for atrace-style ring buffer tracing)
    // .append("duration_ms: 9999")
    String cmd = "perfetto --txt -b -c - -o " + TEMP_TRACE_LOCATION + " <<DOC\n" + config.toString() + "DOC";
    Log.v(TAG, "Starting perfetto trace.");
    try {
        Process process = TraceUtils.exec(cmd, TEMP_DIR);
        if (process.waitFor(300, TimeUnit.MILLISECONDS) && process.exitValue() != 0) {
            Log.e(TAG, "perfetto traceStart failed with: " + process.exitValue());
            return false;
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    Log.v(TAG, "perfetto traceStart succeeded!");
    return true;
}
#method_after
public boolean traceStart(Collection<String> tags, int bufferSizeKb, boolean apps) {
    if (isTracingOn()) {
        Log.e(TAG, "Attempting to start perfetto trace but trace is already in progress");
        return false;
    } else {
        // Ensure the temporary trace file is cleared.
        try {
            Files.deleteIfExists(Paths.get(TEMP_TRACE_LOCATION));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    // Build the perfetto config that will be passed on the command line.
    StringBuilder config = new StringBuilder().append("write_into_file: true\n").append("file_write_period_ms: 1000000000\n").append("buffers {\n").append("  size_kb: " + bufferSizeKb + "\n").append("  fill_policy: RING_BUFFER\n").append("} \n").append("data_sources {\n").append("  config {\n").append("    name: \"linux.ftrace\"\n").append("    target_buffer: 0\n").append("    ftrace_config {\n");
    for (String tag : tags) {
        // Tags are expected to be all lowercase letters and underscores.
        String cleanTag = tag.replaceAll("[^a-z_]", "");
        if (cleanTag.equals(tag)) {
            Log.w(TAG, "Attempting to use an invalid tag: " + tag);
        }
        config.append("      atrace_categories: \"" + cleanTag + "\"\n");
    }
    if (apps) {
        config.append("      atrace_apps: \"*\"\n");
    }
    // These parameters affect only the kernel trace buffer size and how
    // frequently it gets moved into the userspace buffer defined above.
    config.append("      buffer_size_kb: 4096\n").append("      drain_period_ms: 250\n").append("    }\n").append("  }\n").append("}\n").append(" \n").append("data_sources {\n").append("  config {\n").append("    name: \"linux.process_stats\"\n").append("    target_buffer: 0\n").append("  }\n").append("} \n");
    String configString = config.toString();
    // This should never happen.
    if (configString.contains(MARKER)) {
        throw new RuntimeException("The arguments to the Perfetto command are malformed.");
    }
    String cmd = "perfetto --detach=" + PERFETTO_TAG + " -o " + TEMP_TRACE_LOCATION + " -c - --txt" + " <<" + MARKER + "\n" + configString + "\n" + MARKER;
    Log.v(TAG, "Starting perfetto trace.");
    try {
        Process process = TraceUtils.exec(cmd, TEMP_DIR);
        // If we time out, ensure that the perfetto process is destroyed.
        if (!process.waitFor(STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
            Log.e(TAG, "perfetto traceStart has timed out after " + STARTUP_TIMEOUT_MS + " ms.");
            process.destroyForcibly();
            return false;
        }
        if (process.exitValue() != 0) {
            Log.e(TAG, "perfetto traceStart failed with: " + process.exitValue());
            return false;
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    Log.v(TAG, "perfetto traceStart succeeded!");
    return true;
}
#end_block

#method_before
public void traceStop() {
    if (!isTracingOn()) {
        Log.e(TAG, "Attempting to stop perfetto trace but no trace was in progress");
        return;
    }
    Log.v(TAG, "Stopping perfetto trace.");
    String cmd = "killall -s SIGINT perfetto";
    try {
        Process process = TraceUtils.exec(cmd);
        if (process.waitFor() != 0) {
            Log.e(TAG, "perfetto traceStop failed with: " + process.exitValue());
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void traceStop() {
    Log.v(TAG, "Stopping perfetto trace.");
    if (!isTracingOn()) {
        Log.w(TAG, "No trace appears to be in progress. Stopping perfetto trace may not work.");
    }
    String cmd = "perfetto --stop --attach=" + PERFETTO_TAG;
    try {
        Process process = TraceUtils.exec(cmd);
        if (process.waitFor() != 0) {
            Log.e(TAG, "perfetto traceStop failed with: " + process.exitValue());
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean traceDump(File outFile) {
    traceStop();
    Log.v(TAG, "Dumping perfetto trace to " + outFile);
    Path tempTracePath = Paths.get(TEMP_TRACE_LOCATION);
    try {
        if (Files.exists(tempTracePath)) {
            Files.move(tempTracePath, Paths.get(outFile.toURI()));
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    // (readable, ownerOnly)
    outFile.setReadable(true, false);
    return true;
}
#method_after
public boolean traceDump(File outFile) {
    traceStop();
    Log.v(TAG, "Saving perfetto trace to " + outFile);
    try {
        Os.rename(TEMP_TRACE_LOCATION, outFile.getCanonicalPath());
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    // (readable, ownerOnly)
    outFile.setReadable(true, false);
    return true;
}
#end_block

#method_before
public boolean isTracingOn() {
    String cmd = "ps | grep perfetto";
    try {
        Process process = TraceUtils.exec(cmd);
        return (process.waitFor() == 0);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public boolean isTracingOn() {
    String cmd = "perfetto --is_detached=" + PERFETTO_TAG;
    try {
        Process process = TraceUtils.exec(cmd);
        // 0 represents a detached process exists with this name
        // 2 represents no detached process with this name
        // 1 (or other error code) represents an error
        int result = process.waitFor();
        if (result == 0) {
            return true;
        } else if (result == 2) {
            return false;
        } else {
            throw new RuntimeException("Perfetto error: " + result);
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private void addChildInternal(View root, int virtualDescendantId, boolean checked) {
    enforceNotSealed();
    if (mChildNodeIds == null) {
        mChildNodeIds = new LongArray();
    }
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED_ITEM_ID;
    final long childNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
    if (childNodeId == mSourceNodeId) {
        Log.w(TAG, "Cannot add self as child node. Node id: " + childNodeId);
        return;
    }
    // If we're checking uniqueness and the ID already exists, abort.
    if (checked && mChildNodeIds.indexOf(childNodeId) >= 0) {
        return;
    }
    mChildNodeIds.add(childNodeId);
}
#method_after
private void addChildInternal(View root, int virtualDescendantId, boolean checked) {
    enforceNotSealed();
    if (mChildNodeIds == null) {
        mChildNodeIds = new LongArray();
    }
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED_ITEM_ID;
    final long childNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
    if (childNodeId == mSourceNodeId) {
        Log.e(TAG, "Rejecting attempt to make a View its own child");
        return;
    }
    // If we're checking uniqueness and the ID already exists, abort.
    if (checked && mChildNodeIds.indexOf(childNodeId) >= 0) {
        return;
    }
    mChildNodeIds.add(childNodeId);
}
#end_block

#method_before
public void setOnViewTypeChangedListener(@NonNull OnViewTypeChangedListener l) {
    mImpl.setOnViewTypeChangedListener(l);
}
#method_after
public void setOnViewTypeChangedListener(@Nullable OnViewTypeChangedListener l) {
    mImpl.setOnViewTypeChangedListener(l);
}
#end_block

#method_before
@Override
public void onTestFail(DataRecord testData, Description description, Failure failure) {
    // Capture logcat from start time
    if (mDestDir == null) {
        return;
    }
    String command = String.format("logcat -T \"%s\"", mStartTime);
    try (InputStream is = getLogcat(command)) {
        final String fileName = String.format("%s.%s.txt", description.getClassName(), description.getMethodName());
        File logcat = new File(mDestDir, fileName);
        OutputStream out = new FileOutputStream(logcat);
        byte[] buf = new byte[BUFFER_SIZE];
        int length;
        while ((length = is.read(buf)) >= 0) {
            out.write(buf, 0, length);
        }
        testData.addFileMetric(String.format("%s_%s", getTag(), logcat.getName()), logcat);
    } catch (IOException e) {
        Log.e(getTag(), "Error executing: " + command, e);
    }
}
#method_after
@Override
public void onTestFail(DataRecord testData, Description description, Failure failure) {
    // Capture logcat from start time
    if (mDestDir == null) {
        return;
    }
    String command = String.format("logcat -T \"%s\"", mStartTime);
    try (InputStream is = getLogcat(command)) {
        final String fileName = String.format("%s.%s.txt", description.getClassName(), description.getMethodName());
        // TODO: Refactor in a fileUtil like tradefed one
        File logcat = new File(mDestDir, fileName);
        OutputStream out = new FileOutputStream(logcat);
        byte[] buf = new byte[BUFFER_SIZE];
        int length;
        while ((length = is.read(buf)) >= 0) {
            out.write(buf, 0, length);
        }
        testData.addFileMetric(String.format("%s_%s", getTag(), logcat.getName()), logcat);
    } catch (IOException e) {
        Log.e(getTag(), "Error executing: " + command, e);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mTestDesc = Description.createTestDescription("run", "test");
    mCollector = new LogcatOnFailureCollector();
    mMockInstrumentation = Mockito.mock(Instrumentation.class);
    mLogDir = new File(Environment.getExternalStorageDirectory(), "test_logcat");
    mLogDir.mkdirs();
}
#method_after
@Before
public void setUp() throws Exception {
    mCollector = new LogcatOnFailureCollector();
    mMockInstrumentation = Mockito.mock(Instrumentation.class);
    mLogDir = new File(Environment.getExternalStorageDirectory(), "test_logcat");
    mLogDir.mkdirs();
}
#end_block

#method_before
@Test
public void testLogcatOnFailure() throws Exception {
    LogcatOnFailureCollector listener = initListener();
    // Test run start behavior
    listener.testRunStarted(RUN_DESCRIPTION);
    // Test test start behavior
    listener.testStarted(mTestDesc);
    Failure f = new Failure(mTestDesc, new RuntimeException("I failed."));
    listener.testFailure(f);
    listener.testFinished(mTestDesc);
    listener.testRunFinished(new Result());
    // AJUR runner is then gonna call instrumentationRunFinished
    Bundle resultBundle = new Bundle();
    listener.instrumentationRunFinished(System.out, resultBundle, new Result());
    assertEquals(0, resultBundle.size());
    ArgumentCaptor<Bundle> capture = ArgumentCaptor.forClass(Bundle.class);
    Mockito.verify(mMockInstrumentation).sendStatus(Mockito.eq(SendToInstrumentation.INST_STATUS_IN_PROGRESS), capture.capture());
    List<Bundle> capturedBundle = capture.getAllValues();
    assertEquals(1, capturedBundle.size());
    Bundle check = capturedBundle.get(0);
    // Ensure we received the file
    assertEquals(1, check.size());
    // The only key is ours
    for (String key : check.keySet()) {
        assertTrue(key.contains("run.test.txt"));
    }
}
#method_after
@Test
public void testLogcatOnFailure() throws Exception {
    LogcatOnFailureCollector listener = initListener();
    // Test run start behavior
    listener.testRunStarted(RUN_DESCRIPTION);
    // Test test start behavior
    listener.testStarted(TEST_DESCRIPTION);
    Failure f = new Failure(TEST_DESCRIPTION, new RuntimeException("I failed."));
    listener.testFailure(f);
    listener.testFinished(TEST_DESCRIPTION);
    listener.testRunFinished(new Result());
    // AJUR runner is then gonna call instrumentationRunFinished
    Bundle resultBundle = new Bundle();
    listener.instrumentationRunFinished(System.out, resultBundle, new Result());
    assertEquals(0, resultBundle.size());
    ArgumentCaptor<Bundle> capture = ArgumentCaptor.forClass(Bundle.class);
    Mockito.verify(mMockInstrumentation).sendStatus(Mockito.eq(SendToInstrumentation.INST_STATUS_IN_PROGRESS), capture.capture());
    List<Bundle> capturedBundle = capture.getAllValues();
    assertEquals(1, capturedBundle.size());
    Bundle check = capturedBundle.get(0);
    // Ensure we received the file
    assertEquals(1, check.size());
    // The only key is ours
    for (String key : check.keySet()) {
        assertTrue(key.contains("run.test.txt"));
    }
}
#end_block

#method_before
private SetupResult setLinkProperties(DataCallResponse response, LinkProperties linkProperties) {
    // Check if system property dns usable
    String propertyPrefix = "net." + response.getIfname() + ".";
    String[] dnsServers = new String[2];
    dnsServers[0] = SystemProperties.get(propertyPrefix + "dns1");
    dnsServers[1] = SystemProperties.get(propertyPrefix + "dns2");
    boolean okToUseSystemPropertyDns = isDnsOk(dnsServers);
    SetupResult result;
    // Start with clean network properties and if we have
    // a failure we'll clear again at the bottom of this code.
    linkProperties.clear();
    if (response.getStatus() == DcFailCause.NONE.getErrorCode()) {
        try {
            // set interface name
            linkProperties.setInterfaceName(response.getIfname());
            // set link addresses
            if (response.getAddresses().size() > 0) {
                for (LinkAddress la : response.getAddresses()) {
                    if (!la.getAddress().isAnyLocalAddress()) {
                        if (DBG) {
                            log("addr/pl=" + la.getAddress() + "/" + la.getNetworkPrefixLength());
                        }
                        linkProperties.addLinkAddress(la);
                    }
                }
            } else {
                throw new UnknownHostException("no address for ifname=" + response.getIfname());
            }
            // set dns servers
            if (response.getDnses().size() > 0) {
                for (InetAddress dns : response.getDnses()) {
                    if (!dns.isAnyLocalAddress()) {
                        linkProperties.addDnsServer(dns);
                    }
                }
            } else if (okToUseSystemPropertyDns) {
                for (String dnsAddr : dnsServers) {
                    dnsAddr = dnsAddr.trim();
                    if (dnsAddr.isEmpty())
                        continue;
                    InetAddress ia;
                    try {
                        ia = NetworkUtils.numericToInetAddress(dnsAddr);
                    } catch (IllegalArgumentException e) {
                        throw new UnknownHostException("Non-numeric dns addr=" + dnsAddr);
                    }
                    if (!ia.isAnyLocalAddress()) {
                        linkProperties.addDnsServer(ia);
                    }
                }
            } else {
                throw new UnknownHostException("Empty dns response and no system default dns");
            }
            // set pcscf
            if (response.getPcscfs().size() > 0) {
                for (String pcscf : response.getPcscfs()) {
                    pcscf = pcscf.trim();
                    if (pcscf.isEmpty())
                        continue;
                    InetAddress ia;
                    try {
                        ia = NetworkUtils.numericToInetAddress(pcscf);
                    } catch (IllegalArgumentException e) {
                        throw new UnknownHostException("Non-numeric pcscf addr=" + pcscf);
                    }
                    if (!ia.isAnyLocalAddress()) {
                        linkProperties.addPcscfServer(ia);
                    }
                }
            }
            for (InetAddress gateway : response.getGateways()) {
                // Allow 0.0.0.0 or :: as a gateway;
                // this indicates a point-to-point interface.
                linkProperties.addRoute(new RouteInfo(gateway));
            }
            // set interface MTU
            // this may clobber the setting read from the APN db, but that's ok
            linkProperties.setMtu(response.getMtu());
            result = SetupResult.SUCCESS;
        } catch (UnknownHostException e) {
            log("setLinkProperties: UnknownHostException " + e);
            result = SetupResult.ERROR_INVALID_ARG;
        }
    } else {
        result = SetupResult.ERROR_DATA_SERVICE_SPECIFIC_ERROR;
    }
    // An error occurred so clear properties
    if (result != SetupResult.SUCCESS) {
        if (DBG) {
            log("setLinkProperties: error clearing LinkProperties status=" + response.getStatus() + " result=" + result);
        }
        linkProperties.clear();
    }
    return result;
}
#method_after
private SetupResult setLinkProperties(DataCallResponse response, LinkProperties linkProperties) {
    // Check if system property dns usable
    String propertyPrefix = "net." + response.getIfname() + ".";
    String[] dnsServers = new String[2];
    dnsServers[0] = SystemProperties.get(propertyPrefix + "dns1");
    dnsServers[1] = SystemProperties.get(propertyPrefix + "dns2");
    boolean okToUseSystemPropertyDns = isDnsOk(dnsServers);
    SetupResult result;
    // Start with clean network properties and if we have
    // a failure we'll clear again at the bottom of this code.
    linkProperties.clear();
    if (response.getStatus() == DcFailCause.NONE.getErrorCode()) {
        try {
            // set interface name
            linkProperties.setInterfaceName(response.getIfname());
            // set link addresses
            if (response.getAddresses().size() > 0) {
                for (LinkAddress la : response.getAddresses()) {
                    if (!la.getAddress().isAnyLocalAddress()) {
                        if (DBG) {
                            log("addr/pl=" + la.getAddress() + "/" + la.getNetworkPrefixLength());
                        }
                        linkProperties.addLinkAddress(la);
                    }
                }
            } else {
                throw new UnknownHostException("no address for ifname=" + response.getIfname());
            }
            // set dns servers
            if (response.getDnses().size() > 0) {
                for (InetAddress dns : response.getDnses()) {
                    if (!dns.isAnyLocalAddress()) {
                        linkProperties.addDnsServer(dns);
                    }
                }
            } else if (okToUseSystemPropertyDns) {
                for (String dnsAddr : dnsServers) {
                    dnsAddr = dnsAddr.trim();
                    if (dnsAddr.isEmpty())
                        continue;
                    InetAddress ia;
                    try {
                        ia = NetworkUtils.numericToInetAddress(dnsAddr);
                    } catch (IllegalArgumentException e) {
                        throw new UnknownHostException("Non-numeric dns addr=" + dnsAddr);
                    }
                    if (!ia.isAnyLocalAddress()) {
                        linkProperties.addDnsServer(ia);
                    }
                }
            } else {
                throw new UnknownHostException("Empty dns response and no system default dns");
            }
            // set pcscf
            if (response.getPcscfs().size() > 0) {
                for (String pcscf : response.getPcscfs()) {
                    if (pcscf == null)
                        continue;
                    pcscf = pcscf.trim();
                    if (pcscf.isEmpty())
                        continue;
                    InetAddress ia;
                    try {
                        ia = NetworkUtils.numericToInetAddress(pcscf);
                    } catch (IllegalArgumentException e) {
                        throw new UnknownHostException("Non-numeric pcscf addr=" + pcscf);
                    }
                    if (!ia.isAnyLocalAddress()) {
                        linkProperties.addPcscfServer(ia);
                    } else {
                        log("bad address in PCSCF");
                    }
                }
            }
            for (InetAddress gateway : response.getGateways()) {
                // Allow 0.0.0.0 or :: as a gateway;
                // this indicates a point-to-point interface.
                linkProperties.addRoute(new RouteInfo(gateway));
            }
            // set interface MTU
            // this may clobber the setting read from the APN db, but that's ok
            linkProperties.setMtu(response.getMtu());
            result = SetupResult.SUCCESS;
        } catch (UnknownHostException e) {
            log("setLinkProperties: UnknownHostException " + e);
            result = SetupResult.ERROR_INVALID_ARG;
        }
    } else {
        result = SetupResult.ERROR_DATA_SERVICE_SPECIFIC_ERROR;
    }
    // An error occurred so clear properties
    if (result != SetupResult.SUCCESS) {
        if (DBG) {
            log("setLinkProperties: error clearing LinkProperties status=" + response.getStatus() + " result=" + result);
        }
        linkProperties.clear();
    }
    return result;
}
#end_block

#method_before
@Override
public String toString() {
    // Space as a separator, so no need for spaces at start/end of the individual fragments.
    final StringJoiner resultJoiner = new StringJoiner(" ", "{", "}");
    if (mIfaceName != null) {
        resultJoiner.add("InterfaceName:");
        resultJoiner.add(mIfaceName);
    }
    resultJoiner.add("LinkAddresses: [");
    if (!mLinkAddresses.isEmpty()) {
        resultJoiner.add(TextUtils.join(",", mLinkAddresses));
    }
    resultJoiner.add("]");
    resultJoiner.add("DnsAddresses: [");
    if (!mDnses.isEmpty()) {
        resultJoiner.add(TextUtils.join(",", mDnses));
    }
    resultJoiner.add("]");
    if (mUsePrivateDns) {
        resultJoiner.add("UsePrivateDns: true");
    }
    if (mPrivateDnsServerName != null) {
        resultJoiner.add("PrivateDnsServerName:");
        resultJoiner.add(mPrivateDnsServerName);
    }
    resultJoiner.add("PcscfAddresses: [");
    if (!mPcscfs.isEmpty()) {
        resultJoiner.add(TextUtils.join(",", mPcscfs));
    }
    resultJoiner.add("]");
    if (!mValidatedPrivateDnses.isEmpty()) {
        final StringJoiner validatedPrivateDnsesJoiner = new StringJoiner(",", "ValidatedPrivateDnsAddresses: [", "]");
        for (final InetAddress addr : mValidatedPrivateDnses) {
            validatedPrivateDnsesJoiner.add(addr.getHostAddress());
        }
        resultJoiner.add(validatedPrivateDnsesJoiner.toString());
    }
    resultJoiner.add("Domains:");
    resultJoiner.add(mDomains);
    resultJoiner.add("MTU:");
    resultJoiner.add(Integer.toString(mMtu));
    if (mTcpBufferSizes != null) {
        resultJoiner.add("TcpBufferSizes:");
        resultJoiner.add(mTcpBufferSizes);
    }
    resultJoiner.add("Routes: [");
    if (!mRoutes.isEmpty()) {
        resultJoiner.add(TextUtils.join(",", mRoutes));
    }
    resultJoiner.add("]");
    if (mHttpProxy != null) {
        resultJoiner.add("HttpProxy:");
        resultJoiner.add(mHttpProxy.toString());
    }
    final Collection<LinkProperties> stackedLinksValues = mStackedLinks.values();
    if (!stackedLinksValues.isEmpty()) {
        final StringJoiner stackedLinksJoiner = new StringJoiner(",", "Stacked: [", "]");
        for (final LinkProperties lp : stackedLinksValues) {
            stackedLinksJoiner.add("[ " + lp + " ]");
        }
        resultJoiner.add(stackedLinksJoiner.toString());
    }
    return resultJoiner.toString();
}
#method_after
@Override
public String toString() {
    // Space as a separator, so no need for spaces at start/end of the individual fragments.
    final StringJoiner resultJoiner = new StringJoiner(" ", "{", "}");
    if (mIfaceName != null) {
        resultJoiner.add("InterfaceName:");
        resultJoiner.add(mIfaceName);
    }
    resultJoiner.add("LinkAddresses: [");
    if (!mLinkAddresses.isEmpty()) {
        resultJoiner.add(TextUtils.join(",", mLinkAddresses));
    }
    resultJoiner.add("]");
    resultJoiner.add("DnsAddresses: [");
    if (!mDnses.isEmpty()) {
        resultJoiner.add(TextUtils.join(",", mDnses));
    }
    resultJoiner.add("]");
    if (mUsePrivateDns) {
        resultJoiner.add("UsePrivateDns: true");
    }
    if (mPrivateDnsServerName != null) {
        resultJoiner.add("PrivateDnsServerName:");
        resultJoiner.add(mPrivateDnsServerName);
    }
    if (!mPcscfs.isEmpty()) {
        resultJoiner.add("PcscfAddresses: [");
        resultJoiner.add(TextUtils.join(",", mPcscfs));
        resultJoiner.add("]");
    }
    if (!mValidatedPrivateDnses.isEmpty()) {
        final StringJoiner validatedPrivateDnsesJoiner = new StringJoiner(",", "ValidatedPrivateDnsAddresses: [", "]");
        for (final InetAddress addr : mValidatedPrivateDnses) {
            validatedPrivateDnsesJoiner.add(addr.getHostAddress());
        }
        resultJoiner.add(validatedPrivateDnsesJoiner.toString());
    }
    resultJoiner.add("Domains:");
    resultJoiner.add(mDomains);
    resultJoiner.add("MTU:");
    resultJoiner.add(Integer.toString(mMtu));
    if (mTcpBufferSizes != null) {
        resultJoiner.add("TcpBufferSizes:");
        resultJoiner.add(mTcpBufferSizes);
    }
    resultJoiner.add("Routes: [");
    if (!mRoutes.isEmpty()) {
        resultJoiner.add(TextUtils.join(",", mRoutes));
    }
    resultJoiner.add("]");
    if (mHttpProxy != null) {
        resultJoiner.add("HttpProxy:");
        resultJoiner.add(mHttpProxy.toString());
    }
    final Collection<LinkProperties> stackedLinksValues = mStackedLinks.values();
    if (!stackedLinksValues.isEmpty()) {
        final StringJoiner stackedLinksJoiner = new StringJoiner(",", "Stacked: [", "]");
        for (final LinkProperties lp : stackedLinksValues) {
            stackedLinksJoiner.add("[ " + lp + " ]");
        }
        resultJoiner.add(stackedLinksJoiner.toString());
    }
    return resultJoiner.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + mValidatedPrivateDnses.size() * 61 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode()) + (mUsePrivateDns ? 57 : 0) + mPcscfs.size() * 61 + ((null == mPrivateDnsServerName) ? 0 : mPrivateDnsServerName.hashCode());
}
#method_after
@Override
public int hashCode() {
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + mValidatedPrivateDnses.size() * 61 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode()) + (mUsePrivateDns ? 57 : 0) + mPcscfs.size() * 67 + ((null == mPrivateDnsServerName) ? 0 : mPrivateDnsServerName.hashCode());
}
#end_block

#method_before
private NetworkCapabilities getNetworkCapabilitiesInternal(NetworkAgentInfo nai) {
    if (nai != null) {
        synchronized (nai) {
            if (nai.networkCapabilities != null) {
                // that have the NETWORK_SETTINGS permission.
                return networkCapabilitiesWithoutUidsUnlessAllowed(nai.networkCapabilities);
            }
        }
    }
    return null;
}
#method_after
private NetworkCapabilities getNetworkCapabilitiesInternal(NetworkAgentInfo nai) {
    if (nai != null) {
        synchronized (nai) {
            if (nai.networkCapabilities != null) {
                return networkCapabilitiesWithoutUidsUnlessAllowed(nai.networkCapabilities, Binder.getCallingPid(), Binder.getCallingUid());
            }
        }
    }
    return null;
}
#end_block

#method_before
private NetworkCapabilities networkCapabilitiesWithoutUidsUnlessAllowed(NetworkCapabilities nc) {
    if (checkSettingsPermission())
        return nc;
    return new NetworkCapabilities(nc).setUids(null);
}
#method_after
private NetworkCapabilities networkCapabilitiesWithoutUidsUnlessAllowed(NetworkCapabilities nc, int callerPid, int callerUid) {
    if (checkSettingsPermission(callerPid, callerUid))
        return new NetworkCapabilities(nc);
    return new NetworkCapabilities(nc).setUids(null);
}
#end_block

#method_before
private boolean checkSettingsPermission() {
    return PERMISSION_GRANTED == mContext.checkCallingOrSelfPermission(android.Manifest.permission.NETWORK_SETTINGS);
}
#method_after
private boolean checkSettingsPermission(int pid, int uid) {
    return PERMISSION_GRANTED == mContext.checkPermission(android.Manifest.permission.NETWORK_SETTINGS, pid, uid);
}
#end_block

#method_before
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        networkCapabilities.removeCapability(NET_CAPABILITY_NOT_VPN);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    // Set the UID range for this request to the single UID of the requester, or to an empty
    // set of UIDs if the caller has the appropriate permission and UIDs have not been set.
    // This will overwrite any allowed UIDs in the requested capabilities. Though there
    // are no visible methods to set the UIDs, an app could use reflection to try and get
    // networks for other apps so it's essential that the UIDs are overwritten.
    restrictRequestUidsToSetAccessibleToCaller(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#method_after
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        networkCapabilities.removeCapability(NET_CAPABILITY_NOT_VPN);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    // Set the UID range for this request to the single UID of the requester, or to an empty
    // set of UIDs if the caller has the appropriate permission and UIDs have not been set.
    // This will overwrite any allowed UIDs in the requested capabilities. Though there
    // are no visible methods to set the UIDs, an app could use reflection to try and get
    // networks for other apps so it's essential that the UIDs are overwritten.
    restrictRequestUidsForCaller(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    ensureValidNetworkSpecifier(networkCapabilities);
    restrictRequestUidsToSetAccessibleToCaller(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    ensureValidNetworkSpecifier(networkCapabilities);
    restrictRequestUidsForCaller(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsToSetAccessibleToCaller(nc);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsToSetAccessibleToCaller(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#method_after
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesWithoutUidsUnlessAllowed(networkAgent.networkCapabilities);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesWithoutUidsUnlessAllowed(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
public boolean isStateUnknown() {
    if (mCardState == CardState.CARDSTATE_PRESENT && mUiccCard == null) {
        // 'UNKNOWN' is the appropriate state in that scenario.
        return true;
    }
    return (mCardState == null || mCardState == CardState.CARDSTATE_ABSENT) && mStateIsUnknown;
}
#method_after
public boolean isStateUnknown() {
    if (mCardState == null || mCardState == CardState.CARDSTATE_ABSENT) {
        // mStateIsUnknown is valid only in this scenario.
        return mStateIsUnknown;
    }
    // it is safer to return UNKNOWN.
    return mUiccCard == null;
}
#end_block

#method_before
@MainThread
public <T> void set(@NonNull String key, T value) {
    validateValue(value);
    @SuppressWarnings("unchecked")
    MutableLiveData<T> mutableLiveData = (MutableLiveData<T>) mLiveDatas.get(key);
    if (mutableLiveData != null) {
        // it will set value;
        mutableLiveData.setValue(value);
    } else {
        mRegular.put(key, value);
    }
}
#method_after
@MainThread
public <T> void set(@NonNull String key, @Nullable T value) {
    validateValue(value);
    @SuppressWarnings("unchecked")
    MutableLiveData<T> mutableLiveData = (MutableLiveData<T>) mLiveDatas.get(key);
    if (mutableLiveData != null) {
        // it will set value;
        mutableLiveData.setValue(value);
    } else {
        mRegular.put(key, value);
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
static void attach(SavedStateRegistry<Bundle> savedStateStore, ViewModelStoreOwner store) {
    ViewModelStore viewModelStore = store.getViewModelStore();
    for (String key : viewModelStore.keys()) {
        ViewModel viewModel = viewModelStore.get(key);
        SavedStateHandle handle = viewModel.getTag(AbstractSavedStateVMFactory.TAG_SAVED_STATE_HANDLE);
        if (handle != null) {
            savedStateStore.registerSavedStateProvider(key, handle.savedStateProvider());
        }
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
static void attach(SavedStateRegistry<Bundle> savedStateStore, ViewModelStoreOwner store) {
    ViewModelStore viewModelStore = store.getViewModelStore();
    for (String key : viewModelStore.keys()) {
        ViewModel viewModel = viewModelStore.get(key);
        SavedStateHandle handle = viewModel.getTag(AbstractSavedStateVMFactory.TAG_SAVED_STATE_HANDLE);
        if (handle != null) {
            savedStateStore.unregisterSavedStateProvider(key);
            savedStateStore.registerSavedStateProvider(key, handle.savedStateProvider());
        }
    }
}
#end_block

#method_before
@Test
public void testSetNavigationIcon_doesNotThrowError() throws Throwable {
    // Since there is no easy way to compare drawable, here we are testing that calling the
    // relevant APIs doesn't crash.
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon)));
}
#method_after
@Test
public void testSetNavigationIcon_doesNotThrowError() throws Throwable {
    // Since there is no easy way to compare drawable, here we are testing that calling the
    // relevant APIs doesn't crash.
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIcon(android.R.drawable.sym_def_app_icon));
}
#end_block

#method_before
@Test
public void testSetNavigationIconContainerWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, R.drawable.ic_nav_arrow_back));
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int sideWidth = 10;
    // Container width is icon width plus |sideWidth| on both ends.
    int containerWidth = getNavigationIconView().getWidth() + (sideWidth * 2);
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(sideWidth)));
    onView(withId(R.id.title)).check(matches(withLeft(containerWidth)));
}
#method_after
@Test
public void testSetNavigationIconContainerWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(R.drawable.ic_nav_arrow_back);
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int sideWidth = 10;
    // Container width is icon width plus |sideWidth| on both ends.
    int containerWidth = getNavigationIconView().getWidth() + (sideWidth * 2);
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(sideWidth)));
    onView(withId(R.id.title)).check(matches(withLeft(containerWidth)));
}
#end_block

#method_before
@Test
public void testSetNavigationIconContainerWidth_NoContainerKeepsIconCompletelyVisible() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(Icon.createWithResource(mActivity, (R.drawable.ic_nav_arrow_back)));
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int containerWidth = 0;
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(0)));
    onView(withId(R.id.title)).check(isCompletelyRightOf(withId(R.id.nav_button)));
}
#method_after
@Test
public void testSetNavigationIconContainerWidth_NoContainerKeepsIconCompletelyVisible() throws Throwable {
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setNavigationIcon(R.drawable.ic_nav_arrow_back);
        // Set title to verify icon space on right.
        mToolbar.setTitle("title");
    });
    int containerWidth = 0;
    mActivityRule.runOnUiThread(() -> mToolbar.setNavigationIconContainerWidth(containerWidth));
    onView(withId(R.id.nav_button)).check(matches(withLeft(0)));
    onView(withId(R.id.title)).check(isCompletelyRightOf(withId(R.id.nav_button)));
}
#end_block

#method_before
@Test
public void testSetTitleIconShowsAndHidesTitleIconView() throws Throwable {
    mActivityRule.runOnUiThread(() -> mToolbar.setTitleIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon)));
    onView(withId(R.id.title_icon)).check(matches(isDisplayed()));
    mActivityRule.runOnUiThread(() -> mToolbar.setTitleIcon(null));
    onView(withId(R.id.title_icon)).check(matches(not(isDisplayed())));
}
#method_after
@Test
public void testSetTitleIconShowsAndHidesTitleIconView() throws Throwable {
    mActivityRule.runOnUiThread(() -> mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon));
    onView(withId(R.id.title_icon)).check(matches(isDisplayed()));
    mActivityRule.runOnUiThread(() -> mToolbar.setTitleIcon(null));
    onView(withId(R.id.title_icon)).check(matches(not(isDisplayed())));
}
#end_block

#method_before
@Test
public void testTitleIconHasCorrectDefaultWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> mToolbar.setTitleIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon)));
    onView(withId(R.id.title_icon)).check(matches(withWidth(mActivity.getResources().getDimensionPixelSize(R.dimen.car_application_icon_size))));
}
#method_after
@Test
public void testTitleIconHasCorrectDefaultWidth() throws Throwable {
    mActivityRule.runOnUiThread(() -> mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon));
    onView(withId(R.id.title_icon)).check(matches(withWidth(mActivity.getResources().getDimensionPixelSize(R.dimen.car_application_icon_size))));
}
#end_block

#method_before
@Test
public void testSetTitleIconSizeSetsCorrectSize() throws Throwable {
    int size = mActivity.getResources().getDimensionPixelSize(R.dimen.car_avatar_icon_size);
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setTitleIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon));
        mToolbar.setTitleIconSize(size);
    });
    onView(withId(R.id.title_icon)).check(matches(withWidth(size)));
}
#method_after
@Test
public void testSetTitleIconSizeSetsCorrectSize() throws Throwable {
    int size = mActivity.getResources().getDimensionPixelSize(R.dimen.car_avatar_icon_size);
    mActivityRule.runOnUiThread(() -> {
        mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
        mToolbar.setTitleIconSize(size);
    });
    onView(withId(R.id.title_icon)).check(matches(withWidth(size)));
}
#end_block

#method_before
public static <In, Out> LiveData<Out> dedupedMappedLiveDataFor(@NonNull LiveData<In> inputLiveData, @NonNull final Function<In, Out> mappingMethod, @NonNull final TaskExecutor workTaskExecutor) {
    final MediatorLiveData<Out> outputLiveData = new MediatorLiveData<>();
    outputLiveData.addSource(inputLiveData, new Observer<In>() {

        int mLatestDataVersion = 0;

        @Override
        public void onChanged(@Nullable final In input) {
            final int currentVersion = ++mLatestDataVersion;
            final Out previousOutput = outputLiveData.getValue();
            workTaskExecutor.executeOnBackgroundThread(new Runnable() {

                @Override
                public void run() {
                    synchronized (outputLiveData) {
                        Out newOutput = mappingMethod.apply(input);
                        if (previousOutput == null && newOutput != null && currentVersion == mLatestDataVersion) {
                            outputLiveData.postValue(newOutput);
                        } else if (previousOutput != null && !previousOutput.equals(newOutput) && currentVersion == mLatestDataVersion) {
                            outputLiveData.postValue(newOutput);
                        }
                    }
                }
            });
        }
    });
    return outputLiveData;
}
#method_after
public static <In, Out> LiveData<Out> dedupedMappedLiveDataFor(@NonNull LiveData<In> inputLiveData, @NonNull final Function<In, Out> mappingMethod, @NonNull final TaskExecutor workTaskExecutor) {
    final Object lock = new Object();
    final MediatorLiveData<Out> outputLiveData = new MediatorLiveData<>();
    outputLiveData.addSource(inputLiveData, new Observer<In>() {

        Out mCurrentOutput = null;

        @Override
        public void onChanged(@Nullable final In input) {
            workTaskExecutor.executeOnBackgroundThread(new Runnable() {

                @Override
                public void run() {
                    synchronized (lock) {
                        Out newOutput = mappingMethod.apply(input);
                        if (mCurrentOutput == null && newOutput != null) {
                            mCurrentOutput = newOutput;
                            outputLiveData.postValue(newOutput);
                        } else if (mCurrentOutput != null && !mCurrentOutput.equals(newOutput)) {
                            mCurrentOutput = newOutput;
                            outputLiveData.postValue(newOutput);
                        }
                    }
                }
            });
        }
    });
    return outputLiveData;
}
#end_block

#method_before
@Test
@LargeTest
// TODO(b/122504446): Run this test on <P devices
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testPlayVideoWithUri() throws Exception {
    if (!loadResourceWithUri(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#method_after
@Test
@LargeTest
// TODO(b/122504446): Run this test on <P devices
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testPlayVideoWithUri() throws Exception {
    if (!loadResourceWithUri(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
}
#end_block

#method_before
@Override
public void setUp(ITestDevice device, IBuildInfo buildInfo) throws TargetSetupError, BuildError, DeviceNotAvailableException {
    // Record the initial state before configure device.
    final boolean adbWasRoot = device.isAdbRoot();
    isAdbRootBeforeSetup = adbWasRoot;
    CommandResult result = device.executeShellV2Command("getenforce");
    final boolean selinuxWasEnforcing = result.getStdout().contains("Enforcing");
    selinuxWasEnforcingBeforeSetup = selinuxWasEnforcing;
    if (!adbWasRoot) {
        if (!device.enableAdbRoot()) {
            throw new TargetSetupError(String.format("Failed to enable root on device %s.", device.getSerialNumber()), device.getDeviceDescriptor());
        }
    }
    result = device.executeShellV2Command("rm -rf " + APEX_DATA_DIR + "/*");
    if (result.getStatus() != CommandStatus.SUCCESS) {
        throw new TargetSetupError(String.format("Failed to clean up data/apex on device %s. Reason: %s", device.getSerialNumber(), result.getStatus()), device.getDeviceDescriptor());
    }
    // Disable SELinux to directly talk to apexservice.
    if (selinuxWasEnforcing) {
        result = device.executeShellV2Command("setenforce 0");
    }
    if (result.getStatus() != CommandStatus.SUCCESS) {
        throw new TargetSetupError(String.format("Failed to execute 'setenforce 0' on device %s. Reason: %s", device.getSerialNumber(), result.getStatus()), device.getDeviceDescriptor());
    }
    File apexFile;
    try {
        apexFile = getTestApex(buildInfo, mApexFileName);
    } catch (IOException e) {
        throw new TargetSetupError(String.format("Failed to get %s from build  %s", mApexFileName, device.getSerialNumber()), device.getDeviceDescriptor());
    }
    String installResult = device.installPackage(apexFile, false);
    if (installResult != null) {
        throw new TargetSetupError(String.format("Failed to install %s on device %s. Reason: %s", mApexFileName, device.getSerialNumber(), installResult), device.getDeviceDescriptor());
    }
    device.nonBlockingReboot();
    device.waitForDeviceAvailable();
    // TODO: Change to 'pm list packages --apex-only' once it can retrieve version number.
    if (!device.enableAdbRoot()) {
        throw new TargetSetupError(String.format("Failed to enable root on device %s.", device.getSerialNumber()), device.getDeviceDescriptor());
    }
    result = device.executeShellV2Command("setenforce 0");
    if (result.getStatus() != CommandStatus.SUCCESS) {
        throw new TargetSetupError(String.format("Failed to disable SELinux on device %s. Reason: %s", device.getSerialNumber(), result.getStatus()), device.getDeviceDescriptor());
    }
    result = device.executeShellV2Command("cmd apexservice getActivePackages");
    if (CommandStatus.SUCCESS != result.getStatus()) {
        throw new TargetSetupError(String.format("Failed to get active packages on device %s. Reason: %s", device.getSerialNumber(), result.getStatus()), device.getDeviceDescriptor());
    }
    String[] activatedPackages = result.getStdout().split("\n");
    boolean found = false;
    for (String activatedPackageInfo : activatedPackages) {
        if (activatedPackageInfo.contains(mApexPackageName) && activatedPackageInfo.contains(mApexVersion)) {
            found = true;
            break;
        }
    }
    if (!found) {
        throw new TargetSetupError(String.format("Failed to activate  %s on device %s.", mApexFileName, device.getSerialNumber()), device.getDeviceDescriptor());
    } else {
        CLog.i("Apex module is installed successfully");
    }
}
#method_after
@Override
public void setUp(ITestDevice device, IBuildInfo buildInfo) throws TargetSetupError, DeviceNotAvailableException {
    CommandResult result = device.executeShellV2Command("rm -rf " + APEX_DATA_DIR + "/*" + getModuleKeywordFromApexPackageName(mApexPackageName) + "*");
    if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
        throw new TargetSetupError(String.format("Failed to clean up data/apex on device %s. Output: %s Error: %s", device.getSerialNumber(), result.getStdout(), result.getStderr()), device.getDeviceDescriptor());
    }
    // TODO: Make sure the apex to install is the one specified (e.g., checking version info).
    super.setUp(device, buildInfo);
    device.reboot();
    ApexInfo testApexInfo = new ApexInfo(mApexPackageName, mApexVersion);
    Set<ApexInfo> activatedApexes = device.getActiveApexes();
    if (activatedApexes.isEmpty()) {
        throw new TargetSetupError(String.format("Failed to retrieve activated apex on device %s. Empty set returned.", device.getSerialNumber()), device.getDeviceDescriptor());
    }
    if (!activatedApexes.contains(testApexInfo)) {
        throw new TargetSetupError(String.format("Failed to activate %s on device %s. Activated package list: %s", getTestsFileName().toString(), device.getSerialNumber(), activatedApexes.toString()), device.getDeviceDescriptor());
    }
    CLog.i("Apex module is installed successfully");
}
#end_block

#method_before
@Override
public void tearDown(ITestDevice device, IBuildInfo buildInfo, Throwable e) throws DeviceNotAvailableException {
    // Set device to the original state.
    device.enableAdbRoot();
    device.executeShellV2Command("rm -rf " + APEX_DATA_DIR + "/*");
    device.reboot();
    if (isAdbRootBeforeSetup) {
        device.enableAdbRoot();
    }
    if (selinuxWasEnforcingBeforeSetup) {
        device.executeShellV2Command("setenforce 1");
    }
}
#method_after
@Override
public void tearDown(ITestDevice device, IBuildInfo buildInfo, Throwable e) throws DeviceNotAvailableException {
    super.tearDown(device, buildInfo, e);
    if (!(e instanceof DeviceNotAvailableException)) {
        CommandResult result = device.executeShellV2Command("rm -rf " + APEX_DATA_DIR + "/*" + getModuleKeywordFromApexPackageName(mApexPackageName) + "*");
        if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
            CLog.i(String.format("Failed to remove %s from %s", mApexPackageName, APEX_DATA_DIR));
        }
        device.reboot();
    }
}
#end_block

#method_before
@SmallTest
@Test
public void requireArguments() {
    Fragment fragment = new Fragment();
    try {
        fragment.requireArguments();
        fail();
    } catch (IllegalStateException expected) {
    }
    Bundle arguments = new Bundle();
    fragment.setArguments(arguments);
    assertWithMessage("requireArguments should return the arguments").that(fragment.requireArguments()).isEqualTo(arguments);
}
#method_after
@SmallTest
@Test
public void requireArguments() {
    Fragment fragment = new Fragment();
    try {
        fragment.requireArguments();
        fail();
    } catch (IllegalStateException expected) {
    }
    Bundle arguments = new Bundle();
    fragment.setArguments(arguments);
    assertWithMessage("requireArguments should return the arguments").that(fragment.requireArguments()).isSameAs(arguments);
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 23)
public void testPeriodic_dedupe() {
    PeriodicWorkRequest periodicWork = new PeriodicWorkRequest.Builder(TestWorker.class, PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS, TimeUnit.MILLISECONDS).build();
    final String periodicWorkId = periodicWork.getStringId();
    final WorkSpec workSpec = periodicWork.getWorkSpec();
    long now = System.currentTimeMillis();
    workSpec.periodStartTime = now + workSpec.intervalDuration;
    insertWork(periodicWork);
    WorkerWrapper workerWrapper = createBuilder(periodicWorkId).build();
    FutureListener listener = createAndAddFutureListener(workerWrapper);
    workerWrapper.run();
    assertThat(listener.mResult, is(false));
}
#method_after
@Test
@SmallTest
public void testPeriodic_dedupe() {
    PeriodicWorkRequest periodicWork = new PeriodicWorkRequest.Builder(TestWorker.class, PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS, TimeUnit.MILLISECONDS).build();
    final String periodicWorkId = periodicWork.getStringId();
    final WorkSpec workSpec = periodicWork.getWorkSpec();
    long now = System.currentTimeMillis();
    workSpec.periodStartTime = now + workSpec.intervalDuration;
    insertWork(periodicWork);
    WorkerWrapper workerWrapper = createBuilder(periodicWorkId).build();
    FutureListener listener = createAndAddFutureListener(workerWrapper);
    workerWrapper.run();
    assertThat(listener.mResult, is(false));
}
#end_block

#method_before
private void runWorker() {
    if (tryCheckForInterruptionAndResolve()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.get().error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            resolve(false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            resolveIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            return;
        }
        // So is the Work is periodic, we only need to execute it once per interval.
        if (Build.VERSION.SDK_INT == 23 && mWorkSpec.isPeriodic()) {
            long now = System.currentTimeMillis();
            if (now < mWorkSpec.calculateNextRunTime()) {
                resolve(false);
                return;
            }
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.get().error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndResolve();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    WorkerParameters params = new WorkerParameters(UUID.fromString(mWorkSpecId), input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount, mConfiguration.getExecutor(), mWorkTaskExecutor, mConfiguration.getWorkerFactory());
    // in test mode.
    if (mWorker == null) {
        mWorker = mConfiguration.getWorkerFactory().createWorkerWithDefaultFallback(mAppContext, mWorkSpec.workerClassName, params);
    }
    if (mWorker == null) {
        Logger.get().error(TAG, String.format("Could not create Worker %s", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    if (mWorker.isUsed()) {
        Logger.get().error(TAG, String.format("Received an already-used Worker %s; WorkerFactory should return " + "new instances", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    mWorker.setUsed();
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndResolve()) {
            return;
        }
        final SettableFuture<ListenableWorker.Result> future = SettableFuture.create();
        // Call mWorker.startWork() on the main thread.
        mWorkTaskExecutor.getMainThreadExecutor().execute(new Runnable() {

            @Override
            public void run() {
                try {
                    mInnerFuture = mWorker.startWork();
                    future.setFuture(mInnerFuture);
                } catch (Throwable e) {
                    future.setException(e);
                }
            }
        });
        // Avoid synthetic accessors.
        final String workDescription = mWorkDescription;
        future.addListener(new Runnable() {

            @Override
            @SuppressLint("SyntheticAccessor")
            public void run() {
                try {
                    // If the ListenableWorker returns a null result treat it as a failure.
                    ListenableWorker.Result result = future.get();
                    if (result == null) {
                        Logger.get().error(TAG, String.format("%s returned a null result. Treating it as a failure.", mWorkSpec.workerClassName));
                    } else {
                        mResult = result;
                    }
                } catch (CancellationException exception) {
                    // Cancellations need to be treated with care here because innerFuture
                    // cancellations will bubble up, and we need to gracefully handle that.
                    Logger.get().info(TAG, String.format("%s was cancelled", workDescription), exception);
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.get().error(TAG, String.format("%s failed because it threw an exception/error", workDescription), exception);
                } finally {
                    onWorkFinished();
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        resolveIncorrectStatus();
    }
}
#method_after
private void runWorker() {
    if (tryCheckForInterruptionAndResolve()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.get().error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            resolve(false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            resolveIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            return;
        }
        // Also potential bugs in the platform may cause a Job to run more than once.
        if (mWorkSpec.isPeriodic()) {
            long now = System.currentTimeMillis();
            if (now < mWorkSpec.calculateNextRunTime()) {
                resolve(false);
                return;
            }
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.get().error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndResolve();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    WorkerParameters params = new WorkerParameters(UUID.fromString(mWorkSpecId), input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount, mConfiguration.getExecutor(), mWorkTaskExecutor, mConfiguration.getWorkerFactory());
    // in test mode.
    if (mWorker == null) {
        mWorker = mConfiguration.getWorkerFactory().createWorkerWithDefaultFallback(mAppContext, mWorkSpec.workerClassName, params);
    }
    if (mWorker == null) {
        Logger.get().error(TAG, String.format("Could not create Worker %s", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    if (mWorker.isUsed()) {
        Logger.get().error(TAG, String.format("Received an already-used Worker %s; WorkerFactory should return " + "new instances", mWorkSpec.workerClassName));
        setFailedAndResolve();
        return;
    }
    mWorker.setUsed();
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndResolve()) {
            return;
        }
        final SettableFuture<ListenableWorker.Result> future = SettableFuture.create();
        // Call mWorker.startWork() on the main thread.
        mWorkTaskExecutor.getMainThreadExecutor().execute(new Runnable() {

            @Override
            public void run() {
                try {
                    mInnerFuture = mWorker.startWork();
                    future.setFuture(mInnerFuture);
                } catch (Throwable e) {
                    future.setException(e);
                }
            }
        });
        // Avoid synthetic accessors.
        final String workDescription = mWorkDescription;
        future.addListener(new Runnable() {

            @Override
            @SuppressLint("SyntheticAccessor")
            public void run() {
                try {
                    // If the ListenableWorker returns a null result treat it as a failure.
                    ListenableWorker.Result result = future.get();
                    if (result == null) {
                        Logger.get().error(TAG, String.format("%s returned a null result. Treating it as a failure.", mWorkSpec.workerClassName));
                    } else {
                        mResult = result;
                    }
                } catch (CancellationException exception) {
                    // Cancellations need to be treated with care here because innerFuture
                    // cancellations will bubble up, and we need to gracefully handle that.
                    Logger.get().info(TAG, String.format("%s was cancelled", workDescription), exception);
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.get().error(TAG, String.format("%s failed because it threw an exception/error", workDescription), exception);
                } finally {
                    onWorkFinished();
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        resolveIncorrectStatus();
    }
}
#end_block

#method_before
@UnsupportedAppUsage
public View tryCreateView(View parent, String name, Context context, AttributeSet attrs) throws Exception {
    if (name.equals(TAG_1995)) {
        // Let's party like it's 1995!
        return new BlinkLayout(context, attrs);
    }
    View view;
    if (mFactory2 != null) {
        view = mFactory2.onCreateView(parent, name, context, attrs);
    } else if (mFactory != null) {
        view = mFactory.onCreateView(name, context, attrs);
    } else {
        view = null;
    }
    if (view == null && mPrivateFactory != null) {
        view = mPrivateFactory.onCreateView(parent, name, context, attrs);
    }
    return view;
}
#method_after
@UnsupportedAppUsage(trackingBug = 122360734)
@Nullable
public final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) {
    if (name.equals(TAG_1995)) {
        // Let's party like it's 1995!
        return new BlinkLayout(context, attrs);
    }
    View view;
    if (mFactory2 != null) {
        view = mFactory2.onCreateView(parent, name, context, attrs);
    } else if (mFactory != null) {
        view = mFactory.onCreateView(name, context, attrs);
    } else {
        view = null;
    }
    if (view == null && mPrivateFactory != null) {
        view = mPrivateFactory.onCreateView(parent, name, context, attrs);
    }
    return view;
}
#end_block

#method_before
@UnsupportedAppUsage
private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException {
    int type;
    if (parent instanceof ViewGroup) {
        // Apply a theme wrapper, if requested. This is sort of a weird
        // edge case, since developers think the <include> overwrites
        // values in the AttributeSet of the included View. So, if the
        // included View has a theme attribute, we'll need to ignore it.
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        final boolean hasThemeOverride = themeResId != 0;
        if (hasThemeOverride) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
        // If the layout is pointing to a theme attribute, we have to
        // massage the value to get a resource identifier out of it.
        int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
        if (layout == 0) {
            final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
            if (value == null || value.length() <= 0) {
                throw new InflateException("You must specify a layout in the" + " include tag: <include layout=\"@layout/layoutID\" />");
            }
            // Attempt to resolve the "?attr/name" string to an attribute
            // within the default (e.g. application) package.
            layout = context.getResources().getIdentifier(value.substring(1), "attr", context.getPackageName());
        }
        // The layout might be referencing a theme attribute.
        if (mTempValue == null) {
            mTempValue = new TypedValue();
        }
        if (layout != 0 && context.getTheme().resolveAttribute(layout, mTempValue, true)) {
            layout = mTempValue.resourceId;
        }
        if (layout == 0) {
            final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
            throw new InflateException("You must specify a valid layout " + "reference. The layout ID " + value + " is not valid.");
        } else {
            final XmlResourceParser childParser = context.getResources().getLayout(layout);
            try {
                final AttributeSet childAttrs = Xml.asAttributeSet(childParser);
                while ((type = childParser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
                // Empty.
                }
                if (type != XmlPullParser.START_TAG) {
                    throw new InflateException(childParser.getPositionDescription() + ": No start tag found!");
                }
                final String childName = childParser.getName();
                if (TAG_MERGE.equals(childName)) {
                    // The <merge> tag doesn't support android:theme, so
                    // nothing special to do here.
                    rInflate(childParser, parent, context, childAttrs, false);
                } else {
                    final View view = createViewFromTag(parent, childName, context, childAttrs, hasThemeOverride);
                    final ViewGroup group = (ViewGroup) parent;
                    final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Include);
                    final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
                    final int visibility = a.getInt(R.styleable.Include_visibility, -1);
                    a.recycle();
                    // We try to load the layout params set in the <include /> tag.
                    // If the parent can't generate layout params (ex. missing width
                    // or height for the framework ViewGroups, though this is not
                    // necessarily true of all ViewGroups) then we expect it to throw
                    // a runtime exception.
                    // We catch this exception and set localParams accordingly: true
                    // means we successfully loaded layout params from the <include>
                    // tag, false means we need to rely on the included layout params.
                    ViewGroup.LayoutParams params = null;
                    try {
                        params = group.generateLayoutParams(attrs);
                    } catch (RuntimeException e) {
                    // Ignore, just fail over to child attrs.
                    }
                    if (params == null) {
                        params = group.generateLayoutParams(childAttrs);
                    }
                    view.setLayoutParams(params);
                    // Inflate all children.
                    rInflateChildren(childParser, view, childAttrs, true);
                    if (id != View.NO_ID) {
                        view.setId(id);
                    }
                    switch(visibility) {
                        case 0:
                            view.setVisibility(View.VISIBLE);
                            break;
                        case 1:
                            view.setVisibility(View.INVISIBLE);
                            break;
                        case 2:
                            view.setVisibility(View.GONE);
                            break;
                    }
                    group.addView(view);
                }
            } finally {
                childParser.close();
            }
        }
    } else {
        throw new InflateException("<include /> can only be used inside of a ViewGroup");
    }
    LayoutInflater.consumeChildElements(parser);
}
#method_after
@UnsupportedAppUsage
private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException {
    int type;
    if (!(parent instanceof ViewGroup)) {
        throw new InflateException("<include /> can only be used inside of a ViewGroup");
    }
    // Apply a theme wrapper, if requested. This is sort of a weird
    // edge case, since developers think the <include> overwrites
    // values in the AttributeSet of the included View. So, if the
    // included View has a theme attribute, we'll need to ignore it.
    final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
    final int themeResId = ta.getResourceId(0, 0);
    final boolean hasThemeOverride = themeResId != 0;
    if (hasThemeOverride) {
        context = new ContextThemeWrapper(context, themeResId);
    }
    ta.recycle();
    // If the layout is pointing to a theme attribute, we have to
    // massage the value to get a resource identifier out of it.
    int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
    if (layout == 0) {
        final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
        if (value == null || value.length() <= 0) {
            throw new InflateException("You must specify a layout in the" + " include tag: <include layout=\"@layout/layoutID\" />");
        }
        // Attempt to resolve the "?attr/name" string to an attribute
        // within the default (e.g. application) package.
        layout = context.getResources().getIdentifier(value.substring(1), "attr", context.getPackageName());
    }
    // The layout might be referencing a theme attribute.
    if (mTempValue == null) {
        mTempValue = new TypedValue();
    }
    if (layout != 0 && context.getTheme().resolveAttribute(layout, mTempValue, true)) {
        layout = mTempValue.resourceId;
    }
    if (layout == 0) {
        final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
        throw new InflateException("You must specify a valid layout " + "reference. The layout ID " + value + " is not valid.");
    }
    final XmlResourceParser childParser = context.getResources().getLayout(layout);
    try {
        final AttributeSet childAttrs = Xml.asAttributeSet(childParser);
        while ((type = childParser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
        // Empty.
        }
        if (type != XmlPullParser.START_TAG) {
            throw new InflateException(childParser.getPositionDescription() + ": No start tag found!");
        }
        final String childName = childParser.getName();
        if (TAG_MERGE.equals(childName)) {
            // The <merge> tag doesn't support android:theme, so
            // nothing special to do here.
            rInflate(childParser, parent, context, childAttrs, false);
        } else {
            final View view = createViewFromTag(parent, childName, context, childAttrs, hasThemeOverride);
            final ViewGroup group = (ViewGroup) parent;
            final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Include);
            final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
            final int visibility = a.getInt(R.styleable.Include_visibility, -1);
            a.recycle();
            // We try to load the layout params set in the <include /> tag.
            // If the parent can't generate layout params (ex. missing width
            // or height for the framework ViewGroups, though this is not
            // necessarily true of all ViewGroups) then we expect it to throw
            // a runtime exception.
            // We catch this exception and set localParams accordingly: true
            // means we successfully loaded layout params from the <include>
            // tag, false means we need to rely on the included layout params.
            ViewGroup.LayoutParams params = null;
            try {
                params = group.generateLayoutParams(attrs);
            } catch (RuntimeException e) {
            // Ignore, just fail over to child attrs.
            }
            if (params == null) {
                params = group.generateLayoutParams(childAttrs);
            }
            view.setLayoutParams(params);
            // Inflate all children.
            rInflateChildren(childParser, view, childAttrs, true);
            if (id != View.NO_ID) {
                view.setId(id);
            }
            switch(visibility) {
                case 0:
                    view.setVisibility(View.VISIBLE);
                    break;
                case 1:
                    view.setVisibility(View.INVISIBLE);
                    break;
                case 2:
                    view.setVisibility(View.GONE);
                    break;
            }
            group.addView(view);
        }
    } finally {
        childParser.close();
    }
    LayoutInflater.consumeChildElements(parser);
}
#end_block

#method_before
private static List<XsdElement> makeChoice(Map<String, String> attributeMap, List<XsdTag> tags) throws XsdParserException {
    List<XsdElement> elements = new ArrayList<>();
    for (XsdTag tag : tags) {
        if (tag == null)
            continue;
        if (tag instanceof XsdElement) {
            elements.add((XsdElement) tag);
        }
    }
    return elements;
}
#method_after
private static List<XsdElement> makeChoice(Map<String, String> attributeMap, List<XsdTag> tags) throws XsdParserException {
    List<XsdElement> elements = new ArrayList<>();
    for (XsdTag tag : tags) {
        if (tag == null)
            continue;
        if (tag instanceof XsdElement) {
            XsdElement element = (XsdElement) tag;
            elements.add(new XsdChoice(element.getName(), element.getRef(), element.getType(), element.isMultiple()));
        }
    }
    return elements;
}
#end_block

#method_before
private NetworkRegistrationState createRegistrationStateFromDataRegState(Object result) {
    int domain = NetworkRegistrationState.DOMAIN_PS;
    int transportType = TransportType.WWAN;
    if (result instanceof android.hardware.radio.V1_0.DataRegStateResult) {
        android.hardware.radio.V1_0.DataRegStateResult dataRegState = (android.hardware.radio.V1_0.DataRegStateResult) result;
        int regState = getRegStateFromHalRegState(dataRegState.regState);
        int accessNetworkTechnology = getAccessNetworkTechnologyFromRat(dataRegState.rat);
        int reasonForDenial = dataRegState.reasonDataDenied;
        boolean emergencyOnly = isEmergencyOnly(dataRegState.regState);
        int maxDataCalls = dataRegState.maxDataCalls;
        int[] availableServices = getAvailableServices(regState, domain, emergencyOnly);
        CellIdentity cellIdentity = convertHalCellIdentityToCellIdentity(dataRegState.cellIdentity);
        return new NetworkRegistrationState(domain, transportType, regState, accessNetworkTechnology, reasonForDenial, emergencyOnly, availableServices, cellIdentity, maxDataCalls, false, /* isDcNrRestricted */
        false);
    } else if (result instanceof android.hardware.radio.V1_2.DataRegStateResult) {
        android.hardware.radio.V1_2.DataRegStateResult dataRegState = (android.hardware.radio.V1_2.DataRegStateResult) result;
        int regState = getRegStateFromHalRegState(dataRegState.regState);
        int accessNetworkTechnology = getAccessNetworkTechnologyFromRat(dataRegState.rat);
        int reasonForDenial = dataRegState.reasonDataDenied;
        boolean emergencyOnly = isEmergencyOnly(dataRegState.regState);
        int maxDataCalls = dataRegState.maxDataCalls;
        int[] availableServices = getAvailableServices(regState, domain, emergencyOnly);
        CellIdentity cellIdentity = convertHalCellIdentityToCellIdentity(dataRegState.cellIdentity);
        return new NetworkRegistrationState(domain, transportType, regState, accessNetworkTechnology, reasonForDenial, emergencyOnly, availableServices, cellIdentity, maxDataCalls, false, /* isDcNrRestricted */
        false);
    }
    return null;
}
#method_after
private NetworkRegistrationState createRegistrationStateFromDataRegState(Object result) {
    int domain = NetworkRegistrationState.DOMAIN_PS;
    int transportType = TransportType.WWAN;
    if (result instanceof android.hardware.radio.V1_0.DataRegStateResult) {
        android.hardware.radio.V1_0.DataRegStateResult dataRegState = (android.hardware.radio.V1_0.DataRegStateResult) result;
        int regState = getRegStateFromHalRegState(dataRegState.regState);
        int accessNetworkTechnology = getAccessNetworkTechnologyFromRat(dataRegState.rat);
        int reasonForDenial = dataRegState.reasonDataDenied;
        boolean emergencyOnly = isEmergencyOnly(dataRegState.regState);
        int maxDataCalls = dataRegState.maxDataCalls;
        int[] availableServices = getAvailableServices(regState, domain, emergencyOnly);
        CellIdentity cellIdentity = convertHalCellIdentityToCellIdentity(dataRegState.cellIdentity);
        return new NetworkRegistrationState(domain, transportType, regState, accessNetworkTechnology, reasonForDenial, emergencyOnly, availableServices, cellIdentity, maxDataCalls, false, /* isDcNrRestricted */
        false, /* isNrAvailable */
        false);
    } else if (result instanceof android.hardware.radio.V1_2.DataRegStateResult) {
        android.hardware.radio.V1_2.DataRegStateResult dataRegState = (android.hardware.radio.V1_2.DataRegStateResult) result;
        int regState = getRegStateFromHalRegState(dataRegState.regState);
        int accessNetworkTechnology = getAccessNetworkTechnologyFromRat(dataRegState.rat);
        int reasonForDenial = dataRegState.reasonDataDenied;
        boolean emergencyOnly = isEmergencyOnly(dataRegState.regState);
        int maxDataCalls = dataRegState.maxDataCalls;
        int[] availableServices = getAvailableServices(regState, domain, emergencyOnly);
        CellIdentity cellIdentity = convertHalCellIdentityToCellIdentity(dataRegState.cellIdentity);
        return new NetworkRegistrationState(domain, transportType, regState, accessNetworkTechnology, reasonForDenial, emergencyOnly, availableServices, cellIdentity, maxDataCalls, false, /* isDcNrRestricted */
        false, /* isNrAvailable */
        false);
    } else if (result instanceof android.hardware.radio.V1_4.DataRegStateResult) {
        android.hardware.radio.V1_4.DataRegStateResult dataRegState = (android.hardware.radio.V1_4.DataRegStateResult) result;
        int regState = getRegStateFromHalRegState(dataRegState.base.regState);
        int accessNetworkTechnology = getAccessNetworkTechnologyFromRat(dataRegState.base.rat);
        int reasonForDenial = dataRegState.base.reasonDataDenied;
        boolean emergencyOnly = isEmergencyOnly(dataRegState.base.regState);
        int maxDataCalls = dataRegState.base.maxDataCalls;
        int[] availableServices = getAvailableServices(regState, domain, emergencyOnly);
        CellIdentity cellIdentity = convertHalCellIdentityToCellIdentity(dataRegState.base.cellIdentity);
        android.hardware.radio.V1_4.NrIndicators nrIndicators = dataRegState.nrIndicators;
        return new NetworkRegistrationState(domain, transportType, regState, accessNetworkTechnology, reasonForDenial, emergencyOnly, availableServices, cellIdentity, maxDataCalls, nrIndicators.isDcNrRestricted, nrIndicators.isNrAvailable, nrIndicators.isEndcAvailable);
    }
    return null;
}
#end_block

#method_before
@Override
public void close() {
    mCallbackMap.clear();
    mHandlerThread.quit();
    mPhone.mCi.unregisterForNetworkStateChanged(mHandler);
    super.close();
}
#method_after
@Override
public void close() {
    mCallbackMap.clear();
    mHandlerThread.quit();
    mPhone.mCi.unregisterForNetworkStateChanged(mHandler);
}
#end_block

#method_before
@Override
public void close() {
    mPhone.mCi.unregisterForDataCallListChanged(mHandler);
    mHandlerThread.quit();
    super.close();
}
#method_after
@Override
public void close() {
    mPhone.mCi.unregisterForDataCallListChanged(mHandler);
    mHandlerThread.quit();
}
#end_block

#method_before
void clearNfcRoutingTableLocked() {
    for (Map.Entry<String, Integer> aidEntry : mRouteForAid.entrySet()) {
        String aid = aidEntry.getKey();
        if (aid.endsWith("*")) {
            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                Log.e(TAG, "Device does not support prefix AIDs but AID [" + aid + "] is registered");
            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
                if (DBG)
                    Log.d(TAG, "Unrouting prefix AID " + aid);
                // Cut off '*' since controller anyway treats all AIDs as a prefix
                aid = aid.substring(0, aid.length() - 1);
            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX || mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                aid = aid.substring(0, aid.length() - 1);
                if (DBG)
                    Log.d(TAG, "Unrouting prefix AID " + aid);
            }
        } else if (aid.endsWith("#")) {
            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY || mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX) {
                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                if (DBG)
                    Log.d(TAG, "Unrouting subset AID " + aid);
                aid = aid.substring(0, aid.length() - 1);
            }
        } else {
            if (DBG)
                Log.d(TAG, "Unrouting exact AID " + aid);
        }
        NfcService.getInstance().unrouteAids(aid);
    }
    // unRoute EmptyAid
    NfcService.getInstance().unrouteAids("");
}
#method_after
void clearNfcRoutingTableLocked() {
    for (Map.Entry<String, Integer> aidEntry : mRouteForAid.entrySet()) {
        String aid = aidEntry.getKey();
        if (aid.endsWith("*")) {
            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                Log.e(TAG, "Device does not support prefix AIDs but AID [" + aid + "] is registered");
            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
                if (DBG)
                    Log.d(TAG, "Unrouting prefix AID " + aid);
                // Cut off '*' since controller anyway treats all AIDs as a prefix
                aid = aid.substring(0, aid.length() - 1);
            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX || mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                aid = aid.substring(0, aid.length() - 1);
                if (DBG)
                    Log.d(TAG, "Unrouting prefix AID " + aid);
            }
        } else if (aid.endsWith("#")) {
            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY || mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX) {
                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                if (DBG)
                    Log.d(TAG, "Unrouting subset AID " + aid);
                aid = aid.substring(0, aid.length() - 1);
            }
        } else {
            if (DBG)
                Log.d(TAG, "Unrouting exact AID " + aid);
        }
        NfcService.getInstance().unrouteAids(aid);
    }
    if (NfcService.getInstance().getNciVersion() != NfcService.getInstance().NCI_VERSION_1_0) {
        // unRoute EmptyAid
        NfcService.getInstance().unrouteAids("");
    }
}
#end_block

#method_before
public boolean configureRouting(HashMap<String, AidEntry> aidMap) {
    boolean aidRouteResolved = false;
    HashMap<String, AidEntry> aidRoutingTableCache = new HashMap<String, AidEntry>(aidMap.size());
    SparseArray<Set<String>> aidRoutingTable = new SparseArray<Set<String>>(aidMap.size());
    HashMap<String, Integer> routeForAid = new HashMap<String, Integer>(aidMap.size());
    HashMap<String, Integer> infoForAid = new HashMap<String, Integer>(aidMap.size());
    // Then, populate internal data structures first
    for (Map.Entry<String, AidEntry> aidEntry : aidMap.entrySet()) {
        int route = ROUTE_HOST;
        if (!aidEntry.getValue().isOnHost) {
            if (aidEntry.getValue().offHostSE.contains("eSE")) {
                route = mOffHostRouteEse;
            } else if (aidEntry.getValue().offHostSE.contains("SIM")) {
                route = mOffHostRouteUicc;
            }
        }
        int aidType = aidEntry.getValue().aidInfo;
        String aid = aidEntry.getKey();
        Set<String> entries = aidRoutingTable.get(route, new HashSet<String>());
        entries.add(aid);
        aidRoutingTable.put(route, entries);
        routeForAid.put(aid, route);
        infoForAid.put(aid, aidType);
    }
    synchronized (mLock) {
        if (routeForAid.equals(mRouteForAid)) {
            if (DBG)
                Log.d(TAG, "Routing table unchanged, not updating");
            return false;
        }
        // Otherwise, update internal structures and commit new routing
        clearNfcRoutingTableLocked();
        mRouteForAid = routeForAid;
        mAidRoutingTable = aidRoutingTable;
        mMaxAidRoutingTableSize = NfcService.getInstance().getAidRoutingTableSize();
        if (DBG)
            Log.d(TAG, "mMaxAidRoutingTableSize: " + mMaxAidRoutingTableSize);
        // calculate AidRoutingTableSize for RouteHost/mOffHostRouteUicc/mOffHostRouteEse
        for (int index = 0; index < mSeList.size(); index++) {
            mDefaultRoute = mSeList.get(index);
            if (index != 0)
                if (DBG)
                    Log.d(TAG, "AidRoutingTable is full, try to switch mDefaultRoute to 0x" + Integer.toHexString(mDefaultRoute));
            aidRoutingTableCache.clear();
            if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
                /* If a non-default route registers an exact AID which is shorter
                   * than this exact AID, this will create a problem with controllers
                   * that treat every AID in the routing table as a prefix.
                   * For example, if App A registers F0000000041010 as an exact AID,
                   * and App B registers F000000004 as an exact AID, and App B is not
                   * the default route, the following would be added to the routing table:
                   * F000000004 -> non-default destination
                   * However, because in this mode, the controller treats every routing table
                   * entry as a prefix, it means F0000000041010 would suddenly go to the non-default
                   * destination too, whereas it should have gone to the default.
                   *
                   * The only way to prevent this is to add the longer AIDs of the
                   * default route at the top of the table, so they will be matched first.
                   */
                Set<String> defaultRouteAids = mAidRoutingTable.get(mDefaultRoute);
                if (defaultRouteAids != null) {
                    for (String defaultRouteAid : defaultRouteAids) {
                        // TODO this is O(N^2) run-time complexity...
                        for (Map.Entry<String, Integer> aidEntry : mRouteForAid.entrySet()) {
                            String aid = aidEntry.getKey();
                            int route = aidEntry.getValue();
                            if (defaultRouteAid.startsWith(aid) && route != mDefaultRoute) {
                                if (DBG)
                                    Log.d(TAG, "Adding AID " + defaultRouteAid + " for default " + "route, because a conflicting shorter AID will be " + "added to the routing table");
                                aidRoutingTableCache.put(defaultRouteAid, aidMap.get(defaultRouteAid));
                            }
                        }
                    }
                }
            }
            // Add AID entries for all non-default routes
            for (int i = 0; i < mAidRoutingTable.size(); i++) {
                int route = mAidRoutingTable.keyAt(i);
                if (route != mDefaultRoute) {
                    Set<String> aidsForRoute = mAidRoutingTable.get(route);
                    for (String aid : aidsForRoute) {
                        if (aid.endsWith("*")) {
                            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                                Log.e(TAG, "This device does not support prefix AIDs.");
                            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
                                if (DBG)
                                    Log.d(TAG, "Routing prefix AID " + aid + " to route " + Integer.toString(route));
                                // Cut off '*' since controller anyway treats all AIDs as a prefix
                                aidRoutingTableCache.put(aid.substring(0, aid.length() - 1), aidMap.get(aid));
                            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX || mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                                if (DBG)
                                    Log.d(TAG, "Routing prefix AID " + aid + " to route " + Integer.toString(route));
                                aidRoutingTableCache.put(aid.substring(0, aid.length() - 1), aidMap.get(aid));
                            }
                        } else if (aid.endsWith("#")) {
                            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
                            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY || mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX) {
                                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
                            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                                if (DBG)
                                    Log.d(TAG, "Routing subset AID " + aid + " to route " + Integer.toString(route));
                                aidRoutingTableCache.put(aid.substring(0, aid.length() - 1), aidMap.get(aid));
                            }
                        } else {
                            if (DBG)
                                Log.d(TAG, "Routing exact AID " + aid + " to route " + Integer.toString(route));
                            aidRoutingTableCache.put(aid, aidMap.get(aid));
                        }
                    }
                }
            }
            if (mDefaultRoute != mDefaultIsoDepRoute) {
                String emptyAid = "";
                AidEntry entry = new AidEntry();
                if (mDefaultRoute == ROUTE_HOST) {
                    entry.isOnHost = true;
                    entry.offHostSE = null;
                } else if (mDefaultRoute == mOffHostRouteUicc) {
                    entry.isOnHost = false;
                    entry.offHostSE = "SIM";
                } else if (mDefaultRoute == mOffHostRouteEse) {
                    entry.isOnHost = false;
                    entry.offHostSE = "eSE";
                }
                entry.aidInfo = AID_ROUTE_QUAL_PREFIX;
                aidRoutingTableCache.put(emptyAid, entry);
                if (DBG)
                    Log.d(TAG, "Add emptyAid into AidRoutingTable");
            }
            if (calculateAidRouteSize(aidRoutingTableCache) <= mMaxAidRoutingTableSize) {
                aidRouteResolved = true;
                break;
            }
        }
        if (aidRouteResolved == true) {
            commit(aidRoutingTableCache);
        } else {
            Log.e(TAG, "RoutingTable unchanged because it's full, not updating");
        }
    }
    return true;
}
#method_after
public boolean configureRouting(HashMap<String, AidEntry> aidMap) {
    boolean aidRouteResolved = false;
    HashMap<String, AidEntry> aidRoutingTableCache = new HashMap<String, AidEntry>(aidMap.size());
    ArrayList<Integer> seList = new ArrayList<Integer>();
    seList.add(ROUTE_HOST);
    SparseArray<Set<String>> aidRoutingTable = new SparseArray<Set<String>>(aidMap.size());
    HashMap<String, Integer> routeForAid = new HashMap<String, Integer>(aidMap.size());
    HashMap<String, Integer> infoForAid = new HashMap<String, Integer>(aidMap.size());
    // Then, populate internal data structures first
    for (Map.Entry<String, AidEntry> aidEntry : aidMap.entrySet()) {
        int route = ROUTE_HOST;
        if (!aidEntry.getValue().isOnHost) {
            String offHostSE = aidEntry.getValue().offHostSE;
            if (offHostSE == null) {
                route = mDefaultOffHostRoute;
            } else {
                route = getRouteForSecureElement(offHostSE);
                if (route == 0) {
                    Log.e(TAG, "Invalid Off host Aid Entry " + offHostSE);
                    continue;
                }
            }
        }
        if (!seList.contains(route))
            seList.add(route);
        aidEntry.getValue().route = route;
        int aidType = aidEntry.getValue().aidInfo;
        String aid = aidEntry.getKey();
        Set<String> entries = aidRoutingTable.get(route, new HashSet<String>());
        entries.add(aid);
        aidRoutingTable.put(route, entries);
        routeForAid.put(aid, route);
        infoForAid.put(aid, aidType);
    }
    synchronized (mLock) {
        if (routeForAid.equals(mRouteForAid)) {
            if (DBG)
                Log.d(TAG, "Routing table unchanged, not updating");
            return false;
        }
        // Otherwise, update internal structures and commit new routing
        clearNfcRoutingTableLocked();
        mRouteForAid = routeForAid;
        mAidRoutingTable = aidRoutingTable;
        mMaxAidRoutingTableSize = NfcService.getInstance().getAidRoutingTableSize();
        if (DBG)
            Log.d(TAG, "mMaxAidRoutingTableSize: " + mMaxAidRoutingTableSize);
        // calculate AidRoutingTableSize for existing route destination
        for (int index = 0; index < seList.size(); index++) {
            mDefaultRoute = seList.get(index);
            if (index != 0)
                if (DBG)
                    Log.d(TAG, "AidRoutingTable is full, try to switch mDefaultRoute to 0x" + Integer.toHexString(mDefaultRoute));
            aidRoutingTableCache.clear();
            if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
                /* If a non-default route registers an exact AID which is shorter
                   * than this exact AID, this will create a problem with controllers
                   * that treat every AID in the routing table as a prefix.
                   * For example, if App A registers F0000000041010 as an exact AID,
                   * and App B registers F000000004 as an exact AID, and App B is not
                   * the default route, the following would be added to the routing table:
                   * F000000004 -> non-default destination
                   * However, because in this mode, the controller treats every routing table
                   * entry as a prefix, it means F0000000041010 would suddenly go to the non-default
                   * destination too, whereas it should have gone to the default.
                   *
                   * The only way to prevent this is to add the longer AIDs of the
                   * default route at the top of the table, so they will be matched first.
                   */
                Set<String> defaultRouteAids = mAidRoutingTable.get(mDefaultRoute);
                if (defaultRouteAids != null) {
                    for (String defaultRouteAid : defaultRouteAids) {
                        // TODO this is O(N^2) run-time complexity...
                        for (Map.Entry<String, Integer> aidEntry : mRouteForAid.entrySet()) {
                            String aid = aidEntry.getKey();
                            int route = aidEntry.getValue();
                            if (defaultRouteAid.startsWith(aid) && route != mDefaultRoute) {
                                if (DBG)
                                    Log.d(TAG, "Adding AID " + defaultRouteAid + " for default " + "route, because a conflicting shorter AID will be " + "added to the routing table");
                                aidRoutingTableCache.put(defaultRouteAid, aidMap.get(defaultRouteAid));
                            }
                        }
                    }
                }
            }
            // Add AID entries for all non-default routes
            for (int i = 0; i < mAidRoutingTable.size(); i++) {
                int route = mAidRoutingTable.keyAt(i);
                if (route != mDefaultRoute) {
                    Set<String> aidsForRoute = mAidRoutingTable.get(route);
                    for (String aid : aidsForRoute) {
                        if (aid.endsWith("*")) {
                            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                                Log.e(TAG, "This device does not support prefix AIDs.");
                            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
                                if (DBG)
                                    Log.d(TAG, "Routing prefix AID " + aid + " to route " + Integer.toString(route));
                                // Cut off '*' since controller anyway treats all AIDs as a prefix
                                aidRoutingTableCache.put(aid.substring(0, aid.length() - 1), aidMap.get(aid));
                            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX || mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                                if (DBG)
                                    Log.d(TAG, "Routing prefix AID " + aid + " to route " + Integer.toString(route));
                                aidRoutingTableCache.put(aid.substring(0, aid.length() - 1), aidMap.get(aid));
                            }
                        } else if (aid.endsWith("#")) {
                            if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
                                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
                            } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY || mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX) {
                                Log.e(TAG, "Device does not support subset AIDs but AID [" + aid + "] is registered");
                            } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                                if (DBG)
                                    Log.d(TAG, "Routing subset AID " + aid + " to route " + Integer.toString(route));
                                aidRoutingTableCache.put(aid.substring(0, aid.length() - 1), aidMap.get(aid));
                            }
                        } else {
                            if (DBG)
                                Log.d(TAG, "Routing exact AID " + aid + " to route " + Integer.toString(route));
                            aidRoutingTableCache.put(aid, aidMap.get(aid));
                        }
                    }
                }
            }
            if (mDefaultRoute != mDefaultIsoDepRoute) {
                if (NfcService.getInstance().getNciVersion() != NfcService.getInstance().NCI_VERSION_1_0) {
                    String emptyAid = "";
                    AidEntry entry = new AidEntry();
                    entry.route = mDefaultRoute;
                    if (mDefaultRoute == ROUTE_HOST) {
                        entry.isOnHost = true;
                    } else {
                        entry.isOnHost = false;
                    }
                    entry.aidInfo = RegisteredAidCache.AID_ROUTE_QUAL_PREFIX;
                    aidRoutingTableCache.put(emptyAid, entry);
                    if (DBG)
                        Log.d(TAG, "Add emptyAid into AidRoutingTable");
                }
            }
            if (calculateAidRouteSize(aidRoutingTableCache) <= mMaxAidRoutingTableSize) {
                aidRouteResolved = true;
                break;
            }
        }
        if (aidRouteResolved == true) {
            commit(aidRoutingTableCache);
        } else {
            Log.e(TAG, "RoutingTable unchanged because it's full, not updating");
        }
    }
    return true;
}
#end_block

#method_before
private void commit(HashMap<String, AidEntry> routeCache) {
    if (routeCache != null) {
        for (Map.Entry<String, AidEntry> aidEntry : routeCache.entrySet()) {
            int route = ROUTE_HOST;
            if (!aidEntry.getValue().isOnHost) {
                if (aidEntry.getValue().offHostSE.contains("eSE")) {
                    route = mOffHostRouteEse;
                } else if (aidEntry.getValue().offHostSE.contains("SIM")) {
                    route = mOffHostRouteUicc;
                }
            }
            int aidType = aidEntry.getValue().aidInfo;
            String aid = aidEntry.getKey();
            Log.e(TAG, "commit aid:" + aid + "route:" + route + "aidtype:" + aidType);
            NfcService.getInstance().routeAids(aid, route, aidType);
        }
    }
    // And finally commit the routing
    NfcService.getInstance().commitRouting();
}
#method_after
private void commit(HashMap<String, AidEntry> routeCache) {
    if (routeCache != null) {
        for (Map.Entry<String, AidEntry> aidEntry : routeCache.entrySet()) {
            int route = aidEntry.getValue().route;
            int aidType = aidEntry.getValue().aidInfo;
            String aid = aidEntry.getKey();
            Log.d(TAG, "commit aid:" + aid + "route:" + route + "aidtype:" + aidType);
            NfcService.getInstance().routeAids(aid, route, aidType);
        }
    }
    // And finally commit the routing
    NfcService.getInstance().commitRouting();
}
#end_block

#method_before
@Override
public void checkFirmware() {
    doDownload();
}
#method_after
@Override
public boolean checkFirmware() {
    return doDownload();
}
#end_block

#method_before
@Override
protected Void doInBackground(Integer... params) {
    // Sanity check mState
    switch(mState) {
        case NfcAdapter.STATE_TURNING_OFF:
        case NfcAdapter.STATE_TURNING_ON:
            Log.e(TAG, "Processing EnableDisable task " + params[0] + " from bad state " + mState);
            return null;
    }
    /* AsyncTask sets this thread to THREAD_PRIORITY_BACKGROUND,
             * override with the default. THREAD_PRIORITY_BACKGROUND causes
             * us to service software I2C too slow for firmware download
             * with the NXP PN544.
             * TODO: move this to the DAL I2C layer in libnfc-nxp, since this
             * problem only occurs on I2C platforms using PN544
             */
    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
    switch(params[0].intValue()) {
        case TASK_ENABLE:
            enableInternal();
            break;
        case TASK_DISABLE:
            disableInternal();
            break;
        case TASK_BOOT:
            if (mPrefs.getBoolean(PREF_FIRST_BOOT, true)) {
                Log.i(TAG, "First Boot");
                mPrefsEditor.putBoolean(PREF_FIRST_BOOT, false);
                mPrefsEditor.apply();
                mDeviceHost.factoryReset();
            }
            Log.d(TAG, "checking on firmware download");
            if (mPrefs.getBoolean(PREF_NFC_ON, NFC_ON_DEFAULT)) {
                Log.d(TAG, "NFC is on. Doing normal stuff");
                enableInternal();
            } else {
                Log.d(TAG, "NFC is off.  Checking firmware version");
                mDeviceHost.checkFirmware();
            }
            SystemProperties.set("nfc.initialized", "true");
            break;
    }
    // Restore default AsyncTask priority
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    return null;
}
#method_after
@Override
protected Void doInBackground(Integer... params) {
    // Sanity check mState
    switch(mState) {
        case NfcAdapter.STATE_TURNING_OFF:
        case NfcAdapter.STATE_TURNING_ON:
            Log.e(TAG, "Processing EnableDisable task " + params[0] + " from bad state " + mState);
            return null;
    }
    /* AsyncTask sets this thread to THREAD_PRIORITY_BACKGROUND,
             * override with the default. THREAD_PRIORITY_BACKGROUND causes
             * us to service software I2C too slow for firmware download
             * with the NXP PN544.
             * TODO: move this to the DAL I2C layer in libnfc-nxp, since this
             * problem only occurs on I2C platforms using PN544
             */
    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
    switch(params[0].intValue()) {
        case TASK_ENABLE:
            enableInternal();
            break;
        case TASK_DISABLE:
            disableInternal();
            break;
        case TASK_BOOT:
            boolean initialized;
            if (mPrefs.getBoolean(PREF_FIRST_BOOT, true)) {
                Log.i(TAG, "First Boot");
                mPrefsEditor.putBoolean(PREF_FIRST_BOOT, false);
                mPrefsEditor.apply();
                mDeviceHost.factoryReset();
            }
            Log.d(TAG, "checking on firmware download");
            if (mPrefs.getBoolean(PREF_NFC_ON, NFC_ON_DEFAULT)) {
                Log.d(TAG, "NFC is on. Doing normal stuff");
                initialized = enableInternal();
            } else {
                Log.d(TAG, "NFC is off.  Checking firmware version");
                initialized = mDeviceHost.checkFirmware();
            }
            if (initialized) {
                SystemProperties.set("nfc.initialized", "true");
            }
            break;
    }
    // Restore default AsyncTask priority
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    return null;
}
#end_block

#method_before
@Override
public void onTestRunStart(DataRecord runData, Description description) {
    Bundle args = getArgsBundle();
    String procsString = args.getString(PROCESS_NAMES_KEY);
    if (procsString == null) {
        Log.e(TAG, "No processes provided to GC");
        return;
    }
    String[] procs = procsString.split(PROCESS_SEPARATOR);
    mGcHelper.setUp(procs);
    String gcWaitString = args.getString(GC_WAIT_TIME_KEY);
    if (gcWaitString != null) {
        try {
            mWaitTime = Long.parseLong(gcWaitString);
        } catch (NumberFormatException e) {
            Log.e(TAG, "Unexpected wait time format. Using default time", e);
        }
    }
}
#method_after
@Override
public void onTestRunStart(DataRecord runData, Description description) {
    Bundle args = getArgsBundle();
    String procsString = args.getString(PROCESS_NAMES_KEY);
    if (procsString == null) {
        Log.e(TAG, "No processes provided to GC");
        return;
    }
    String[] procs = procsString.split(PROCESS_SEPARATOR);
    mGcHelper.setUp(procs);
    String gcWaitString = args.getString(GC_WAIT_TIME_KEY);
    if (gcWaitString != null) {
        try {
            mWaitTime = Long.parseLong(gcWaitString);
        } catch (NumberFormatException e) {
            Log.e(TAG, "Unexpected wait time format. Using default time", e);
        }
    }
    mSetUp = true;
}
#end_block

#method_before
private void garbageCollect() {
    if (mWaitTime == null || mWaitTime < 0l) {
        // If no wait time specified or invalid, use default garbage collect call.
        mGcHelper.garbageCollect();
    } else {
        mGcHelper.garbageCollect(mWaitTime);
    }
}
#method_after
private void garbageCollect() {
    if (!mSetUp) {
        return;
    }
    if (mWaitTime == null || mWaitTime < 0l) {
        // If no wait time specified or invalid, use default garbage collect call.
        mGcHelper.garbageCollect();
    } else {
        mGcHelper.garbageCollect(mWaitTime);
    }
}
#end_block

#method_before
@Test
public void testHelperGcsProvidedWaitTime() throws Exception {
    Bundle b = new Bundle();
    b.putString(PROCESS_NAMES_KEY, TEST_PROCESS_NAME_1);
    b.putString(GC_WAIT_TIME_KEY, Long.toString(TEST_WAIT_TIME));
    mPreparer = initPreparer(b);
    mPreparer.testRunStarted(mRunDesc);
    mPreparer.onTestStart(mock(DataRecord.class), mRunDesc);
    verify(mGcHelper).garbageCollect(TEST_WAIT_TIME);
}
#method_after
@Test
public void testHelperGcsProvidedWaitTime() throws Exception {
    Bundle b = new Bundle();
    b.putString(PROCESS_NAMES_KEY, TEST_PROCESS_NAME_1);
    b.putString(GC_WAIT_TIME_KEY, Long.toString(TEST_WAIT_TIME));
    mPreparer = initPreparer(b);
    mPreparer.testRunStarted(mRunDesc);
    mPreparer.testStarted(mRunDesc);
    mPreparer.testFinished(mRunDesc);
    verify(mGcHelper, times(2)).garbageCollect(TEST_WAIT_TIME);
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
public void testEndAtMidnight_dateOnly() {
    BiFunction<Long, Long, String> fmt = (from, to) -> formatDateRange(ENGLISH, GMT_ZONE, from, to, FORMAT_SHOW_DATE);
    // If we're only showing dates and the end-point is midnight of any day, we want the
    // behaviour of showing an end date one earlier. So if the end-point is March 2, 00:00, show
    // March 1 instead (whether the start-point is midnight or not).
    assertEquals("February 27 – March 1, 2007", fmt.apply(1172534400000L, 1172793600000L));
    assertEquals("February 27 – March 1, 2007", fmt.apply(1172548800000L, 1172793600000L));
    // We want to show the true date if the end-point is a millisecond after midnight.
    assertEquals("February 27 – March 2, 2007", fmt.apply(1172534400000L, 1172793600001L));
    // 2006-02-27 00:00:00.000 GMT - 2007-03-02 00:00:00.000 GMT
    assertEquals("February 27, 2006 – March 1, 2007", fmt.apply(1140998400000L, 1172793600000L));
    // Spans a leap year's Feb 29th.
    assertEquals("February 27 – March 1, 2004", fmt.apply(1077840000000L, 1078185600000L));
}
#method_after
public void testEndAtMidnight_dateOnly() {
    BiFunction<Long, Long, String> fmt = (from, to) -> formatDateRange(ENGLISH, GMT_ZONE, from, to, FORMAT_SHOW_DATE);
    // If we're only showing dates and the end-point is midnight of any day, we want the
    // behaviour of showing an end date one earlier. So if the end-point is March 2, 2007 00:00,
    // show March 1, 2007 instead (whether the start-point is midnight or not).
    assertEquals("February 27 – March 1, 2007", fmt.apply(1172534400000L, 1172793600000L));
    assertEquals("February 27 – March 1, 2007", fmt.apply(1172548800000L, 1172793600000L));
    // We want to show the true date if the end-point is a millisecond after midnight.
    assertEquals("February 27 – March 2, 2007", fmt.apply(1172534400000L, 1172793600001L));
    // 2006-02-27 00:00:00.000 GMT - 2007-03-02 00:00:00.000 GMT
    assertEquals("February 27, 2006 – March 1, 2007", fmt.apply(1140998400000L, 1172793600000L));
    // Spans a leap year's Feb 29th.
    assertEquals("February 27 – March 1, 2004", fmt.apply(1077840000000L, 1078185600000L));
}
#end_block

#method_before
private boolean playVibration(final NotificationRecord record, long[] vibration, boolean delayVibForSound) {
    // Escalate privileges so we can use the vibrator even if the
    // notifying app does not have the VIBRATE permission.
    long identity = Binder.clearCallingIdentity();
    try {
        final VibrationEffect effect;
        try {
            final boolean insistent = (record.getNotification().flags & Notification.FLAG_INSISTENT) != 0;
            effect = VibrationEffect.createWaveform(vibration, insistent ? 0 : -1);
        } catch (IllegalArgumentException e) {
            Slog.e(TAG, "Error creating vibration waveform with pattern: " + Arrays.toString(vibration));
            return false;
        }
        if (delayVibForSound) {
            new Thread(() -> {
                // delay the vibration by the same amount as the notification sound
                final int waitMs = mAudioManager.getFocusRampTimeMs(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK, record.getAudioAttributes());
                if (DBG)
                    Slog.v(TAG, "Delaying vibration by " + waitMs + "ms");
                try {
                    Thread.sleep(waitMs);
                } catch (InterruptedException e) {
                }
                // so need to check the notification still valide for vibrate.
                if (record.getKey().equals(mVibrateNotificationKey) && mNotificationsByKey.get(record.getKey()) != null) {
                    mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), effect, record.getAudioAttributes());
                } else {
                    Slog.e(TAG, "No vibration for canceled notification : " + record.getKey());
                }
            }).start();
        } else {
            mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), effect, record.getAudioAttributes());
        }
        return true;
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#method_after
private boolean playVibration(final NotificationRecord record, long[] vibration, boolean delayVibForSound) {
    // Escalate privileges so we can use the vibrator even if the
    // notifying app does not have the VIBRATE permission.
    long identity = Binder.clearCallingIdentity();
    try {
        final VibrationEffect effect;
        try {
            final boolean insistent = (record.getNotification().flags & Notification.FLAG_INSISTENT) != 0;
            effect = VibrationEffect.createWaveform(vibration, insistent ? 0 : -1);
        } catch (IllegalArgumentException e) {
            Slog.e(TAG, "Error creating vibration waveform with pattern: " + Arrays.toString(vibration));
            return false;
        }
        if (delayVibForSound) {
            new Thread(() -> {
                // delay the vibration by the same amount as the notification sound
                final int waitMs = mAudioManager.getFocusRampTimeMs(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK, record.getAudioAttributes());
                if (DBG)
                    Slog.v(TAG, "Delaying vibration by " + waitMs + "ms");
                try {
                    Thread.sleep(waitMs);
                } catch (InterruptedException e) {
                }
                // so need to check the notification still valide for vibrate.
                synchronized (mNotificationLock) {
                    if (mNotificationsByKey.get(record.getKey()) != null) {
                        mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), effect, record.getAudioAttributes());
                    } else {
                        Slog.e(TAG, "No vibration for canceled notification : " + record.getKey());
                    }
                }
            }).start();
        } else {
            mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), effect, record.getAudioAttributes());
        }
        return true;
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // validate a few MediaMetrics.
    PersistableBundle metrics = mPlayer.getMetrics();
    if (metrics == null) {
        fail("MediaPlayer.getMetrics() returned null metrics");
    } else if (metrics.isEmpty()) {
        fail("MediaPlayer.getMetrics() returned empty metrics");
    } else {
        int size = metrics.size();
        Set<String> keys = metrics.keySet();
        if (keys == null) {
            fail("MediaMetricsSet returned no keys");
        } else if (keys.size() != size) {
            fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
        }
        // we played something; so one of these should be non-null
        String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
        String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
        if (vmime == null && amime == null) {
            fail("getMetrics() returned neither video nor audio mime value");
        }
        long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
        if (duration == -2) {
            fail("getMetrics() didn't return a duration");
        }
        long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
        if (playing == -2) {
            fail("getMetrics() didn't return a playing time");
        }
        if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
            fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
        }
    }
    MediaItem item = mPlayer.getCurrentMediaItem();
    mPlayer.close();
    // Set the player to null so we don't try to close it again in tearDown().
    mPlayer = null;
    assertTrue(((FileMediaItem) item).isClosed());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // validate a few MediaMetrics.
    PersistableBundle metrics = mPlayer.getMetrics();
    if (metrics == null) {
        fail("MediaPlayer.getMetrics() returned null metrics");
    } else if (metrics.isEmpty()) {
        fail("MediaPlayer.getMetrics() returned empty metrics");
    } else {
        int size = metrics.size();
        Set<String> keys = metrics.keySet();
        if (keys == null) {
            fail("MediaMetricsSet returned no keys");
        } else if (keys.size() != size) {
            fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
        }
        // we played something; so one of these should be non-null
        String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
        String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
        if (vmime == null && amime == null) {
            fail("getMetrics() returned neither video nor audio mime value");
        }
        long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
        if (duration == -2) {
            fail("getMetrics() didn't return a duration");
        }
        long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
        if (playing == -2) {
            fail("getMetrics() didn't return a playing time");
        }
        if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
            fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
        }
    }
    MediaItem item = mPlayer.getCurrentMediaItem();
    mPlayer.reset();
    assertTrue(((FileMediaItem) item).isClosed());
}
#end_block

#method_before
@Override
public void onCreatePreferences(Bundle bundle, String s) {
    mSwapIntervalKey = getResources().getString(R.string.swap_interval_key);
    addPreferencesFromResource(R.xml.preferences);
    PreferenceScreen preferenceScreen = getPreferenceScreen();
    for (int i = 0; i < preferenceScreen.getPreferenceCount(); ++i) {
        Preference preference = preferenceScreen.getPreference(i);
        final String key = preference.getKey();
        if (key != null && key.equals(mSwapIntervalKey)) {
            mSwapIntervalPreference = (ListPreference) preference;
        }
    }
    // fill the swap interval list based on the screen refresh rate
    List<String> entries = new ArrayList<>();
    List<String> entryValues = new ArrayList<>();
    float refreshRate = getActivity().getWindowManager().getDefaultDisplay().getRefreshRate();
    for (int dev = 1; refreshRate / dev >= 20; dev++) {
        int fps = (int) (refreshRate / dev);
        float ms = 1000 / (refreshRate / dev);
        entries.add(String.format(Locale.US, "%.2fms (%dfps)", ms, fps));
        entryValues.add(Float.toString(ms));
    }
    entries.add(String.format(Locale.US, "No pacing"));
    entryValues.add(Float.toString(100));
    mSwapIntervalPreference.setEntries(entries.toArray(new String[0]));
    mSwapIntervalPreference.setEntryValues(entryValues.toArray(new String[0]));
    mSwapIntervalPreference.setDefaultValue(entries.get(0));
    Context context = getContext();
    if (context != null) {
        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
        sharedPreferences.registerOnSharedPreferenceChangeListener(this);
        // set default if it doesn't exist
        if (sharedPreferences.getString(mSwapIntervalKey, null) == null)
            sharedPreferences.edit().putString(mSwapIntervalKey, entryValues.get(0)).apply();
        updateSwapIntervalSummary(sharedPreferences.getString(mSwapIntervalKey, null));
    }
}
#method_after
@Override
public void onCreatePreferences(Bundle bundle, String s) {
    mSwapIntervalKey = getResources().getString(R.string.swap_interval_key);
    addPreferencesFromResource(R.xml.preferences);
    PreferenceScreen preferenceScreen = getPreferenceScreen();
    for (int i = 0; i < preferenceScreen.getPreferenceCount(); ++i) {
        Preference preference = preferenceScreen.getPreference(i);
        final String key = preference.getKey();
        if (key != null && key.equals(mSwapIntervalKey)) {
            mSwapIntervalPreference = (ListPreference) preference;
        }
    }
    // fill the swap interval list based on the screen refresh rate
    float refreshRate = getActivity().getWindowManager().getDefaultDisplay().getRefreshRate();
    int numEntries = (int) (refreshRate / 20 + 1);
    String[] entries = new String[numEntries];
    String[] entryValues = new String[numEntries];
    for (int interval = 0; interval < numEntries - 1; interval++) {
        float fps = refreshRate / (interval + 1);
        float ms = 1000 / fps;
        entries[interval] = String.format(Locale.US, "%.2fms (%.0ffps)", ms, fps);
        entryValues[interval] = Float.toString(ms);
    }
    entries[numEntries - 1] = String.format(Locale.US, "No pacing");
    entryValues[numEntries - 1] = Float.toString(100);
    mSwapIntervalPreference.setEntries(entries);
    mSwapIntervalPreference.setEntryValues(entryValues);
    mSwapIntervalPreference.setDefaultValue(entries[0]);
    Context context = getContext();
    if (context != null) {
        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
        sharedPreferences.registerOnSharedPreferenceChangeListener(this);
        // set default if it doesn't exist
        if (sharedPreferences.getString(mSwapIntervalKey, null) == null)
            sharedPreferences.edit().putString(mSwapIntervalKey, entryValues[0]).apply();
        updateSwapIntervalSummary(sharedPreferences.getString(mSwapIntervalKey, null));
    }
}
#end_block

#method_before
@NonNull
public LibraryParams build() {
    return new LibraryParams(mBundle, mRecent, mOffline, mSuggested);
}
#method_after
@Override
@NonNull
public MediaLibrarySession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {
        };
    }
    return new MediaLibrarySession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
public long getCurrentPosition() {
    long position = mPlayer.getCurrentPosition();
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem != null) {
        position += mediaItem.getStartPosition();
    }
    return position;
}
#method_after
public long getCurrentPosition() {
    Preconditions.checkState(getState() != MediaPlayer2.PLAYER_STATE_IDLE);
    long position = mPlayer.getCurrentPosition();
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem != null) {
        position += mediaItem.getStartPosition();
    }
    return position;
}
#end_block

#method_before
public long getBufferedPosition() {
    long position = mPlayer.getBufferedPosition();
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem != null) {
        position += mediaItem.getStartPosition();
    }
    return position;
}
#method_after
public long getBufferedPosition() {
    Preconditions.checkState(getState() != MediaPlayer2.PLAYER_STATE_IDLE);
    long position = mPlayer.getBufferedPosition();
    MediaItem mediaItem = mMediaItemQueue.getCurrentMediaItem();
    if (mediaItem != null) {
        position += mediaItem.getStartPosition();
    }
    return position;
}
#end_block

#method_before
public void setPlaybackParams(PlaybackParams playbackParams2) {
    // TODO(b/80232248): Decide how to handle fallback modes, which ExoPlayer doesn't support.
    mPlaybackParams = playbackParams2;
    mPlayer.setPlaybackParameters(ExoPlayerUtils.getPlaybackParameters(mPlaybackParams));
    mListener.onMediaTimeDiscontinuity(getCurrentMediaItem(), getTimestamp());
}
#method_after
public void setPlaybackParams(PlaybackParams playbackParams2) {
    // TODO(b/80232248): Decide how to handle fallback modes, which ExoPlayer doesn't support.
    mPlaybackParams = playbackParams2;
    mPlayer.setPlaybackParameters(ExoPlayerUtils.getPlaybackParameters(mPlaybackParams));
    if (getState() == MediaPlayer2.PLAYER_STATE_PLAYING) {
        mListener.onMediaTimeDiscontinuity(getCurrentMediaItem(), getTimestamp());
    }
}
#end_block

#method_before
public MediaTimestamp getTimestamp() {
    boolean isPlaying = mPlayer.getPlaybackState() == Player.STATE_READY && mPlayer.getPlayWhenReady();
    float speed = isPlaying ? mPlaybackParams.getSpeed() : 0f;
    return new MediaTimestamp(C.msToUs(getCurrentPosition()), System.nanoTime(), speed);
}
#method_after
public MediaTimestamp getTimestamp() {
    long positionUs = mPlayer.getPlaybackState() == Player.STATE_IDLE ? 0L : C.msToUs(getCurrentPosition());
    float speed = mPlayer.getPlaybackState() == Player.STATE_READY && mPlayer.getPlayWhenReady() ? mPlaybackParams.getSpeed() : 0f;
    return new MediaTimestamp(positionUs, System.nanoTime(), speed);
}
#end_block

#method_before
public void reset() {
    if (mPlayer != null) {
        mPlayer.setPlayWhenReady(false);
        mListener.onMediaTimeDiscontinuity(getCurrentMediaItem(), getTimestamp());
        mPlayer.release();
        mMediaItemQueue.clear();
    }
    ComponentListener listener = new ComponentListener();
    mAudioSink = new DefaultAudioSink(AudioCapabilities.getCapabilities(mContext), new AudioProcessor[0]);
    TextRenderer textRenderer = new TextRenderer(listener);
    mTrackSelector = new TrackSelector(textRenderer);
    mPlayer = ExoPlayerFactory.newSimpleInstance(mContext, new RenderersFactory(mContext, mAudioSink, textRenderer), mTrackSelector.getPlayerTrackSelector(), new DefaultLoadControl(), /* drmSessionManager= */
    null, mBandwidthMeter, new AnalyticsCollector.Factory(), mLooper);
    mMediaItemQueue = new MediaItemQueue(mContext, mPlayer, mListener);
    mPlayer.addListener(listener);
    mPlayer.addVideoListener(listener);
    mPlayer.addMetadataOutput(listener);
    mVideoWidth = 0;
    mVideoHeight = 0;
    mPrepared = false;
    mNewlyPrepared = false;
    mRebuffering = false;
    mPendingSeek = false;
    mHasAudioAttributes = false;
    mAudioSessionId = C.AUDIO_SESSION_ID_UNSET;
    mAuxEffectId = AuxEffectInfo.NO_AUX_EFFECT_ID;
    mAuxEffectSendLevel = 0f;
    mPlaybackParams = new PlaybackParams.Builder().setSpeed(1f).setPitch(1f).setAudioFallbackMode(PlaybackParams.AUDIO_FALLBACK_MODE_DEFAULT).build();
}
#method_after
public void reset() {
    if (mPlayer != null) {
        mPlayer.setPlayWhenReady(false);
        if (getState() != MediaPlayer2.PLAYER_STATE_IDLE) {
            mListener.onMediaTimeDiscontinuity(getCurrentMediaItem(), getTimestamp());
        }
        mPlayer.release();
        mMediaItemQueue.clear();
    }
    ComponentListener listener = new ComponentListener();
    mAudioSink = new DefaultAudioSink(AudioCapabilities.getCapabilities(mContext), new AudioProcessor[0]);
    TextRenderer textRenderer = new TextRenderer(listener);
    mTrackSelector = new TrackSelector(textRenderer);
    mPlayer = ExoPlayerFactory.newSimpleInstance(mContext, new RenderersFactory(mContext, mAudioSink, textRenderer), mTrackSelector.getPlayerTrackSelector(), new DefaultLoadControl(), /* drmSessionManager= */
    null, mBandwidthMeter, new AnalyticsCollector.Factory(), mLooper);
    mMediaItemQueue = new MediaItemQueue(mContext, mPlayer, mListener);
    mPlayer.addListener(listener);
    mPlayer.addVideoListener(listener);
    mPlayer.addMetadataOutput(listener);
    mVideoWidth = 0;
    mVideoHeight = 0;
    mPrepared = false;
    mNewlyPrepared = false;
    mRebuffering = false;
    mPendingSeek = false;
    mHasAudioAttributes = false;
    mAudioSessionId = C.AUDIO_SESSION_ID_UNSET;
    mAuxEffectId = AuxEffectInfo.NO_AUX_EFFECT_ID;
    mAuxEffectSendLevel = 0f;
    mPlaybackParams = new PlaybackParams.Builder().setSpeed(1f).setPitch(1f).setAudioFallbackMode(PlaybackParams.AUDIO_FALLBACK_MODE_DEFAULT).build();
}
#end_block

#method_before
public void close() {
    if (mPlayer != null) {
        mPlayer.release();
        mPlayer = null;
        mMediaItemQueue.clear();
    }
}
#method_after
public void close() {
    if (mPlayer != null) {
        mPlayer.release();
        mPlayer = null;
        mMediaItemQueue.clear();
        mHasAudioAttributes = false;
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void handleVideoSizeChanged(int width, int height) {
    mVideoWidth = width;
    mVideoHeight = height;
    mListener.onVideoSizeChanged(mMediaItemQueue.getCurrentMediaItem(), width, height);
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void handleVideoSizeChanged(int width, int height, float pixelWidthHeightRatio) {
    if (pixelWidthHeightRatio != 1f) {
        mVideoWidth = (int) (pixelWidthHeightRatio * width);
    } else {
        mVideoWidth = width;
    }
    mVideoHeight = height;
    mListener.onVideoSizeChanged(mMediaItemQueue.getCurrentMediaItem(), width, height);
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void handlePlayerError(ExoPlaybackException exception) {
    mListener.onError(getCurrentMediaItem(), ExoPlayerUtils.getError(exception));
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void handlePlayerError(ExoPlaybackException exception) {
    mListener.onMediaTimeDiscontinuity(getCurrentMediaItem(), getTimestamp());
    mListener.onError(getCurrentMediaItem(), ExoPlayerUtils.getError(exception));
}
#end_block

#method_before
// VideoListener implementation.
@Override
public void onVideoSizeChanged(final int width, final int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
    handleVideoSizeChanged(width, height);
}
#method_after
// VideoListener implementation.
@Override
public void onVideoSizeChanged(final int width, final int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
    handleVideoSizeChanged(width, height, pixelWidthHeightRatio);
}
#end_block

#method_before
@Test
public void testCurrentMediaItemChange() throws Exception {
    prepareLooper();
    String displayTitle = "displayTitle";
    MediaMetadata metadata = new MediaMetadata.Builder().putText(MediaMetadata.METADATA_KEY_DISPLAY_TITLE, displayTitle).build();
    MediaItem currentMediaItem = new FileMediaItem.Builder(ParcelFileDescriptor.adoptFd(-1)).setMetadata(metadata).build();
    List<MediaItem> playlist = MediaTestUtils.createFileMediaItems(5);
    final int testItemIndex = 3;
    playlist.set(testItemIndex, currentMediaItem);
    mSession.getMockPlayer().setPlaylistWithDummyItem(playlist);
    final MediaControllerCallback controllerCallback = new MediaControllerCallback();
    controllerCallback.reset(1);
    mControllerCompat.registerCallback(controllerCallback, sHandler);
    mSession.getMockPlayer().setCurrentMediaItem(testItemIndex);
    mSession.getMockPlayer().notifyCurrentMediaItemChanged(testItemIndex);
    assertTrue(controllerCallback.await(MediaSessionTestBase.TIMEOUT_MS));
    assertTrue(controllerCallback.mOnMetadataChangedCalled);
    assertEquals(displayTitle, controllerCallback.mMediaMetadata.getString(MediaMetadata.METADATA_KEY_DISPLAY_TITLE));
}
#method_after
@Test
public void testCurrentMediaItemChange() throws Exception {
    prepareLooper();
    String displayTitle = "displayTitle";
    MediaMetadata metadata = new MediaMetadata.Builder().putText(MediaMetadata.METADATA_KEY_DISPLAY_TITLE, displayTitle).build();
    MediaItem currentMediaItem = new FileMediaItem.Builder(ParcelFileDescriptor.adoptFd(-1)).setMetadata(metadata).build();
    List<MediaItem> playlist = MediaTestUtils.createFileMediaItems(5);
    final int testItemIndex = 3;
    playlist.set(testItemIndex, currentMediaItem);
    mSession.getMockPlayer().setPlaylistWithDummyItem(playlist);
    final MediaControllerCallback controllerCallback = new MediaControllerCallback();
    controllerCallback.reset(1);
    mControllerCompat.registerCallback(controllerCallback, sHandler);
    mSession.getMockPlayer().setCurrentMediaItem(testItemIndex);
    mSession.getMockPlayer().notifyCurrentMediaItemChanged(testItemIndex);
    assertTrue(controllerCallback.await(MediaSessionTestBase.TIMEOUT_MS));
    assertTrue(controllerCallback.mOnMetadataChangedCalled);
    assertEquals(displayTitle, controllerCallback.mMediaMetadata.getString(MediaMetadataCompat.METADATA_KEY_DISPLAY_TITLE));
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public void removeParcelFileDescriptorClient(Object client) {
    synchronized (mClientMap) {
        if (mClientMap.remove(client) && mClientMap.isEmpty() && !mClosed) {
            try {
                mPFD.close();
            } catch (IOException e) {
                Log.e(TAG, "Failed to close the ParcelFileDescriptor " + mPFD, e);
            } finally {
                mClosed = true;
            }
        }
    }
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void removeParcelFileDescriptorClient(Object client) {
    synchronized (mClientMap) {
        if (mClientMap.remove(client) && mClientMap.isEmpty() && !mClosed) {
            try {
                if (mPFD != null) {
                    mPFD.close();
                }
            } catch (IOException e) {
                Log.e(TAG, "Failed to close the ParcelFileDescriptor " + mPFD, e);
            } finally {
                mClosed = true;
            }
        }
    }
}
#end_block

#method_before
@VisibleForTesting
boolean isClosed() {
    synchronized (mClientMap) {
        return mClosed;
    }
}
#method_after
boolean isClosed() {
    synchronized (mClientMap) {
        return mClosed;
    }
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public void close() throws IOException {
    synchronized (mClientMap) {
        mPFD.close();
        mClosed = true;
    }
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void close() throws IOException {
    synchronized (mClientMap) {
        if (mPFD != null) {
            mPFD.close();
        }
        mClosed = true;
    }
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetDuration() throws Exception {
    if (!checkLoadResource(R.raw.testvideo)) {
        return;
    }
    final int expectedDuration = 11047;
    final int tolerance = 70;
    final Monitor prepareCompleted = new Monitor();
    MediaPlayer2.EventCallback callback = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PREPARE) {
                prepareCompleted.signal();
            }
            super.onCallCompleted(mp, item, what, status);
        }
    };
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    mPlayer.setEventCallback(mExecutor, callback);
    assertEquals(MediaPlayer2.PLAYER_STATE_IDLE, mPlayer.getState());
    try {
        assertTrue(mPlayer.getDuration() <= 0);
    } catch (IllegalStateException e) {
    // may throw exception
    }
    mPlayer.prepare();
    assertTrue(prepareCompleted.waitForSignal());
    assertEquals(MediaPlayer2.PLAYER_STATE_PREPARED, mPlayer.getState());
    assertEquals(expectedDuration, mPlayer.getDuration(), tolerance);
}
#method_after
// Temporarily disabled for being flaky, bug b/121070831 filed to keep track
// @Test
// @SmallTest
public void testGetDuration() throws Exception {
    if (!checkLoadResource(R.raw.testvideo)) {
        return;
    }
    final int expectedDuration = 11047;
    final int tolerance = 70;
    final Monitor prepareCompleted = new Monitor();
    MediaPlayer2.EventCallback callback = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PREPARE) {
                prepareCompleted.signal();
            }
            super.onCallCompleted(mp, item, what, status);
        }
    };
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    mPlayer.setEventCallback(mExecutor, callback);
    assertEquals(MediaPlayer2.PLAYER_STATE_IDLE, mPlayer.getState());
    try {
        assertTrue(mPlayer.getDuration() <= 0);
    } catch (IllegalStateException e) {
    // may throw exception
    }
    mPlayer.prepare();
    assertTrue(prepareCompleted.waitForSignal());
    assertEquals(MediaPlayer2.PLAYER_STATE_PREPARED, mPlayer.getState());
    assertEquals(expectedDuration, mPlayer.getDuration(), tolerance);
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testChangeSubtitleTrack() throws Throwable {
    if (!checkLoadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        // skip;
        return;
    }
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                mOnPlayCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer2 mp, MediaItem item, SubtitleData data) {
            if (data != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Waits until at least two captions are fired. Timeout is 2.5 sec.
    selectSubtitleTrack(0);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    mOnSubtitleDataCalled.reset();
    selectSubtitleTrack(1);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testChangeSubtitleTrack() throws Throwable {
    if (!checkLoadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        // skip;
        return;
    }
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                mOnPlayCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer2 mp, MediaItem item, SubtitleData data) {
            if (data != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Waits until at least two captions are fired. Timeout is 2.5 sec.
    selectSubtitleTrack(0);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    assertEquals(mSubtitleTrackIndex.get(0).intValue(), mPlayer.getSelectedTrack(MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE));
    mOnSubtitleDataCalled.reset();
    selectSubtitleTrack(1);
    assertTrue(mOnSubtitleDataCalled.waitForCountedSignals(2, 2500) >= 2);
    assertEquals(mSubtitleTrackIndex.get(1).intValue(), mPlayer.getSelectedTrack(MediaPlayer2.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE));
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testResumeAtEnd() throws Throwable {
    int testsRun = testResumeAtEnd(R.raw.loudsoftmp3) + testResumeAtEnd(R.raw.loudsoftwav) + testResumeAtEnd(R.raw.loudsoftogg) + testResumeAtEnd(R.raw.loudsoftitunes) + testResumeAtEnd(R.raw.loudsoftfaac) + testResumeAtEnd(R.raw.loudsoftaac);
}
#method_after
/*
     *  This test assumes the resources being tested are between 8 and 14 seconds long
     *  The ones being used here are 10 seconds long.
     */
// This test is disabled due to a framework issue. b/79754424
// @Test
// @LargeTest
public void testResumeAtEnd() throws Throwable {
    int testsRun = testResumeAtEnd(R.raw.loudsoftmp3) + testResumeAtEnd(R.raw.loudsoftwav) + testResumeAtEnd(R.raw.loudsoftogg) + testResumeAtEnd(R.raw.loudsoftitunes) + testResumeAtEnd(R.raw.loudsoftfaac) + testResumeAtEnd(R.raw.loudsoftaac);
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback source = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    final Monitor labelReached = new Monitor();
    final ArrayList<Pair<Integer, Integer>> commandsCompleted = new ArrayList<>();
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem item, int what, int status) {
            commandsCompleted.add(new Pair<>(what, status));
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem item, int what, int extra) {
            mOnErrorCalled.signal();
        }

        @Override
        public void onCommandLabelReached(MediaPlayer2 mp, @NonNull Object label) {
            labelReached.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mOnErrorCalled.reset();
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    mPlayer.seekTo(3000);
    mPlayer.seekTo(2000);
    mPlayer.seekTo(1000);
    mPlayer.notifyWhenCommandLabelReached(new Object());
    readAllowed.signal();
    labelReached.waitForSignal();
    assertFalse(mOnErrorCalled.isSignalled());
    assertTrue(mOnPrepareCalled.isSignalled());
    assertEquals(5, commandsCompleted.size());
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(0));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_PREPARE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(1));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(2));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(3));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(4));
}
#method_after
// Temporarily disabled for being flaky: b/121254745
// @Test
// @SmallTest
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback source = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    final Monitor labelReached = new Monitor();
    final ArrayList<Pair<Integer, Integer>> commandsCompleted = new ArrayList<>();
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem item, int what, int status) {
            commandsCompleted.add(new Pair<>(what, status));
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem item, int what, int extra) {
            mOnErrorCalled.signal();
        }

        @Override
        public void onCommandLabelReached(MediaPlayer2 mp, @NonNull Object label) {
            labelReached.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mOnErrorCalled.reset();
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    mPlayer.seekTo(3000);
    mPlayer.seekTo(2000);
    mPlayer.seekTo(1000);
    mPlayer.notifyWhenCommandLabelReached(new Object());
    readAllowed.signal();
    labelReached.waitForSignal();
    assertFalse(mOnErrorCalled.isSignalled());
    assertTrue(mOnPrepareCalled.isSignalled());
    assertEquals(5, commandsCompleted.size());
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(0));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_PREPARE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(1));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(2));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(3));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(4));
}
#end_block

#method_before
@Parameterized.Parameters(name = "{index}: operation={0} state={1} valid={2}")
public static Collection<Object[]> data() {
    return Arrays.asList(new Object[][] { { sCloseOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sCloseOperation, PLAYER_STATE_IDLE, true }, { sCloseOperation, PLAYER_STATE_PREPARED, true }, { sCloseOperation, PLAYER_STATE_PAUSED, true }, { sCloseOperation, PLAYER_STATE_PLAYING, true }, { sCloseOperation, PLAYER_STATE_ERROR, true }, { sPlayOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sPlayOperation, PLAYER_STATE_IDLE, false }, { sPlayOperation, PLAYER_STATE_PREPARED, true }, { sPlayOperation, PLAYER_STATE_PAUSED, true }, { sPlayOperation, PLAYER_STATE_PLAYING, true }, { sPlayOperation, PLAYER_STATE_ERROR, false }, { sPrepareOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sPrepareOperation, PLAYER_STATE_IDLE, true }, { sPrepareOperation, PLAYER_STATE_PREPARED, false }, { sPrepareOperation, PLAYER_STATE_PAUSED, false }, { sPrepareOperation, PLAYER_STATE_PLAYING, false }, { sPrepareOperation, PLAYER_STATE_ERROR, false }, { sPauseOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sPauseOperation, PLAYER_STATE_IDLE, false }, { sPauseOperation, PLAYER_STATE_PREPARED, true }, { sPauseOperation, PLAYER_STATE_PAUSED, true }, { sPauseOperation, PLAYER_STATE_PLAYING, true }, { sPauseOperation, PLAYER_STATE_ERROR, false }, { sSkipToNextOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSkipToNextOperation, PLAYER_STATE_IDLE, true }, { sSkipToNextOperation, PLAYER_STATE_PREPARED, true }, { sSkipToNextOperation, PLAYER_STATE_PAUSED, true }, { sSkipToNextOperation, PLAYER_STATE_PLAYING, true }, { sSkipToNextOperation, PLAYER_STATE_ERROR, false }, { sSeekToOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSeekToOperation, PLAYER_STATE_IDLE, false }, { sSeekToOperation, PLAYER_STATE_PREPARED, true }, { sSeekToOperation, PLAYER_STATE_PAUSED, true }, { sSeekToOperation, PLAYER_STATE_PLAYING, true }, { sSeekToOperation, PLAYER_STATE_ERROR, false }, { sGetCurrentPositionOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetCurrentPositionOperation, PLAYER_STATE_IDLE, false }, { sGetCurrentPositionOperation, PLAYER_STATE_PREPARED, true }, { sGetCurrentPositionOperation, PLAYER_STATE_PAUSED, true }, { sGetCurrentPositionOperation, PLAYER_STATE_PLAYING, true }, { sGetCurrentPositionOperation, PLAYER_STATE_ERROR, false }, { sGetDurationOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetDurationOperation, PLAYER_STATE_IDLE, false }, { sGetDurationOperation, PLAYER_STATE_PREPARED, true }, { sGetDurationOperation, PLAYER_STATE_PAUSED, true }, { sGetDurationOperation, PLAYER_STATE_PLAYING, true }, { sGetDurationOperation, PLAYER_STATE_ERROR, false }, { sGetBufferedPositionOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetBufferedPositionOperation, PLAYER_STATE_IDLE, false }, { sGetBufferedPositionOperation, PLAYER_STATE_PREPARED, true }, { sGetBufferedPositionOperation, PLAYER_STATE_PAUSED, true }, { sGetBufferedPositionOperation, PLAYER_STATE_PLAYING, true }, { sGetBufferedPositionOperation, PLAYER_STATE_ERROR, false }, { sGetStateOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetStateOperation, PLAYER_STATE_IDLE, true }, { sGetStateOperation, PLAYER_STATE_PREPARED, true }, { sGetStateOperation, PLAYER_STATE_PAUSED, true }, { sGetStateOperation, PLAYER_STATE_PLAYING, true }, { sGetStateOperation, PLAYER_STATE_ERROR, true }, { sSetAudioAttributesOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetAudioAttributesOperation, PLAYER_STATE_IDLE, true }, { sSetAudioAttributesOperation, PLAYER_STATE_PREPARED, true }, { sSetAudioAttributesOperation, PLAYER_STATE_PAUSED, true }, { sSetAudioAttributesOperation, PLAYER_STATE_PLAYING, true }, { sSetAudioAttributesOperation, PLAYER_STATE_ERROR, false }, { sSetDataSourceOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetDataSourceOperation, PLAYER_STATE_IDLE, false }, { sSetDataSourceOperation, PLAYER_STATE_PREPARED, false }, { sSetDataSourceOperation, PLAYER_STATE_PAUSED, false }, { sSetDataSourceOperation, PLAYER_STATE_PLAYING, false }, { sSetDataSourceOperation, PLAYER_STATE_ERROR, false }, { sSetNextDataSourceOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSetNextDataSourceOperation, PLAYER_STATE_IDLE, true }, { sSetNextDataSourceOperation, PLAYER_STATE_PREPARED, true }, { sSetNextDataSourceOperation, PLAYER_STATE_PAUSED, true }, { sSetNextDataSourceOperation, PLAYER_STATE_PLAYING, true }, { sSetNextDataSourceOperation, PLAYER_STATE_ERROR, false }, { sSetNextDataSourcesOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSetNextDataSourcesOperation, PLAYER_STATE_IDLE, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_PREPARED, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_PAUSED, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_PLAYING, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_ERROR, false }, { sLoopCurrentOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sLoopCurrentOperation, PLAYER_STATE_IDLE, true }, { sLoopCurrentOperation, PLAYER_STATE_PREPARED, true }, { sLoopCurrentOperation, PLAYER_STATE_PAUSED, true }, { sLoopCurrentOperation, PLAYER_STATE_PLAYING, true }, { sLoopCurrentOperation, PLAYER_STATE_ERROR, false }, { sSetPlayerVolumeOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_IDLE, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_PREPARED, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_PAUSED, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_PLAYING, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_ERROR, false }, { sGetPlayerVolumeOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_IDLE, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_PREPARED, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_PAUSED, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_PLAYING, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_ERROR, false }, { sGetMaxPlayerVolumeOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_IDLE, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_PREPARED, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_PAUSED, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_PLAYING, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_ERROR, false }, { sNotifyWhenCommandLabelReachedOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_IDLE, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_PREPARED, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_PAUSED, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_PLAYING, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_ERROR, true }, { sSetSurfaceOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetSurfaceOperation, PLAYER_STATE_IDLE, true }, { sSetSurfaceOperation, PLAYER_STATE_PREPARED, true }, { sSetSurfaceOperation, PLAYER_STATE_PAUSED, true }, { sSetSurfaceOperation, PLAYER_STATE_PLAYING, true }, { sSetSurfaceOperation, PLAYER_STATE_ERROR, false }, { sClearPendingCommandsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sClearPendingCommandsOperation, PLAYER_STATE_IDLE, true }, { sClearPendingCommandsOperation, PLAYER_STATE_PREPARED, true }, { sClearPendingCommandsOperation, PLAYER_STATE_PAUSED, true }, { sClearPendingCommandsOperation, PLAYER_STATE_PLAYING, true }, { sClearPendingCommandsOperation, PLAYER_STATE_ERROR, true }, { sGetVideoWidthOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetVideoWidthOperation, PLAYER_STATE_IDLE, true }, { sGetVideoWidthOperation, PLAYER_STATE_PREPARED, true }, { sGetVideoWidthOperation, PLAYER_STATE_PAUSED, true }, { sGetVideoWidthOperation, PLAYER_STATE_PLAYING, true }, { sGetVideoWidthOperation, PLAYER_STATE_ERROR, false }, { sGetVideoHeightOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetVideoHeightOperation, PLAYER_STATE_IDLE, true }, { sGetVideoHeightOperation, PLAYER_STATE_PREPARED, true }, { sGetVideoHeightOperation, PLAYER_STATE_PAUSED, true }, { sGetVideoHeightOperation, PLAYER_STATE_PLAYING, true }, { sGetVideoHeightOperation, PLAYER_STATE_ERROR, false }, { sGetMetricsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetMetricsOperation, PLAYER_STATE_IDLE, true }, { sGetMetricsOperation, PLAYER_STATE_PREPARED, true }, { sGetMetricsOperation, PLAYER_STATE_PAUSED, true }, { sGetMetricsOperation, PLAYER_STATE_PLAYING, true }, { sGetMetricsOperation, PLAYER_STATE_ERROR, false }, { sSetPlaybackParamsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_IDLE, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_PREPARED, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_PAUSED, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_PLAYING, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_ERROR, false }, { sGetPlaybackParamsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetPlaybackParamsOperation, PLAYER_STATE_IDLE, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_PREPARED, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_PAUSED, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_PLAYING, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_ERROR, false }, { sGetTimestampOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetTimestampOperation, PLAYER_STATE_IDLE, true }, { sGetTimestampOperation, PLAYER_STATE_PREPARED, true }, { sGetTimestampOperation, PLAYER_STATE_PAUSED, true }, { sGetTimestampOperation, PLAYER_STATE_PLAYING, true }, { sGetTimestampOperation, PLAYER_STATE_ERROR, false }, { sResetOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sResetOperation, PLAYER_STATE_IDLE, true }, { sResetOperation, PLAYER_STATE_PREPARED, true }, { sResetOperation, PLAYER_STATE_PAUSED, true }, { sResetOperation, PLAYER_STATE_PLAYING, true }, { sResetOperation, PLAYER_STATE_ERROR, true }, { sSetAudioSessionIdOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_IDLE, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_PREPARED, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_PAUSED, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_PLAYING, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_ERROR, false }, { sGetAudioSessionIdOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_IDLE, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_PREPARED, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_PAUSED, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_PLAYING, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_ERROR, false }, { sAttachAuxEffectOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sAttachAuxEffectOperation, PLAYER_STATE_IDLE, true }, { sAttachAuxEffectOperation, PLAYER_STATE_PREPARED, true }, { sAttachAuxEffectOperation, PLAYER_STATE_PAUSED, true }, { sAttachAuxEffectOperation, PLAYER_STATE_PLAYING, true }, { sAttachAuxEffectOperation, PLAYER_STATE_ERROR, false }, { sSetAuxEffectSendLevelOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_IDLE, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_PREPARED, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_PAUSED, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_PLAYING, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_ERROR, false }, { sGetTrackInfoOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetTrackInfoOperation, PLAYER_STATE_IDLE, true }, { sGetTrackInfoOperation, PLAYER_STATE_PREPARED, true }, { sGetTrackInfoOperation, PLAYER_STATE_PAUSED, true }, { sGetTrackInfoOperation, PLAYER_STATE_PLAYING, true }, { sGetTrackInfoOperation, PLAYER_STATE_ERROR, false }, { sGetSelectedTrackOperation, PLAYER_STATE_IDLE, true }, { sGetSelectedTrackOperation, PLAYER_STATE_IDLE, true }, { sGetSelectedTrackOperation, PLAYER_STATE_PREPARED, true }, { sGetSelectedTrackOperation, PLAYER_STATE_PAUSED, true }, { sGetSelectedTrackOperation, PLAYER_STATE_PLAYING, true }, { sGetSelectedTrackOperation, PLAYER_STATE_ERROR, false }, { sSelectTrackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSelectTrackOperation, PLAYER_STATE_IDLE, false }, { sSelectTrackOperation, PLAYER_STATE_PREPARED, true }, { sSelectTrackOperation, PLAYER_STATE_PAUSED, true }, { sSelectTrackOperation, PLAYER_STATE_PLAYING, true }, { sSelectTrackOperation, PLAYER_STATE_ERROR, false }, { sDeselectTrackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sDeselectTrackOperation, PLAYER_STATE_IDLE, false }, { sDeselectTrackOperation, PLAYER_STATE_PREPARED, true }, { sDeselectTrackOperation, PLAYER_STATE_PAUSED, true }, { sDeselectTrackOperation, PLAYER_STATE_PLAYING, true }, { sDeselectTrackOperation, PLAYER_STATE_ERROR, false }, { sSetEventCallbackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetEventCallbackOperation, PLAYER_STATE_IDLE, true }, { sSetEventCallbackOperation, PLAYER_STATE_PREPARED, true }, { sSetEventCallbackOperation, PLAYER_STATE_PAUSED, true }, { sSetEventCallbackOperation, PLAYER_STATE_PLAYING, true }, { sSetEventCallbackOperation, PLAYER_STATE_ERROR, false }, { sClearEventCallbackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sClearEventCallbackOperation, PLAYER_STATE_IDLE, true }, { sClearEventCallbackOperation, PLAYER_STATE_PREPARED, true }, { sClearEventCallbackOperation, PLAYER_STATE_PAUSED, true }, { sClearEventCallbackOperation, PLAYER_STATE_PLAYING, true }, { sClearEventCallbackOperation, PLAYER_STATE_ERROR, false } });
}
#method_after
@Parameterized.Parameters(name = "{index}: operation={0} state={1} valid={2}")
public static Collection<Object[]> data() {
    return Arrays.asList(new Object[][] { { sCloseOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sCloseOperation, PLAYER_STATE_IDLE, true }, { sCloseOperation, PLAYER_STATE_PREPARED, true }, { sCloseOperation, PLAYER_STATE_PAUSED, true }, { sCloseOperation, PLAYER_STATE_PLAYING, true }, { sCloseOperation, PLAYER_STATE_ERROR, true }, { sPlayOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sPlayOperation, PLAYER_STATE_IDLE, false }, { sPlayOperation, PLAYER_STATE_PREPARED, true }, { sPlayOperation, PLAYER_STATE_PAUSED, true }, { sPlayOperation, PLAYER_STATE_PLAYING, true }, { sPlayOperation, PLAYER_STATE_ERROR, false }, { sPrepareOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sPrepareOperation, PLAYER_STATE_IDLE, true }, { sPrepareOperation, PLAYER_STATE_PREPARED, false }, { sPrepareOperation, PLAYER_STATE_PAUSED, false }, { sPrepareOperation, PLAYER_STATE_PLAYING, false }, { sPrepareOperation, PLAYER_STATE_ERROR, false }, { sPauseOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sPauseOperation, PLAYER_STATE_IDLE, false }, { sPauseOperation, PLAYER_STATE_PREPARED, true }, { sPauseOperation, PLAYER_STATE_PAUSED, true }, { sPauseOperation, PLAYER_STATE_PLAYING, true }, { sPauseOperation, PLAYER_STATE_ERROR, false }, { sSkipToNextOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSkipToNextOperation, PLAYER_STATE_IDLE, true }, { sSkipToNextOperation, PLAYER_STATE_PREPARED, true }, { sSkipToNextOperation, PLAYER_STATE_PAUSED, true }, { sSkipToNextOperation, PLAYER_STATE_PLAYING, true }, { sSkipToNextOperation, PLAYER_STATE_ERROR, false }, { sSeekToOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSeekToOperation, PLAYER_STATE_IDLE, false }, { sSeekToOperation, PLAYER_STATE_PREPARED, true }, { sSeekToOperation, PLAYER_STATE_PAUSED, true }, { sSeekToOperation, PLAYER_STATE_PLAYING, true }, { sSeekToOperation, PLAYER_STATE_ERROR, false }, { sGetCurrentPositionOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetCurrentPositionOperation, PLAYER_STATE_IDLE, false }, { sGetCurrentPositionOperation, PLAYER_STATE_PREPARED, true }, { sGetCurrentPositionOperation, PLAYER_STATE_PAUSED, true }, { sGetCurrentPositionOperation, PLAYER_STATE_PLAYING, true }, { sGetCurrentPositionOperation, PLAYER_STATE_ERROR, false }, { sGetDurationOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetDurationOperation, PLAYER_STATE_IDLE, false }, { sGetDurationOperation, PLAYER_STATE_PREPARED, true }, { sGetDurationOperation, PLAYER_STATE_PAUSED, true }, { sGetDurationOperation, PLAYER_STATE_PLAYING, true }, { sGetDurationOperation, PLAYER_STATE_ERROR, false }, { sGetBufferedPositionOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetBufferedPositionOperation, PLAYER_STATE_IDLE, false }, { sGetBufferedPositionOperation, PLAYER_STATE_PREPARED, true }, { sGetBufferedPositionOperation, PLAYER_STATE_PAUSED, true }, { sGetBufferedPositionOperation, PLAYER_STATE_PLAYING, true }, { sGetBufferedPositionOperation, PLAYER_STATE_ERROR, false }, { sGetStateOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetStateOperation, PLAYER_STATE_IDLE, true }, { sGetStateOperation, PLAYER_STATE_PREPARED, true }, { sGetStateOperation, PLAYER_STATE_PAUSED, true }, { sGetStateOperation, PLAYER_STATE_PLAYING, true }, { sGetStateOperation, PLAYER_STATE_ERROR, true }, { sSetAudioAttributesOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetAudioAttributesOperation, PLAYER_STATE_IDLE, true }, { sSetAudioAttributesOperation, PLAYER_STATE_PREPARED, true }, { sSetAudioAttributesOperation, PLAYER_STATE_PAUSED, true }, { sSetAudioAttributesOperation, PLAYER_STATE_PLAYING, true }, { sSetAudioAttributesOperation, PLAYER_STATE_ERROR, false }, { sSetDataSourceOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetDataSourceOperation, PLAYER_STATE_IDLE, false }, { sSetDataSourceOperation, PLAYER_STATE_PREPARED, false }, { sSetDataSourceOperation, PLAYER_STATE_PAUSED, false }, { sSetDataSourceOperation, PLAYER_STATE_PLAYING, false }, { sSetDataSourceOperation, PLAYER_STATE_ERROR, false }, { sSetNextDataSourceOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSetNextDataSourceOperation, PLAYER_STATE_IDLE, true }, { sSetNextDataSourceOperation, PLAYER_STATE_PREPARED, true }, { sSetNextDataSourceOperation, PLAYER_STATE_PAUSED, true }, { sSetNextDataSourceOperation, PLAYER_STATE_PLAYING, true }, { sSetNextDataSourceOperation, PLAYER_STATE_ERROR, false }, { sSetNextDataSourcesOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSetNextDataSourcesOperation, PLAYER_STATE_IDLE, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_PREPARED, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_PAUSED, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_PLAYING, true }, { sSetNextDataSourcesOperation, PLAYER_STATE_ERROR, false }, { sLoopCurrentOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sLoopCurrentOperation, PLAYER_STATE_IDLE, true }, { sLoopCurrentOperation, PLAYER_STATE_PREPARED, true }, { sLoopCurrentOperation, PLAYER_STATE_PAUSED, true }, { sLoopCurrentOperation, PLAYER_STATE_PLAYING, true }, { sLoopCurrentOperation, PLAYER_STATE_ERROR, false }, { sSetPlayerVolumeOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_IDLE, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_PREPARED, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_PAUSED, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_PLAYING, true }, { sSetPlayerVolumeOperation, PLAYER_STATE_ERROR, false }, { sGetPlayerVolumeOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_IDLE, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_PREPARED, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_PAUSED, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_PLAYING, true }, { sGetPlayerVolumeOperation, PLAYER_STATE_ERROR, false }, { sGetMaxPlayerVolumeOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_IDLE, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_PREPARED, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_PAUSED, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_PLAYING, true }, { sGetMaxPlayerVolumeOperation, PLAYER_STATE_ERROR, false }, { sNotifyWhenCommandLabelReachedOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_IDLE, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_PREPARED, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_PAUSED, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_PLAYING, true }, { sNotifyWhenCommandLabelReachedOperation, PLAYER_STATE_ERROR, true }, { sSetSurfaceOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetSurfaceOperation, PLAYER_STATE_IDLE, true }, { sSetSurfaceOperation, PLAYER_STATE_PREPARED, true }, { sSetSurfaceOperation, PLAYER_STATE_PAUSED, true }, { sSetSurfaceOperation, PLAYER_STATE_PLAYING, true }, { sSetSurfaceOperation, PLAYER_STATE_ERROR, false }, { sClearPendingCommandsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sClearPendingCommandsOperation, PLAYER_STATE_IDLE, true }, { sClearPendingCommandsOperation, PLAYER_STATE_PREPARED, true }, { sClearPendingCommandsOperation, PLAYER_STATE_PAUSED, true }, { sClearPendingCommandsOperation, PLAYER_STATE_PLAYING, true }, { sClearPendingCommandsOperation, PLAYER_STATE_ERROR, true }, { sGetVideoWidthOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetVideoWidthOperation, PLAYER_STATE_IDLE, true }, { sGetVideoWidthOperation, PLAYER_STATE_PREPARED, true }, { sGetVideoWidthOperation, PLAYER_STATE_PAUSED, true }, { sGetVideoWidthOperation, PLAYER_STATE_PLAYING, true }, { sGetVideoWidthOperation, PLAYER_STATE_ERROR, false }, { sGetVideoHeightOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetVideoHeightOperation, PLAYER_STATE_IDLE, true }, { sGetVideoHeightOperation, PLAYER_STATE_PREPARED, true }, { sGetVideoHeightOperation, PLAYER_STATE_PAUSED, true }, { sGetVideoHeightOperation, PLAYER_STATE_PLAYING, true }, { sGetVideoHeightOperation, PLAYER_STATE_ERROR, false }, { sGetMetricsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetMetricsOperation, PLAYER_STATE_IDLE, true }, { sGetMetricsOperation, PLAYER_STATE_PREPARED, true }, { sGetMetricsOperation, PLAYER_STATE_PAUSED, true }, { sGetMetricsOperation, PLAYER_STATE_PLAYING, true }, { sGetMetricsOperation, PLAYER_STATE_ERROR, false }, { sSetPlaybackParamsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_IDLE, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_PREPARED, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_PAUSED, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_PLAYING, true }, { sSetPlaybackParamsOperation, PLAYER_STATE_ERROR, false }, { sGetPlaybackParamsOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetPlaybackParamsOperation, PLAYER_STATE_IDLE, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_PREPARED, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_PAUSED, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_PLAYING, true }, { sGetPlaybackParamsOperation, PLAYER_STATE_ERROR, false }, { sGetTimestampOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetTimestampOperation, PLAYER_STATE_IDLE, false }, { sGetTimestampOperation, PLAYER_STATE_PREPARED, true }, { sGetTimestampOperation, PLAYER_STATE_PAUSED, true }, { sGetTimestampOperation, PLAYER_STATE_PLAYING, true }, { sGetTimestampOperation, PLAYER_STATE_ERROR, false }, { sResetOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sResetOperation, PLAYER_STATE_IDLE, true }, { sResetOperation, PLAYER_STATE_PREPARED, true }, { sResetOperation, PLAYER_STATE_PAUSED, true }, { sResetOperation, PLAYER_STATE_PLAYING, true }, { sResetOperation, PLAYER_STATE_ERROR, true }, { sSetAudioSessionIdOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_IDLE, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_PREPARED, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_PAUSED, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_PLAYING, true }, { sSetAudioSessionIdOperation, PLAYER_STATE_ERROR, false }, { sGetAudioSessionIdOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_IDLE, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_PREPARED, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_PAUSED, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_PLAYING, true }, { sGetAudioSessionIdOperation, PLAYER_STATE_ERROR, false }, { sAttachAuxEffectOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sAttachAuxEffectOperation, PLAYER_STATE_IDLE, true }, { sAttachAuxEffectOperation, PLAYER_STATE_PREPARED, true }, { sAttachAuxEffectOperation, PLAYER_STATE_PAUSED, true }, { sAttachAuxEffectOperation, PLAYER_STATE_PLAYING, true }, { sAttachAuxEffectOperation, PLAYER_STATE_ERROR, false }, { sSetAuxEffectSendLevelOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_IDLE, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_PREPARED, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_PAUSED, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_PLAYING, true }, { sSetAuxEffectSendLevelOperation, PLAYER_STATE_ERROR, false }, { sGetTrackInfoOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sGetTrackInfoOperation, PLAYER_STATE_IDLE, true }, { sGetTrackInfoOperation, PLAYER_STATE_PREPARED, true }, { sGetTrackInfoOperation, PLAYER_STATE_PAUSED, true }, { sGetTrackInfoOperation, PLAYER_STATE_PLAYING, true }, { sGetTrackInfoOperation, PLAYER_STATE_ERROR, false }, { sGetSelectedTrackOperation, PLAYER_STATE_IDLE, true }, { sGetSelectedTrackOperation, PLAYER_STATE_IDLE, true }, { sGetSelectedTrackOperation, PLAYER_STATE_PREPARED, true }, { sGetSelectedTrackOperation, PLAYER_STATE_PAUSED, true }, { sGetSelectedTrackOperation, PLAYER_STATE_PLAYING, true }, { sGetSelectedTrackOperation, PLAYER_STATE_ERROR, false }, { sSelectTrackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sSelectTrackOperation, PLAYER_STATE_IDLE, false }, { sSelectTrackOperation, PLAYER_STATE_PREPARED, true }, { sSelectTrackOperation, PLAYER_STATE_PAUSED, true }, { sSelectTrackOperation, PLAYER_STATE_PLAYING, true }, { sSelectTrackOperation, PLAYER_STATE_ERROR, false }, { sDeselectTrackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, false }, { sDeselectTrackOperation, PLAYER_STATE_IDLE, false }, { sDeselectTrackOperation, PLAYER_STATE_PREPARED, true }, { sDeselectTrackOperation, PLAYER_STATE_PAUSED, true }, { sDeselectTrackOperation, PLAYER_STATE_PLAYING, true }, { sDeselectTrackOperation, PLAYER_STATE_ERROR, false }, { sSetEventCallbackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sSetEventCallbackOperation, PLAYER_STATE_IDLE, true }, { sSetEventCallbackOperation, PLAYER_STATE_PREPARED, true }, { sSetEventCallbackOperation, PLAYER_STATE_PAUSED, true }, { sSetEventCallbackOperation, PLAYER_STATE_PLAYING, true }, { sSetEventCallbackOperation, PLAYER_STATE_ERROR, false }, { sClearEventCallbackOperation, MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE, true }, { sClearEventCallbackOperation, PLAYER_STATE_IDLE, true }, { sClearEventCallbackOperation, PLAYER_STATE_PREPARED, true }, { sClearEventCallbackOperation, PLAYER_STATE_PAUSED, true }, { sClearEventCallbackOperation, PLAYER_STATE_PLAYING, true }, { sClearEventCallbackOperation, PLAYER_STATE_ERROR, false } });
}
#end_block

#method_before
@Test
@MediumTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testPlayAudioOnce() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    final TestUtils.Monitor playing = new TestUtils.Monitor();
    mPlayer.registerPlayerCallback(mExecutor, new SessionPlayer.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer player, int playerState) {
            playing.signal();
        }
    });
    mPlayer.prepare();
    mPlayer.play();
    assertTrue(playing.waitForSignal(SLEEP_TIME));
}
#method_after
@Test
@MediumTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayAudioOnce() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    final TestUtils.Monitor playing = new TestUtils.Monitor();
    mPlayer.registerPlayerCallback(mExecutor, new SessionPlayer.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer player, int playerState) {
            playing.signal();
        }
    });
    mPlayer.prepare();
    mPlayer.play();
    assertTrue(playing.waitForSignal(SLEEP_TIME));
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    try (AssetFileDescriptor afd = mResources.openRawResourceFd(resid)) {
        mPlayer.setMediaItem(new FileMediaItem.Builder(ParcelFileDescriptor.dup(afd.getFileDescriptor()), afd.getStartOffset(), afd.getLength()).build());
    }
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    assertEquals(mp3Duration, mPlayer.getDuration(), tolerance);
    long pos = mPlayer.getCurrentPosition();
    assertTrue(pos >= 0);
    assertTrue(pos < mp3Duration - seekDuration);
    future = mPlayer.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertEquals(pos + seekDuration, mPlayer.getCurrentPosition(), tolerance);
    future = mPlayer.pause();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    try (AssetFileDescriptor afd = mResources.openRawResourceFd(resid)) {
        mPlayer.setMediaItem(new FileMediaItem.Builder(ParcelFileDescriptor.dup(afd.getFileDescriptor()), afd.getStartOffset(), afd.getLength()).build());
    }
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    assertEquals(mp3Duration, mPlayer.getDuration(), tolerance);
    long pos = mPlayer.getCurrentPosition();
    assertTrue(pos >= 0);
    assertTrue(pos < mp3Duration - seekDuration);
    future = mPlayer.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertEquals(pos + seekDuration, mPlayer.getCurrentPosition(), tolerance);
    future = mPlayer.pause();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertFalse(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    future = mPlayer.play();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // validate a few MediaMetrics.
    PersistableBundle metrics = mPlayer.getMetrics();
    if (metrics == null) {
        fail("MediaPlayer.getMetrics() returned null metrics");
    } else if (metrics.isEmpty()) {
        fail("MediaPlayer.getMetrics() returned empty metrics");
    } else {
        int size = metrics.size();
        Set<String> keys = metrics.keySet();
        if (keys == null) {
            fail("MediaMetricsSet returned no keys");
        } else if (keys.size() != size) {
            fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
        }
        // we played something; so one of these should be non-null
        String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
        String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
        if (vmime == null && amime == null) {
            fail("getMetrics() returned neither video nor audio mime value");
        }
        long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
        if (duration == -2) {
            fail("getMetrics() didn't return a duration");
        }
        long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
        if (playing == -2) {
            fail("getMetrics() didn't return a playing time");
        }
        if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
            fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
        }
    }
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    MediaItem item = mPlayer.getCurrentMediaItem();
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // validate a few MediaMetrics.
    PersistableBundle metrics = mPlayer.getMetrics();
    if (metrics == null) {
        fail("MediaPlayer.getMetrics() returned null metrics");
    } else if (metrics.isEmpty()) {
        fail("MediaPlayer.getMetrics() returned empty metrics");
    } else {
        int size = metrics.size();
        Set<String> keys = metrics.keySet();
        if (keys == null) {
            fail("MediaMetricsSet returned no keys");
        } else if (keys.size() != size) {
            fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
        }
        // we played something; so one of these should be non-null
        String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
        String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
        if (vmime == null && amime == null) {
            fail("getMetrics() returned neither video nor audio mime value");
        }
        long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
        if (duration == -2) {
            fail("getMetrics() didn't return a duration");
        }
        long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
        if (playing == -2) {
            fail("getMetrics() didn't return a playing time");
        }
        if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
            fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
        }
    }
    mPlayer.close();
    assertTrue(((FileMediaItem) item).isClosed());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetDuration() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int expectedDuration = 11047;
    final int tolerance = 70;
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getDuration());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    assertEquals(MediaPlayer.PLAYER_STATE_PAUSED, mPlayer.getPlayerState());
    assertEquals(expectedDuration, mPlayer.getDuration(), tolerance);
}
#method_after
// Temporarily disabled for being flaky, bug b/121078676 filed.
// @Test
// @SmallTest
public void testGetDuration() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int expectedDuration = 11047;
    final int tolerance = 70;
    mPlayer.setSurface(mActivity.getSurfaceHolder2().getSurface());
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getDuration());
    ListenableFuture<PlayerResult> future = mPlayer.prepare();
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    assertEquals(MediaPlayer.PLAYER_STATE_PAUSED, mPlayer.getPlayerState());
    assertEquals(expectedDuration, mPlayer.getDuration(), tolerance);
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testGetCurrentPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getCurrentPosition());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetCurrentPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getCurrentPosition());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testGetBufferedPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getBufferedPosition());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testGetBufferedPosition() throws Exception {
    assertEquals(MediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    assertEquals(MediaPlayer.UNKNOWN_TIME, mPlayer.getBufferedPosition());
}
#end_block

#method_before
private void selectSubtitleTrack(int index) throws Exception {
    int trackIndex = mSubtitleTrackIndex.get(index);
    ListenableFuture<PlayerResult> future = mPlayer.selectTrack(trackIndex);
    assertEquals(RESULT_CODE_SUCCESS, future.get().getResultCode());
    mSelectedSubtitleIndex = index;
}
#method_after
private void selectSubtitleTrack(int index) throws Exception {
    int trackIndex = mSubtitleTrackIndex.get(index);
    ListenableFuture<PlayerResult> future = mPlayer.selectTrack(trackIndex);
    assertEquals(RESULT_SUCCESS, future.get().getResultCode());
    mSelectedSubtitleIndex = index;
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testDeselectTrackForSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mInstrumentation.waitForIdleSync();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem dsd, SubtitleData data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Run twice to check if repeated selection-deselection on the same track works well.
    for (int i = 0; i < 2; i++) {
        // Waits until at least one subtitle is fired. Timeout is 2.5 seconds.
        selectSubtitleTrack(i);
        mOnSubtitleDataCalled.reset();
        assertTrue(mOnSubtitleDataCalled.waitForSignal(2500));
        // Try deselecting track.
        assertEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(i));
        mOnSubtitleDataCalled.reset();
        assertFalse(mOnSubtitleDataCalled.waitForSignal(1500));
    }
    // Deselecting unselected track: expected error status
    assertNotEquals(RESULT_CODE_SUCCESS, deselectSubtitleTrack(0));
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testDeselectTrackForSubtitleTracks() throws Throwable {
    if (!loadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    mInstrumentation.waitForIdleSync();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_METADATA_UPDATE) {
                mOnInfoCalled.signal();
            }
        }

        @Override
        public void onSubtitleData(MediaPlayer mp, MediaItem dsd, SubtitleData data) {
            if (data != null && data.getData() != null) {
                mOnSubtitleDataCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play().get();
    assertTrue(mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING);
    // Closed caption tracks are in-band.
    // So, those tracks will be found after processing a number of frames.
    mOnInfoCalled.waitForSignal(1500);
    mOnInfoCalled.reset();
    mOnInfoCalled.waitForSignal(1500);
    readSubtitleTracks();
    // Run twice to check if repeated selection-deselection on the same track works well.
    for (int i = 0; i < 2; i++) {
        // Waits until at least one subtitle is fired. Timeout is 2.5 seconds.
        selectSubtitleTrack(i);
        mOnSubtitleDataCalled.reset();
        assertTrue(mOnSubtitleDataCalled.waitForSignal(2500));
        // Try deselecting track.
        assertEquals(RESULT_SUCCESS, deselectSubtitleTrack(i));
        mOnSubtitleDataCalled.reset();
        assertFalse(mOnSubtitleDataCalled.waitForSignal(1500));
    }
    // Deselecting unselected track: expected error status
    assertNotEquals(RESULT_SUCCESS, deselectSubtitleTrack(0));
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMediaTimeDiscontinuity() throws Exception {
    if (!loadResource(R.raw.bbb_s1_320x240_mp4_h264_mp2_800kbps_30fps_aac_lc_5ch_240kbps_44100hz)) {
        // skip
        return;
    }
    final BlockingDeque<MediaTimestamp> timestamps = new LinkedBlockingDeque<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onMediaTimeDiscontinuity(MediaPlayer mp, MediaItem dsd, MediaTimestamp timestamp) {
            timestamps.add(timestamp);
            mOnMediaTimeDiscontinuityCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    // Timestamp needs to be reported when playback starts.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.play();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be reported when seeking is done.
    mOnMediaTimeDiscontinuityCalled.reset();
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.seekTo(3000).get().getResultCode());
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be updated when playback rate changes.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(0.5f).build());
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.5f) > 0.01f);
    // Timestamp needs to be updated when player is paused.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.pause();
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.0f) > 0.01f);
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMediaTimeDiscontinuity() throws Exception {
    if (!loadResource(R.raw.bbb_s1_320x240_mp4_h264_mp2_800kbps_30fps_aac_lc_5ch_240kbps_44100hz)) {
        // skip
        return;
    }
    final BlockingDeque<MediaTimestamp> timestamps = new LinkedBlockingDeque<>();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onMediaTimeDiscontinuity(MediaPlayer mp, MediaItem dsd, MediaTimestamp timestamp) {
            timestamps.add(timestamp);
            mOnMediaTimeDiscontinuityCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    // Timestamp needs to be reported when playback starts.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.play();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be reported when seeking is done.
    mOnMediaTimeDiscontinuityCalled.reset();
    assertEquals(RESULT_SUCCESS, mPlayer.seekTo(3000).get().getResultCode());
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 1.0f) > 0.01f);
    // Timestamp needs to be updated when playback rate changes.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams.Builder().setSpeed(0.5f).build());
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.5f) > 0.01f);
    // Timestamp needs to be updated when player is paused.
    mOnMediaTimeDiscontinuityCalled.reset();
    mPlayer.pause();
    mOnMediaTimeDiscontinuityCalled.waitForSignal();
    do {
        assertTrue(mOnMediaTimeDiscontinuityCalled.waitForSignal(1000));
    } while (Math.abs(timestamps.getLast().getMediaClockRate() - 0.0f) > 0.01f);
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    TestDataSourceCallback dataSource = new TestDataSourceCallback(new byte[0]);
    assertEquals(RESULT_CODE_SUCCESS, mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build()).get().getResultCode());
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    TestDataSourceCallback dataSource = new TestDataSourceCallback(new byte[0]);
    assertEquals(RESULT_SUCCESS, mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build()).get().getResultCode());
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    // Ensure that we throw after reading enough data for preparation to complete.
    dataSource.throwFromReadAtPosition(500_000);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mPlayer.prepare().get();
    mOnErrorCalled.reset();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    TestDataSourceCallback dataSource = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    // Ensure that we throw after reading enough data for preparation to complete.
    dataSource.throwFromReadAtPosition(500_000);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mPlayer.prepare().get();
    mOnErrorCalled.reset();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback source = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mOnErrorCalled.reset();
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture1 = mPlayer.seekTo(3000);
    ListenableFuture<PlayerResult> seekFuture2 = mPlayer.seekTo(2000);
    ListenableFuture<PlayerResult> seekFuture3 = mPlayer.seekTo(1000);
    readAllowed.signal();
    assertEquals(RESULT_CODE_SKIPPED, seekFuture1.get().getResultCode());
    assertEquals(RESULT_CODE_SKIPPED, seekFuture2.get().getResultCode());
    assertEquals(RESULT_CODE_SUCCESS, seekFuture3.get().getResultCode());
    assertFalse(mOnErrorCalled.isSignalled());
}
#method_after
// Temporarily disabled for being flaky: b/121255910
// @Test
// @SmallTest
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback source = TestDataSourceCallback.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback dataSource = new DataSourceCallback() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setMediaItem(new CallbackMediaItem.Builder(dataSource).build());
    mOnErrorCalled.reset();
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    ListenableFuture<PlayerResult> seekFuture1 = mPlayer.seekTo(3000);
    ListenableFuture<PlayerResult> seekFuture2 = mPlayer.seekTo(2000);
    ListenableFuture<PlayerResult> seekFuture3 = mPlayer.seekTo(1000);
    readAllowed.signal();
    assertEquals(RESULT_INFO_SKIPPED, seekFuture1.get().getResultCode());
    assertEquals(RESULT_INFO_SKIPPED, seekFuture2.get().getResultCode());
    assertEquals(RESULT_SUCCESS, seekFuture3.get().getResultCode());
    assertFalse(mOnErrorCalled.isSignalled());
}
#end_block

#method_before
@Test
@MediumTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testClose() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    mPlayer.prepare();
    mPlayer.play();
    mPlayer.close();
    // Tests whether the notification from the player after the close() doesn't crash.
    Thread.sleep(SLEEP_TIME);
}
#method_after
@Test
@MediumTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testClose() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    mPlayer.prepare();
    mPlayer.play();
    mPlayer.close();
    // Set the player to null so we don't try to close it again in tearDown().
    mPlayer = null;
    // Tests whether the notification from the player after the close() doesn't crash.
    Thread.sleep(SLEEP_TIME);
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetAndGetRepeatMode() throws Exception {
    final TestUtils.Monitor onRepeatModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onRepeatModeChanged(SessionPlayer player, int repeatMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(repeatMode);
            onRepeatModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int repeatMode = mPlayer.getRepeatMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (repeatMode != SessionPlayer.REPEAT_MODE_NONE) {
        onRepeatModeChangedMonitor.reset();
        future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE);
        assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, mPlayer.getRepeatMode());
    }
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, mPlayer.getRepeatMode());
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_GROUP);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
    // INVALID_REPEAT_MODE will not change the repeat mode.
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(INVALID_REPEAT_MODE);
    assertFalse(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_CODE_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetAndGetRepeatMode() throws Exception {
    final TestUtils.Monitor onRepeatModeChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onRepeatModeChanged(SessionPlayer player, int repeatMode) {
            mPlayerCbArg1 = player;
            mPlayerCbArg2 = new Integer(repeatMode);
            onRepeatModeChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    int repeatMode = mPlayer.getRepeatMode();
    ListenableFuture<PlayerResult> future;
    PlayerResult result;
    if (repeatMode != SessionPlayer.REPEAT_MODE_NONE) {
        onRepeatModeChangedMonitor.reset();
        future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE);
        assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
        result = future.get();
        assertEquals(mPlayer, mPlayerCbArg1);
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, ((Integer) mPlayerCbArg2).intValue());
        assertEquals(SessionPlayer.REPEAT_MODE_NONE, mPlayer.getRepeatMode());
    }
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_ALL, mPlayer.getRepeatMode());
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_GROUP);
    assertTrue(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, ((Integer) mPlayerCbArg2).intValue());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
    // INVALID_REPEAT_MODE will not change the repeat mode.
    onRepeatModeChangedMonitor.reset();
    future = mPlayer.setRepeatMode(INVALID_REPEAT_MODE);
    assertFalse(onRepeatModeChangedMonitor.waitForSignal(WAIT_TIME_MS));
    result = future.get();
    assertEquals(mPlayer, mPlayerCbArg1);
    assertEquals(RESULT_ERROR_BAD_VALUE, result.getResultCode());
    assertEquals(SessionPlayer.REPEAT_MODE_GROUP, mPlayer.getRepeatMode());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetPlaylist() throws Exception {
    List<MediaItem> playlist = createPlaylist(10);
    try {
        mPlayer.setPlaylist(null, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    try {
        List<MediaItem> list = new ArrayList<>();
        list.add(null);
        mPlayer.setPlaylist(list, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    ListenableFuture<PlayerResult> future = mPlayer.setPlaylist(playlist, null);
    PlayerResult result = future.get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(playlist.size(), mPlayer.getPlaylist().size());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSetPlaylist() throws Exception {
    List<MediaItem> playlist = createPlaylist(10);
    try {
        mPlayer.setPlaylist(null, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    try {
        List<MediaItem> list = new ArrayList<>();
        list.add(null);
        mPlayer.setPlaylist(list, null);
        fail();
    } catch (Exception e) {
    // pass-through
    }
    ListenableFuture<PlayerResult> future = mPlayer.setPlaylist(playlist, null);
    PlayerResult result = future.get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(playlist.size(), mPlayer.getPlaylist().size());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPlaylistItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // Test skipToPlaylistItem
    for (int i = listSize - 1; i >= 0; --i) {
        result = mPlayer.skipToPlaylistItem(i).get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(i, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(i), mPlayer.getCurrentMediaItem());
    }
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPlaylistItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    // Test skipToPlaylistItem
    for (int i = listSize - 1; i >= 0; --i) {
        result = mPlayer.skipToPlaylistItem(i).get();
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(i, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(i), mPlayer.getCurrentMediaItem());
    }
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = 0
    for (int curPlayPos = 0; curPlayPos < listSize - 1; ++curPlayPos) {
        result = mPlayer.skipToNextPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos + 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos + 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    // curPlayPos = 0
    for (int curPlayPos = 0; curPlayPos < listSize - 1; ++curPlayPos) {
        result = mPlayer.skipToNextPlaylistItem().get();
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos + 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos + 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPreviousItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPlaylistItem(listSize - 1).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    // curPlayPos = listSize - 1
    for (int curPlayPos = listSize - 1; curPlayPos > 0; --curPlayPos) {
        result = mPlayer.skipToPreviousPlaylistItem().get();
        assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos - 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos - 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToPreviousItems() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_NONE).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPlaylistItem(listSize - 1).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    // curPlayPos = listSize - 1
    for (int curPlayPos = listSize - 1; curPlayPos > 0; --curPlayPos) {
        result = mPlayer.skipToPreviousPlaylistItem().get();
        assertEquals(RESULT_SUCCESS, result.getResultCode());
        assertEquals(curPlayPos - 1, mPlayer.getCurrentMediaItemIndex());
        assertEquals(playlist.get(curPlayPos - 1), mPlayer.getCurrentMediaItem());
    }
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextPreviousItemsWithRepeatMode() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getPreviousMediaItemIndex());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
    assertEquals(0, mPlayer.getNextMediaItemIndex());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testSkipToNextPreviousItemsWithRepeatMode() throws Exception {
    int listSize = 5;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getPreviousMediaItemIndex());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(listSize - 1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(listSize - 1), mPlayer.getCurrentMediaItem());
    assertEquals(0, mPlayer.getNextMediaItemIndex());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToNextItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    // Will not go to the next if the next is end of the playlist
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToNextItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    // Will not go to the next if the next is end of the playlist
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.skipToNextPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToPreviousItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    // Will not go to the previous if the current is the first one
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlaylistAfterSkipToPreviousItem() throws Exception {
    int listSize = 2;
    List<MediaItem> playlist = createPlaylist(listSize);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    // Will not go to the previous if the current is the first one
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_ERROR_INVALID_STATE, result.getResultCode());
    assertEquals(0, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(0), mPlayer.getCurrentMediaItem());
    result = mPlayer.setRepeatMode(SessionPlayer.REPEAT_MODE_ALL).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    result = mPlayer.skipToPreviousPlaylistItem().get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertEquals(1, mPlayer.getCurrentMediaItemIndex());
    assertEquals(playlist.get(1), mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetMediaItem() throws Exception {
    final int currentIdx = -1;
    MediaItem item = createMediaItem(100);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setMediaItem(item).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetMediaItem() throws Exception {
    final int currentIdx = -1;
    MediaItem item = createMediaItem(100);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setMediaItem(item).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#end_block

#method_before
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetPlayList() throws Exception {
    int listSize = 2;
    final int currentIdx = 0;
    List<MediaItem> playlist = createPlaylist(listSize);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_CODE_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#method_after
@Test
@SmallTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testCurrentMediaItemChangedCalledAfterSetPlayList() throws Exception {
    int listSize = 2;
    final int currentIdx = 0;
    List<MediaItem> playlist = createPlaylist(listSize);
    final TestUtils.Monitor onCurrentMediaItemChangedMonitor = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onCurrentMediaItemChanged(SessionPlayer player, MediaItem item) {
            assertEquals(currentIdx, mPlayer.getCurrentMediaItemIndex());
            onCurrentMediaItemChangedMonitor.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    PlayerResult result = mPlayer.setPlaylist(playlist, null).get();
    assertEquals(RESULT_SUCCESS, result.getResultCode());
    assertTrue(onCurrentMediaItemChangedMonitor.waitForSignal(WAIT_TIME_MS));
}
#end_block

#method_before
@Override
public List<TrackInfo> getTrackInfo() {
    MediaPlayer.TrackInfo[] list = mPlayer.getTrackInfo();
    List<TrackInfo> trackList = new ArrayList<>();
    for (MediaPlayer.TrackInfo info : list) {
        trackList.add(new TrackInfoImpl(info.getTrackType(), info.getFormat()));
    }
    return trackList;
}
#method_after
@Override
public List<TrackInfo> getTrackInfo() {
    MediaPlayer.TrackInfo[] list = mPlayer.getTrackInfo();
    List<TrackInfo> trackList = new ArrayList<>();
    for (MediaPlayer.TrackInfo info : list) {
        int trackType = sTrackTypeMap.get(info.getTrackType());
        MediaFormat format = info.getFormat();
        if (format != null && TextUtils.equals(format.getString(MediaFormat.KEY_MIME), MediaFormat.MIMETYPE_TEXT_VTT)) {
            // Hide WebVTT track. For background, see b/120081663.
            trackType = TrackInfo.MEDIA_TRACK_TYPE_UNKNOWN;
        }
        trackList.add(new TrackInfoImpl(trackType, format));
    }
    return trackList;
}
#end_block

#method_before
synchronized MediaTimestamp getTimestamp() {
    android.media.MediaTimestamp t = getCurrentPlayer().getTimestamp();
    return (t == null) ? null : new MediaTimestamp(t);
}
#method_after
synchronized MediaTimestamp getTimestamp() {
    Preconditions.checkState(getFirst().mMp2State != PLAYER_STATE_IDLE);
    android.media.MediaTimestamp t = getCurrentPlayer().getTimestamp();
    return (t == null) ? null : new MediaTimestamp(t);
}
#end_block

#method_before
synchronized int getSelectedTrack(int trackType) {
    return getCurrentPlayer().getSelectedTrack(trackType);
}
#method_after
synchronized int getSelectedTrack(int trackType) {
    final MediaPlayerSource currentPlayerSource = mQueue.get(0);
    return currentPlayerSource.getSelectedTrack(trackType);
}
#end_block

#method_before
synchronized void selectTrack(int index) {
    getCurrentPlayer().selectTrack(index);
}
#method_after
synchronized void selectTrack(int index) {
    final MediaPlayerSource currentPlayerSource = mQueue.get(0);
    currentPlayerSource.selectTrack(index);
}
#end_block

#method_before
synchronized void deselectTrack(int index) {
    getCurrentPlayer().deselectTrack(index);
}
#method_after
synchronized void deselectTrack(int index) {
    final MediaPlayerSource currentPlayerSource = mQueue.get(0);
    currentPlayerSource.deselectTrack(index);
}
#end_block

#method_before
@Override
@RequiresApi(Build.VERSION_CODES.LOLLIPOP)
public PersistableBundle getMetrics() {
    return runPlayerCallableBlocking(new Callable<PersistableBundle>() {

        @Override
        public PersistableBundle call() throws Exception {
            return mPlayer.getMetricsV21();
        }
    });
}
#method_after
@Override
@RequiresApi(21)
public PersistableBundle getMetrics() {
    return runPlayerCallableBlocking(new Callable<PersistableBundle>() {

        @Override
        public PersistableBundle call() throws Exception {
            return mPlayer.getMetricsV21();
        }
    });
}
#end_block

#method_before
public static final MediaPlayer2 create(@NonNull Context context) {
    if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.O_MR1 || DEBUG_USE_EXOPLAYER) {
        return new ExoPlayerMediaPlayer2Impl(context);
    } else {
        return new MediaPlayer2Impl();
    }
}
#method_after
public static final MediaPlayer2 create(@NonNull Context context) {
    if (Build.VERSION.SDK_INT <= 27 || DEBUG_USE_EXOPLAYER) {
        return new ExoPlayerMediaPlayer2Impl(context);
    } else {
        return new MediaPlayer2Impl();
    }
}
#end_block

#method_before
@AudioFallbackMode
@Nullable
public Integer getAudioFallbackMode() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        try {
            return mPlaybackParams.getAudioFallbackMode();
        } catch (IllegalStateException e) {
            return null;
        }
    } else {
        return mAudioFallbackMode;
    }
}
#method_after
@AudioFallbackMode
@Nullable
public Integer getAudioFallbackMode() {
    if (Build.VERSION.SDK_INT >= 23) {
        try {
            return mPlaybackParams.getAudioFallbackMode();
        } catch (IllegalStateException e) {
            return null;
        }
    } else {
        return mAudioFallbackMode;
    }
}
#end_block

#method_before
@Nullable
public Float getPitch() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        try {
            return mPlaybackParams.getPitch();
        } catch (IllegalStateException e) {
            return null;
        }
    } else {
        return mPitch;
    }
}
#method_after
@Nullable
public Float getPitch() {
    if (Build.VERSION.SDK_INT >= 23) {
        try {
            return mPlaybackParams.getPitch();
        } catch (IllegalStateException e) {
            return null;
        }
    } else {
        return mPitch;
    }
}
#end_block

#method_before
@Nullable
public Float getSpeed() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        try {
            return mPlaybackParams.getSpeed();
        } catch (IllegalStateException e) {
            return null;
        }
    } else {
        return mSpeed;
    }
}
#method_after
@Nullable
public Float getSpeed() {
    if (Build.VERSION.SDK_INT >= 23) {
        try {
            return mPlaybackParams.getSpeed();
        } catch (IllegalStateException e) {
            return null;
        }
    } else {
        return mSpeed;
    }
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
@RequiresApi(Build.VERSION_CODES.M)
public android.media.PlaybackParams getPlaybackParams() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        return mPlaybackParams;
    } else {
        return null;
    }
}
#method_after
@RestrictTo(LIBRARY_GROUP)
@RequiresApi(23)
public android.media.PlaybackParams getPlaybackParams() {
    if (Build.VERSION.SDK_INT >= 23) {
        return mPlaybackParams;
    } else {
        return null;
    }
}
#end_block

#method_before
@NonNull
public Builder setAudioFallbackMode(@AudioFallbackMode int audioFallbackMode) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        mPlaybackParams.setAudioFallbackMode(audioFallbackMode);
    } else {
        mAudioFallbackMode = audioFallbackMode;
    }
    return this;
}
#method_after
@NonNull
public Builder setAudioFallbackMode(@AudioFallbackMode int audioFallbackMode) {
    if (Build.VERSION.SDK_INT >= 23) {
        mPlaybackParams.setAudioFallbackMode(audioFallbackMode);
    } else {
        mAudioFallbackMode = audioFallbackMode;
    }
    return this;
}
#end_block

#method_before
@NonNull
public Builder setPitch(float pitch) {
    if (pitch < 0.f) {
        throw new IllegalArgumentException("pitch must not be negative");
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        mPlaybackParams.setPitch(pitch);
    } else {
        mPitch = pitch;
    }
    return this;
}
#method_after
@NonNull
public Builder setPitch(float pitch) {
    if (pitch < 0.f) {
        throw new IllegalArgumentException("pitch must not be negative");
    }
    if (Build.VERSION.SDK_INT >= 23) {
        mPlaybackParams.setPitch(pitch);
    } else {
        mPitch = pitch;
    }
    return this;
}
#end_block

#method_before
@NonNull
public Builder setSpeed(float speed) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        mPlaybackParams.setSpeed(speed);
    } else {
        mSpeed = speed;
    }
    return this;
}
#method_after
@NonNull
public Builder setSpeed(float speed) {
    if (Build.VERSION.SDK_INT >= 23) {
        mPlaybackParams.setSpeed(speed);
    } else {
        mSpeed = speed;
    }
    return this;
}
#end_block

#method_before
@NonNull
public PlaybackParams build() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        return new PlaybackParams(mPlaybackParams);
    } else {
        return new PlaybackParams(mAudioFallbackMode, mPitch, mSpeed);
    }
}
#method_after
@NonNull
public PlaybackParams build() {
    if (Build.VERSION.SDK_INT >= 23) {
        return new PlaybackParams(mPlaybackParams);
    } else {
        return new PlaybackParams(mAudioFallbackMode, mPitch, mSpeed);
    }
}
#end_block

#method_before
@RequiresApi(Build.VERSION_CODES.LOLLIPOP)
public PersistableBundle getMetricsV21() {
    TrackGroupArray trackGroupArray = mPlayer.getCurrentTrackGroups();
    long durationMs = mPlayer.getDuration();
    long playingTimeMs = mMediaItemQueue.getCurrentMediaItemPlayingTimeMs();
    @Nullable
    String primaryAudioMimeType = null;
    @Nullable
    String primaryVideoMimeType = null;
    for (int i = 0; i < trackGroupArray.length; i++) {
        TrackGroup trackGroup = trackGroupArray.get(i);
        String mimeType = trackGroup.getFormat(0).sampleMimeType;
        if (primaryVideoMimeType == null && MimeTypes.isVideo(mimeType)) {
            primaryVideoMimeType = mimeType;
        } else if (primaryAudioMimeType == null && MimeTypes.isAudio(mimeType)) {
            primaryAudioMimeType = mimeType;
        }
    }
    PersistableBundle bundle = new PersistableBundle();
    if (primaryVideoMimeType != null) {
        bundle.putString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, primaryVideoMimeType);
    }
    if (primaryAudioMimeType != null) {
        bundle.putString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, primaryAudioMimeType);
    }
    bundle.putLong(MediaPlayer2.MetricsConstants.DURATION, durationMs == C.TIME_UNSET ? -1 : durationMs);
    bundle.putLong(MediaPlayer2.MetricsConstants.PLAYING, playingTimeMs);
    return bundle;
}
#method_after
@RequiresApi(21)
public PersistableBundle getMetricsV21() {
    TrackGroupArray trackGroupArray = mPlayer.getCurrentTrackGroups();
    long durationMs = mPlayer.getDuration();
    long playingTimeMs = mMediaItemQueue.getCurrentMediaItemPlayingTimeMs();
    @Nullable
    String primaryAudioMimeType = null;
    @Nullable
    String primaryVideoMimeType = null;
    for (int i = 0; i < trackGroupArray.length; i++) {
        TrackGroup trackGroup = trackGroupArray.get(i);
        String mimeType = trackGroup.getFormat(0).sampleMimeType;
        if (primaryVideoMimeType == null && MimeTypes.isVideo(mimeType)) {
            primaryVideoMimeType = mimeType;
        } else if (primaryAudioMimeType == null && MimeTypes.isAudio(mimeType)) {
            primaryAudioMimeType = mimeType;
        }
    }
    PersistableBundle bundle = new PersistableBundle();
    if (primaryVideoMimeType != null) {
        bundle.putString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, primaryVideoMimeType);
    }
    if (primaryAudioMimeType != null) {
        bundle.putString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, primaryAudioMimeType);
    }
    bundle.putLong(MediaPlayer2.MetricsConstants.DURATION, durationMs == C.TIME_UNSET ? -1 : durationMs);
    bundle.putLong(MediaPlayer2.MetricsConstants.PLAYING, playingTimeMs);
    return bundle;
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
private void testHmacKeySupportedSizesHelper(boolean useStrongbox) throws Exception {
    CountingSecureRandom rng = new CountingSecureRandom();
    for (String algorithm : useStrongbox ? EXPECTED_STRONGBOX_ALGORITHMS : EXPECTED_ALGORITHMS) {
        if (!TestUtils.isHmacAlgorithm(algorithm)) {
            continue;
        }
        for (int i = -16; i <= 1024; i++) {
            try {
                rng.resetCounters();
                KeyGenerator keyGenerator = getKeyGenerator(algorithm);
                KeyGenParameterSpec spec;
                if (i >= 0) {
                    spec = getWorkingSpec().setKeySize(i).setIsStrongBoxBacked(useStrongbox).build();
                } else {
                    try {
                        spec = getWorkingSpec().setKeySize(i).setIsStrongBoxBacked(useStrongbox).build();
                        fail();
                    } catch (IllegalArgumentException expected) {
                        continue;
                    }
                }
                // TODO: This test currently fails, will be fixed on resolution of b/113525261
                if (useStrongbox && i > 512) {
                    try {
                        keyGenerator.init(spec, rng);
                        fail();
                    } catch (InvalidAlgorithmParameterException expected) {
                        assertEquals(0, rng.getOutputSizeBytes());
                        continue;
                    }
                }
                if ((i >= 64) && ((i % 8) == 0)) {
                    keyGenerator.init(spec, rng);
                    SecretKey key = keyGenerator.generateKey();
                    assertEquals(i, TestUtils.getKeyInfo(key).getKeySize());
                    assertEquals((i + 7) / 8, rng.getOutputSizeBytes());
                } else if (i >= 64) {
                    try {
                        keyGenerator.init(spec, rng);
                        fail();
                    } catch (InvalidAlgorithmParameterException expected) {
                    }
                    assertEquals(0, rng.getOutputSizeBytes());
                }
            } catch (Throwable e) {
                throw new RuntimeException("Failed for " + algorithm + " with key size " + i + ". Use Strongbox: " + useStrongbox, e);
            }
        }
    }
}
#method_after
private void testHmacKeySupportedSizesHelper(boolean useStrongbox) throws Exception {
    CountingSecureRandom rng = new CountingSecureRandom();
    for (String algorithm : useStrongbox ? EXPECTED_STRONGBOX_ALGORITHMS : EXPECTED_ALGORITHMS) {
        if (!TestUtils.isHmacAlgorithm(algorithm)) {
            continue;
        }
        for (int i = -16; i <= 1024; i++) {
            try {
                rng.resetCounters();
                KeyGenerator keyGenerator = getKeyGenerator(algorithm);
                KeyGenParameterSpec spec;
                if (i >= 0) {
                    spec = getWorkingSpec().setKeySize(i).setIsStrongBoxBacked(useStrongbox).build();
                } else {
                    try {
                        spec = getWorkingSpec().setKeySize(i).setIsStrongBoxBacked(useStrongbox).build();
                        fail();
                    } catch (IllegalArgumentException expected) {
                        continue;
                    }
                }
                // TODO: This test currently fails, will be fixed on resolution of b/113525261
                if (useStrongbox && i > 512) {
                    try {
                        keyGenerator.init(spec, rng);
                        fail();
                    } catch (InvalidAlgorithmParameterException expected) {
                        assertEquals(0, rng.getOutputSizeBytes());
                    }
                } else if ((i >= 64) && ((i % 8) == 0)) {
                    keyGenerator.init(spec, rng);
                    SecretKey key = keyGenerator.generateKey();
                    assertEquals(i, TestUtils.getKeyInfo(key).getKeySize());
                    assertEquals((i + 7) / 8, rng.getOutputSizeBytes());
                } else if (i >= 64) {
                    try {
                        keyGenerator.init(spec, rng);
                        fail();
                    } catch (InvalidAlgorithmParameterException expected) {
                    }
                    assertEquals(0, rng.getOutputSizeBytes());
                }
            } catch (Throwable e) {
                throw new RuntimeException("Failed for " + algorithm + " with key size " + i + ". Use Strongbox: " + useStrongbox, e);
            }
        }
    }
}
#end_block

#method_before
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#method_after
@Nullable
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#end_block

#method_before
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#method_after
@Nullable
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#end_block

#method_before
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#method_after
@Nullable
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#end_block

#method_before
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#method_after
@Nullable
public String getMobileNetworkOperator() {
    return (mMccStr == null || mMncStr == null) ? null : mMccStr + mMncStr;
}
#end_block

