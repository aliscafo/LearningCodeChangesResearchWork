665
#method_before
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().timeBoundPoll(this.timeout, this.unit);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().timeBoundPoll(this.getParameters().getTimeout(), this.getParameters().getUnit());
}
#end_block

#method_before
private boolean doQueryOpenImpl(ExtMap filter) {
    boolean found = false;
    if (filter.<Integer>get(Authz.QueryFilterRecord.OPERATOR) == Authz.QueryFilterOperator.EQ) {
        ExtKey extKey = filter.<ExtKey>get(Authz.QueryFilterRecord.KEY);
        if (extKey.equals(Authz.PrincipalRecord.NAME)) {
            String name = filter.<String>get(Authz.PrincipalRecord.NAME);
            found = userName.matches(name.replace("*", ".*"));
        } else if (extKey.equals(Authz.PrincipalRecord.ID)) {
            found = filter.<String>get(Authz.PrincipalRecord.ID).equals(configuration.getProperty("config.authz.user.id"));
        } else {
            found = false;
        }
    } else {
        for (ExtMap currentFilter : filter.<Collection<ExtMap>>get(Authz.QueryFilterRecord.FILTER)) {
            found = found || doQueryOpenImpl(currentFilter);
        }
    }
    return found;
}
#method_after
private boolean doQueryOpenImpl(ExtMap filter) {
    boolean found = false;
    if (filter.<Integer>get(Authz.QueryFilterRecord.OPERATOR) == Authz.QueryFilterOperator.EQ) {
        ExtKey extKey = filter.<ExtKey>get(Authz.QueryFilterRecord.KEY);
        if (extKey.equals(Authz.PrincipalRecord.NAME)) {
            String name = filter.<String>get(Authz.PrincipalRecord.NAME);
            found = configuration.getProperty("config.authz.user.name").matches(name.replace("*", ".*"));
        } else if (extKey.equals(Authz.PrincipalRecord.ID)) {
            found = filter.<String>get(Authz.PrincipalRecord.ID).equals(configuration.getProperty("config.authz.user.id"));
        } else {
            found = false;
        }
    } else {
        for (ExtMap currentFilter : filter.<Collection<ExtMap>>get(Authz.QueryFilterRecord.FILTER)) {
            found = found || doQueryOpenImpl(currentFilter);
        }
    }
    return found;
}
#end_block

#method_before
private void doLoad(ExtMap input, ExtMap output) {
    context = input.<ExtMap>get(Base.InvokeKeys.CONTEXT);
    configuration = context.<Properties>get(Base.ContextKeys.CONFIGURATION);
    context.mput(Base.ContextKeys.AUTHOR, "The oVirt Project").mput(Base.ContextKeys.EXTENSION_NAME, "Internal Authz (Built-in)").mput(Base.ContextKeys.LICENSE, "ASL 2.0").mput(Base.ContextKeys.HOME_URL, "http://www.ovirt.org").mput(Base.ContextKeys.VERSION, "N/A").mput(Authz.ContextKeys.QUERY_MAX_FILTER_SIZE, Integer.parseInt(configuration.getProperty("config.query.filter.size"))).mput(Base.ContextKeys.BUILD_INTERFACE_VERSION, Base.INTERFACE_VERSION_CURRENT).mput(Authz.ContextKeys.AVAILABLE_NAMESPACES, Arrays.asList(NAMESPACE));
    userName = configuration.getProperty("config.authz.user.name");
    adminUser = new ExtMap().mput(Authz.PrincipalRecord.NAMESPACE, NAMESPACE).mput(Authz.PrincipalRecord.NAME, userName).mput(Authz.PrincipalRecord.FIRST_NAME, userName).mput(Authz.PrincipalRecord.ID, configuration.getProperty("config.authz.user.id")).mput(Authz.PrincipalRecord.PRINCIPAL, userName);
}
#method_after
private void doLoad(ExtMap input, ExtMap output) {
    context = input.<ExtMap>get(Base.InvokeKeys.CONTEXT);
    configuration = context.<Properties>get(Base.ContextKeys.CONFIGURATION);
    context.mput(Base.ContextKeys.AUTHOR, "The oVirt Project").mput(Base.ContextKeys.EXTENSION_NAME, "Internal Authz (Built-in)").mput(Base.ContextKeys.LICENSE, "ASL 2.0").mput(Base.ContextKeys.HOME_URL, "http://www.ovirt.org").mput(Base.ContextKeys.VERSION, "N/A").mput(Authz.ContextKeys.QUERY_MAX_FILTER_SIZE, Integer.parseInt(configuration.getProperty("config.query.filter.size"))).mput(Base.ContextKeys.BUILD_INTERFACE_VERSION, Base.INTERFACE_VERSION_CURRENT).mput(Authz.ContextKeys.AVAILABLE_NAMESPACES, Arrays.asList(NAMESPACE));
    adminUser = new ExtMap().mput(Authz.PrincipalRecord.NAMESPACE, NAMESPACE).mput(Authz.PrincipalRecord.NAME, configuration.getProperty("config.authz.user.name")).mput(Authz.PrincipalRecord.FIRST_NAME, configuration.getProperty("config.authz.user.name")).mput(Authz.PrincipalRecord.ID, configuration.getProperty("config.authz.user.id")).mput(Authz.PrincipalRecord.PRINCIPAL, configuration.getProperty("config.authz.user.name"));
}
#end_block

#method_before
public <T extends Serializable> T getEntityGuid(BusinessEntity<T> entity) {
    return entity.getId();
}
#method_after
public <T extends Guid> T getEntityGuid(BusinessEntity<T> entity) {
    return entity.getId();
}
#end_block

#method_before
public Guid getEntityGuid(Object entity) {
    if (entity instanceof BusinessEntity) {
        // BusinessEntity can have lot of different ID types, but from this context it cannot be determined.
        Object id = getEntityGuid((BusinessEntity<?>) entity);
        // check whether result can be casted to Guid, otherwise continue with explicit rules.
        if (id instanceof Guid) {
            return (Guid) id;
        }
    }
    if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else {
        return Guid.Empty;
    }
}
#method_after
public Guid getEntityGuid(Object entity) {
    if (entity instanceof BusinessEntity) {
        // BusinessEntity can have lot of different ID types, but from this context it cannot be determined.
        Object id = ((BusinessEntity<?>) entity).getId();
        // check whether result can be casted to Guid, otherwise continue with explicit rules.
        if (id instanceof Guid) {
            return (Guid) id;
        }
    }
    if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else {
        return Guid.Empty;
    }
}
#end_block

#method_before
public static void main(String[] args) {
    NotificationProperties prop = null;
    NotificationService notificationService = null;
    EngineMonitorService engineMonitorService = null;
    try {
        prop = NotificationProperties.getInstance();
        prop.validate();
        notificationService = new NotificationService(prop);
        engineMonitorService = new EngineMonitorService(prop);
        notificationService.registerTransport(new Smtp(prop));
        notificationService.registerTransport(new Snmp(prop));
        if (!notificationService.hasTransports()) {
            throw new RuntimeException("No transport is enabled, please enable at least one of SMTP (using MAIL_SERVER option)" + " or SNMP (using SNMP_MANAGERS option) transports.");
        }
    } catch (Exception ex) {
        log.error("Failed to initialize", ex);
        // print error also to stderr to be seen in console during service startup
        System.err.println(ex.getMessage());
        System.exit(1);
    }
    if (args != null && args.length > 0 && ARG_VALIDATE.equals(args[0])) {
        // command line argument to validate only entered
        System.exit(0);
    }
    try {
        notificationService.run();
        engineMonitorService.run();
    } catch (Exception e) {
        log.error("Failed to run the event notification service. ", e);
        // flag exit code to calling script after threads shut down.
        System.exit(1);
    }
}
#method_after
public static void main(String[] args) {
    NotificationProperties prop = null;
    NotificationService notificationService = null;
    EngineMonitorService engineMonitorService = null;
    try {
        prop = NotificationProperties.getInstance();
        JavaLoggingUtils.setLogLevel(prop.getProperty(LOG_LEVEL));
        prop.validate();
        notificationService = new NotificationService(prop);
        engineMonitorService = new EngineMonitorService(prop);
        notificationService.registerTransport(new Smtp(prop));
        notificationService.registerTransport(new Snmp(prop));
        if (!notificationService.hasTransports()) {
            throw new RuntimeException("No transport is enabled, please enable at least one of SMTP (using MAIL_SERVER option)" + " or SNMP (using SNMP_MANAGERS option) transports.");
        }
    } catch (Exception ex) {
        log.error("Failed to initialize", ex);
        // print error also to stderr to be seen in console during service startup
        System.err.println(ex.getMessage());
        System.exit(1);
    }
    if (args != null && args.length > 0 && ARG_VALIDATE.equals(args[0])) {
        // command line argument to validate only entered
        System.exit(0);
    }
    try {
        notificationService.run();
        engineMonitorService.run();
    } catch (Exception e) {
        log.error("Failed to run the event notification service. ", e);
        // flag exit code to calling script after threads shut down.
        System.exit(1);
    }
}
#end_block

#method_before
public static void main(String... args) {
    EngineConfigCLIParser parser = null;
    try {
        parser = new EngineConfigCLIParser();
        parser.parse(args);
        EngineConfigMap argsMap = parser.getEngineConfigMap();
        if (argsMap.getLogFile() != null) {
            JavaLoggingUtils.addFileHandler(argsMap.getLogFile(), argsMap.getLogLevel());
        }
    } catch (Throwable t) {
        System.out.println(t.getMessage());
        System.exit(1);
    }
    try {
        EngineConfig.getInstance().setUpAndExecute(parser);
    } catch (Throwable t) {
        LoggerFactory.getLogger(EngineConfigExecutor.class).debug("Exiting with error: ", t);
        System.out.println(t.getMessage());
        System.exit(1);
    }
}
#method_after
public static void main(String... args) {
    EngineConfigCLIParser parser = null;
    try {
        parser = new EngineConfigCLIParser();
        parser.parse(args);
        EngineConfigMap argsMap = parser.getEngineConfigMap();
        if (argsMap.getLogFile() != null) {
            JavaLoggingUtils.addFileHandler(argsMap.getLogFile());
        }
        if (argsMap.getLogLevel() != null) {
            JavaLoggingUtils.setLogLevel(argsMap.getLogLevel());
        }
    } catch (Throwable t) {
        System.out.println(t.getMessage());
        System.exit(1);
    }
    try {
        EngineConfig.getInstance().setUpAndExecute(parser);
    } catch (Throwable t) {
        LoggerFactory.getLogger(EngineConfigExecutor.class).debug("Exiting with error: ", t);
        System.out.println(t.getMessage());
        System.exit(1);
    }
}
#end_block

#method_before
public static void main(String... args) {
    ManageDomainsArguments mdArgs = null;
    try {
        setupDefaultLogging();
        mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        setupCustomLogging(mdArgs.get(ARG_LOG4J_CONFIG), mdArgs.get(ARG_LOG_FILE), mdArgs.get(ARG_LOG_LEVEL));
    } catch (Throwable t) {
        System.out.println(t.getMessage());
        System.exit(1);
    }
    try {
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
            System.exit(0);
        } else {
            ManageDomains util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        ManageDomains.exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String... args) {
    ManageDomainsArguments mdArgs = null;
    try {
        mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        if (mdArgs.contains(ARG_LOG_FILE)) {
            JavaLoggingUtils.addFileHandler(mdArgs.get(ARG_LOG_FILE));
        }
        if (mdArgs.contains(ARG_LOG_LEVEL)) {
            JavaLoggingUtils.setLogLevel(mdArgs.get(ARG_LOG_LEVEL));
        }
    } catch (Throwable t) {
        System.out.println(t.getMessage());
        System.exit(1);
    }
    try {
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
            System.exit(0);
        } else {
            ManageDomains util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        ManageDomains.exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#end_block

#method_before
public static Level parseLevel(String levelName) {
    if ("ALL".equalsIgnoreCase(levelName)) {
        return Level.ALL;
    } else if ("FINEST".equalsIgnoreCase(levelName)) {
        return Level.FINEST;
    } else if ("TRACE".equalsIgnoreCase(levelName) || "FINER".equalsIgnoreCase(levelName)) {
        return Level.FINER;
    } else if ("DEBUG".equalsIgnoreCase(levelName) || "FINE".equalsIgnoreCase(levelName)) {
        return Level.FINE;
    } else if ("CONFIG".equalsIgnoreCase(levelName)) {
        return Level.CONFIG;
    } else if ("INFO".equalsIgnoreCase(levelName)) {
        return Level.INFO;
    } else if ("WARN".equalsIgnoreCase(levelName) || "WARNING".equalsIgnoreCase(levelName)) {
        return Level.WARNING;
    } else if ("ERROR".equalsIgnoreCase(levelName) || "FATAL".equalsIgnoreCase(levelName) || "SEVERE".equalsIgnoreCase(levelName)) {
        return Level.SEVERE;
    } else if ("OFF".equalsIgnoreCase(levelName)) {
        return Level.OFF;
    }
    // unknown level
    throw new IllegalArgumentException(String.format("Invalid log level value: '%s'", levelName));
}
#method_after
public static Level parseLevel(String levelName) {
    if (levelName == null) {
        throw new IllegalArgumentException("Invalid log level value: 'null'");
    }
    return Level.parse(levelName.toUpperCase());
}
#end_block

#method_before
public static void addFileHandler(String fileName, String levelName) {
    try {
        FileHandler fh = new FileHandler(fileName);
        fh.setLevel(parseLevel(levelName));
        fh.setFormatter(new JavaLoggingFormatter());
        Logger.getLogger("org.ovirt").addHandler(fh);
    } catch (SecurityException | IOException ex) {
        throw new IllegalArgumentException(String.format("Error accessing log file '%s': '%s'", fileName, ex.getMessage()), ex);
    }
}
#method_after
public static void addFileHandler(String fileName) {
    try {
        FileHandler fh = new FileHandler(fileName);
        fh.setFormatter(new SimpleFormatter());
        Logger.getLogger("").addHandler(fh);
    } catch (SecurityException | IOException ex) {
        throw new IllegalArgumentException(String.format("Error accessing log file '%s': '%s'", fileName, ex.getMessage()), ex);
    }
}
#end_block

#method_before
@Override
public void idle() {
    if (lastSendInterval++ >= sendIntervals) {
        lastSendInterval = 0;
        Iterator<DispatchAttempt> iterator = sendQueue.iterator();
        while (iterator.hasNext()) {
            DispatchAttempt attempt = iterator.next();
            try {
                EventMessageContent message = new EventMessageContent();
                message.prepareMessage(hostName, attempt.event, isBodyHtml);
                log.info("Send email to [{}]\n subject:\n [{}]", attempt.address, message.getMessageSubject());
                if (log.isDebugEnabled()) {
                    log.debug("body:\n [{}]", message.getMessageBody());
                }
                sendMail(attempt.address, message.getMessageSubject(), message.getMessageBody());
                notifyObservers(DispatchResult.success(attempt.event, attempt.address, EventNotificationMethod.SMTP));
                iterator.remove();
            } catch (Exception ex) {
                attempt.retries++;
                if (attempt.retries >= retries) {
                    notifyObservers(DispatchResult.failure(attempt.event, attempt.address, EventNotificationMethod.SMTP, ex.getMessage()));
                    iterator.remove();
                }
            }
        }
    }
}
#method_after
@Override
public void idle() {
    if (lastSendInterval++ >= sendIntervals) {
        lastSendInterval = 0;
        Iterator<DispatchAttempt> iterator = sendQueue.iterator();
        while (iterator.hasNext()) {
            DispatchAttempt attempt = iterator.next();
            try {
                EventMessageContent message = new EventMessageContent();
                message.prepareMessage(hostName, attempt.event, isBodyHtml);
                log.info("Send mail subject='{}' to='{}'", message.getMessageSubject(), attempt.address);
                log.debug("Send mail body='{}'", message.getMessageBody());
                sendMail(attempt.address, message.getMessageSubject(), message.getMessageBody());
                notifyObservers(DispatchResult.success(attempt.event, attempt.address, EventNotificationMethod.SMTP));
                iterator.remove();
            } catch (Exception ex) {
                attempt.retries++;
                if (attempt.retries >= retries) {
                    notifyObservers(DispatchResult.failure(attempt.event, attempt.address, EventNotificationMethod.SMTP, ex.getMessage()));
                    iterator.remove();
                }
            }
        }
    }
}
#end_block

#method_before
@Test
public void testGetValue() throws Exception {
    final String key = "MaxNumberOfHostsInStoragePool";
    log.info("getValue: Testing fetch of " + key);
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    log.info("getValue: got: " + configKey);
    Assert.assertNotNull(configKey.getValue());
}
#method_after
@Test
public void testGetValue() throws Exception {
    final String key = "MaxNumberOfHostsInStoragePool";
    log.info("getValue: Testing fetch of {}", key);
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    log.info("getValue: got: {}", configKey);
    Assert.assertNotNull(configKey.getValue());
}
#end_block

#method_before
@Test
public void testSetIntValue() throws Exception {
    final String key = "VdsRefreshRate";
    final String newValue = "15";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setIntValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(Integer.parseInt(updatedValue), Integer.parseInt(newValue));
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#method_after
@Test
public void testSetIntValue() throws Exception {
    final String key = "VdsRefreshRate";
    final String newValue = "15";
    String oldValue = getOldValue(key);
    log.info("{} old value: {}", key, oldValue);
    log.info("setIntValue: Testing set of {}", key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info("{} new value: {}", key, updatedValue);
    Assert.assertEquals(Integer.parseInt(updatedValue), Integer.parseInt(newValue));
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#end_block

#method_before
@Test
public void testSetStringValue() throws Exception {
    final String key = "SysPrepDefaultUser";
    final String newValue = "ExampleSysPrepDefaultUser";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setStringValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(updatedValue, newValue);
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#method_after
@Test
public void testSetStringValue() throws Exception {
    final String key = "SysPrepDefaultUser";
    final String newValue = "ExampleSysPrepDefaultUser";
    String oldValue = getOldValue(key);
    log.info("{} old value: {}", key, oldValue);
    log.info("setStringValue: Testing set of {}", key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info("{} new value: {}", key, updatedValue);
    Assert.assertEquals(updatedValue, newValue);
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#end_block

#method_before
public void write(Object what) {
    System.out.print(what);
    System.out.flush();
    log.info("Written to standard output \"" + what + "\".");
}
#method_after
public void write(Object what) {
    System.out.print(what);
    System.out.flush();
    log.info("Written to standard output \"{}\".", what);
}
#end_block

#method_before
public void writeError(Object what) {
    System.err.print(what);
    System.err.flush();
    log.info("Written to standard error \"" + what + "\".");
}
#method_after
public void writeError(Object what) {
    System.err.print(what);
    System.err.flush();
    log.info("Written to standard error \"{}\".", what);
}
#end_block

#method_before
public String readLine() {
    StringBuilder buffer = new StringBuilder();
    for (; ; ) {
        int character;
        try {
            character = System.in.read();
        } catch (IOException exception) {
            log.error("Error while reading line from standard input. Will " + "consider it the end of the line and continue.", exception);
            break;
        }
        if (character == -1 || character == '\n') {
            break;
        }
        buffer.append((char) character);
    }
    String line = buffer.toString();
    log.info("Read from stdin \"" + line + "\".");
    return line;
}
#method_after
public String readLine() {
    StringBuilder buffer = new StringBuilder();
    for (; ; ) {
        int character;
        try {
            character = System.in.read();
        } catch (IOException exception) {
            log.error("Error while reading line from standard input. Will " + "consider it the end of the line and continue.", exception);
            break;
        }
        if (character == -1 || character == '\n') {
            break;
        }
        buffer.append((char) character);
    }
    String line = buffer.toString();
    log.info("Read from stdin \"{}\".", line);
    return line;
}
#end_block

#method_before
public char[] readPassword(String prompt) {
    char[] password = System.console().readPassword(prompt);
    log.info("Written to console \"" + prompt + "\".");
    log.info("Read password from console.");
    return password;
}
#method_after
public char[] readPassword(String prompt) {
    char[] password = System.console().readPassword(prompt);
    log.info("Written to console \"{}\".", prompt);
    log.info("Read password from console.");
    return password;
}
#end_block

#method_before
private ValueHelper getHelperByType(String type) {
    ValueHelper valueHelper;
    try {
        if (type == null) {
            type = "String";
        }
        Class<?> cls = Class.forName("org.ovirt.engine.core.config.entity.helper." + type + "ValueHelper");
        valueHelper = (ValueHelper) cls.newInstance();
    } catch (Exception e) {
        // failed finding a helper for this type. Setting default string type
        LoggerFactory.getLogger(EngineConfig.class).debug("Unable to find " + type + " type. Using default string type.");
        valueHelper = new StringValueHelper();
    }
    return valueHelper;
}
#method_after
private ValueHelper getHelperByType(String type) {
    ValueHelper valueHelper;
    try {
        if (type == null) {
            type = "String";
        }
        Class<?> cls = Class.forName("org.ovirt.engine.core.config.entity.helper." + type + "ValueHelper");
        valueHelper = (ValueHelper) cls.newInstance();
    } catch (Exception e) {
        // failed finding a helper for this type. Setting default string type
        LoggerFactory.getLogger(EngineConfig.class).debug("Unable to find {} type. Using default string type.", type);
        valueHelper = new StringValueHelper();
    }
    return valueHelper;
}
#end_block

#method_before
public void execute() throws Exception {
    ConfigActionType actionType = parser.getConfigAction();
    log.debug("execute: beginning execution of action " + actionType + ".");
    switch(actionType) {
        case ACTION_ALL:
            printAllValues();
            break;
        case ACTION_LIST:
            listKeys();
            break;
        case ACTION_GET:
            printKey();
            break;
        case ACTION_SET:
            persistValue();
            break;
        case ACTION_MERGE:
            mergeValue();
            break;
        case ACTION_HELP:
            printHelpForKey();
            break;
        case ACTION_RELOAD:
            reloadConfigurations();
            break;
        default:
            // Should have already been discovered before execute
            log.debug("execute: unable to recognize action: " + actionType + ".");
            throw new UnsupportedOperationException("Please tell me what to do: list? get? set? get-all? reload?");
    }
}
#method_after
public void execute() throws Exception {
    ConfigActionType actionType = parser.getConfigAction();
    log.debug("execute: beginning execution of action {}.", actionType);
    switch(actionType) {
        case ACTION_ALL:
            printAllValues();
            break;
        case ACTION_LIST:
            listKeys();
            break;
        case ACTION_GET:
            printKey();
            break;
        case ACTION_SET:
            persistValue();
            break;
        case ACTION_MERGE:
            mergeValue();
            break;
        case ACTION_HELP:
            printHelpForKey();
            break;
        case ACTION_RELOAD:
            reloadConfigurations();
            break;
        default:
            // Should have already been discovered before execute
            log.debug("execute: unable to recognize action: {}.", actionType);
            throw new UnsupportedOperationException("Please tell me what to do: list? get? set? get-all? reload?");
    }
}
#end_block

#method_before
private void printAllValuesForKey(String key) throws Exception {
    List<ConfigKey> keysForName = getConfigDAO().getKeysForName(key);
    if (keysForName.size() == 0) {
        log.debug("Failed to fetch value for key \"" + key + "\", no such entry with default version.");
        throw new RuntimeException("Error fetching " + key + " value: no such entry with default version.");
    }
    for (ConfigKey configKey : keysForName) {
        console.write(key);
        console.write(": ");
        if (!configKey.isPasswordKey()) {
            console.write(configKey.getDisplayValue());
        } else {
            char[] value = configKey.getDisplayValue().toCharArray();
            console.writePassword(value);
            Arrays.fill(value, '\0');
        }
        console.write(" ");
        console.write("version: ");
        console.write(configKey.getVersion());
        console.writeLine();
    }
}
#method_after
private void printAllValuesForKey(String key) throws Exception {
    List<ConfigKey> keysForName = getConfigDAO().getKeysForName(key);
    if (keysForName.size() == 0) {
        log.debug("Failed to fetch value for key \"{}\", no such entry with default version.", key);
        throw new RuntimeException("Error fetching " + key + " value: no such entry with default version.");
    }
    for (ConfigKey configKey : keysForName) {
        console.write(key);
        console.write(": ");
        if (!configKey.isPasswordKey()) {
            console.write(configKey.getDisplayValue());
        } else {
            char[] value = configKey.getDisplayValue().toCharArray();
            console.writePassword(value);
            Arrays.fill(value, '\0');
        }
        console.write(" ");
        console.write("version: ");
        console.write(configKey.getVersion());
        console.writeLine();
    }
}
#end_block

#method_before
private void printAllValues() {
    List<ConfigurationNode> configNodes = keysConfig.getRootNode().getChildren();
    for (ConfigurationNode node : configNodes) {
        ConfigKey key = configKeyFactory.generateByPropertiesKey(node.getName());
        // TODO - move to one statement for all - time permitting;
        try {
            printAllValuesForKey(key.getKey());
        } catch (Exception exception) {
            log.error("Error while retriving value for key \"" + key.getKey() + "\".", exception);
        }
    }
}
#method_after
private void printAllValues() {
    List<ConfigurationNode> configNodes = keysConfig.getRootNode().getChildren();
    for (ConfigurationNode node : configNodes) {
        ConfigKey key = configKeyFactory.generateByPropertiesKey(node.getName());
        // TODO - move to one statement for all - time permitting;
        try {
            printAllValuesForKey(key.getKey());
        } catch (Exception exception) {
            log.error("Error while retrieving value for key \"{}\".", key.getKey(), exception);
        }
    }
}
#end_block

#method_before
private void printKeyWithSpecifiedVersion(String key, String version) throws Exception {
    ConfigKey configKey = fetchConfigKey(key, version);
    if (configKey == null || configKey.getKey() == null) {
        log.debug("getValue: error fetching " + key + " value: no such entry with version '" + version + "'.");
        throw new RuntimeException("Error fetching " + key + " value: no such entry with version '" + version + "'.");
    }
    if (configKey.isPasswordKey()) {
        console.writePassword(configKey.getDisplayValue().toCharArray());
    } else {
        console.write(configKey.getDisplayValue());
    }
    console.writeLine();
}
#method_after
private void printKeyWithSpecifiedVersion(String key, String version) throws Exception {
    ConfigKey configKey = fetchConfigKey(key, version);
    if (configKey == null || configKey.getKey() == null) {
        log.debug("getValue: error fetching {} value: no such entry with version '{}'.", key, version);
        throw new RuntimeException("Error fetching " + key + " value: no such entry with version '" + version + "'.");
    }
    if (configKey.isPasswordKey()) {
        console.writePassword(configKey.getDisplayValue().toCharArray());
    } else {
        console.write(configKey.getDisplayValue());
    }
    console.writeLine();
}
#end_block

#method_before
private void persistValue() throws Exception {
    String key = parser.getKey();
    String value = parser.getValue();
    String version = parser.getVersion();
    if (version == null) {
        version = startVersionDialog(key);
    }
    boolean sucessUpdate = persist(key, value, version);
    if (!sucessUpdate) {
        log.debug("setValue: error setting " + key + "'s value. No such entry" + (version == null ? "" : " with version " + version) + ".");
        throw new IllegalArgumentException("Error setting " + key + "'s value. No such entry" + (version == null ? "" : " with version " + version) + ".");
    }
}
#method_after
private void persistValue() throws Exception {
    String key = parser.getKey();
    String value = parser.getValue();
    String version = parser.getVersion();
    if (version == null) {
        version = startVersionDialog(key);
    }
    boolean sucessUpdate = persist(key, value, version);
    if (!sucessUpdate) {
        log.debug("setValue: error setting {}'s value. No such entry{}{}.", key, version == null ? "" : " with version ", version);
        throw new IllegalArgumentException("Error setting " + key + "'s value. No such entry" + (version == null ? "" : " with version " + version) + ".");
    }
}
#end_block

#method_before
private ConfigKey getConfigKey(String key) {
    ConfigKey ckReturn = null;
    ckReturn = configKeyFactory.generateByPropertiesKey(key);
    if (ckReturn == null || ckReturn.getKey() == null) {
        ckReturn = null;
        log.debug("getConfigKey: Unable to fetch the value of " + key + ".");
    }
    return ckReturn;
}
#method_after
private ConfigKey getConfigKey(String key) {
    ConfigKey ckReturn = null;
    ckReturn = configKeyFactory.generateByPropertiesKey(key);
    if (ckReturn == null || ckReturn.getKey() == null) {
        ckReturn = null;
        log.debug("getConfigKey: Unable to fetch the value of {}.", key);
    }
    return ckReturn;
}
#end_block

#method_before
public ConfigKey fetchConfigKey(String key, String version) {
    ConfigKey configKey = getConfigKey(key);
    if (configKey == null || configKey.getKey() == null) {
        log.debug("Unable to fetch the value of " + key + " in version " + version);
        return null;
    }
    configKey.setVersion(version);
    log.debug("Fetching key=" + configKey.getKey() + " ver=" + version);
    try {
        return getConfigDAO().getKey(configKey);
    } catch (SQLException e) {
        return null;
    }
}
#method_after
public ConfigKey fetchConfigKey(String key, String version) {
    ConfigKey configKey = getConfigKey(key);
    if (configKey == null || configKey.getKey() == null) {
        log.debug("Unable to fetch the value of {} in version {}", key, version);
        return null;
    }
    configKey.setVersion(version);
    log.debug("Fetching key={} ver={}", configKey.getKey(), version);
    try {
        return getConfigDAO().getKey(configKey);
    } catch (SQLException e) {
        return null;
    }
}
#end_block

#method_before
@Test
public void getValueWithMultipleVersions() throws Exception {
    final String key = "MaxNumOfVmSockets";
    log.info("getValue: Testing fetch multiple version of " + key);
    List<ConfigKey> keys = config.getEngineConfigLogic().getConfigDAO().getKeysForName(key);
    for (ConfigKey configKey : keys) {
        log.info(configKey.getDisplayValue() + " version: " + configKey.getVersion());
    }
    Assert.assertTrue(keys.size() > 0);
}
#method_after
@Test
public void getValueWithMultipleVersions() throws Exception {
    final String key = "MaxNumOfVmSockets";
    log.info("getValue: Testing fetch multiple version of {}", key);
    List<ConfigKey> keys = config.getEngineConfigLogic().getConfigDAO().getKeysForName(key);
    for (ConfigKey configKey : keys) {
        log.info("{} version: {}", configKey.getDisplayValue(), configKey.getVersion());
    }
    Assert.assertTrue(keys.size() > 0);
}
#end_block

#method_before
public void setUpAndExecute(EngineConfigCLIParser parser) throws Exception {
    log.debug("Arguments have been parsed: " + parser.engineConfigMapToString());
    ConfigActionType actionType = parser.getConfigAction();
    actionType.validate(parser.getEngineConfigMap());
    setEngineConfigLogic(new EngineConfigLogic(parser));
    engineConfigLogic.execute();
}
#method_after
public void setUpAndExecute(EngineConfigCLIParser parser) throws Exception {
    log.debug("Arguments have been parsed: {}", parser.engineConfigMapToString());
    ConfigActionType actionType = parser.getConfigAction();
    actionType.validate(parser.getEngineConfigMap());
    setEngineConfigLogic(new EngineConfigLogic(parser));
    engineConfigLogic.execute();
}
#end_block

#method_before
public void execute() throws MojoExecutionException {
    // Make sure the list of modules is not empty:
    if (modules == null) {
        modules = new ArrayList<Module>(1);
    }
    // artifact of this project:
    if (modules.isEmpty()) {
        Module module = new Module();
        module.setArtifactId(project.getArtifactId());
        module.setGroupId(project.getGroupId());
        modules.add(module);
    }
    // Locate the target directory:
    File targetDir = new File(project.getBuild().getDirectory());
    // Create the modules directory in the temporary build directory:
    modulesDir = new File(targetDir, "modules");
    getLog().info("Creating modules directory \"" + modulesDir + "\"");
    if (!modulesDir.exists()) {
        if (!modulesDir.mkdirs()) {
            throw new MojoExecutionException("Can't create target modules directory \"" + modulesDir.getAbsolutePath() + "\"");
        }
    }
    // Copy any content from the source modules directory to the modules
    // directory:
    String sourcePath = "src" + File.separator + "main" + File.separator + "modules";
    File sourceDir = new File(project.getBasedir(), sourcePath);
    getLog().info("Copying module resources to \"" + modulesDir + "\"");
    if (sourceDir.exists()) {
        try {
            FileUtils.copyDirectoryStructure(sourceDir, modulesDir);
        } catch (IOException exception) {
            throw new MojoExecutionException("Can't copy source modules directory \"" + sourceDir.getAbsolutePath() + "\" " + "to target modules directory \"" + modulesDir.getAbsolutePath() + "\"", exception);
        }
    }
    // Generate the modules:
    for (Module module : modules) {
        createModule(module);
    }
    // Create the archive containing all the contents of the modules
    // directory:
    File modulesArchive = new File(targetDir, String.format("%s-%s-modules.zip", project.getBuild().getFinalName(), category));
    ZipArchiver modulesArchiver = new ZipArchiver();
    modulesArchiver.setDestFile(modulesArchive);
    modulesArchiver.addDirectory(modulesDir);
    getLog().info("Creating module archive \"" + modulesArchive + "\"");
    try {
        modulesArchiver.createArchive();
    } catch (Exception exception) {
        throw new MojoExecutionException("Can't generate modules archive \"" + modulesArchive.getAbsolutePath() + "\"", exception);
    }
    // Attach the generated zip file containing the modules as an
    // additional artifact:
    getLog().info("Attaching modules artifact \"" + modulesArchive + "\"");
    projectHelper.attachArtifact(project, "zip", "modules", modulesArchive);
}
#method_after
public void execute() throws MojoExecutionException {
    // Make sure the list of modules is not empty:
    if (modules == null) {
        modules = new ArrayList<Module>(1);
    }
    // artifact of this project:
    if (modules.isEmpty()) {
        Module module = new Module();
        module.setArtifactId(project.getArtifactId());
        module.setGroupId(project.getGroupId());
        modules.add(module);
    }
    // Locate the target directory:
    File targetDir = new File(project.getBuild().getDirectory());
    // Create the modules directory in the temporary build directory:
    modulesDir = new File(targetDir, "modules");
    getLog().info("Creating modules directory \"" + modulesDir + "\"");
    if (!modulesDir.exists()) {
        if (!modulesDir.mkdirs()) {
            throw new MojoExecutionException("Can't create target modules directory \"" + modulesDir.getAbsolutePath() + "\"");
        }
    }
    // Copy any content from the source modules directory to the modules
    // directory:
    String sourcePath = "src" + File.separator + "main" + File.separator + "modules";
    File sourceDir = new File(project.getBasedir(), sourcePath);
    getLog().info("Copying module resources to \"" + modulesDir + "\"");
    if (sourceDir.exists()) {
        try {
            FileUtils.copyDirectoryStructure(sourceDir, modulesDir);
        } catch (IOException exception) {
            throw new MojoExecutionException("Can't copy source modules directory \"" + sourceDir.getAbsolutePath() + "\" " + "to target modules directory \"" + modulesDir.getAbsolutePath() + "\"", exception);
        }
    }
    // Generate the modules:
    for (Module module : modules) {
        createModule(module);
    }
    // Create the archive containing all the contents of the modules
    // directory:
    File modulesArchive = new File(targetDir, String.format("%s-%s-modules.zip", project.getBuild().getFinalName(), category));
    ZipArchiver modulesArchiver = new ZipArchiver();
    modulesArchiver.setDestFile(modulesArchive);
    modulesArchiver.addDirectory(modulesDir);
    getLog().info("Creating module archive \"" + modulesArchive + "\"");
    try {
        modulesArchiver.createArchive();
    } catch (Exception exception) {
        throw new MojoExecutionException("Can't generate modules archive \"" + modulesArchive.getAbsolutePath() + "\"", exception);
    }
    // Attach the generated zip file containing the modules as an
    // additional artifact:
    getLog().info("Attaching modules artifact \"" + modulesArchive + "\"");
    projectHelper.attachArtifact(project, "zip", String.format("%s-modules", category), modulesArchive);
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmNumaNodeRuntimeData();
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getUsageMemPercent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getUsageCpuPercent() != null && stat.getUsageCpuPercent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getUsageCpuPercent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getSwapTotal() == null || stat.getSwapFree() == null || stat.getSwapTotal() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getSwapTotal() - stat.getSwapFree()) / stat.getSwapTotal();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getSwapFree() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getSwapFree() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getSwapFree().toString());
        logable.addCustomValue("Threshold", stat.getSwapFree() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = null;
        if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(_vds.getVdsGroupCompatibilityVersion()) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
            try {
                logicalName = getDeviceLogicalName((Map<?, ?>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
            } catch (Exception e) {
                log.errorFormat("error while getting device name when processing, vm {0}, device info {1} with exception, skipping", vmId, device, e);
            }
        }
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device, logicalName);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            vmDevice.setLogicalName(logicalName);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device, String logicalName) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null, logicalName);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#end_block

#method_before
public static List<Pair<EditableDeviceOnVmStatusField, Boolean>> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = new ArrayList<>();
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        Boolean isEnabled = null;
        try {
            isEnabled = (Boolean) field.get(objectWithEditableDeviceFields);
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("VmHandler:: isUpdateValidForVmDevices: Reflection error");
        }
        // if device type is set to unknown, search by general type only
        // because some devices has more than one type, like sound can be ac97/ich6
        String device = null;
        if (annotation.type() != VmDeviceType.UNKNOWN) {
            device = annotation.type().getName();
        }
        if (isEnabled == null || !VmDeviceUtils.vmDeviceChanged(vmId, annotation.generalType(), device, isEnabled)) {
            continue;
        }
        if (!VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            fieldList.add(new Pair<>(annotation, isEnabled));
        }
    }
    return fieldList;
}
#method_after
public static List<Pair<EditableDeviceOnVmStatusField, Boolean>> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        Boolean isEnabled = null;
        try {
            isEnabled = (Boolean) field.get(objectWithEditableDeviceFields);
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("VmHandler:: isUpdateValidForVmDevices: Reflection error");
            log.debug("Original exception was:", e);
        }
        // if device type is set to unknown, search by general type only
        // because some devices has more than one type, like sound can be ac97/ich6
        String device = null;
        if (annotation.type() != VmDeviceType.UNKNOWN) {
            device = annotation.type().getName();
        }
        if (isEnabled == null || !VmDeviceUtils.vmDeviceChanged(vmId, annotation.generalType(), device, isEnabled)) {
            continue;
        }
        if (!VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            fieldList.add(new Pair<>(annotation, isEnabled));
        }
    }
    return fieldList;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if ((getParameters().getVm() != null) && (!StringUtils.isBlank(getParameters().getVm().getName()))) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getVm() != null && !StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED));
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    if (MultiLevelAdministrationHandler.isAdminUser(getUser())) {
        VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceGeneralType.DISK);
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                VmPayload payload = new VmPayload(disk);
                payload.setDeviceType(VmDeviceType.valueOf(disk.getDevice().toUpperCase()));
                for (Map.Entry<String, String> entry : payload.getFiles().entrySet()) {
                    entry.setValue(new String(Base64.decodeBase64(entry.getValue())));
                }
                getQueryReturnValue().setReturnValue(payload);
            }
        }
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    if (MultiLevelAdministrationHandler.isAdminUser(getUser())) {
        VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceGeneralType.DISK);
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                VmPayload payload = new VmPayload(disk);
                for (Map.Entry<String, String> entry : payload.getFiles().entrySet()) {
                    entry.setValue(new String(Base64.decodeBase64(entry.getValue())));
                }
                getQueryReturnValue().setReturnValue(payload);
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(1, 2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2, 1);
    setUpGetRngDeviceExpectations(2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(1, 2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2, 1);
    setUpGetRngDeviceExpectations(2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#method_after
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetSoundcardExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetSoundcardExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#method_after
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        if (vmNumaNodes.isEmpty()) {
            return;
        }
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#end_block

#method_before
private void loadPayload() {
    VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
    List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getVmId(), VmDeviceGeneralType.DISK);
    for (VmDevice disk : disks) {
        if (VmPayload.isPayload(disk.getSpecParams())) {
            VmPayload payload = new VmPayload(disk);
            payload.setDeviceType(VmDeviceType.valueOf(disk.getDevice().toUpperCase()));
            getVm().setVmPayload(payload);
            break;
        }
    }
}
#method_after
private void loadPayload() {
    VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
    List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getVmId(), VmDeviceGeneralType.DISK);
    for (VmDevice disk : disks) {
        if (VmPayload.isPayload(disk.getSpecParams())) {
            VmPayload payload = new VmPayload(disk);
            getVm().setVmPayload(payload);
            break;
        }
    }
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPaloadExists(VmDeviceType.FLOPPY.getName())) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPaloadExists(VmDeviceType.CDROM.getName())) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.getCpuId(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    if (isRunAsStateless()) {
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    if (isRunAsStateless()) {
        return validateSpaceRequirements();
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    return true;
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources(), null));
    }
    if (model.isSetFencingPolicy()) {
        entity = map(model.getFencingPolicy(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources(), null));
    }
    if (model.isSetFencingPolicy()) {
        entity.setFencingPolicy(FencingPolicyMapper.map(model.getFencingPolicy(), null));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(map(entity, new FencingPolicy()));
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    return model;
}
#end_block

#method_before
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    final int UNKNOWN_RESULT_ALLOWED = 3;
    int i = 1;
    int j = 1;
    boolean statusReached = false;
    log.infoFormat("Waiting for vds {0} to {1}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(getSleep(actionType, order));
    // a potential preferred proxy host has connectivity problems and can not access the fenced host PM card
    if (executor.findProxyHost()) {
        while (!statusReached && i <= getRerties()) {
            log.infoFormat("Attempt {0} to get vds {1} status", i, vdsName);
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // Allow command to fail temporarily
                    if (j <= UNKNOWN_RESULT_ALLOWED && i <= getRerties()) {
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                        i++;
                        j++;
                        continue;
                    }
                    // No need to retry , agent definitions are corrupted
                    log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", vdsName, order.name(), actionType.name());
                    break;
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.infoFormat("vds {0} status is {1}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.errorFormat("Failed to get host {0} status.", vdsName);
                break;
            }
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        auditLogable.setVdsId(getVds().getId());
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#method_after
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    final int UNKNOWN_RESULT_ALLOWED = 3;
    int i = 1;
    int j = 1;
    boolean statusReached = false;
    log.infoFormat("Waiting for vds {0} to {1}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(getSleep(actionType, order));
    // a potential preferred proxy host has connectivity problems and can not access the fenced host PM card
    if (executor.findProxyHost()) {
        while (!statusReached && i <= getRerties()) {
            log.infoFormat("Attempt {0} to get vds {1} status", i, vdsName);
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // Allow command to fail temporarily
                    if (j <= UNKNOWN_RESULT_ALLOWED && i <= getRerties()) {
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                        i++;
                        j++;
                    } else {
                        // No need to retry , agent definitions are corrupted
                        log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", vdsName, order.name(), actionType.name());
                        break;
                    }
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.infoFormat("vds {0} status is {1}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.errorFormat("Failed to get host {0} status.", vdsName);
                break;
            }
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        auditLogable.setVdsId(getVds().getId());
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final StorageDomain dom = getStorageDomain();
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    setSucceeded(false);
    if (isLocalFs(dom) && isDomainAttached(dom) && !detachStorage(dom)) {
        return;
    }
    if (!isISO(dom) && !isExport(dom) || format) {
        Pair<Boolean, VdcFault> connectResult = connectStorage();
        if (!connectResult.getFirst()) {
            getReturnValue().setFault(connectResult.getSecond());
            return;
        }
        boolean failed = !formatStorage(dom, vds);
        disconnectStorage();
        if (failed) {
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStorageHelper(dom).storageDomainRemoved(dom.getStorageStaticData());
            getStorageDomainDAO().remove(dom.getId());
            return null;
        }
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final StorageDomain dom = getStorageDomain();
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    setSucceeded(false);
    if (isLocalFs(dom) && isDomainAttached(dom) && !detachStorage(dom)) {
        return;
    }
    if (format) {
        Pair<Boolean, VdcFault> connectResult = connectStorage();
        if (!connectResult.getFirst()) {
            getReturnValue().setFault(connectResult.getSecond());
            return;
        }
        boolean failed = !formatStorage(dom, vds);
        disconnectStorage();
        if (failed) {
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStorageHelper(dom).storageDomainRemoved(dom.getStorageStaticData());
            getStorageDomainDAO().remove(dom.getId());
            return null;
        }
    });
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    StorageDomain dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    boolean localFs = isLocalFs(dom);
    if (!checkStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !checkStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!initializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (isDataDomain(dom) && !format) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_STORAGE_DOMAIN_DO_FORMAT);
        return false;
    }
    if (dom.getStorageType() == StorageType.GLANCE) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    StorageDomain dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean localFs = isLocalFs(dom);
    if (!checkStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !checkStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!initializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (dom.getStorageType() == StorageType.GLANCE) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean detachStorage(StorageDomain dom) {
    Guid domId = dom.getId();
    Guid poolId = dom.getStoragePoolId();
    DetachStorageDomainFromPoolParameters params = new DetachStorageDomainFromPoolParameters(domId, poolId);
    params.setDestroyingPool(getParameters().getDestroyingPool());
    return getBackend().runInternalAction(VdcActionType.DetachStorageDomainFromPool, params).getSucceeded();
}
#method_after
protected boolean detachStorage(StorageDomain dom) {
    Guid domId = dom.getId();
    Guid poolId = dom.getStoragePoolId();
    DetachStorageDomainFromPoolParameters params = new DetachStorageDomainFromPoolParameters(domId, poolId);
    params.setDestroyingPool(getParameters().getDestroyingPool());
    return getBackend().runInternalAction(VdcActionType.DetachStorageDomainFromPool, params, cloneContext().withoutCompensationContext().withoutExecutionContext()).getSucceeded();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    VdcBllMessages errMsg = AbstractVmNumaNodeCommand.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId());
    if (errMsg != null) {
        return failCanDoAction(errMsg);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    VdcBllMessages errMsg = AbstractVmNumaNodeCommand.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId());
    if (errMsg != null) {
        return failCanDoAction(errMsg);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    VdcBllMessages errorMsg = checkNumaPreferredTuneMode(getParameters().getNumaTuneMode(), vmNumaNodes, getVmId());
    if (errorMsg != null) {
        return failCanDoAction(errorMsg);
    }
    if (vmNumaNodes == null || vmNumaNodes.size() == 0) {
        // if VM do not contain any NUMA node, skip checking
        return true;
    }
    boolean pinHost = !Config.<Boolean>getValue(ConfigValues.SupportNUMAMigration);
    Guid vdsId = getDedicatedHost();
    if (pinHost && vdsId == null && getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_NUMA_PINNED_VDS_NOT_EXIST);
    }
    List<VdsNumaNode> hostNumaNodes = new ArrayList<>();
    if (pinHost) {
        hostNumaNodes = getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
        if (hostNumaNodes == null || hostNumaNodes.size() == 0) {
            return failCanDoAction(VdcBllMessages.VM_NUMA_PINNED_VDS_NODE_EMPTY);
        }
    }
    boolean memStrict = getNumaTuneMode() == NumaTuneMode.STRICT;
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() == null || pair.getSecond().getSecond() == null) {
                return failCanDoAction(VdcBllMessages.VM_NUMA_NODE_PINNED_INDEX_ERROR);
            }
            Integer index = pair.getSecond().getSecond();
            for (VdsNumaNode vdsNumaNode : hostNumaNodes) {
                if (vdsNumaNode.getIndex() == index) {
                    if (memStrict && vmNumaNode.getMemTotal() > vdsNumaNode.getMemTotal()) {
                        return failCanDoAction(VdcBllMessages.VM_NUMA_NODE_MEMRORY_ERROR);
                    }
                    break;
                }
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getNumaTuneMode(), vmNumaNodes, getVmId()))) {
        return false;
    }
    if (vmNumaNodes == null || vmNumaNodes.size() == 0) {
        // if VM do not contain any NUMA node, skip checking
        return true;
    }
    boolean pinHost = !Config.<Boolean>getValue(ConfigValues.SupportNUMAMigration);
    Guid vdsId = getDedicatedHost();
    if (pinHost && vdsId == null && getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_NUMA_PINNED_VDS_NOT_EXIST);
    }
    List<VdsNumaNode> hostNumaNodes = new ArrayList<>();
    if (pinHost) {
        hostNumaNodes = getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
        if (hostNumaNodes == null || hostNumaNodes.size() == 0) {
            return failCanDoAction(VdcBllMessages.VM_NUMA_PINNED_VDS_NODE_EMPTY);
        }
    }
    boolean memStrict = getNumaTuneMode() == NumaTuneMode.STRICT;
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() == null || pair.getSecond().getSecond() == null) {
                return failCanDoAction(VdcBllMessages.VM_NUMA_NODE_PINNED_INDEX_ERROR);
            }
            Integer index = pair.getSecond().getSecond();
            for (VdsNumaNode vdsNumaNode : hostNumaNodes) {
                if (vdsNumaNode.getIndex() == index) {
                    if (memStrict && vmNumaNode.getMemTotal() > vdsNumaNode.getMemTotal()) {
                        return failCanDoAction(VdcBllMessages.VM_NUMA_NODE_MEMRORY_ERROR);
                    }
                    break;
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    if (!(value instanceof String)) {
        result.setSuccess(false);
        result.setReasons(Arrays.asList(ConstantsManager.getInstance().getConstants().StringArgExpected()));
        return result;
    }
    String cidr = (String) value;
    if (!CidrValidator.isCidrFormatValid(cidr)) {
        result.setSuccess(false);
        result.setReasons(Arrays.asList(ConstantsManager.getInstance().getConstants().CidrBadFormat()));
        return result;
    }
    if (!CidrValidator.isCidrValidNetworkAddress(cidr)) {
        result.setSuccess(false);
        result.setReasons(Arrays.asList(ConstantsManager.getInstance().getConstants().CidrNotNetworkAddress()));
        return result;
    }
    result.setSuccess(true);
    return result;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    // This validation must be applied to a String
    assert value == null || value instanceof String;
    String cidr = (String) value;
    ValidationResult result = new ValidationResult();
    if (!CidrValidator.getInstance().isCidrFormatValid(cidr)) {
        failWith(result, getThisFieldMustContainCidrInFormatMsg());
    } else if (!CidrValidator.getInstance().isCidrNetworkAddressValid(cidr)) {
        failWith(result, getCidrNotNetworkAddress());
    }
    return result;
}
#end_block

#method_before
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    return CidrValidatorTest.data();
}
#method_after
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    return Arrays.asList(new Object[][] { // Bad Format
    { "a.a.a.a", false, false }, // Not A Network address
    { "253.0.0.32/26", true, false }, // valid CIDR
    { "255.255.255.255/32", true, true } });
}
#end_block

#method_before
@Override
public boolean isValid(String cidr, ConstraintValidatorContext context) {
    boolean isCidrFormat = CidrValidator.isCidrFormatValid(cidr);
    if (!isCidrFormat) {
        return false;
    }
    boolean isNetworkAddress = CidrValidator.isCidrValidNetworkAddress(cidr);
    if (!isNetworkAddress) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate("CIDR_NOT_NETWORK_ADDRESS").addNode("cidr").addConstraintViolation();
        return false;
    }
    return true;
}
#method_after
@Override
public boolean isValid(String cidr, ConstraintValidatorContext context) {
    if (!isCidrFormatValid(cidr)) {
        return failWith(context, VdcBllMessages.BAD_CIDR_FORMAT.name());
    }
    if (!isCidrNetworkAddressValid(cidr)) {
        return failWith(context, VdcBllMessages.CIDR_NOT_NETWORK_ADDRESS.name());
    }
    return true;
}
#end_block

#method_before
protected Set<Guid> getStorageDomainsIds() {
    Set<Guid> storageIds = new HashSet<>();
    for (DiskImage disk : getSourceImages()) {
        storageIds.addAll(disk.getStorageIds());
    }
    return storageIds;
}
#method_after
protected Collection<Guid> getStorageDomainsIds() {
    return ImagesHandler.getAllStorageIdsForImageIds(getSourceImages());
}
#end_block

#method_before
protected MultipleStorageDomainsValidator getStorageDomainsValidator(Guid spId, Set<Guid> sdIds) {
    return new MultipleStorageDomainsValidator(spId, sdIds);
}
#method_after
protected MultipleStorageDomainsValidator getStorageDomainsValidator(Guid spId, Collection<Guid> sdIds) {
    return new MultipleStorageDomainsValidator(spId, sdIds);
}
#end_block

#method_before
protected List<DiskImage> getImages() {
    if (images == null) {
        images = new ArrayList<>();
        for (Guid imageId : getParameters().getImageIds()) {
            if (imageId == null) {
                // Disks existence is validated in canDoAction
                continue;
            }
            images.add(getDiskImageDao().getSnapshotById(imageId));
        }
    }
    return images;
}
#method_after
protected List<DiskImage> getImages() {
    if (images == null) {
        images = new ArrayList<>();
        for (Guid imageId : getParameters().getImageIds()) {
            if (imageId == null) {
                // Disks existence is validated in canDoAction
                continue;
            }
            DiskImage image = getDiskImageDao().getSnapshotById(imageId);
            if (image != null) {
                images.add(image);
            }
        }
    }
    return images;
}
#end_block

#method_before
protected boolean validateStorageDomainAvailableSpace() {
    return validate(getStorageDomainValidator().hasSpaceForClonedDisks(getImages()));
}
#method_after
protected boolean validateStorageDomainAvailableSpace() {
    // (as opposed to the whole chain).
    return validate(getStorageDomainValidator().hasSpaceForClonedDisks(getImages()));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    return vds;
}
#end_block

#method_before
@Override
protected VDSExceptionBase createDefaultConcreteException(String errorMessage) {
    StorageDomain domainFromDb = DbFacade.getInstance().getStorageDomainDao().get(getParameters().getStorageDomainId());
    if (domainFromDb == null || domainFromDb.getStorageDomainType() == StorageDomainType.ImportExport || domainFromDb.getStorageDomainType() == StorageDomainType.ISO) {
        return new IrsOperationFailedNoFailoverException(errorMessage);
    }
    return super.createDefaultConcreteException(errorMessage);
}
#method_after
@Override
protected VDSExceptionBase createDefaultConcreteException(String errorMessage) {
    StorageDomain domainFromDb = DbFacade.getInstance().getStorageDomainDao().get(getParameters().getStorageDomainId());
    if (domainFromDb == null || !domainFromDb.getStorageDomainType().isDataDomain()) {
        return new IrsOperationFailedNoFailoverException(errorMessage);
    }
    return super.createDefaultConcreteException(errorMessage);
}
#end_block

#method_before
private GlusterBrickEntity getBrickEntity(GlusterVolumeEntity volume, Map<String, Object> brick) {
    String brickName = (String) brick.get(BRICK);
    String glusterHostUuid = (String) brick.get(HOST_UUID);
    if (!StringUtils.isEmpty(glusterHostUuid)) {
        GlusterServer glusterServer = GlusterDBUtils.getInstance().getServerByUuid(Guid.createGuidFromString(glusterHostUuid));
        if (glusterServer == null) {
            log.warnFormat("Could not update brick {0} to volume {1} - server uuid {2} not found", brickName, volume.getName(), glusterHostUuid);
            return null;
        }
        String[] brickParts = brickName.split(":", -1);
        if (brickParts.length != 2) {
            log.warnFormat("Invalid brick representation [" + brickName + "]");
            return null;
        }
        String brickDir = brickParts[1];
        VdsStatic server = DbFacade.getInstance().getVdsStaticDao().get(glusterServer.getId());
        return DbFacade.getInstance().getGlusterBrickDao().getBrickByServerIdAndDirectory(server.getId(), brickDir);
    }
    return GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), brickName);
}
#method_after
private GlusterBrickEntity getBrickEntity(GlusterVolumeEntity volume, Map<String, Object> brick) {
    String brickName = (String) brick.get(BRICK);
    String glusterHostUuid = (String) brick.get(HOST_UUID);
    if (!StringUtils.isEmpty(glusterHostUuid)) {
        GlusterServer glusterServer = GlusterDBUtils.getInstance().getServerByUuid(Guid.createGuidFromString(glusterHostUuid));
        if (glusterServer == null) {
            log.warnFormat("Could not update brick {0} to volume {1} - server uuid {2} not found", brickName, volume.getName(), glusterHostUuid);
            return null;
        }
        String[] brickParts = brickName.split(":", -1);
        if (brickParts.length != 2) {
            log.warnFormat("Invalid brick representation [" + brickName + "]");
            return null;
        }
        String brickDir = brickParts[1];
        return DbFacade.getInstance().getGlusterBrickDao().getBrickByServerIdAndDirectory(glusterServer.getId(), brickDir);
    }
    return GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), brickName);
}
#end_block

#method_before
private static BaseErrorListener getListener() {
    return new BaseErrorListener() {

        @Override
        public void syntaxError(@NotNull Recognizer<?, ?> recognizer, @Nullable Object offendingSymbol, int line, int charPositionInLine, @NotNull String msg, @Nullable RecognitionException e) {
            log.error("line " + line + ":" + charPositionInLine + " " + msg);
            throw new RuntimeException("parsing error");
        }
    };
}
#method_after
private static BaseErrorListener getListener() {
    return new BaseErrorListener() {

        @Override
        public void syntaxError(@NotNull Recognizer<?, ?> recognizer, @Nullable Object offendingSymbol, int line, int charPositionInLine, @NotNull String msg, @Nullable RecognitionException e) {
            throw new RuntimeException("osinfo properties syntax error: " + ("line " + line + ":" + charPositionInLine + " " + msg));
        }
    };
}
#end_block

#method_before
@Parameters
public static Collection<Object[]> data() {
    return Arrays.asList(new Object[][] { // Bad Format
    { null, false }, { "", false }, { "?\"?>!", false }, { "a", false }, { "a.a", false }, { "a.a.a", false }, { "a.a.a.a", false }, { "a.a.a.a/a", false }, { "1.1.1.1/33", false }, { "1111.1.1.1/1", false }, { "1111.1.1.1/32", false }, { "1.1.1.1/1/1", false }, { "1.1/1.1/.1/.1", false }, { "256.1.1.1/1", false }, { "256.1.1.1/32", false }, { "256.1.1.1/222222222222222222222222", false }, { "255.?.?././", false }, { "255?23?1?0/8", false }, { "23\22\22\22\22\\", false }, { ".................", false }, { "././././", false }, { "?/?/?/?/", false }, // Not A Network address
    { "255.255.255.250/16", false }, { "255.255.255.255/16", false }, { "255.255.255.255/1", false }, { "255.255.255.253/2", false }, { "255.255.255.247/3", false }, { "255.255.255.243/4", false }, { "255.255.255.228/5", false }, { "255.255.255.199/6", false }, { "255.255.255.119/7", false }, { "255.255.255.16/8", false }, { "255.255.254.128/9", false }, { "255.255.252.64/10", false }, { "255.255.255.0/11", false }, { "255.255.253.0/12", false }, { "255.255.240.0/13", false }, { "255.255.200.17/14", false }, { "255.255.140.0/15", false }, { "255.255.64.0/16", false }, { "255.254.128.0/17", false }, { "255.255.0.0/18", false }, { "255.248.64.0/19", false }, { "255.240.54.32/20", false }, { "255.225.0.0/21", false }, { "255.193.0.0/22", false }, { "255.14.1.0/23", false }, { "255.1.0.0/24", false }, { "255.0.0.64/25", false }, { "253.0.0.0/26", false }, { "249.43.32.0/27", false }, { "245.0.0.0/28", false }, { "226.0.0.0/29", false }, { "198.0.0.0/30", false }, { "130.0.0.0/31", false }, { "1.0.0.0/32", false }, // valid CIDR
    { "255.255.255.255/0", true }, { "255.255.255.254/1", true }, { "255.255.255.252/2", true }, { "255.255.255.248/3", true }, { "255.255.255.240/4", true }, { "255.255.255.224/5", true }, { "255.255.255.192/6", true }, { "255.255.255.128/7", true }, { "255.255.255.0/8", true }, { "255.255.254.0/9", true }, { "255.255.252.0/10", true }, { "255.255.248.0/11", true }, { "255.255.240.0/12", true }, { "255.255.224.0/13", true }, { "255.255.192.0/14", true }, { "255.255.128.0/15", true }, { "255.255.0.0/16", true }, { "255.254.0.0/17", true }, { "255.252.0.0/18", true }, { "255.248.0.0/19", true }, { "255.240.0.0/20", true }, { "255.224.0.0/21", true }, { "255.192.0.0/22", true }, { "255.128.0.0/23", true }, { "255.0.0.0/24", true }, { "254.0.0.0/25", true }, { "252.0.0.0/26", true }, { "248.0.0.0/27", true }, { "240.0.0.0/28", true }, { "224.0.0.0/29", true }, { "192.0.0.0/30", true }, { "128.0.0.0/31", true }, { "0.0.0.0/32", true }, { "255.255.255.255/0", true }, { "255.255.255.254/1", true }, { "255.255.255.252/2", true }, { "255.255.255.248/3", true }, { "255.255.255.240/4", true }, { "255.255.255.224/5", true }, { "255.255.255.192/6", true }, { "255.255.255.128/7", true }, { "255.255.255.0/8", true }, { "255.0.254.0/9", true }, { "255.0.252.0/10", true }, { "255.0.248.0/11", true }, { "255.0.240.0/12", true }, { "255.0.224.0/13", true }, { "255.0.192.0/14", true }, { "255.0.128.0/15", true }, { "255.0.0.0/16", true }, // TODO elevi ask if this consider a valid cidr
    { "255.0.0.0/17", true }, { "255.0.0.0/18", true }, { "255.0.0.0/19", true }, { "255.0.0.0/20", true }, { "1.0.0.0/21", true }, { "1.0.0.0/22", true }, { "1.0.0.0/23", true }, { "1.0.0.0/24", true }, { "0.255.255.255/0", true }, { "0.255.255.254/1", true }, { "0.255.255.252/2", true }, { "05.255.255.248/3", true }, { "0.255.255.240/4", true }, { "0.255.255.224/5", true }, { "0.255.255.192/6", true }, { "0.255.255.128/7", true }, { "0.255.255.0/8", true }, { "0.255.254.0/9", true }, { "0.255.252.0/10", true }, { "0.255.248.0/11", true }, { "0.255.240.0/12", true }, { "0.255.224.0/13", true }, { "0.255.192.0/14", true }, { "0.255.128.0/15", true }, { "0.255.0.0/16", true } });
}
#method_after
@Parameters
public static Collection<Object[]> data() {
    return Arrays.asList(new Object[][] { // Bad Format
    { null, false, false }, { "", false, false }, { "?\"?>!", false, false }, { "a", false, false }, { "a.a", false, false }, { "a.a.a", false, false }, { "a.a.a.a", false, false }, { "a.a.a.a/a", false, false }, { "1", false, false }, { "1.1.1.1", false, false }, { "1.1.1.1/", false, false }, { "1000.1.1.1/24", false, false }, { "1.1000.1.1/24", false, false }, { "1.1.1000.1/24", false, false }, { "1.1.1.1000/24", false, false }, { "1.1.1.1/33", false, false }, { "1111.1.1.1/1", false, false }, { "1111.1.1.1/32", false, false }, { "1.1.1.1/1/1", false, false }, { "1.1/1.1/.1/.1", false, false }, { "256.1.1.1/1", false, false }, { "256.1.1.1/32", false, false }, { "256.1.1.1/222222222222222222222222", false, false }, { "255.?.?././", false, false }, { "255?23?1?0/8", false, false }, { "23\22\22\22\22\\", false, false }, { ".................", false, false }, { "././././", false, false }, { "?/?/?/?/", false, false }, // Not A Network address
    { "253.0.0.32/26", true, false }, { "255.255.255.192/25", true, false }, { "255.255.255.16/24", true, false }, { "255.254.192.0/17", true, false }, { "255.255.255.250/16", true, false }, { "255.255.192.17/14", true, false }, { "255.128.0.0/8", true, false }, { "240.255.255.247/3", true, false }, { "224.0.0.0/2", true, false }, { "192.0.0.0/1", true, false }, { "255.255.255.255/0", true, false }, // valid CIDR
    { "255.255.255.255/32", true, true }, { "0.0.0.0/32", true, true }, { "255.255.255.254/31", true, true }, { "255.255.255.248/29", true, true }, { "255.255.255.0/24", true, true }, { "255.255.254.0/23", true, true }, { "255.0.254.0/23", true, true }, { "255.255.0.0/16", true, true }, { "255.252.0.0/14", true, true }, { "255.0.0.0/8", true, true }, { "248.0.0.0/5", true, true }, { "128.0.0.0/1", true, true } });
}
#end_block

#method_before
public static boolean isCidrFormatValid(String cidr) {
    return (cidr == null || !cidr.matches(getCidrRegex())) ? false : true;
}
#method_after
public boolean isCidrFormatValid(String cidr) {
    return cidr != null && cidr.matches(ValidationUtils.CIDR_FORMAT_PATTERN);
}
#end_block

#method_before
private static int covnertIpToInt(String ipAdd) {
    String[] subAdd = ipAdd.split("\\.");
    int output = 0;
    int temp;
    for (int index = 3; index > -1; index--) {
        temp = Integer.parseInt(subAdd[3 - index]);
        temp <<= (index * 8);
        output |= temp;
    }
    return output;
}
#method_after
private static long covnertIpToInt(String ipAdd) {
    String[] subAdd = ipAdd.split("\\.");
    long output = 0;
    long temp;
    for (int index = 3; index > -1; index--) {
        temp = Integer.parseInt(subAdd[3 - index]);
        temp <<= (index * 8);
        output |= temp;
    }
    return output;
}
#end_block

#method_before
private static boolean isNetworkAddress(int ip, int mask) {
    int temp = 1;
    int check = 0;
    for (int i = 0; i < mask; i++) {
        check = temp & ip;
        if (check != 0) {
            return false;
        }
        temp <<= 1;
    }
    return true;
}
#method_after
private static boolean isNetworkAddress(long ip, int mask) {
    long postfix = (long) Math.pow(2, 32 - mask) - 1;
    return (ip & postfix) == 0;
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().isNextRunConfigurationChanged(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields.toString());
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    setRngDeviceToParams(model, updateVmParams);
    return updateVmParams;
}
#method_after
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    setRngDeviceToParams(model, updateVmParams);
    return updateVmParams;
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
        if (model.getProgress() != null) {
            return;
        }
        VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

            @Override
            public void vnicCreated(Guid vmId) {
            // do nothing
            }

            @Override
            public void queryFailed() {
            // do nothing
            }
        });
        model.startProgress(null);
        AddVmParameters parameters = new AddVmParameters(getcurrentVm());
        parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
        parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
        parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
        parameters.setBalloonEnabled(balloonEnabled(model));
        setVmWatchdogToParams(model, parameters);
        setRngDeviceToParams(model, parameters);
        Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                getWindow().stopProgress();
                VdcReturnValueBase returnValue = result.getReturnValue();
                if (returnValue != null && returnValue.getSucceeded()) {
                    setWindow(null);
                    setGuideContext(returnValue.getActionReturnValue());
                    updateActionAvailability();
                    getGuideCommand().execute();
                } else {
                    cancel();
                }
                super.executed(result);
            }
        }, this);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        if (model.getProvisioning().getEntity()) {
            model.startProgress(null);
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    VmListModel vmListModel = (VmListModel) model1;
                    UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                    VM vm = vmListModel.getcurrentVm();
                    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                    VmManagementParametersBase param = new VmManagementParametersBase(vm);
                    param.setDiskInfoDestinationMap(unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap());
                    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                    param.setBalloonEnabled(balloonEnabled(model));
                    param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                    setRngDeviceToParams(model, param);
                    Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                }
            };
            AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase params = new VmManagementParametersBase(vm);
            params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            params.setBalloonEnabled(balloonEnabled(model));
            params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
            ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
            parameters.add(params);
            params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            setVmWatchdogToParams(model, params);
            setRngDeviceToParams(model, params);
            Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        }
    }
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
        if (model.getProgress() != null) {
            return;
        }
        VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

            @Override
            public void vnicCreated(Guid vmId) {
            // do nothing
            }

            @Override
            public void queryFailed() {
            // do nothing
            }
        });
        model.startProgress(null);
        AddVmParameters parameters = new AddVmParameters(getcurrentVm());
        parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
        parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
        parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
        parameters.setBalloonEnabled(balloonEnabled(model));
        setVmWatchdogToParams(model, parameters);
        setRngDeviceToParams(model, parameters);
        Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                getWindow().stopProgress();
                VdcReturnValueBase returnValue = result.getReturnValue();
                if (returnValue != null && returnValue.getSucceeded()) {
                    setWindow(null);
                    setGuideContext(returnValue.getActionReturnValue());
                    updateActionAvailability();
                    getGuideCommand().execute();
                } else {
                    cancel();
                }
                super.executed(result);
            }
        }, this);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        if (model.getProvisioning().getEntity()) {
            model.startProgress(null);
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    VmListModel vmListModel = (VmListModel) model1;
                    UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                    VM vm = vmListModel.getcurrentVm();
                    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                    VmManagementParametersBase param = new VmManagementParametersBase(vm);
                    param.setDiskInfoDestinationMap(unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap());
                    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                    param.setBalloonEnabled(balloonEnabled(model));
                    param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                    setRngDeviceToParams(model, param);
                    Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                }
            };
            AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase params = new VmManagementParametersBase(vm);
            params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            params.setBalloonEnabled(balloonEnabled(model));
            params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
            params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            setVmWatchdogToParams(model, params);
            setRngDeviceToParams(model, params);
            Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        }
    }
}
#end_block

#method_before
public boolean IsFieldUpdatable(Enum<?> status, String name, Object fieldContainer, boolean hotsetEnabled) {
    boolean returnValue = true;
    if (!IsFieldUpdatable(name)) {
        if (fieldContainer != null && container != null && !container.canUpdateField(fieldContainer, name, status)) {
            returnValue = false;
        } else {
            Set<String> values = dictionary.get(status);
            returnValue = values != null ? values.contains(name) : false;
            // if field is not updateable in this status, check if hotset request and its an hotset allowed field
            if (!returnValue && hotsetEnabled) {
                returnValue = hotsetAllowedFields.contains(name);
            }
        }
        if (!returnValue) {
            LogError(name, status);
        }
    }
    return returnValue;
}
#method_after
public boolean IsFieldUpdatable(Enum<?> status, String name, Object fieldContainer, boolean hotsetEnabled) {
    boolean returnValue = true;
    if (!IsFieldUpdatable(name)) {
        if (fieldContainer != null && container != null && !container.canUpdateField(fieldContainer, name, status)) {
            returnValue = false;
        } else {
            Set<String> values = dictionary.get(status);
            returnValue = values != null ? values.contains(name) : false;
            // if field is not updateable in this status, check if hotset request and its an hotset allowed field
            if (!returnValue && hotsetEnabled) {
                returnValue = hotsetAllowedFields.contains(name);
            }
        }
        if (!returnValue) {
            log.warnFormat("Field {0} can not be updated when status is {1}", name, status);
        }
    }
    return returnValue;
}
#end_block

#method_before
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(Guid.Empty)) {
            AddVmParameters parameters = new AddVmParameters(gettempVm());
            parameters.setMakeCreatorExplicitOwner(true);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            setRngDeviceToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        } else {
            setstorageDomain(model.getStorageDomain().getSelectedItem());
            if (model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        final UnitVmModel unitVmModel = (UnitVmModel) userPortalListModel1.getWindow();
                        VM vm = gettempVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase param = new VmManagementParametersBase(vm);
                        param.setDiskInfoDestinationMap(unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap());
                        param.setMakeCreatorExplicitOwner(true);
                        param.setCopyTemplatePermissions(unitVmModel.getCopyPermissions().getEntity());
                        param.setSoundDeviceEnabled(unitVmModel.getIsSoundcardEnabled().getEntity());
                        param.setConsoleEnabled(unitVmModel.getIsConsoleDeviceEnabled().getEntity());
                        setRngDeviceToParams(unitVmModel, param);
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(unitVmModel, defaultNetworkCreatingManager), this);
                    }
                };
                AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, gettempVm().getVmtGuid());
            } else {
                VM vm = gettempVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase param = new VmManagementParametersBase(vm);
                param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                param.setMakeCreatorExplicitOwner(true);
                param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                setRngDeviceToParams(model, param);
                Frontend.getInstance().runAction(VdcActionType.AddVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().isNextRunConfigurationChanged(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields.toString());
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(Guid.Empty)) {
            AddVmParameters parameters = new AddVmParameters(gettempVm());
            parameters.setMakeCreatorExplicitOwner(true);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            setRngDeviceToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        } else {
            setstorageDomain(model.getStorageDomain().getSelectedItem());
            if (model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        final UnitVmModel unitVmModel = (UnitVmModel) userPortalListModel1.getWindow();
                        VM vm = gettempVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase param = new VmManagementParametersBase(vm);
                        param.setDiskInfoDestinationMap(unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap());
                        param.setMakeCreatorExplicitOwner(true);
                        param.setCopyTemplatePermissions(unitVmModel.getCopyPermissions().getEntity());
                        param.setSoundDeviceEnabled(unitVmModel.getIsSoundcardEnabled().getEntity());
                        param.setConsoleEnabled(unitVmModel.getIsConsoleDeviceEnabled().getEntity());
                        setRngDeviceToParams(unitVmModel, param);
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(unitVmModel, defaultNetworkCreatingManager), this);
                    }
                };
                AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, gettempVm().getVmtGuid());
            } else {
                VM vm = gettempVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase param = new VmManagementParametersBase(vm);
                param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                param.setMakeCreatorExplicitOwner(true);
                param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                setRngDeviceToParams(model, param);
                Frontend.getInstance().runAction(VdcActionType.AddVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#end_block

#method_before
public String getChangedFields() {
    return changedFields;
}
#method_after
public List<String> getChangedFields() {
    return changedFields;
}
#end_block

#method_before
public void setChangedFields(String changedFields) {
    this.changedFields = changedFields;
}
#method_after
public void setChangedFields(List<String> changedFields) {
    this.changedFields = changedFields;
}
#end_block

#method_before
@Override
public void edit(VmNextRunConfigurationModel object) {
    driver.edit(object);
    cpuPanel.setVisible(object.isCpuPluggable());
    changedFields.setHTML(SafeHtmlUtils.fromSafeConstant(object.getChangedFields()));
}
#method_after
@Override
public void edit(VmNextRunConfigurationModel object) {
    driver.edit(object);
    cpuPanel.setVisible(object.isCpuPluggable());
    SafeHtmlBuilder changedFieldsBuilder = new SafeHtmlBuilder();
    for (String field : object.getChangedFields()) {
        String escapedField = SafeHtmlUtils.htmlEscape(field);
        changedFieldsBuilder.append(listItem(escapedField, templates));
    }
    changedFields.setHTML(changedFieldsBuilder.toSafeHtml());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmNetworkInterface)) {
        return false;
    }
    VmNetworkInterface other = (VmNetworkInterface) obj;
    if (!ObjectUtils.objectsEqual(getNetworkName(), other.getNetworkName())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getVnicProfileName(), other.getVnicProfileName())) {
        return false;
    }
    if (isPortMirroring() != other.isPortMirroring()) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getVmName(), other.getVmName())) {
        return false;
    }
    if (isPlugged() != other.isPlugged()) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getQosName(), other.getNetworkName())) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmNetworkInterface)) {
        return false;
    }
    VmNetworkInterface other = (VmNetworkInterface) obj;
    if (!ObjectUtils.objectsEqual(other.getNetworkName(), other.getNetworkName())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(other.getVnicProfileName(), other.getVnicProfileName())) {
        return false;
    }
    if (isPortMirroring() != other.isPortMirroring()) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(other.getVmName(), other.getVmName())) {
        return false;
    }
    if (isPlugged() != other.isPlugged()) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getQosName(), other.getQosName())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    // we use %{x} convention to avoid conflict with jboss properties
    url = EngineLocalConfig.getInstance().expandString(config.getInitParameter(URL).replaceAll("%\\{", "\\${"));
    url404 = EngineLocalConfig.getInstance().expandString(config.getInitParameter(URL404).replaceAll("%\\{", "\\${"));
}
#method_after
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    // we use %{x} convention to avoid conflict with jboss properties
    url = EngineLocalConfig.getInstance().expandString(config.getInitParameter(URL).replaceAll("%\\{", "\\${"));
    String url404ConfigValue = config.getInitParameter(URL404);
    if (StringUtils.isNotEmpty(url404ConfigValue)) {
        url404 = EngineLocalConfig.getInstance().expandString(url404ConfigValue.replaceAll("%\\{", "\\${"));
    } else {
        url404 = url404Default;
    }
}
#end_block

#method_before
@Override
protected void executeImport() {
    ImportTemplateModel model = (ImportTemplateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object object : importModel.getItems()) {
        ImportTemplateData importData = (ImportTemplateData) object;
        VmTemplate template = importData.getTemplate();
        ImportVmTemplateParameters importVmTemplateParameters = new ImportVmTemplateParameters(model.getStoragePool().getId(), getEntity().getId(), Guid.Empty, ((VDSGroup) model.getCluster().getSelectedItem()).getId(), template);
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            importVmTemplateParameters.setQuotaId(((Quota) importModel.getClusterQuota().getSelectedItem()).getId());
        }
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (DiskImage disk : template.getDiskList()) {
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        importVmTemplateParameters.setImageToDestinationDomainMap(map);
        if (importData.isExistsInSystem() || (Boolean) importData.getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(template.getId())) {
                continue;
            }
            importVmTemplateParameters.setImportAsNewEntity(true);
            importVmTemplateParameters.getVmTemplate().setName(((ImportTemplateData) cloneObjectMap.get(template.getId())).getTemplate().getName());
        }
        prms.add(importVmTemplateParameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVmTemplate, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            TemplateBackupModel templateBackupModel = (TemplateBackupModel) result.getState();
            templateBackupModel.getWindow().stopProgress();
            templateBackupModel.cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && templateBackupModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedTemplates = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object a : templateBackupModel.getSelectedItems()) {
                    VmTemplate template = (VmTemplate) a;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedTemplates.append(template.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    templateBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importTemplatesTitle());
                    confirmModel.setHelpTag(HelpTag.import_template);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_template");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForTemplates(StringHelper.trimEnd(importedTemplates.toString().trim(), ',')));
                    // $NON-NLS-1$
                    UICommand tempVar = new UICommand("CancelConfirm", templateBackupModel);
                    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar.setIsDefault(true);
                    tempVar.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar);
                }
            }
        }
    }, this);
}
#method_after
@Override
protected void executeImport() {
    ImportTemplateModel model = (ImportTemplateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object object : importModel.getItems()) {
        ImportTemplateData importData = (ImportTemplateData) object;
        VmTemplate template = importData.getTemplate();
        ImportVmTemplateParameters importVmTemplateParameters = new ImportVmTemplateParameters(model.getStoragePool().getId(), getEntity().getId(), Guid.Empty, ((VDSGroup) model.getCluster().getSelectedItem()).getId(), template);
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            importVmTemplateParameters.setQuotaId(((Quota) importModel.getClusterQuota().getSelectedItem()).getId());
        }
        CpuProfile cpuProfile = importModel.getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            importVmTemplateParameters.setCpuProfileId(cpuProfile.getId());
        }
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (DiskImage disk : template.getDiskList()) {
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        importVmTemplateParameters.setImageToDestinationDomainMap(map);
        if (importData.isExistsInSystem() || (Boolean) importData.getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(template.getId())) {
                continue;
            }
            importVmTemplateParameters.setImportAsNewEntity(true);
            importVmTemplateParameters.getVmTemplate().setName(((ImportTemplateData) cloneObjectMap.get(template.getId())).getTemplate().getName());
        }
        prms.add(importVmTemplateParameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVmTemplate, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            TemplateBackupModel templateBackupModel = (TemplateBackupModel) result.getState();
            templateBackupModel.getWindow().stopProgress();
            templateBackupModel.cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && templateBackupModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedTemplates = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object a : templateBackupModel.getSelectedItems()) {
                    VmTemplate template = (VmTemplate) a;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedTemplates.append(template.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    templateBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importTemplatesTitle());
                    confirmModel.setHelpTag(HelpTag.import_template);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_template");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForTemplates(StringHelper.trimEnd(importedTemplates.toString().trim(), ',')));
                    // $NON-NLS-1$
                    UICommand tempVar = new UICommand("CancelConfirm", templateBackupModel);
                    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar.setIsDefault(true);
                    tempVar.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar);
                }
            }
        }
    }, this);
}
#end_block

#method_before
protected void executeImport() {
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object item : importModel.getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        ImportVmParameters prm = new ImportVmParameters(vm, getEntity().getId(), Guid.Empty, importModel.getStoragePool().getId(), ((VDSGroup) importModel.getCluster().getSelectedItem()).getId());
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(((Quota) importModel.getClusterQuota().getSelectedItem()).getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse((Boolean) ((ImportVmData) item).getCollapseSnapshots().getEntity());
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            disk.setvolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getStorageType()));
            disk.setVolumeType(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        prm.setImageToDestinationDomainMap(map);
        if (((ImportVmData) item).isExistsInSystem() || (Boolean) ((ImportVmData) item).getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(vm.getId())) {
                continue;
            }
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
            prm.getVm().setName(((ImportVmData) cloneObjectMap.get(vm.getId())).getVm().getName());
        }
        prms.add(prm);
    }
    importModel.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVm, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            VmBackupModel vmBackupModel = (VmBackupModel) result.getState();
            vmBackupModel.getWindow().stopProgress();
            vmBackupModel.cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && vmBackupModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedVms = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : vmBackupModel.getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms.append(vm.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    vmBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    confirmModel.setHelpTag(HelpTag.import_virtual_machine);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(StringHelper.trimEnd(importedVms.toString().trim(), ',')));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", vmBackupModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, this);
}
#method_after
protected void executeImport() {
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object item : importModel.getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        ImportVmParameters prm = new ImportVmParameters(vm, getEntity().getId(), Guid.Empty, importModel.getStoragePool().getId(), ((VDSGroup) importModel.getCluster().getSelectedItem()).getId());
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(((Quota) importModel.getClusterQuota().getSelectedItem()).getId());
        }
        CpuProfile cpuProfile = importModel.getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            prm.setCpuProfileId(cpuProfile.getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse((Boolean) ((ImportVmData) item).getCollapseSnapshots().getEntity());
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            disk.setvolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getStorageType()));
            disk.setVolumeType(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        prm.setImageToDestinationDomainMap(map);
        if (((ImportVmData) item).isExistsInSystem() || (Boolean) ((ImportVmData) item).getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(vm.getId())) {
                continue;
            }
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
            prm.getVm().setName(((ImportVmData) cloneObjectMap.get(vm.getId())).getVm().getName());
        }
        prms.add(prm);
    }
    importModel.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVm, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            VmBackupModel vmBackupModel = (VmBackupModel) result.getState();
            vmBackupModel.getWindow().stopProgress();
            vmBackupModel.cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && vmBackupModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedVms = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : vmBackupModel.getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms.append(vm.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    vmBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    confirmModel.setHelpTag(HelpTag.import_virtual_machine);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(StringHelper.trimEnd(importedVms.toString().trim(), ',')));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", vmBackupModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, this);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    StorageDomain dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    boolean localFs = isLocalFs(dom);
    if (!checkStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !checkStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!initializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (dom.getStorageType() == StorageType.GLANCE) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    StorageDomain dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean localFs = isLocalFs(dom);
    if (!checkStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !checkStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!initializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (dom.getStorageType() == StorageType.GLANCE) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        return false;
    }
    return true;
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setEntity(!storage.getStorageDomainType().isIsoOrImportExportDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setEntity(storage.getStorageDomainType().isDataDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void moveDiskInDB(final Guid sourceStorageDomainId, final Guid targetStorageDomainId, final Guid targetQuota, final Guid targetDiskProfile) {
    if (isMoveDiskInDbSucceded(targetStorageDomainId)) {
        return;
    }
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

        @SuppressWarnings("synthetic-access")
        @Override
        public Object runInTransaction() {
            for (DiskImage di : getDiskImageDao().getAllSnapshotsForImageGroup(getEnclosingCommand().getParameters().getImageGroupID())) {
                getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(di.getImageId(), sourceStorageDomainId));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(di.getImageId(), targetStorageDomainId, targetQuota, targetDiskProfile));
                if (sourceQuotaId == null) {
                    sourceQuotaId = di.getQuotaId();
                }
                if (sourceDiskProfileId == null) {
                    sourceDiskProfileId = di.getDiskProfileId();
                }
            }
            return null;
        }
    });
}
#method_after
private void moveDiskInDB(final Guid sourceStorageDomainId, final Guid targetStorageDomainId, final Guid targetQuota, final Guid targetDiskProfile) {
    if (isMoveDiskInDbSucceded(targetStorageDomainId)) {
        return;
    }
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

        @SuppressWarnings("synthetic-access")
        @Override
        public Object runInTransaction() {
            for (DiskImage di : getDiskImageDao().getAllSnapshotsForImageGroup(getEnclosingCommand().getParameters().getImageGroupID())) {
                getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(di.getImageId(), sourceStorageDomainId));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(di.getImageId(), targetStorageDomainId, targetQuota, targetDiskProfile));
                // an exception, we store locally the old quota and disk profile id.
                if (sourceQuotaId == null) {
                    sourceQuotaId = di.getQuotaId();
                }
                if (sourceDiskProfileId == null) {
                    sourceDiskProfileId = di.getDiskProfileId();
                }
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    if (getVdsGroup() != null && getVm().isBalloonEnabled() && !getVdsGroup().isBalloonSupported()) {
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH, String.format("$clusterArch %1$s", getVdsGroup().getArchitecture()));
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    if (getVm().isBalloonEnabled() && !getVdsGroup().isBalloonSupported()) {
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH, String.format("$clusterArch %1$s", getVdsGroup().getArchitecture()));
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                    // Creating default disk profile for existing storage domain.
                    if (FeatureSupported.storageQoS(getStoragePool().getcompatibility_version()) && getDbFacade().getDiskProfileDao().getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
                        getDiskProfileDao().save(DiskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName()));
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                    createDefaultDiskProfile();
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(getDbFacade().getSnapshotDao().getAll(getVmId()));
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(getDbFacade().getSnapshotDao().getAll(getVmId()));
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
@Override
protected Network getNetwork() {
    return getParameters().getNetwork();
}
#method_after
private Network getNetwork() {
    return getParameters().getNetwork();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDAO(), getVmDAO(), getNetworkCluster(), getNetworkName(), AuditLogDirectorDelegator.getInstance());
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    getNetworkClusterDAO().update(getNetworkCluster());
    if (getNetworkCluster().isDisplay() != getOldNetworkCluster().isDisplay()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetworkCluster().isDisplay() ? getNetwork().getId() : getManagementNetwork().getId());
    }
    if (getNetworkCluster().isMigration() != getOldNetworkCluster().isMigration()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsMigration(getVdsGroupId(), getNetworkCluster().isMigration() ? getNetwork().getId() : getManagementNetwork().getId());
    }
    NetworkClusterHelper.setStatus(getVdsGroupId(), getNetwork());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDAO(), getVmDAO(), getNetworkCluster(), getNetworkName(), AuditLogDirectorDelegator.getInstance());
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    getNetworkClusterDAO().update(getNetworkCluster());
    if (getNetworkCluster().isDisplay() != getOldNetworkCluster().isDisplay()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetworkCluster().isDisplay() ? getPersistedNetwork().getId() : getManagementNetwork().getId());
    }
    if (getNetworkCluster().isMigration() != getOldNetworkCluster().isMigration()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsMigration(getVdsGroupId(), getNetworkCluster().isMigration() ? getPersistedNetwork().getId() : getManagementNetwork().getId());
    }
    NetworkClusterHelper.setStatus(getVdsGroupId(), getPersistedNetwork());
    setSucceeded(true);
}
#end_block

#method_before
protected boolean validateAttachment() {
    NetworkClusterValidator validator = new NetworkClusterValidator(getNetworkCluster(), getClusterVersion());
    return (!NetworkUtils.isManagementNetwork(getNetwork()) || validate(validator.managementNetworkAttachment(getNetworkName()))) && validate(validator.migrationPropertySupported(getNetworkName())) && (!getNetwork().isExternal() || validateExternalNetwork(validator));
}
#method_after
protected boolean validateAttachment() {
    NetworkClusterValidator validator = new NetworkClusterValidator(getNetworkCluster(), getClusterVersion());
    return (!NetworkUtils.isManagementNetwork(getNetworkName()) || validate(validator.managementNetworkAttachment(getNetworkName()))) && validate(validator.migrationPropertySupported(getNetworkName())) && (!getPersistedNetwork().isExternal() || validateExternalNetwork(validator));
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return getBackendCommandObjectsHandler().runAction(command, getExecutionContext());
}
#method_after
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, getExecutionContext());
}
#end_block

#method_before
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params, CommandContext rollbackContext) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, rollbackContext);
    }
    return new VdcReturnValueBase();
}
#method_after
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context.clone());
    }
    return new VdcReturnValueBase();
}
#end_block

#method_before
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params, null);
}
#method_after
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params);
}
#end_block

#method_before
public void setCompensationContext(CompensationContext compensationContext) {
    context.setCompensationContext(compensationContext);
}
#method_after
public void setCompensationContext(CompensationContext compensationContext) {
    context.withCompensationContext(compensationContext);
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        if (!getReturnValue().getSucceeded()) {
            clearAsyncTasksWithOutVdsmId();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
            clearChildAsyncTasksWithOutVdsmId();
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        AsyncTaskManager.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTask task = CommandCoordinatorUtil.getAsyncTaskFromDb(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        CommandCoordinatorUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private void initiateLockEndAction() {
    if (commandLock == null) {
        LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
        if (annotation != null && !annotation.isReleaseAtEndOfExecute()) {
            commandLock = buildLock();
        }
    }
}
#method_after
private void initiateLockEndAction() {
    if (context.getLock() == null) {
        LockProperties lockProperties = getLockProperties();
        if (Scope.Command.equals(lockProperties.getScope())) {
            context.withLock(buildLock());
        }
    }
}
#end_block

#method_before
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.setCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#method_after
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.withCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (isInternalExecution() || !isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
private boolean isQuotaDependant() {
    return getActionType().getQuotaDependency() != VdcActionType.QuotaDependency.NONE;
}
#method_after
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, List<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#method_after
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debugFormat("Checking whether user {0} or one of the groups he is member of, have the following permissions: {1}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.infoFormat("No permission found for user {0} or one of the groups he is member of," + " when running action {1}, Required permissions are: Action type: {2} Action group: {3}" + " Object type: {4}  Object ID: {5}.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : consumptionParameters) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = getPermissionSubjectsAsStringBuilder(permissionSubjectList);
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
protected final void execute() {
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    if (getCallBack() != null) {
        persistCommand(getParameters().getParentCommand(), true);
    }
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
private boolean hasTasks() {
    return !getReturnValue().getVdsmTaskIdList().isEmpty();
}
#method_after
public boolean hasTasks() {
    return !getReturnValue().getVdsmTaskIdList().isEmpty();
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = getBackendCommandObjectsHandler().createAction(entry.getValue().getFirst(), entry.getValue().getSecond());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.infoFormat("Command {0} persisting async task placeholder for child command {1}", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
protected VdcActionType getActionType() {
    try {
        if (actionType == null) {
            String name = getClass().getName();
            name = name.substring(0, name.length() - 7);
            name = name.substring(name.lastIndexOf('.') + 1);
            actionType = VdcActionType.valueOf(name);
        }
        return actionType;
    } catch (Exception e) {
        return VdcActionType.Unknown;
    }
}
#method_after
public VdcActionType getActionType() {
    try {
        if (actionType == null) {
            String name = getClass().getName();
            name = name.substring(0, name.length() - 7);
            name = name.substring(name.lastIndexOf('.') + 1);
            actionType = VdcActionType.valueOf(name);
        }
        return actionType;
    } catch (Exception e) {
        return VdcActionType.Unknown;
    }
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTasks task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }

            private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
                getAsyncTaskDao().save(task);
                taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during persistAsyncTaskPlaceHolder for command: {0}. Exception {1}", getClass().getName(), ex);
    }
    return taskId;
}
#method_after
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during persistAsyncTaskPlaceHolder for command: {0}. Exception {1}", getClass().getName(), ex);
    }
    return taskId;
}
#end_block

#method_before
public void deleteAsyncTaskPlaceHolder(String taskKey) {
    Guid taskId = taskKeyToTaskIdMap.remove(taskKey);
    if (!Guid.isNullOrEmpty(taskId)) {
        AsyncTaskManager.removeTaskFromDbByTaskId(taskId);
    }
}
#method_after
public void deleteAsyncTaskPlaceHolder(String taskKey) {
    Guid taskId = taskKeyToTaskIdMap.remove(taskKey);
    if (!Guid.isNullOrEmpty(taskId)) {
        CommandCoordinatorUtil.removeTaskFromDbByTaskId(taskId);
    }
}
#end_block

#method_before
private Guid createTaskImpl(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#method_after
private Guid createTaskImpl(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return CommandCoordinatorUtil.createTask(taskId, this, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(getParameters().getEntityInfo());
    return createTask(internalGetTaskType(), p);
}
#method_after
public SPMTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorUtil.concreteCreateTask(taskId, this, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
private VdcActionParametersBase getParentParameters(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParametersForTask(parentCommand, getParameters());
    if (parentParameters.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parentParameters.setParametersCurrentUser(getCurrentUser());
    }
    return parentParameters;
}
#method_after
public VdcActionParametersBase getParentParameters(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParametersForTask(parentCommand, getParameters());
    if (parentParameters.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parentParameters.setParametersCurrentUser(getCurrentUser());
    }
    return parentParameters;
}
#end_block

#method_before
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    return new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), parentParameters, getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId(), parentParameters.getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType());
}
#method_after
private AsyncTask createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorUtil.createAsyncTask(this, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
protected AsyncTaskType getTaskType() {
    throw new UnsupportedOperationException();
}
#method_after
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.notSupported;
}
#end_block

#method_before
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        getAsyncTaskManager().startPollingTask(taskID);
    }
}
#method_after
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        CommandCoordinatorUtil.startPollingTask(taskID);
    }
}
#end_block

#method_before
private void cancelTasks() {
    if (hasTasks()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                log.infoFormat("Rollback for command: {0}.", CommandBase.this.getClass().getName());
                try {
                    getAsyncTaskManager().cancelTasks(getReturnValue().getVdsmTaskIdList());
                } catch (Exception e) {
                    log.errorFormat("Failed to cancel tasks for command: {0}.", CommandBase.this.getClass().getName());
                }
            }
        });
    }
}
#method_after
private void cancelTasks() {
    CommandCoordinatorUtil.cancelTasks(this);
}
#end_block

#method_before
protected void revertTasks() {
    if (getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<>();
        for (Guid taskId : getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = getAsyncTaskManager().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
protected void revertTasks() {
    CommandCoordinatorUtil.revertTasks(this);
}
#end_block

#method_before
protected EngineLock getLock() {
    return commandLock;
}
#method_after
protected EngineLock getLock() {
    return context.getLock();
}
#end_block

#method_before
protected void setLock(EngineLock lock) {
    commandLock = lock;
}
#method_after
protected void setLock(EngineLock lock) {
    context.withLock(lock);
}
#end_block

#method_before
protected boolean acquireLock() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!annotation.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#method_after
protected boolean acquireLock() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (!Scope.None.equals(lockProperties.getScope())) {
        releaseLocksAtEndOfExecute = Scope.Execution.equals(lockProperties.getScope());
        if (!lockProperties.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#end_block

#method_before
public final boolean acquireLockAsyncTask() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#method_after
public final boolean acquireLockAsyncTask() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (!Scope.None.equals(lockProperties.getScope())) {
        releaseLocksAtEndOfExecute = Scope.Execution.equals(lockProperties.getScope());
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                commandLock = lock;
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                context.withLock(lock);
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            commandLock = lock;
        }
    }
}
#method_after
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
        }
    }
}
#end_block

#method_before
protected void freeLock() {
    if (commandLock != null) {
        getLockManager().releaseLock(commandLock);
        log.infoFormat("Lock freed to object {0}", commandLock);
        commandLock = null;
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.infoFormat("Lock freed to object {0}", context.getLock());
        context.withLock(null);
    }
}
#end_block

#method_before
public void setExecutionContext(ExecutionContext executionContext) {
    context.setExecutionContext(executionContext);
}
#method_after
public void setExecutionContext(ExecutionContext executionContext) {
    context.withExecutionContext(executionContext);
}
#end_block

#method_before
protected boolean hasTaskHandlers() {
    return getTaskHandlers() != null;
}
#method_after
public boolean hasTaskHandlers() {
    return getTaskHandlers() != null;
}
#end_block

#method_before
protected SPMAsyncTaskHandler getCurrentTaskHandler() {
    return getTaskHandlers().get(getExecutionIndex());
}
#method_after
public SPMAsyncTaskHandler getCurrentTaskHandler() {
    return getTaskHandlers().get(getExecutionIndex());
}
#end_block

#method_before
private String generateTokenValueResponse() {
    byte[] tokenBytes;
    HttpSession session = getThreadLocalRequest().getSession();
    synchronized (session) {
        if (session.getAttribute(XSRF_TOKEN) == null) {
            tokenBytes = new byte[TOKEN_SIZE];
            // nextBytes is thread safe.
            random.nextBytes(tokenBytes);
            session.setAttribute(XSRF_TOKEN, tokenBytes);
        } else {
            tokenBytes = (byte[]) session.getAttribute(XSRF_TOKEN);
        }
    }
    return StringUtils.toHexString(tokenBytes);
}
#method_after
private String generateTokenValueResponse() {
    return StringUtils.toHexString((byte[]) getThreadLocalRequest().getSession().getAttribute(XSRF_TOKEN));
}
#end_block

#method_before
@Override
protected void validateXsrfToken(RpcToken token, Method method) {
    if (token == null) {
        // $NON-NLS-1$
        throw new RpcTokenException("XSRF token missing");
    }
    String expectedToken;
    HttpSession session = getThreadLocalRequest().getSession();
    synchronized (session) {
        expectedToken = StringUtils.toHexString((byte[]) session.getAttribute(OvirtXsrfTokenServiceServlet.XSRF_TOKEN));
    }
    XsrfToken xsrfToken = (XsrfToken) token;
    if (!expectedToken.equals(xsrfToken.getToken())) {
        // $NON-NLS-1$
        throw new RpcTokenException("Invalid XSRF token");
    }
}
#method_after
@Override
protected void validateXsrfToken(RpcToken token, Method method) {
    if (token == null) {
        // $NON-NLS-1$
        throw new RpcTokenException("XSRF token missing");
    }
    String expectedToken;
    HttpSession session = getThreadLocalRequest().getSession();
    expectedToken = StringUtils.toHexString((byte[]) session.getAttribute(OvirtXsrfTokenServiceServlet.XSRF_TOKEN));
    XsrfToken xsrfToken = (XsrfToken) token;
    if (!expectedToken.equals(xsrfToken.getToken())) {
        // $NON-NLS-1$
        throw new RpcTokenException("Invalid XSRF token");
    }
}
#end_block

#method_before
public static Network getNetworkByVnicProfileId(Guid vnicProfileId) {
    if (vnicProfileId == null) {
        return null;
    }
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vnicProfileId);
    return getNetworkByVnicProfile(vnicProfile);
}
#method_after
public static Network getNetworkByVnicProfileId(Guid vnicProfileId) {
    VnicProfile vnicProfile = getVnicProfile(vnicProfileId);
    return getNetworkByVnicProfile(vnicProfile);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    if (!unregisteredDisks.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(unregisteredDisks);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (vdcReturnValueBase.getSucceeded()) {
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) vdcReturnValueBase.getActionReturnValue(), getParameters().getStorageDomainId());
                } else {
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
            }
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return Collections.emptyList();
}
#end_block

#method_before
private Pair<DiskImage, Long> getLatestOVFDisk(List<Disk> disks) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (Disk disk : disks) {
        boolean isBetterOvfDiskFound = false;
        // Check which disks are of OVF_STORE
        String diskDecription = ((DiskImage) disk).getDescription();
        if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
            Map<String, Object> diskDescriptionMap;
            try {
                diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
            } catch (IOException e) {
                log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
                continue;
            }
            // The purpose of this check is to verify that it's an OVF store with data related to the Storage Domain.
            if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                log.warnFormat("The disk description does not contain the storage domain id {0}", getParameters().getStorageDomainId());
                continue;
            }
            boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
            Date date = getDateFromDiskDescription(diskDescriptionMap);
            if (isFoundOvfDiskUpdated && !isUpdated) {
                continue;
            }
            if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
                isBetterOvfDiskFound = true;
            }
            if (isBetterOvfDiskFound) {
                isFoundOvfDiskUpdated = isUpdated;
                foundOvfDiskUpdateDate = date;
                ovfDisk = disk;
                size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
            }
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#method_after
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(ovfStoreDisk.getDescription());
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (date == null) {
            continue;
        }
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#end_block

#method_before
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(map.get(OvfInfoFileConstants.LastUpdated).toString());
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
        return null;
    }
}
#method_after
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        Object lastUpdate = map.get(OvfInfoFileConstants.LastUpdated);
        if (lastUpdate != null) {
            return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(lastUpdate.toString());
        } else {
            log.info("LastUpdate Date is not initialized in the OVF_STORE disk.");
        }
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
    }
    return null;
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getcompatibility_version());
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getcompatibility_version());
}
#end_block

#method_before
@Test
public void refuseBalloonOnPPC() {
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(0);
    c.getParameters().getVm().setBalloonEnabled(true);
    c.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.ppc64);
    cluster.setcompatibility_version(Version.getLast());
    doReturn(cluster).when(c).getVdsGroup();
    when(osRepository.isBalloonEnabled(c.getParameters().getVm().getVmOsId(), cluster.getcompatibility_version())).thenReturn(false);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH.toString()));
}
#method_after
@Test
public void refuseBalloonOnPPC() {
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(createParameters());
    c.getParameters().getVm().setBalloonEnabled(true);
    c.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.ppc64);
    cluster.setcompatibility_version(Version.getLast());
    doReturn(cluster).when(c).getVdsGroup();
    when(osRepository.isBalloonEnabled(c.getParameters().getVm().getVmOsId(), cluster.getcompatibility_version())).thenReturn(false);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH.toString()));
}
#end_block

#method_before
@Test
public void acceptBalloon() {
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(0);
    c.getParameters().getVm().setBalloonEnabled(true);
    c.getParameters().getVm().setClusterArch(ArchitectureType.x86_64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setcompatibility_version(Version.getLast());
    doReturn(cluster).when(c).getVdsGroup();
    osRepository.getDisplayTypes().get(0).put(Version.getLast(), Arrays.asList(DisplayType.qxl));
    when(osRepository.isBalloonEnabled(c.getParameters().getVm().getVmOsId(), cluster.getcompatibility_version())).thenReturn(true);
    assertTrue(c.canDoAction());
}
#method_after
@Test
public void acceptBalloon() {
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(createParameters());
    c.getParameters().getVm().setBalloonEnabled(true);
    c.getParameters().getVm().setClusterArch(ArchitectureType.x86_64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setcompatibility_version(Version.getLast());
    doReturn(cluster).when(c).getVdsGroup();
    osRepository.getDisplayTypes().get(0).put(Version.getLast(), Arrays.asList(DisplayType.qxl));
    when(osRepository.isBalloonEnabled(c.getParameters().getVm().getVmOsId(), cluster.getcompatibility_version())).thenReturn(true);
    assertTrue(c.canDoAction());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void mockOsRepository() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
}
#method_after
protected void mockOsRepository() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#end_block

#method_before
private void onImport() {
    StorageModel model = (StorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().importingStorageDomainProgress());
    VDS host = model.getHost().getSelectedItem();
    // Save changes.
    if (model.getSelectedItem() instanceof NfsStorageModel) {
        NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
        nfsModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), nfsModel.getPath().getEntity(), nfsModel.getRole(), StorageType.NFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof LocalStorageModel) {
        LocalStorageModel localModel = (LocalStorageModel) model.getSelectedItem();
        localModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), localModel.getPath().getEntity(), localModel.getRole(), StorageType.LOCALFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof GlusterStorageModel) {
        GlusterStorageModel glusterModel = (GlusterStorageModel) model.getSelectedItem();
        glusterModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), glusterModel.getPath().getEntity(), glusterModel.getRole(), StorageType.GLUSTERFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof PosixStorageModel) {
        PosixStorageModel posixModel = (PosixStorageModel) model.getSelectedItem();
        posixModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), posixModel.getPath().getEntity(), posixModel.getRole(), StorageType.POSIXFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof ImportSanStorageModel) {
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportSan", host.getId(), model.getActivateDomain().getEntity() }))).run();
    }
}
#method_after
private void onImport() {
    StorageModel model = (StorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().importingStorageDomainProgress());
    VDS host = model.getHost().getSelectedItem();
    // Save changes.
    if (model.getSelectedItem() instanceof NfsStorageModel) {
        NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
        nfsModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), nfsModel.getPath().getEntity(), nfsModel.getRole(), StorageType.NFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof LocalStorageModel) {
        LocalStorageModel localModel = (LocalStorageModel) model.getSelectedItem();
        localModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), localModel.getPath().getEntity(), localModel.getRole(), StorageType.LOCALFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof PosixStorageModel) {
        PosixStorageModel posixModel = (PosixStorageModel) model.getSelectedItem();
        posixModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), posixModel.getPath().getEntity(), posixModel.getRole(), StorageType.POSIXFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof GlusterStorageModel) {
        GlusterStorageModel glusterModel = (GlusterStorageModel) model.getSelectedItem();
        glusterModel.setMessage(null);
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), glusterModel.getPath().getEntity(), glusterModel.getRole(), StorageType.GLUSTERFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getSelectedItem() instanceof ImportSanStorageModel) {
        Task.create(this, new ArrayList<Object>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportSan", host.getId(), model.getActivateDomain().getEntity() }))).run();
    }
}
#end_block

#method_before
private DiskImage createDiskImage(boolean active) {
    DiskImage di = new DiskImage();
    di.setActive(active);
    di.setId(Guid.newGuid());
    di.setImageId(Guid.newGuid());
    di.setParentId(Guid.newGuid());
    di.setImageStatus(ImageStatus.OK);
    return di;
}
#method_after
private static DiskImage createDiskImage(boolean active) {
    DiskImage di = new DiskImage();
    di.setActive(active);
    di.setId(Guid.newGuid());
    di.setImageId(Guid.newGuid());
    di.setParentId(Guid.newGuid());
    di.setImageStatus(ImageStatus.OK);
    return di;
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmNumaNodeRuntimeData();
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getswap_free() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, boolean copySnapshotDevices) {
    Guid id;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
            if (cluster != null) {
                addSoundCard(vmBase, cluster.getcompatibility_version());
            }
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, boolean copySnapshotDevices) {
    Guid id;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
            addSoundCard(vmBase, cluster != null ? cluster.getcompatibility_version() : null);
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Integer>> storageQosIoTuneMap = new HashMap<>();
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                if (FeatureSupported.storageQoS(vm.getVdsGroupCompatibilityVersion())) {
                    Map<String, Integer> ioTune = buildIoTune(diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
                    if (ioTune != null) {
                        if (vmDevice.getSpecParams() == null) {
                            vmDevice.setSpecParams(new HashMap<String, Object>());
                        }
                        vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
                    }
                }
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#method_after
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!osRepository.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), CpuFlagsManagerHandler.getCpuIdByNameAndVersion(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version()))) {
        String unsupportedCpus = osRepository.getUnsupportedCpus().get(new Pair<>(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version())).toString();
        return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS, "$unsupportedCpus " + StringUtils.strip(unsupportedCpus.toString(), "[]"));
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#end_block

#method_before
private boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.isBalloonEnabled(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.isBalloonEnabled(getVmId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!osRepository.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), CpuFlagsManagerHandler.getCpuIdByNameAndVersion(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version()))) {
        String unsupportedCpus = osRepository.getUnsupportedCpus().get(new Pair<>(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version())).toString();
        return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS, "$unsupportedCpus " + StringUtils.strip(unsupportedCpus.toString(), "[]"));
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getcompatibility_version());
}
#end_block

#method_before
private void createMenu(final List<VdsNumaNode> numaNodeList, int indexToSkip) {
    menuBar = new MenuBar(true);
    for (final VdsNumaNode numaNode : numaNodeList) {
        menuBar.addItem(commonMessages.numaNode(numaNodeList.indexOf(numaNode)), new Command() {

            @Override
            public void execute() {
                UpdatedVnumaEvent.fire(DraggableVirtualNumaPanel.this, nodeModel.getVm().getId(), nodeModel.isPinned(), nodeModel.getVmNumaNode().getIndex(), numaNodeList.indexOf(numaNode));
                menuPopup.hide();
            }
        });
    }
    if (nodeModel.isPinned()) {
        menuBar.addSeparator();
        menuBar.addItem(commonConstants.unPinNode(), new Command() {

            @Override
            public void execute() {
                UpdatedVnumaEvent.fire(DraggableVirtualNumaPanel.this, nodeModel.getVm().getId(), nodeModel.isPinned(), nodeModel.getVmNumaNode().getIndex(), -1);
                menuPopup.hide();
            }
        });
    }
}
#method_after
private void createMenu(final List<VdsNumaNode> numaNodeList, int indexToSkip) {
    menuBar = new MenuBar(true);
    for (final VdsNumaNode numaNode : numaNodeList) {
        final int nodeIndex = numaNode.getIndex();
        menuBar.addItem(commonMessages.numaNode(nodeIndex), new Command() {

            @Override
            public void execute() {
                UpdatedVnumaEvent.fire(DraggableVirtualNumaPanel.this, nodeModel.getVm().getId(), nodeModel.isPinned(), nodeModel.getVmNumaNode().getIndex(), nodeIndex);
                menuPopup.hide();
            }
        });
    }
    if (nodeModel.isPinned()) {
        menuBar.addSeparator();
        menuBar.addItem(commonConstants.unPinNode(), new Command() {

            @Override
            public void execute() {
                UpdatedVnumaEvent.fire(DraggableVirtualNumaPanel.this, nodeModel.getVm().getId(), nodeModel.isPinned(), nodeModel.getVmNumaNode().getIndex(), -1);
                menuPopup.hide();
            }
        });
    }
}
#end_block

#method_before
@Override
public void setVmsWithvNumaNodeList(List<VM> vmsWithvNumaNodeList) {
    if (Guid.isNullOrEmpty(vm.getId())) {
        vmsWithvNumaNodeList.add(vm);
    } else {
        VM removeVm = null;
        for (VM inerVm : vmsWithvNumaNodeList) {
            if (inerVm.getId().equals(vm.getId())) {
                removeVm = inerVm;
                break;
            }
        }
        vmsWithvNumaNodeList.remove(removeVm);
        vmsWithvNumaNodeList.add(vm);
    }
    super.setVmsWithvNumaNodeList(vmsWithvNumaNodeList);
}
#method_after
@Override
public void setVmsWithvNumaNodeList(List<VM> vmsWithvNumaNodeList) {
    if (Guid.isNullOrEmpty(vm.getId())) {
        vmsWithvNumaNodeList.add(vm);
    } else {
        VM removeVm = null;
        for (VM iterVm : vmsWithvNumaNodeList) {
            if (iterVm.getId().equals(vm.getId())) {
                removeVm = iterVm;
                break;
            }
        }
        vmsWithvNumaNodeList.remove(removeVm);
        vmsWithvNumaNodeList.add(vm);
    }
    super.setVmsWithvNumaNodeList(vmsWithvNumaNodeList);
}
#end_block

#method_before
@Override
protected void build(UnitVmModel model, VmBase vm) {
    Integer nodeCount = model.getNumaNodeCount().getEntity();
    // clear NUMA nodes
    if (nodeCount == null || nodeCount == 0) {
        vm.setvNumaNodeList(null);
    } else {
        // no change in NUMA nodes
        if (model.getVmNumaNodes() != null && nodeCount == model.getVmNumaNodes().size()) {
            vm.setvNumaNodeList(model.getVmNumaNodes());
        // create numa nodes
        } else {
            List<VmNumaNode> nodeList = new ArrayList<VmNumaNode>(nodeCount);
            Integer coresPerNode = Integer.parseInt(model.getTotalCPUCores().getEntity()) / nodeCount;
            int coreIndex = 0;
            for (int i = 0; i < nodeCount; i++) {
                VmNumaNode vmNumaNode = new VmNumaNode();
                vmNumaNode.setIndex(i);
                // divide memory for each numa node
                vmNumaNode.setMemTotal(model.getMemSize().getEntity() / nodeCount);
                vmNumaNode.setVdsNumaNodeList(new ArrayList<Pair<Guid, Pair<Boolean, Integer>>>());
                Pair<Guid, Pair<Boolean, Integer>> pair = new Pair<Guid, Pair<Boolean, Integer>>();
                pair.setSecond(new Pair<Boolean, Integer>(false, i));
                vmNumaNode.getVdsNumaNodeList().add(pair);
                List<Integer> coreList = new ArrayList<Integer>();
                for (int j = 0; j < coresPerNode; j++, coreIndex++) {
                    coreList.add(coreIndex);
                }
                vmNumaNode.setCpuIds(coreList);
                nodeList.add(vmNumaNode);
            }
            vm.setvNumaNodeList(nodeList);
        }
    }
    vm.setNumaTuneMode(model.getNumaTuneMode().getSelectedItem());
}
#method_after
@Override
protected void build(UnitVmModel model, VmBase vm) {
    // Tune Mode:
    vm.setNumaTuneMode(model.getNumaTuneMode().getSelectedItem());
    // Virtual nodes:
    Integer nodeCount = model.getNumaNodeCount().getEntity();
    // clear NUMA nodes
    if (nodeCount == null || nodeCount == 0) {
        vm.setvNumaNodeList(null);
    } else {
        List<VmNumaNode> nodeList = null;
        if (model.getVmNumaNodes() != null && nodeCount == model.getVmNumaNodes().size()) {
            nodeList = model.getVmNumaNodes();
        } else {
            nodeList = new ArrayList<VmNumaNode>(nodeCount);
            for (int i = 0; i < nodeCount; i++) {
                VmNumaNode newNode = new VmNumaNode();
                newNode.setIndex(i);
                nodeList.add(newNode);
            }
        }
        Integer cpuCount = 0;
        for (int i = 0; i < nodeList.size(); i++) {
            VmNumaNode vmNumaNode = nodeList.get(i);
            updateMemory(vmNumaNode, model.getMemSize().getEntity() / nodeCount);
            cpuCount = updateCpus(vmNumaNode, Integer.parseInt(model.getTotalCPUCores().getEntity()) / nodeCount, cpuCount);
            updateNumaPinning(vmNumaNode, i);
        }
        vm.setvNumaNodeList(nodeList);
    }
}
#end_block

#method_before
protected void initHostNUMATopology() {
    startProgress(null);
    AsyncDataProvider.getHostNumaTopologyByHostId(new AsyncQuery(new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object returnValue) {
            // TODO: host query can be skipped in case it was already fetched.
            NumaSupportModel.this.getNumaNodeList().addAll((List<VdsNumaNode>) returnValue);
            NumaSupportModel.this.initFirstLevelDistanceSetList();
            AsyncDataProvider.getVMsWithVNumaNodesByClusterId(new AsyncQuery(new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    NumaSupportModel.this.setVmsWithvNumaNodeList((List<VM>) returnValue);
                    NumaSupportModel.this.modelReady();
                }
            }), NumaSupportModel.this.hosts.getSelectedItem().getVdsGroupId());
        }
    }), hosts.getSelectedItem().getId());
}
#method_after
protected void initHostNUMATopology() {
    startProgress(null);
    AsyncDataProvider.getInstance().getHostNumaTopologyByHostId(new AsyncQuery(new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object returnValue) {
            // TODO: host query can be skipped in case it was already fetched.
            NumaSupportModel.this.getNumaNodeList().addAll((List<VdsNumaNode>) returnValue);
            NumaSupportModel.this.initFirstLevelDistanceSetList();
            AsyncDataProvider.getInstance().getVMsWithVNumaNodesByClusterId(new AsyncQuery(new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    NumaSupportModel.this.setVmsWithvNumaNodeList((List<VM>) returnValue);
                    NumaSupportModel.this.modelReady();
                }
            }), NumaSupportModel.this.hosts.getSelectedItem().getVdsGroupId());
        }
    }), hosts.getSelectedItem().getId());
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getInstanceTypes().setIsChangable(!vm.isRunning());
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = (List<VmNumaNode>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().getNumaNodeCount().setEntity(nodes.size());
        }
    }));
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getInstanceTypes().setIsChangable(!vm.isRunning());
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = (List<VmNumaNode>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().updateNodeCount(nodes.size());
        }
    }));
}
#end_block

#method_before
protected void initPoolSpecificWidgets(CommonApplicationResources resources, final CommonApplicationMessages messages) {
    createNumOfDesktopEditors();
    incraseNumOfVmsEditor.setKeepTitleOnSetEnabled(true);
    numOfVmsEditor.setKeepTitleOnSetEnabled(true);
    newPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    editPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    poolNameIcon = new InfoIcon(applicationTemplates.italicText(messages.poolNameHelp()), resources);
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    outOfxInPool = new ValueLabel<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
    // //$NON-NLS-1$
    numaInfoIcon = new InfoIcon(SafeHtmlUtils.fromTrustedString(""), resources);
}
#method_after
protected void initPoolSpecificWidgets(CommonApplicationResources resources, final CommonApplicationMessages messages) {
    createNumOfDesktopEditors();
    incraseNumOfVmsEditor.setKeepTitleOnSetEnabled(true);
    numOfVmsEditor.setKeepTitleOnSetEnabled(true);
    newPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    editPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    poolNameIcon = new InfoIcon(applicationTemplates.italicText(messages.poolNameHelp()), resources);
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    outOfxInPool = new ValueLabel<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
    // $NON-NLS-1$
    numaInfoIcon = new InfoIcon(SafeHtmlUtils.fromTrustedString(""), resources);
}
#end_block

#method_before
private void setNumaInfoMsg(String message) {
    if (message == null) {
        // $NON-NLS-1$
        message = "";
    }
    numaInfoIcon.setText(SafeHtmlUtils.fromTrustedString(message));
}
#method_after
private void setNumaInfoMsg(String message) {
    if (message == null) {
        // $NON-NLS-1$
        message = "";
    }
    numaInfoIcon.setText(applicationTemplates.italicText(message));
}
#end_block

#method_before
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#method_after
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(osType, cluster.getcompatibility_version());
    if (displayTypes == null) {
        Integer defaultOs = AsyncDataProvider.getInstance().getDefaultOs(cluster.getArchitecture());
        displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(defaultOs, cluster.getcompatibility_version());
    }
    initDisplayProtocolWithTypes(displayTypes);
}
#end_block

#method_before
private void numaSupport() {
    getBehavior().numaSupport();
}
#method_after
private void numaSupport() {
    setNumaChanged(true);
    getBehavior().numaSupport();
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> list = new ArrayList<>();
    // If Vm in Paused mode - no additional memory allocation needed
    if (vm.getStatus() == VMStatus.Paused) {
        return hosts;
    }
    List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
    for (VDS vds : hosts) {
        if (!isVMSwapValueLegal(vds)) {
            log.debugFormat("host '{0}' swap value is illegal", vds.getName());
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__SWAP_VALUE_ILLEGAL.toString());
            continue;
        }
        if (!memoryChecker.evaluate(vds, vm)) {
            log.debugFormat("host '{0}' has insufficient memory to run the VM", vds.getName());
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__NOT_ENOUGH_MEMORY.toString());
            continue;
        }
        // * there isn't enough memory for pinned vNode in pNode
        if (isVmNumaPinned(vmNumaNodes) && vm.getNumaTuneMode() == NumaTuneMode.STRICT && (!vds.isNumaSupport() || !canVmNumaPinnedToVds(vm, vmNumaNodes, vds))) {
            log.debugFormat("host '{0}' cannot accommodate memory of VM's pinned virtual NUMA nodes within host's physical NUMA nodes", vds.getName());
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__NOT_ENOUGH_MEMORY.toString());
            continue;
        }
        list.add(vds);
    }
    return list;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> list = new ArrayList<>();
    // If Vm in Paused mode - no additional memory allocation needed
    if (vm.getStatus() == VMStatus.Paused) {
        return hosts;
    }
    List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
    for (VDS vds : hosts) {
        if (!isVMSwapValueLegal(vds)) {
            log.debugFormat("host '{0}' swap value is illegal", vds.getName());
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__SWAP_VALUE_ILLEGAL.toString());
            continue;
        }
        if (!memoryChecker.evaluate(vds, vm)) {
            log.debugFormat("host '{0}' has insufficient memory to run the VM", vds.getName());
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__NOT_ENOUGH_MEMORY.toString());
            continue;
        }
        // * there isn't enough memory for pinned vNode in pNode
        if (vm.getNumaTuneMode() == NumaTuneMode.STRICT && isVmNumaPinned(vmNumaNodes) && (!vds.isNumaSupport() || !canVmNumaPinnedToVds(vm, vmNumaNodes, vds))) {
            log.debugFormat("host '{0}' cannot accommodate memory of VM's pinned virtual NUMA nodes within host's physical NUMA nodes", vds.getName());
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__NOT_MEMORY_PINNED_NUMA.toString());
            continue;
        }
        list.add(vds);
    }
    return list;
}
#end_block

#method_before
private boolean canVmNumaPinnedToVds(VM vm, List<VmNumaNode> nodes, VDS vds) {
    List<VdsNumaNode> pNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    if (pNodes == null || pNodes.isEmpty()) {
        return false;
    }
    Map<Integer, VdsNumaNode> indexMap = toMap(pNodes);
    for (VmNumaNode vNode : nodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getFirst()) {
                if (vNode.getMemTotal() > indexMap.get(vNode.getIndex()).getNumaNodeStatistics().getMemFree()) {
                    return false;
                }
            }
        }
    }
    return true;
}
#method_after
private boolean canVmNumaPinnedToVds(VM vm, List<VmNumaNode> nodes, VDS vds) {
    List<VdsNumaNode> pNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    if (pNodes == null || pNodes.isEmpty()) {
        return false;
    }
    Map<Integer, VdsNumaNode> indexMap = toMap(pNodes);
    for (VmNumaNode vNode : nodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getFirst()) {
                if (vNode.getMemTotal() > indexMap.get(pair.getSecond().getSecond()).getNumaNodeStatistics().getMemFree()) {
                    return false;
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(AssignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.valueOf(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = AssignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, new Comparator<VdsNumaNode>() {

            @Override
            public int compare(VdsNumaNode arg0, VdsNumaNode arg1) {
                return arg0.getIndex() < arg1.getIndex() ? -1 : 1;
            }
        });
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            List<Integer> distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
            Map<Integer, Integer> distanceMap = new HashMap<>(distances.size());
            for (int i = 0; i < distances.size(); i++) {
                distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#method_after
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(AssignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.valueOf(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = AssignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            List<Integer> distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
            Map<Integer, Integer> distanceMap = new HashMap<>(distances.size());
            for (int i = 0; i < distances.size(); i++) {
                distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return isInternalExecution() ? getSucceeded() ? AuditLogType.SYSTEM_UPDATE_VM : AuditLogType.SYSTEM_FAILED_UPDATE_VM : getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    UpdateVmNumaNodes();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = getBackend().runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = getBackend().runInternalAction(VdcActionType.RemoveRngDevice, params);
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = getBackend().runInternalAction(VdcActionType.UpdateRngDevice, params);
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.EMPTY_LIST, getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.EMPTY_LIST, VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = getBackend().runInternalAction(VdcActionType.HotSetNumberOfCpus, params);
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = getBackend().runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                getBackend().runInternalAction(VdcActionType.AddWatchdog, parameters);
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                getBackend().runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters);
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                getBackend().runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters);
            }
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), !getParameters().isApplyChangesLater()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    return newImage;
}
#method_after
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    newImage.setDiskProfileId(image.getDiskProfileId());
    return newImage;
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority, getMacPool());
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        getBackend().runInternalAction(VdcActionType.AddWatchdog, parameters);
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
    if (instanceTypeId != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmDisksSource.getId(), VmDeviceGeneralType.DISK);
    VmDeviceUtils.copyVmDevices(vmDisksSource.getId(), getVmId(), getVm(), getVm().getStaticData(), true, disks, getSrcDeviceIdToTargetDeviceIdMapping(), false, false, false, false, false);
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    VmDeviceUtils.copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfileOnNic(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected void addVmNumaNodes() {
    List<VdsNumaNode> numaNodes = new ArrayList<VdsNumaNode>();
    for (VmNumaNode vnode : getParameters().getVmStaticData().getvNumaNodeList()) {
        numaNodes.add(vnode);
    }
    DbFacade.getInstance().getVmNumaNodeDAO().massSaveNumaNode(numaNodes, null, getVmId());
}
#method_after
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getVmId(), numaNodes);
    params.setNumaTuneMode(getParameters().getVmStaticData().getNumaTuneMode());
    params.setDedicatedHost(getParameters().getVmStaticData().getDedicatedVmForVds());
    params.setMigrationSupport(getParameters().getVmStaticData().getMigrationSupport());
    if (numaNodes == null || numaNodes.isEmpty()) {
        return;
    }
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        AuditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            tempVar.setDiskProfileId(diskInfoDestinationMap.get(dit.getId()).getDiskProfileId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (instanceTypeId != null && !checkInstanceTypeImagePermissions(instanceTypeId)) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && instanceTypeId != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && getInstanceTypeId() != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    return getParameters().isBalloonEnabled();
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version());
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean succeeded = false;
    try {
        Guid vdsId = getVm().getDedicatedVmForVds();
        List<VdsNumaNode> vdsNumaNodes = new ArrayList<VdsNumaNode>();
        if (vdsId != null) {
            vdsNumaNodes = getDbFacade().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        }
        List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
        List<VdsNumaNode> nodes = new ArrayList<VdsNumaNode>();
        for (VmNumaNode vmNumaNode : vmNumaNodes) {
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
                int index = pair.getSecond().getSecond();
                for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                    if (vdsNumaNode.getIndex() == index) {
                        pair.setFirst(vdsNumaNode.getId());
                        pair.getSecond().setFirst(true);
                        break;
                    }
                }
            }
            nodes.add((VdsNumaNode) vmNumaNode);
        }
        getDbFacade().getVmNumaNodeDAO().massUpdateNumaNode(nodes);
        succeeded = true;
    } finally {
        setSucceeded(succeeded);
    }
}
#method_after
@Override
protected void executeCommand() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    Guid vdsId = getVm().getDedicatedVmForVds();
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vdsId != null) {
        vdsNumaNodes = getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
    }
    List<VdsNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            int index = pair.getSecond().getSecond();
            for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                if (vdsNumaNode.getIndex() == index) {
                    pair.setFirst(vdsNumaNode.getId());
                    pair.getSecond().setFirst(true);
                    break;
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massUpdateNumaNode(nodes);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, getActionType().getActionGroup()));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean succeeded = false;
    try {
        Guid vmId = getParameters().getVmId();
        Guid vdsId = getVm().getDedicatedVmForVds();
        List<VdsNumaNode> vdsNumaNodes = new ArrayList<VdsNumaNode>();
        if (vdsId != null) {
            vdsNumaNodes = getDbFacade().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        }
        List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
        List<VdsNumaNode> nodes = new ArrayList<VdsNumaNode>();
        for (VmNumaNode vmNumaNode : vmNumaNodes) {
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
                int index = pair.getSecond().getSecond();
                for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                    if (vdsNumaNode.getIndex() == index) {
                        pair.setFirst(vdsNumaNode.getId());
                        pair.getSecond().setFirst(true);
                        break;
                    }
                }
            }
            nodes.add((VdsNumaNode) vmNumaNode);
        }
        getDbFacade().getVmNumaNodeDAO().massSaveNumaNode(nodes, null, vmId);
        // Used for restful API for reture first NUMA node GUID
        setActionReturnValue(nodes.get(0).getId());
        succeeded = true;
    } finally {
        setSucceeded(succeeded);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid vmId = getParameters().getVmId();
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    Guid vdsId = getVm().getDedicatedVmForVds();
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vdsId != null) {
        vdsNumaNodes = getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
    }
    List<VdsNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            int index = pair.getSecond().getSecond();
            for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                if (vdsNumaNode.getIndex() == index) {
                    pair.setFirst(vdsNumaNode.getId());
                    pair.getSecond().setFirst(true);
                    break;
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massSaveNumaNode(nodes, null, vmId);
    // Used for restful API for reture first NUMA node GUID
    setActionReturnValue(nodes.get(0).getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, getActionType().getActionGroup()));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean succeeded = false;
    try {
        List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
        List<Guid> guids = new ArrayList<Guid>();
        for (VmNumaNode node : vmNumaNodes) {
            guids.add(node.getId());
        }
        getDbFacade().getVmNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(guids);
        succeeded = true;
    } finally {
        setSucceeded(succeeded);
    }
}
#method_after
@Override
protected void executeCommand() {
    boolean succeeded = false;
    try {
        List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
        List<Guid> guids = new ArrayList<>();
        for (VmNumaNode node : vmNumaNodes) {
            guids.add(node.getId());
        }
        getVmNumaNodeDao().massRemoveNumaNodeByNumaNodeId(guids);
        succeeded = true;
    } finally {
        setSucceeded(succeeded);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, getActionType().getActionGroup()));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((cpu_sysField == null) ? 0 : cpu_sysField.hashCode());
    result = prime * result + ((cpu_userField == null) ? 0 : cpu_userField.hashCode());
    result = prime * result + ((elapsed_timeField == null) ? 0 : elapsed_timeField.hashCode());
    result = prime * result + ((interfaceStatisticsField == null) ? 0 : interfaceStatisticsField.hashCode());
    result = prime * result + ((roundedElapsedTimeField == null) ? 0 : roundedElapsedTimeField.hashCode());
    result = prime * result + ((usage_cpu_percentField == null) ? 0 : usage_cpu_percentField.hashCode());
    result = prime * result + ((usage_mem_percentField == null) ? 0 : usage_mem_percentField.hashCode());
    result = prime * result + ((usage_network_percentField == null) ? 0 : usage_network_percentField.hashCode());
    result = prime * result + ((migrationProgressPercent == null) ? 0 : migrationProgressPercent.hashCode());
    result = prime * result + ((disksUsage == null) ? 0 : disksUsage.hashCode());
    result = prime * result + ((vm_guidField == null) ? 0 : vm_guidField.hashCode());
    result = prime * result + ((vNumaNodeStatisticsList == null) ? 0 : vNumaNodeStatisticsList.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((cpu_sysField == null) ? 0 : cpu_sysField.hashCode());
    result = prime * result + ((cpu_userField == null) ? 0 : cpu_userField.hashCode());
    result = prime * result + ((elapsed_timeField == null) ? 0 : elapsed_timeField.hashCode());
    result = prime * result + ((interfaceStatisticsField == null) ? 0 : interfaceStatisticsField.hashCode());
    result = prime * result + ((roundedElapsedTimeField == null) ? 0 : roundedElapsedTimeField.hashCode());
    result = prime * result + ((usage_cpu_percentField == null) ? 0 : usage_cpu_percentField.hashCode());
    result = prime * result + ((usage_mem_percentField == null) ? 0 : usage_mem_percentField.hashCode());
    result = prime * result + ((usage_network_percentField == null) ? 0 : usage_network_percentField.hashCode());
    result = prime * result + ((migrationProgressPercent == null) ? 0 : migrationProgressPercent.hashCode());
    result = prime * result + ((disksUsage == null) ? 0 : disksUsage.hashCode());
    result = prime * result + ((vm_guidField == null) ? 0 : vm_guidField.hashCode());
    result = prime * result + ((cpuUsageHistory == null) ? 0 : cpuUsageHistory.hashCode());
    result = prime * result + ((networkUsageHistory == null) ? 0 : networkUsageHistory.hashCode());
    result = prime * result + ((memoryUsageHistory == null) ? 0 : memoryUsageHistory.hashCode());
    result = prime * result + ((vNumaNodeStatisticsList == null) ? 0 : vNumaNodeStatisticsList.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmStatistics other = (VmStatistics) obj;
    return (ObjectUtils.objectsEqual(cpu_sysField, other.cpu_sysField) && ObjectUtils.objectsEqual(cpu_userField, other.cpu_userField) && ObjectUtils.objectsEqual(elapsed_timeField, other.elapsed_timeField) && ObjectUtils.objectsEqual(interfaceStatisticsField, other.interfaceStatisticsField) && ObjectUtils.objectsEqual(roundedElapsedTimeField, other.roundedElapsedTimeField) && ObjectUtils.objectsEqual(usage_cpu_percentField, other.usage_cpu_percentField) && ObjectUtils.objectsEqual(usage_mem_percentField, other.usage_mem_percentField) && ObjectUtils.objectsEqual(migrationProgressPercent, other.migrationProgressPercent) && ObjectUtils.objectsEqual(usage_network_percentField, other.usage_network_percentField) && ObjectUtils.objectsEqual(disksUsage, other.disksUsage) && ObjectUtils.objectsEqual(vm_guidField, other.vm_guidField) && ObjectUtils.objectsEqual(vNumaNodeStatisticsList, other.vNumaNodeStatisticsList));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmStatistics other = (VmStatistics) obj;
    return (ObjectUtils.objectsEqual(cpu_sysField, other.cpu_sysField) && ObjectUtils.objectsEqual(cpu_userField, other.cpu_userField) && ObjectUtils.objectsEqual(elapsed_timeField, other.elapsed_timeField) && ObjectUtils.objectsEqual(interfaceStatisticsField, other.interfaceStatisticsField) && ObjectUtils.objectsEqual(roundedElapsedTimeField, other.roundedElapsedTimeField) && ObjectUtils.objectsEqual(usage_cpu_percentField, other.usage_cpu_percentField) && ObjectUtils.objectsEqual(usage_mem_percentField, other.usage_mem_percentField) && ObjectUtils.objectsEqual(migrationProgressPercent, other.migrationProgressPercent) && ObjectUtils.objectsEqual(usage_network_percentField, other.usage_network_percentField) && ObjectUtils.objectsEqual(disksUsage, other.disksUsage) && ObjectUtils.objectsEqual(vm_guidField, other.vm_guidField) && ObjectUtils.objectsEqual(cpuUsageHistory, other.cpuUsageHistory) && ObjectUtils.objectsEqual(networkUsageHistory, other.networkUsageHistory) && ObjectUtils.objectsEqual(memoryUsageHistory, other.memoryUsageHistory) && ObjectUtils.objectsEqual(vNumaNodeStatisticsList, other.vNumaNodeStatisticsList));
}
#end_block

#method_before
@Override
public int compareTo(VmStatistics o) {
    return BusinessEntityGuidComparator.<VmStatistics>newInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(VmStatistics o) {
    return BusinessEntityComparator.<VmStatistics, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
@Override
public void massUpdateVmNumaNodeRuntimePinning(List<VmNumaNode> vmNumaNodes) {
    List<MapSqlParameterSource> vNodeToPnodeDeletions = new ArrayList<>();
    List<MapSqlParameterSource> vNodeToPnodeInsertions = new ArrayList<>();
    for (VmNumaNode node : vmNumaNodes) {
        vNodeToPnodeDeletions.add(getCustomMapSqlParameterSource().addValue("vm_numa_node_id", node.getId()));
        for (Pair<Guid, Pair<Boolean, Integer>> pair : node.getVdsNumaNodeList()) {
            vNodeToPnodeInsertions.add(createVnodeToPnodeParametersMapper(pair, node.getId()));
        }
    }
    getCallsHandler().executeStoredProcAsBatch("DeleteUnpinnedNumaNodeMapByVmNumaNodeId", vNodeToPnodeDeletions);
    getCallsHandler().executeStoredProcAsBatch("InsertNumaNodeMap", vNodeToPnodeInsertions);
}
#method_after
@Override
public void massUpdateVmNumaNodeRuntimePinning(List<VmNumaNode> vmNumaNodes) {
    List<MapSqlParameterSource> vNodeToPnodeDeletions = new ArrayList<>();
    List<MapSqlParameterSource> vNodeToPnodeInsertions = new ArrayList<>();
    for (VmNumaNode node : vmNumaNodes) {
        vNodeToPnodeDeletions.add(getCustomMapSqlParameterSource().addValue("vm_numa_node_id", node.getId()));
        for (Pair<Guid, Pair<Boolean, Integer>> pair : node.getVdsNumaNodeList()) {
            if (!pair.getSecond().getFirst()) {
                vNodeToPnodeInsertions.add(createVnodeToPnodeParametersMapper(pair, node.getId()));
            }
        }
    }
    if (!vNodeToPnodeDeletions.isEmpty()) {
        getCallsHandler().executeStoredProcAsBatch("DeleteUnpinnedNumaNodeMapByVmNumaNodeId", vNodeToPnodeDeletions);
    }
    if (!vNodeToPnodeInsertions.isEmpty()) {
        getCallsHandler().executeStoredProcAsBatch("InsertNumaNodeMap", vNodeToPnodeInsertions);
    }
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    }
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
private static void updateNetworkInterfaceDataFromHost(VdsNetworkInterface iface, VDS host, Map<String, Object> nic) {
    if (nic != null) {
        if (nic.get("speed") != null) {
            Object speed = nic.get("speed");
            iface.setSpeed((Integer) speed);
        }
        iface.setAddress((String) nic.get("addr"));
        iface.setSubnet((String) nic.get("netmask"));
        iface.setMacAddress((String) nic.get("hwaddr"));
        // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
        if (nic.get("permhwaddr") != null) {
            iface.setMacAddress((String) nic.get("permhwaddr"));
        }
        if (StringUtils.isNotBlank((String) nic.get(VdsProperties.MTU))) {
            iface.setMtu(Integer.parseInt((String) nic.get(VdsProperties.MTU)));
        }
        addBootProtocol((Map<String, Object>) nic.get("cfg"), host, iface);
    }
}
#method_after
private static void updateNetworkInterfaceDataFromHost(VdsNetworkInterface iface, VDS host, Map<String, Object> nic) {
    if (nic != null) {
        if (nic.get("speed") != null) {
            Object speed = nic.get("speed");
            iface.setSpeed((Integer) speed);
        }
        iface.setAddress((String) nic.get("addr"));
        iface.setSubnet((String) nic.get("netmask"));
        iface.setMacAddress((String) nic.get("hwaddr"));
        // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
        String mac = (String) nic.get("permhwaddr");
        if (mac != null) {
            // TODO remove when the minimal supported vdsm version is >=3.6
            // in older VDSM version, slave's Mac is in upper case
            iface.setMacAddress(mac.toLowerCase());
        }
        if (StringUtils.isNotBlank((String) nic.get(VdsProperties.MTU))) {
            iface.setMtu(Integer.parseInt((String) nic.get(VdsProperties.MTU)));
        }
        addBootProtocol((Map<String, Object>) nic.get("cfg"), host, iface);
    }
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmNumaNodeRuntimeData();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmNumaNodeRuntimeData();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void saveVmNumaNodeRuntimeData() {
    if (!_vmStatisticsToSave.isEmpty()) {
        final List<VmNumaNode> vmNumaNodesToUpdate = new ArrayList<>();
        for (VmStatistics vmStats : _vmStatisticsToSave.values()) {
            vmNumaNodesToUpdate.addAll(vmStats.getvNumaNodeStatisticsList());
        }
        if (!vmNumaNodesToUpdate.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getVmNumaNodeDAO().massUpdateVmNumaNodeRuntimePinning(vmNumaNodesToUpdate);
                    return null;
                }
            });
        }
    }
}
#method_after
private void saveVmNumaNodeRuntimeData() {
    if (!_vmStatisticsToSave.isEmpty()) {
        final List<VmNumaNode> vmNumaNodesToUpdate = new ArrayList<>();
        for (VmStatistics vmStats : _vmStatisticsToSave.values()) {
            vmNumaNodesToUpdate.addAll(vmStats.getvNumaNodeStatisticsList());
        }
        if (!vmNumaNodesToUpdate.isEmpty()) {
            getDbFacade().getVmNumaNodeDAO().massUpdateVmNumaNodeRuntimePinning(vmNumaNodesToUpdate);
        }
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getswap_free() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        Guid vmGuid = vmToRemove.getId();
        if (!migrating && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        updateVmNumaNodeRuntimeInfo(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#end_block

#method_before
private void updateVmNumaNodeRuntimeInfo(VmStatistics statistics, VM vm) {
    if (vm.getRunOnVds() == null) {
        return;
    }
    List<VdsNumaNode> runOnVdsAllNumaNodes = getDbFacade().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vm.getRunOnVds());
    List<VmNumaNode> vmAllNumaNodes = getDbFacade().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
    Map<Integer, VdsNumaNode> runOnVdsAllNumaNodesMap = new HashMap<>();
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = new HashMap<>();
    for (VdsNumaNode vdsNumaNode : runOnVdsAllNumaNodes) {
        runOnVdsAllNumaNodesMap.put(vdsNumaNode.getIndex(), vdsNumaNode);
    }
    for (VmNumaNode vmNumaNode : vmAllNumaNodes) {
        vmAllNumaNodesMap.put(vmNumaNode.getIndex(), vmNumaNode);
    }
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if ((!pinnedNodes.contains(pair.getSecond().getSecond())) && (runOnVdsAllNumaNodesMap.containsKey(pair.getSecond().getSecond()))) {
                    pair.setFirst(runOnVdsAllNumaNodesMap.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            vNode.setVdsNumaNodeList(runTimePinList);
            if (!vNode.getVdsNumaNodeList().isEmpty()) {
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    vm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#method_after
private void updateVmNumaNodeRuntimeInfo(VmStatistics statistics, VM vm) {
    if (!vm.getStatus().isRunning()) {
        vm.getStatisticsData().getvNumaNodeStatisticsList().clear();
        return;
    }
    // Build numa nodes map of the host which the vm is running on with node index as the key
    Map<Integer, VdsNumaNode> runOnVdsAllNumaNodesMap = new HashMap<>();
    List<VdsNumaNode> runOnVdsAllNumaNodes = getDbFacade().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vm.getRunOnVds());
    for (VdsNumaNode vdsNumaNode : runOnVdsAllNumaNodes) {
        runOnVdsAllNumaNodesMap.put(vdsNumaNode.getIndex(), vdsNumaNode);
    }
    // Build numa nodes map of the vm with node index as the key
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = new HashMap<>();
    List<VmNumaNode> vmAllNumaNodes = getDbFacade().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
    for (VmNumaNode vmNumaNode : vmAllNumaNodes) {
        vmAllNumaNodesMap.put(vmNumaNode.getIndex(), vmNumaNode);
    }
    // Initialize the unpinned vm numa nodes list with the runtime pinning information
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if ((!pinnedNodes.contains(pair.getSecond().getSecond())) && (runOnVdsAllNumaNodesMap.containsKey(pair.getSecond().getSecond()))) {
                    pair.setFirst(runOnVdsAllNumaNodesMap.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            if (!runTimePinList.isEmpty()) {
                vNode.setVdsNumaNodeList(runTimePinList);
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    vm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getswap_free() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < allowedMinAvailableThreshold ? allowedMinAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    final double THRESHOLD = 0.98;
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    // Allow the space to be up to 2% lower than as defined in configuration
    Long allowedMinAvailableThreshold = Math.round(minAvailableThreshold.doubleValue() * THRESHOLD);
    AuditLogType valueToLog = stat.getswap_free() < allowedMinAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < allowedMinAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < allowedMinAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private VmInfoBuilderBase createBuilder() {
    if (VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion())) {
        // backward compatibility for 3.0
        return new VmOldInfoBuilder(vm, createInfo);
    } else {
        return new VmInfoBuilder(vm, createInfo);
    }
}
#method_after
private VmInfoBuilderBase createBuilder() {
    if (VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion())) {
        // backward compatibility for 3.0
        return new VmOldInfoBuilder(vm, createInfo);
    } else {
        return new VmInfoBuilder(vm, getParameters().getVdsId(), createInfo);
    }
}
#end_block

#method_before
private void buildVmData() {
    builder.buildVmProperties();
    builder.buildVmVideoCards();
    builder.buildVmCD();
    builder.buildVmFloppy();
    builder.buildVmDrives();
    builder.buildVmNetworkInterfaces();
    builder.buildVmNetworkCluster();
    builder.buildVmBootSequence();
    builder.buildVmBootOptions();
    builder.buildVmSoundDevices();
    builder.buildVmConsoleDevice();
    builder.buildVmTimeZone();
    builder.buildVmUsbDevices();
    builder.buildVmMemoryBalloon();
    builder.buildVmWatchdog();
    builder.buildVmVirtioScsi();
    builder.buildVmRngDevice();
    builder.buildUnmanagedDevices();
    builder.buildVmSerialNumber();
    builder.buildVmNumaProperties(getParameters().getVdsId());
}
#method_after
private void buildVmData() {
    builder.buildVmProperties();
    builder.buildVmVideoCards();
    builder.buildVmCD();
    builder.buildVmFloppy();
    builder.buildVmDrives();
    builder.buildVmNetworkInterfaces();
    builder.buildVmNetworkCluster();
    builder.buildVmBootSequence();
    builder.buildVmBootOptions();
    builder.buildVmSoundDevices();
    builder.buildVmConsoleDevice();
    builder.buildVmTimeZone();
    builder.buildVmUsbDevices();
    builder.buildVmMemoryBalloon();
    builder.buildVmWatchdog();
    builder.buildVmVirtioScsi();
    builder.buildVmVirtioSerial();
    builder.buildVmRngDevice();
    builder.buildUnmanagedDevices();
    builder.buildVmSerialNumber();
    builder.buildVmNumaProperties();
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, String.valueOf(Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getVdsGroupCompatibilityVersion().getValue())));
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, getVdsGroup().getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, getVdsGroup().getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(unregisteredDisks);
    if (!ovfStoreDiskImages.isEmpty()) {
        registerAllOvfDisks(ovfStoreDiskImages);
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                } else {
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
            }
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Initialize the list with all the ovfDisks in the specified Storage Domain.
    List<DiskImage> ovfStoreDiskImages = getAllOVFDisks();
    if (!ovfStoreDiskImages.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                } else {
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
            }
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#end_block

#method_before
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias("OVF_STORE");
        ovfStoreDiskImage.setDiskDescription("OVF_STORE");
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        String result = "succeeded";
        try {
            if (!runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, null).getSucceeded()) {
                result = "failed";
            }
        } catch (Exception e) {
            result = "failed";
            log.error(e);
        }
        log.infoFormat("Register OVF_STORE disk id {0} for storage domain {1} has {2}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), result);
    }
}
#method_after
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        String result = "succeeded";
        if (!runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded()) {
            result = "failed";
        }
        log.infoFormat("Register new floating OVF_STORE disk with disk id {0} for storage domain {1} has {2}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), result);
    }
}
#end_block

#method_before
private List<DiskImage> getAllOVFDisks(List<Disk> disks) {
    List<DiskImage> ovfDisks = new ArrayList<>();
    for (Disk disk : disks) {
        DiskImage ovfStoreDisk = (DiskImage) disk;
        String diskDecription = ovfStoreDisk.getDescription();
        if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
            Map<String, Object> diskDescriptionMap;
            try {
                diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
            } catch (IOException e) {
                log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
                continue;
            }
            // Domain.
            if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                log.warnFormat("The disk description does not contain the storage domain id {0}", getParameters().getStorageDomainId());
                continue;
            }
            ovfDisks.add(ovfStoreDisk);
        }
    }
    return ovfDisks;
}
#method_after
protected List<DiskImage> getAllOVFDisks() {
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
        for (Disk disk : unregisteredDisks) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDecription = ovfStoreDisk.getDescription();
            if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
                } catch (IOException e) {
                    log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                    log.warnFormat("The disk description does not contain the storage domain id {0}", getParameters().getStorageDomainId());
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#end_block

#method_before
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        // Check which disks are of OVF_STORE
        String diskDecription = ovfStoreDisk.getDescription();
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#method_after
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(ovfStoreDisk.getDescription());
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#end_block

#method_before
@Override
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (_vds.getStatus() != VDSStatus.Maintenance && _vds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, _vds);
            updateDynamicData(_vds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(_vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#method_after
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (_vds.getStatus() != VDSStatus.Maintenance && _vds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, _vds);
            updateDynamicData(_vds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(_vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#end_block

#method_before
@Override
public void handlePreviousStatus() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        _vds.setPreviousStatus(_vds.getStatus());
    } else {
        _vds.setPreviousStatus(VDSStatus.Up);
    }
}
#method_after
public void handlePreviousStatus() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        _vds.setPreviousStatus(_vds.getStatus());
    } else {
        _vds.setPreviousStatus(VDSStatus.Up);
    }
}
#end_block

#method_before
@Override
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int timeout = Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes);
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    duringFailureJobId = sched.scheduleAFixedDelayJob(this, "onVdsDuringFailureTimer", new Class[0], new Object[0], timeout, timeout, TimeUnit.MINUTES);
    sched.pauseJob(duringFailureJobId);
    // start with refresh statistics
    _refreshIteration = _numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#method_after
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    // start with refresh statistics
    _refreshIteration = _numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#method_after
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!isInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval && _vds.getStatus() != VDSStatus.InstallingOS) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@Override
public boolean isMonitoringNeeded() {
    return (monitoringStrategy.isMonitoringNeeded(_vds) && _vds.getStatus() != VDSStatus.Installing && _vds.getStatus() != VDSStatus.InstallFailed && _vds.getStatus() != VDSStatus.Reboot && _vds.getStatus() != VDSStatus.Maintenance && _vds.getStatus() != VDSStatus.PendingApproval && _vds.getStatus() != VDSStatus.Down);
}
#method_after
public boolean isMonitoringNeeded() {
    return (monitoringStrategy.isMonitoringNeeded(_vds) && _vds.getStatus() != VDSStatus.Installing && _vds.getStatus() != VDSStatus.InstallFailed && _vds.getStatus() != VDSStatus.Reboot && _vds.getStatus() != VDSStatus.Maintenance && _vds.getStatus() != VDSStatus.PendingApproval && _vds.getStatus() != VDSStatus.InstallingOS && _vds.getStatus() != VDSStatus.Down && _vds.getStatus() != VDSStatus.Kdumping);
}
#end_block

#method_before
private void HandleVdsRecoveringException(VDSRecoveringException ex) {
    if (_vds.getStatus() != VDSStatus.Initializing && _vds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, _vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(_vds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, error = {2}, continuing.", _vds.getId(), _vds.getName(), ex.getMessage());
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMintues);
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(_vds.getId(), jobId);
    }
}
#method_after
private void HandleVdsRecoveringException(VDSRecoveringException ex) {
    if (_vds.getStatus() != VDSStatus.Initializing && _vds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, _vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(_vds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, error = {2}, continuing.", _vds.getId(), _vds.getName(), ex.getMessage());
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(_vds.getId(), jobId);
    }
}
#end_block

#method_before
@Override
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#method_after
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#end_block

#method_before
@Override
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#method_after
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#end_block

#method_before
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
@Override
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
                if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warnFormat("Host {0} is running with disabled SELinux.", vds.getName());
            } else {
                log.warnFormat("Host {0} does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
@Override
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of {1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        moveVMsToUnknown();
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing, lastUpdate);
    }
    return true;
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    XmlRpcUtils.shutDownConnection(((VdsServerWrapper) _vdsProxy).getHttpClient());
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    _vdsProxy.close();
}
#end_block

#method_before
public void setInitialized(boolean value) {
    privateInitialized = value;
}
#method_after
public void setInitialized(boolean value) {
    initialized = value;
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            if (_firstStatus != VDSStatus.Up) {
                monitoringStrategy.processHardwareCapabilities(_vds);
            }
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.infoFormat("Host '{0}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{1}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface.getName());
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        Guid vmGuid = vmToRemove.getId();
        if (!migrating && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#end_block

#method_before
@Override
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#method_after
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, vds);
            updateDynamicData(vds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#end_block

#method_before
@Override
public void handlePreviousStatus() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        vds.setPreviousStatus(vds.getStatus());
    } else {
        vds.setPreviousStatus(VDSStatus.Up);
    }
}
#method_after
public void handlePreviousStatus() {
    if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        vds.setPreviousStatus(vds.getStatus());
    } else {
        vds.setPreviousStatus(VDSStatus.Up);
    }
}
#end_block

#method_before
@Override
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int timeout = Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes);
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    duringFailureJobId = sched.scheduleAFixedDelayJob(this, "onVdsDuringFailureTimer", new Class[0], new Object[0], timeout, timeout, TimeUnit.MINUTES);
    sched.pauseJob(duringFailureJobId);
    // start with refresh statistics
    refreshIteration = numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#method_after
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    // start with refresh statistics
    refreshIteration = numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#method_after
public void updateVmDynamic(VmDynamic vmDynamic) {
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, vds, monitoringStrategy);
                        vdsUpdater.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && vds.getStatus() != VDSStatus.NonResponsive && vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (vdsUpdater != null) {
                        vdsUpdater.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (vds != null && vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = vds.getStoragePoolId();
                            domainsList = vds.getDomains();
                        }
                    }
                    vds = null;
                    vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, vds, monitoringStrategy);
                        vdsUpdater.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!isInitialized() && vds.getStatus() != VDSStatus.NonResponsive && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
                        log.infoFormat("Initializing Host: {0}", vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (vdsUpdater != null) {
                        vdsUpdater.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (vds != null && vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = vds.getStoragePoolId();
                            domainsList = vds.getDomains();
                        }
                    }
                    vds = null;
                    vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@Override
public boolean isMonitoringNeeded() {
    return (monitoringStrategy.isMonitoringNeeded(vds) && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallFailed && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Down);
}
#method_after
public boolean isMonitoringNeeded() {
    return (monitoringStrategy.isMonitoringNeeded(vds) && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallFailed && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.Down && vds.getStatus() != VDSStatus.Kdumping);
}
#end_block

#method_before
@Override
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#method_after
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
}
#end_block

#method_before
@Override
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#method_after
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
}
#end_block

#method_before
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
@Override
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (vds != null) {
                vds.setPreviousStatus(vds.getStatus());
                if (vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.vds != null) {
            this.vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.vds != null) {
                    this.vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.vds != null) {
                    this.vds.setCpuSys(Double.valueOf(0));
                    this.vds.setCpuUser(Double.valueOf(0));
                    this.vds.setCpuIdle(Double.valueOf(0));
                    this.vds.setCpuLoad(Double.valueOf(0));
                    this.vds.setUsageCpuPercent(0);
                    this.vds.setUsageMemPercent(0);
                    this.vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (this.vds != null) {
                this.vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.vds != null) {
            this.vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.vds != null) {
                    this.vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.vds != null) {
                    this.vds.setCpuSys(Double.valueOf(0));
                    this.vds.setCpuUser(Double.valueOf(0));
                    this.vds.setCpuIdle(Double.valueOf(0));
                    this.vds.setCpuLoad(Double.valueOf(0));
                    this.vds.setUsageCpuPercent(0);
                    this.vds.setUsageMemPercent(0);
                    this.vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warnFormat("Host {0} is running with disabled SELinux.", vds.getName());
            } else {
                log.warnFormat("Host {0} does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
@Override
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of {1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        moveVMsToUnknown();
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing, lastUpdate);
    }
    return true;
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    XmlRpcUtils.shutDownConnection(((VdsServerWrapper) vdsProxy).getHttpClient());
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    vdsProxy.close();
}
#end_block

#method_before
@Override
public void logNetworkException(VDSNetworkException e) {
    switch(vds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debugFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
            break;
        default:
            log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
    }
}
#method_after
private void logNetworkException(VDSNetworkException e) {
    switch(vds.getStatus()) {
        case Down:
            break;
        case NonResponsive:
            log.debugFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
            break;
        default:
            log.warnFormat("Failed to refresh VDS , vds = {0} : {1}, VDS Network Error, continuing.\n{2}", vds.getId(), vds.getName(), e.getMessage());
    }
}
#end_block

#method_before
@Override
public void finishSshSoftFencingExecution(VDS vds) {
    // reset the unresponded counter to wait if VDSM restart helps
    mUnrespondedAttempts.set(0);
    // change VDS state to connecting
    setStatus(VDSStatus.Connecting, vds);
    updateDynamicData(vds.getDynamicData());
}
#method_after
public void finishSshSoftFencingExecution(VDS vds) {
    // reset the unresponded counter to wait if VDSM restart helps
    mUnrespondedAttempts.set(0);
    // change VDS state to connecting
    setStatus(VDSStatus.Connecting, vds);
    updateDynamicData(vds.getDynamicData());
}
#end_block

#method_before
public void setInitialized(boolean value) {
    privateInitialized = value;
}
#method_after
public void setInitialized(boolean value) {
    initialized = value;
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getStatus() && _vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getName());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(_vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            getVdsEventListener().processOnVmPoweringUp(runningVm.getId());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            if (_firstStatus != VDSStatus.Up) {
                monitoringStrategy.processHardwareCapabilities(_vds);
            }
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    getVdsEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.infoFormat("Host '{0}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{1}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface.getName());
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                if ((vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.Up) || (vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp)) {
                    _poweringUpVms.add(runningVm);
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.isInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        Guid vmGuid = vmToRemove.getId();
        if (!migrating && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getName());
        returnValue = true;
    } else if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(_vds.getId()) && runningVm.getStatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            vdsMaintenanceTimeoutOccurred = _vdsManager.isTimeToRetryMaintenance();
        }
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        Guid vmId = vmToUpdate.getId();
        Collection<DiskImageDynamic> vmDisksDynamic = _runningVms.get(vmId).getVmDynamic().getDisks();
        for (DiskImageDynamic diskImageDynamic : vmDisksDynamic) {
            _vmDiskImageDynamicToSave.add(new Pair<>(vmId, diskImageDynamic));
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + (initialized ? 1231 : 1237);
    result = prime * result + diskSize;
    result = prime * result + ((getName() == null) ? 0 : getName().hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((vmtGuid == null) ? 0 : vmtGuid.hashCode());
    result = prime * result + (useHostCpuFlags ? 1231 : 1237);
    result = prime * result + ((instanceTypeId == null) ? 0 : instanceTypeId.hashCode());
    result = prime * result + ((imageTypeId == null) ? 0 : imageTypeId.hashCode());
    result = prime * result + ((originalTemplateGuid == null) ? 0 : originalTemplateGuid.hashCode());
    result = prime * result + ((originalTemplateName == null) ? 0 : originalTemplateName.hashCode());
    result = prime * result + (useLatestVersion ? 1249 : 1259);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + (initialized ? 1231 : 1237);
    result = prime * result + ((getName() == null) ? 0 : getName().hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((vmtGuid == null) ? 0 : vmtGuid.hashCode());
    result = prime * result + (useHostCpuFlags ? 1231 : 1237);
    result = prime * result + ((instanceTypeId == null) ? 0 : instanceTypeId.hashCode());
    result = prime * result + ((imageTypeId == null) ? 0 : imageTypeId.hashCode());
    result = prime * result + ((originalTemplateGuid == null) ? 0 : originalTemplateGuid.hashCode());
    result = prime * result + ((originalTemplateName == null) ? 0 : originalTemplateName.hashCode());
    result = prime * result + (useLatestVersion ? 1249 : 1259);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmStatic)) {
        return false;
    }
    VmStatic other = (VmStatic) obj;
    return (initialized == other.initialized && diskSize == other.diskSize && ObjectUtils.objectsEqual(getName(), other.getName()) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(vmtGuid, other.vmtGuid) && useHostCpuFlags == other.useHostCpuFlags && ObjectUtils.objectsEqual(instanceTypeId, other.instanceTypeId) && ObjectUtils.objectsEqual(imageTypeId, other.imageTypeId) && ObjectUtils.objectsEqual(originalTemplateGuid, other.originalTemplateGuid) && ObjectUtils.objectsEqual(originalTemplateName, other.originalTemplateName) && useLatestVersion == other.useLatestVersion);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmStatic)) {
        return false;
    }
    VmStatic other = (VmStatic) obj;
    return (initialized == other.initialized && ObjectUtils.objectsEqual(getName(), other.getName()) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(vmtGuid, other.vmtGuid) && useHostCpuFlags == other.useHostCpuFlags && ObjectUtils.objectsEqual(instanceTypeId, other.instanceTypeId) && ObjectUtils.objectsEqual(imageTypeId, other.imageTypeId) && ObjectUtils.objectsEqual(originalTemplateGuid, other.originalTemplateGuid) && ObjectUtils.objectsEqual(originalTemplateName, other.originalTemplateName) && useLatestVersion == other.useLatestVersion);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList));
}
#end_block

#method_before
@Test
public void testGetAllEntitiesForStorageDomain() {
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomainByEntityType(FixturesTool.STORAGE_DOAMIN_NFS2_1, null);
    assertTrue("There should be entities fetched for the specified storage domain", !ovfEntityDataList.isEmpty());
    assertEquals("A Template and a VM should be fetched for the specified storage domain", 2, ovfEntityDataList.size());
}
#method_after
@Test
public void testGetAllEntitiesForStorageDomain() {
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomainByEntityType(FixturesTool.STORAGE_DOAMIN_NFS2_1, null);
    assertEquals("A Template and a VM should be fetched for the specified storage domain", 2, ovfEntityDataList.size());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        registerAllOvfDisks(getAllOVFDisks());
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Initialize the list with all the ovfDisks in the specified Storage Domain.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                } else {
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
            }
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Initialize the list with all the ovfDisks in the specified Storage Domain.
    List<DiskImage> ovfStoreDiskImages = getAllOVFDisks();
    if (!ovfStoreDiskImages.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                } else {
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
            }
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#end_block

#method_before
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        String result = "succeeded";
        if (!runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, null).getSucceeded()) {
            result = "failed";
        }
        log.infoFormat("Register new floating OVF_STORE disk with disk id {0} for storage domain {1} has {2}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), result);
    }
}
#method_after
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        String result = "succeeded";
        if (!runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded()) {
            result = "failed";
        }
        log.infoFormat("Register new floating OVF_STORE disk with disk id {0} for storage domain {1} has {2}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), result);
    }
}
#end_block

#method_before
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        // Check which disks are of OVF_STORE
        String diskDecription = ovfStoreDisk.getDescription();
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (date == null) {
            continue;
        }
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#method_after
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(ovfStoreDisk.getDescription());
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (date == null) {
            continue;
        }
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#end_block

#method_before
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        if (map.get(OvfInfoFileConstants.LastUpdated) != null) {
            return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(map.get(OvfInfoFileConstants.LastUpdated).toString());
        } else {
            log.info("LastUpdate Date is not initialized in the OVF_STORE disk.");
        }
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
    }
    return null;
}
#method_after
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        Object lastUpdate = map.get(OvfInfoFileConstants.LastUpdated);
        if (lastUpdate != null) {
            return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(lastUpdate.toString());
        } else {
            log.info("LastUpdate Date is not initialized in the OVF_STORE disk.");
        }
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
    }
    return null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(unregisteredDisks);
    if (!ovfStoreDiskImages.isEmpty()) {
        registerAllOvfDisks(ovfStoreDiskImages);
        boolean entitiesRetrieved = false;
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                if (!entitiesRetrieved) {
                    try {
                        VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                        if (retrievedByteData.getSucceeded()) {
                            ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                            entitiesRetrieved = true;
                        } else {
                            log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                        }
                    } catch (RuntimeException e) {
                        // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                        // a RuntimeException if there is a problem to untar the file.
                        log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                    }
                }
                addOvfStoreDiskToDomain(ovfDisk);
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        if (!entitiesRetrieved) {
            AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                    if (retrievedByteData.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void addOvfStoreDiskToDomain(DiskImage ovfDisk) {
    if (ovfDisk != null) {
        // Setting OVF_STORE disk to be outdated so it will be updated.
        StorageDomainOvfInfo storageDomainOvfInfo = new StorageDomainOvfInfo(getStorageDomainId(), null, ovfDisk.getId(), StorageDomainOvfInfoStatus.OUTDATED, null);
        getDbFacade().getStorageDomainOvfInfoDao().save(storageDomainOvfInfo);
    }
}
#method_after
private void addOvfStoreDiskToDomain(DiskImage ovfDisk) {
    // Setting OVF_STORE disk to be outdated so it will be updated.
    StorageDomainOvfInfo storageDomainOvfInfo = new StorageDomainOvfInfo(getStorageDomainId(), null, ovfDisk.getId(), StorageDomainOvfInfoStatus.OUTDATED, null);
    getDbFacade().getStorageDomainOvfInfoDao().save(storageDomainOvfInfo);
}
#end_block

#method_before
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias("OVF_STORE");
        ovfStoreDiskImage.setDiskDescription("OVF_STORE");
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        String result = "succeeded";
        try {
            if (!runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, null).getSucceeded()) {
                result = "failed";
            }
        } catch (Exception e) {
            result = "failed";
            log.error(e);
        }
        log.infoFormat("Register new floating OVF_STORE disk with disk id {0} for storage domain {1} has {2}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), result);
    }
}
#method_after
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        String result = "succeeded";
        if (!runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded()) {
            result = "failed";
        }
        log.infoFormat("Register new floating OVF_STORE disk with disk id {0} for storage domain {1} has {2}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), result);
        addOvfStoreDiskToDomain(ovfStoreDiskImage);
    }
}
#end_block

#method_before
private List<DiskImage> getAllOVFDisks(List<Disk> disks) {
    List<DiskImage> ovfDisks = new ArrayList<>();
    for (Disk disk : disks) {
        DiskImage ovfStoreDisk = (DiskImage) disk;
        String diskDecription = ovfStoreDisk.getDescription();
        if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
            Map<String, Object> diskDescriptionMap;
            try {
                diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
            } catch (IOException e) {
                log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
                continue;
            }
            // Domain.
            if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                log.warnFormat("The disk description does not contain the storage domain id {0}", getParameters().getStorageDomainId());
                continue;
            }
            ovfDisks.add(ovfStoreDisk);
        }
    }
    return ovfDisks;
}
#method_after
protected List<DiskImage> getAllOVFDisks() {
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
        for (Disk disk : unregisteredDisks) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDecription = ovfStoreDisk.getDescription();
            if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
                } catch (IOException e) {
                    log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                    log.warnFormat("The disk description does not contain the storage domain id {0}", getParameters().getStorageDomainId());
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#end_block

#method_before
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        // Check which disks are of OVF_STORE
        String diskDecription = ovfStoreDisk.getDescription();
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#method_after
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(ovfStoreDisk.getDescription());
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (date == null) {
            continue;
        }
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#end_block

#method_before
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(map.get(OvfInfoFileConstants.LastUpdated).toString());
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
        return null;
    }
}
#method_after
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        Object lastUpdate = map.get(OvfInfoFileConstants.LastUpdated);
        if (lastUpdate != null) {
            return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(lastUpdate.toString());
        } else {
            log.info("LastUpdate Date is not initialized in the OVF_STORE disk.");
        }
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
    }
    return null;
}
#end_block

#method_before
private byte[] buildOvfInfoFileByteArray(List<Guid> vmAndTemplatesIds) {
    ByteArrayOutputStream bufferedOutputStream = new ByteArrayOutputStream();
    try (InMemoryTar inMemoryTar = new InMemoryTar(bufferedOutputStream)) {
        inMemoryTar.addTarEntry(generateInfoFileData().getBytes(), "info.json");
        int i = 0;
        while (i < vmAndTemplatesIds.size()) {
            int size = Math.min(StorageConstants.OVF_MAX_ITEMS_PER_SQL_STATEMENT, vmAndTemplatesIds.size() - i);
            List<Guid> idsToProcess = vmAndTemplatesIds.subList(i, i + size);
            i += size;
            List<Pair<Guid, String>> ovfs = getVmAndTemplatesGenerationsDao().loadOvfDataForIds(idsToProcess);
            addUnregisteredEntities(ovfs);
            if (!ovfs.isEmpty()) {
                buildFilesForOvfs(ovfs, inMemoryTar);
            }
        }
    } catch (Exception e) {
        throw new RuntimeException(String.format("Exception while building in memory tar of the OVFs of domain %s", getParameters().getStorageDomainId()), e);
    }
    return bufferedOutputStream.toByteArray();
}
#method_after
private byte[] buildOvfInfoFileByteArray(List<Guid> vmAndTemplatesIds) {
    ByteArrayOutputStream bufferedOutputStream = new ByteArrayOutputStream();
    Set<Guid> processedIds = new HashSet<>();
    try (InMemoryTar inMemoryTar = new InMemoryTar(bufferedOutputStream)) {
        inMemoryTar.addTarEntry(generateInfoFileData().getBytes(), "info.json");
        int i = 0;
        while (i < vmAndTemplatesIds.size()) {
            int size = Math.min(StorageConstants.OVF_MAX_ITEMS_PER_SQL_STATEMENT, vmAndTemplatesIds.size() - i);
            List<Guid> idsToProcess = vmAndTemplatesIds.subList(i, i + size);
            i += size;
            List<Pair<Guid, String>> ovfs = getVmAndTemplatesGenerationsDao().loadOvfDataForIds(idsToProcess);
            if (!ovfs.isEmpty()) {
                processedIds.addAll(buildFilesForOvfs(ovfs, inMemoryTar));
            }
        }
        List<Pair<Guid, String>> unprocessedOvfData = retrieveUnprocessedUnregisteredOvfData(processedIds);
        buildFilesForOvfs(unprocessedOvfData, inMemoryTar);
    } catch (Exception e) {
        throw new RuntimeException(String.format("Exception while building in memory tar of the OVFs of domain %s", getParameters().getStorageDomainId()), e);
    }
    return bufferedOutputStream.toByteArray();
}
#end_block

#method_before
protected void buildFilesForOvfs(List<Pair<Guid, String>> ovfs, InMemoryTar inMemoryTar) throws Exception {
    for (Pair<Guid, String> pair : ovfs) {
        if (pair.getSecond() != null) {
            inMemoryTar.addTarEntry(pair.getSecond().getBytes(), pair.getFirst() + ".ovf");
        }
    }
}
#method_after
protected Set<Guid> buildFilesForOvfs(List<Pair<Guid, String>> ovfs, InMemoryTar inMemoryTar) throws Exception {
    Set<Guid> addedOvfIds = new HashSet<>();
    for (Pair<Guid, String> pair : ovfs) {
        if (pair.getSecond() != null) {
            inMemoryTar.addTarEntry(pair.getSecond().getBytes(), pair.getFirst() + ".ovf");
            addedOvfIds.add(pair.getFirst());
        }
    }
    return addedOvfIds;
}
#end_block

#method_before
public void ensureColumnPresent(Column<T, ?> column, String headerText, boolean present, String width) {
    if (present) {
        // Remove the column first
        if (getColumnIndex(column) != -1) {
            removeColumn(column);
        }
        // Re-add the column
        if (width == null) {
            addColumnWithHtmlHeader(column, headerText);
        } else {
            addColumnWithHtmlHeader(column, headerText, width);
        }
    } else if (!present && getColumnIndex(column) != -1) {
        // Remove the column
        removeColumn(column);
    }
}
#method_after
public void ensureColumnPresent(Column<T, ?> column, String headerText, boolean present, String width) {
    boolean columnPresent = getColumnIndex(column) != -1;
    if (present && !columnPresent) {
        // Add the column
        if (width == null) {
            addColumnWithHtmlHeader(column, headerText);
        } else {
            addColumnWithHtmlHeader(column, headerText, width);
        }
    } else if (!present && columnPresent) {
        // Remove the column
        removeColumn(column);
    }
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    param.setPmProxyPreferences(getPmProxyPreferences());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#end_block

#method_before
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation() });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#method_after
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50) });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (getIsDiscorveredHosts().getEntity()) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().validateEntity(new IValidation[] { new NotEmptyValidation() });
        getExternalHostGroups().validateEntity(new IValidation[] { new NotEmptyValidation() });
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (Boolean.TRUE.equals(getIsDiscoveredHosts().getEntity())) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().setIsValid(getExternalComputeResource().getSelectedItem() != null);
        getExternalHostGroups().setIsValid(getExternalHostGroups().getSelectedItem() != null);
    } else {
        getExternalComputeResource().setIsValid(true);
        getExternalHostGroups().setIsValid(true);
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid() && getExternalHostGroups().getIsValid() && getExternalComputeResource().getIsValid() && getUserPassword().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsAvailable(showTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void updateExternalHostModels() {
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<Provider> providers = (ArrayList<Provider>) result;
            ListModel providersListModel = getProviders();
            providersListModel.setItems(providers);
            providersListModel.setIsChangable(true);
            getIsDiscoveredHosts().setEntity(null);
            getIsDiscoveredHosts().setEntity(true);
        }
    };
    AsyncDataProvider.getInstance().getAllProvidersByType(getProvidersQuery, ProviderType.FOREMAN);
}
#method_after
private void updateExternalHostModels() {
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<Provider> providers = (ArrayList<Provider>) result;
            ListModel<Provider> providersListModel = getProviders();
            providersListModel.setItems(providers, Linq.firstOrDefault(providers));
            providersListModel.setIsChangable(true);
            getIsDiscoveredHosts().setEntity(null);
            getIsDiscoveredHosts().setEntity(true);
        }
    };
    AsyncDataProvider.getInstance().getAllProvidersByType(getProvidersQuery, ProviderType.FOREMAN);
}
#end_block

#method_before
@Override
public String toString() {
    // Since the static data arrives from external source it's not guarenteed not to be null so a null check is
    // mandatory in order to avoid NPE when invoking toString by the logger
    String domainName = staticData.getName() == null ? "null" : staticData.getName();
    String domainId = staticData.getId() == null ? "null" : staticData.getId().toString();
    return "StorageDomain[" + domainName + ", " + domainId + "]";
}
#method_after
@Override
public String toString() {
    // Since the static data arrives from external source it's not guarenteed not to be null so a null check is
    // mandatory in order to avoid NPE when invoking toString by the logger
    String domainName = staticData == null ? "null" : staticData.getName();
    Guid domainId = staticData == null ? null : staticData.getId();
    return "StorageDomain[" + domainName + ", " + domainId + "]";
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getIsDiscoveredHosts().getEntity()) {
            Provider<?> provider = (Provider<?>) model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = (Provider<?>) model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (getIsDiscoveredHosts().getEntity()) {
        getUserPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255) });
        getExternalComputeResource().validateEntity(new IValidation[] { new NotEmptyValidation() });
        getExternalHostGroups().validateEntity(new IValidation[] { new NotEmptyValidation() });
    }
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid() && getExternalHostGroups().getIsValid() && getExternalComputeResource().getIsValid() && getUserPassword().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getIsDiscoveredHosts().getEntity() == true) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText(object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
@Override
public void showPowerManagement() {
    tabPanel.switchTab(powerManagementTab);
}
#method_after
@Override
public void showPowerManagement() {
    getTabPanel().switchTab(powerManagementTab);
}
#end_block

#method_before
public void ensureColumnPresent(Column<T, ?> column, String headerText, boolean present, String width) {
    if (present) {
        if (getColumnIndex(column) == -1) {
            // Add the column
            if (width == null) {
                addColumnWithHtmlHeader(column, headerText);
            } else {
                addColumnWithHtmlHeader(column, headerText, width);
            }
        }
    } else if (!present && getColumnIndex(column) != -1) {
        // Remove the column
        removeColumn(column);
    }
}
#method_after
public void ensureColumnPresent(Column<T, ?> column, String headerText, boolean present, String width) {
    boolean columnPresent = getColumnIndex(column) != -1;
    if (present && !columnPresent) {
        // Add the column
        if (width == null) {
            addColumnWithHtmlHeader(column, headerText);
        } else {
            addColumnWithHtmlHeader(column, headerText, width);
        }
    } else if (!present && columnPresent) {
        // Remove the column
        removeColumn(column);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (getDbFacade().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid(), getContext().getEngineContext())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.checkImagesConfiguration(getParameters().getStorageDomainId(), disksForExport, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshots that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    handleDestStorageDomain(disksForExport);
    SnapshotsValidator snapshotValidator = new SnapshotsValidator();
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (getDbFacade().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid(), getContext().getEngineContext())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.checkImagesConfiguration(getParameters().getStorageDomainId(), disksForExport, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshots that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    if (!handleDestStorageDomain(disksForExport)) {
        return false;
    }
    SnapshotsValidator snapshotValidator = new SnapshotsValidator();
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean handleDestStorageDomain(List<DiskImage> disksList) {
    ensureDomainMap(disksList, getStorageDomainId());
    List<DiskImage> dummiesDisksList = createDiskDummiesForSpaceValidations(disksList);
    dummiesDisksList.addAll(getMemoryDisks());
    return validateSpaceRequirements(dummiesDisksList);
}
#method_after
protected boolean handleDestStorageDomain(List<DiskImage> disksList) {
    ensureDomainMap(disksList, getStorageDomainId());
    List<DiskImage> dummiesDisksList = createDiskDummiesForSpaceValidations(disksList);
    dummiesDisksList.addAll(getMemoryVolumes());
    return validateSpaceRequirements(dummiesDisksList);
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    preferences.node("/os/windows_8/devices/cpu/unsupported").put("value", "conroe, opteron_g1");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    preferences.node("/os/windows_8/cpu/unsupported").put("value", "conroe, opteron_g1");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            SearchableListModel searchableListModel = (SearchableListModel) model;
            ArrayList<StorageDomain> domains = (ArrayList<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            for (StorageDomain domain : domains) {
                String guid = domain.getStoragePoolId() != null ? domain.getStoragePoolId().toString() : Guid.Empty.toString();
                domain.setId(domain.getStoragePoolId());
            }
            searchableListModel.setItems(domains);
            setIsEmpty(((List) searchableListModel.getItems()).size() == 0);
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(getEntity().getId());
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainListById, tempVar, _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            SearchableListModel searchableListModel = (SearchableListModel) model;
            ArrayList<StorageDomain> domains = (ArrayList<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            for (StorageDomain domain : domains) {
                domain.setId(domain.getStoragePoolId());
            }
            searchableListModel.setItems(domains);
            setIsEmpty(((List) searchableListModel.getItems()).size() == 0);
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(getEntity().getId());
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainListById, tempVar, _asyncQuery);
}
#end_block

#method_before
private boolean allowedNetworkLabelManipulation() {
    Network oldNetwork = getOldNetwork();
    Network newNetwork = getNetwork();
    boolean labelNotChanged = Objects.equals(oldNetwork.getLabel(), newNetwork.getLabel());
    boolean newLabelAssigned = oldNetwork.getLabel() == null && newNetwork.getLabel() != null;
    return labelNotChanged || newLabelAssigned;
}
#method_after
private boolean allowedNetworkLabelManipulation() {
    boolean labelNotChanged = !new SyncNetworkParametersBuilder(getContext()).labelChanged();
    boolean newLabelAssigned = !new SyncNetworkParametersBuilder(getContext()).labelAdded();
    return !getNetwork().isExternal() && (labelNotChanged || newLabelAssigned);
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    XmlRpcUtils.shutDownConnection(_vdsProxy.getHttpClient());
    if (JsonRpcVdsServer.class.isInstance(_vdsProxy)) {
        ((JsonRpcVdsServer) _vdsProxy).close();
    }
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    _vdsProxy.close();
}
#end_block

#method_before
private void cacheNegotiatingProfiles() {
    synchronized (this) {
        schemes = new ArrayList<String>();
        profiles = new ArrayList<AuthenticationProfile>();
        for (AuthenticationProfile profile : AuthenticationProfileRepository.getInstance().getProfiles()) {
            ExtMap authnContext = profile.getAuthn().getContext();
            if ((authnContext.<Long>get(Authn.ContextKeys.CAPABILITIES).longValue() & caps) != 0) {
                profiles.add(profile);
                schemes.addAll(authnContext.<Collection<String>>get(Authn.ContextKeys.HTTP_AUTHENTICATION_SCHEME, Collections.<String>emptyList()));
            }
        }
        Collections.sort(profiles, new Comparator<AuthenticationProfile>() {

            @Override
            public int compare(AuthenticationProfile o1, AuthenticationProfile o2) {
                return Integer.valueOf(o1.getNegotiationPriority()).compareTo(o2.getNegotiationPriority());
            }
        });
    }
}
#method_after
private synchronized void cacheNegotiatingProfiles() {
    schemes = new ArrayList<String>();
    profiles = new ArrayList<AuthenticationProfile>();
    for (AuthenticationProfile profile : AuthenticationProfileRepository.getInstance().getProfiles()) {
        ExtMap authnContext = profile.getAuthn().getContext();
        if ((authnContext.<Long>get(Authn.ContextKeys.CAPABILITIES).longValue() & caps) != 0) {
            profiles.add(profile);
            schemes.addAll(authnContext.<Collection<String>>get(Authn.ContextKeys.HTTP_AUTHENTICATION_SCHEME, Collections.<String>emptyList()));
        }
    }
    Collections.sort(profiles, new Comparator<AuthenticationProfile>() {

        @Override
        public int compare(AuthenticationProfile o1, AuthenticationProfile o2) {
            return Integer.valueOf(o1.getNegotiationPriority()).compareTo(o2.getNegotiationPriority());
        }
    });
}
#end_block

#method_before
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    return createParams;
}
#method_after
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    createParams.setDiskProfileId(diskInfoDestinationMap.get(diskImage.getId()).getDiskProfileId());
    return createParams;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    persistCommand(getParameters().getParentCommand(), false);
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
    persistCommand(getParameters().getParentCommand(), false);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (TaskManagerUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    return getAcceptableHosts(true, hosts, vm, messages);
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    return getAcceptableHosts(true, hosts, vm, messages);
}
#end_block

#method_before
public static List<VDS> getAcceptableHosts(boolean enforcing, List<VDS> hosts, VM vm, List<String> messages) {
    List<AffinityGroup> affinityGroups = getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    // no affinity groups found for VM return all hosts
    if (affinityGroups.isEmpty()) {
        return hosts;
    }
    Set<Guid> allVmIdsPositive = new HashSet<Guid>();
    Set<Guid> allVmIdsNegative = new HashSet<Guid>();
    List<String> positiveAffinityGroupNames = new ArrayList<>();
    // Group by all vms in affinity groups per positive or negative
    for (AffinityGroup affinityGroup : affinityGroups) {
        if (affinityGroup.isEnforcing() == enforcing) {
            for (Guid entityId : affinityGroup.getEntityIds()) {
                // Skip current VM
                if (entityId.equals(vm.getId())) {
                    continue;
                }
                if (affinityGroup.isPositive()) {
                    positiveAffinityGroupNames.add(affinityGroup.getName());
                    allVmIdsPositive.add(entityId);
                } else {
                    allVmIdsNegative.add(entityId);
                }
            }
        }
    }
    // No entities, all hosts are valid
    if (allVmIdsPositive.isEmpty() && allVmIdsNegative.isEmpty()) {
        return hosts;
    }
    // Get all running VMs in cluster
    Map<Guid, VM> runningVMsMap = new HashMap<Guid, VM>();
    for (VM iter : getVmDao().getAllRunningByCluster(vm.getVdsGroupId())) {
        runningVMsMap.put(iter.getId(), iter);
    }
    Map<Guid, VDS> hostMap = new HashMap<>();
    for (VDS host : hosts) {
        hostMap.put(host.getId(), host);
    }
    Set<Guid> acceptableHosts = new HashSet<Guid>();
    // Group all hosts for VMs with positive affinity
    for (Guid id : allVmIdsPositive) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null && hostMap.get(runVm.getRunOnVds()) != null && // can't migrate).
        hostMap.get(runVm.getRunOnVds()).getStatus() != VDSStatus.PreparingForMaintenance) {
            acceptableHosts.add(runVm.getRunOnVds());
        }
    }
    boolean hasPositiveConstraint = false;
    // No hosts associated with positive affinity, all hosts is applicable.
    if (acceptableHosts.isEmpty()) {
        acceptableHosts.addAll(hostMap.keySet());
    } else if (acceptableHosts.size() == 1 && hostMap.containsKey(acceptableHosts.iterator().next())) {
        hasPositiveConstraint = true;
    // Only one host is allowed for positive affinity, i.e. if the VM contained in a positive
    // affinity group he must run on the host that all the other members are running, if the
    // VMs spread across hosts, the affinity rule isn't applied.
    } else {
        messages.add(String.format("$affinityGroupName %1$s", StringUtils.join(positiveAffinityGroupNames, ", ")));
        List<String> hostsNames = new ArrayList<>();
        for (Guid hostId : acceptableHosts) {
            if (hostMap.containsKey(hostId)) {
                hostsNames.add(hostMap.get(hostId).getName());
            } else {
                hostsNames.add(getVdsStaticDao().get(hostId).getName());
            }
        }
        messages.add(String.format("$hostName %1$s", StringUtils.join(hostsNames, ", ")));
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_POSITIVE_AFFINITY_GROUP.toString());
        return null;
    }
    // Handle negative affinity
    StringBuilder negativeLogMessage = new StringBuilder("Negative Affinity remove host(s):");
    for (Guid id : allVmIdsNegative) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null) {
            acceptableHosts.remove(runVm.getRunOnVds());
            negativeLogMessage.append(MessageFormat.format(" {0} (vm {1}),", runVm.getRunOnVds(), vm.getName()));
        }
    }
    if (acceptableHosts.isEmpty()) {
        if (hasPositiveConstraint) {
            messages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIX_POSITIVE_NEGATIVE_AFFINITY_GROUP.toString());
        } else {
            messages.add(VdcBllMessages.ACTION_TYPE_FAILED_NEGATIVE_AFFINITY_GROUP.toString());
        }
        log.info(negativeLogMessage);
        return null;
    }
    List<VDS> retList = new ArrayList<VDS>();
    for (VDS host : hosts) {
        if (acceptableHosts.contains(host.getId())) {
            retList.add(host);
        }
    }
    return retList;
}
#method_after
public static List<VDS> getAcceptableHosts(boolean enforcing, List<VDS> hosts, VM vm, PerHostMessages messages) {
    List<AffinityGroup> affinityGroups = getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    // no affinity groups found for VM return all hosts
    if (affinityGroups.isEmpty()) {
        return hosts;
    }
    Set<Guid> allVmIdsPositive = new HashSet<>();
    Set<Guid> allVmIdsNegative = new HashSet<>();
    // Group by all vms in affinity groups per positive or negative
    for (AffinityGroup affinityGroup : affinityGroups) {
        if (affinityGroup.isEnforcing() == enforcing) {
            for (Guid entityId : affinityGroup.getEntityIds()) {
                // Skip current VM
                if (entityId.equals(vm.getId())) {
                    continue;
                }
                if (affinityGroup.isPositive()) {
                    allVmIdsPositive.add(entityId);
                } else {
                    allVmIdsNegative.add(entityId);
                }
            }
        }
    }
    // No entities, all hosts are valid
    if (allVmIdsPositive.isEmpty() && allVmIdsNegative.isEmpty()) {
        return hosts;
    }
    // Get all running VMs in cluster
    Map<Guid, VM> runningVMsMap = new HashMap<>();
    for (VM iter : getVmDao().getAllRunningByCluster(vm.getVdsGroupId())) {
        runningVMsMap.put(iter.getId(), iter);
    }
    Map<Guid, VDS> hostMap = new HashMap<>();
    for (VDS host : hosts) {
        hostMap.put(host.getId(), host);
    }
    Set<Guid> acceptableHosts = new HashSet<>();
    // Group all hosts for VMs with positive affinity
    for (Guid id : allVmIdsPositive) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null && hostMap.get(runVm.getRunOnVds()) != null && // can't migrate).
        hostMap.get(runVm.getRunOnVds()).getStatus() != VDSStatus.PreparingForMaintenance) {
            acceptableHosts.add(runVm.getRunOnVds());
        }
    }
    Set<Guid> unacceptableHosts = new HashSet<>();
    // Group all hosts for VMs with negative affinity
    for (Guid id : allVmIdsNegative) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null) {
            unacceptableHosts.add(runVm.getRunOnVds());
        }
    }
    // Compute the intersection of hosts with positive and negative affinity and report that
    // contradicting rules to the log
    unacceptableHosts.retainAll(acceptableHosts);
    for (Guid id : unacceptableHosts) {
        log.warnFormat("Host {1} ({2}) belongs to both positive and negative affinity list" + " while scheduling VM {3} ({4})", hostMap.get(id).getName(), id.toString(), vm.getName(), vm.getId());
    }
    // No hosts associated with positive affinity, all hosts are applicable.
    if (acceptableHosts.isEmpty()) {
        acceptableHosts.addAll(hostMap.keySet());
    } else if (acceptableHosts.size() > 1) {
        log.warnFormat("Invalid affinity situation was detected while scheduling VM {1} ({2})." + " VMs belonging to the same affinity groups are running on more than one host.", vm.getName(), vm.getId());
    }
    // Report hosts that were removed because of violating the positive affinity rules
    for (VDS host : hosts) {
        if (!acceptableHosts.contains(host.getId())) {
            messages.addMessage(host.getId(), // TODO compute the affinity rule names
            String.format("$affinityRules %1$s", ""));
            messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__AFFINITY_FAILED_POSITIVE.toString());
        }
    }
    // Remove hosts that contain VMs with negaive affinity to the currently scheduled Vm
    for (Guid id : allVmIdsNegative) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null && acceptableHosts.contains(runVm.getRunOnVds())) {
            acceptableHosts.remove(runVm.getRunOnVds());
            messages.addMessage(runVm.getRunOnVds(), // TODO compute the affinity rule names
            String.format("$affinityRules %1$s", ""));
            messages.addMessage(runVm.getRunOnVds(), VdcBllMessages.VAR__DETAIL__AFFINITY_FAILED_NEGATIVE.toString());
        }
    }
    List<VDS> retList = new ArrayList<>();
    for (VDS host : hosts) {
        if (acceptableHosts.contains(host.getId())) {
            retList.add(host);
        }
    }
    return retList;
}
#end_block

#method_before
private boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    IntegerValidation tempVar5 = new IntegerValidation();
    tempVar5.setMinimum(68);
    getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if (getExport().getEntity() && getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getNetworkLabel().getIsValid());
    setValidTab(TabName.SUBNET_TAB, subnetValid);
    setValidTab(TabName.PROFILES_TAB, profilesValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && subnetValid;
}
#method_after
private boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    IntegerValidation tempVar5 = new IntegerValidation();
    tempVar5.setMinimum(68);
    getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if (getExport().getEntity() && getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getNetworkLabel().getIsValid());
    setValidTab(TabName.SUBNET_TAB, subnetValid);
    setValidTab(TabName.PROFILES_TAB, profilesValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return allTabsValid();
}
#end_block

#method_before
public void discoverNetworks() {
    ArrayList<Provider<?>> items = new ArrayList<Provider<?>>();
    items.add(provider);
    getProviders().setItems(items);
    getProviders().setSelectedItem(provider);
}
#method_after
public void discoverNetworks() {
    Collection<Provider<?>> items = new ArrayList<Provider<?>>();
    items.add(provider);
    getProviders().setItems(items);
    getProviders().setSelectedItem(provider);
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.errorFormat("Can't login because authentication profile \"{1}\" doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.errorFormat("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
            return false;
        }
        if (!isPasswordAuth(authnExtension)) {
            log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
    if (!dbUser.isActive()) {
        dbUser.setActive(true);
        log.info(String.format("The user %1$s was reactivated as it was found in authz provider %2$s during login attempt.", dbUser.getLoginName(), dbUser.getDomain()));
    }
    getDbUserDAO().saveOrUpdate(dbUser);
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord);
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.errorFormat("Can't login because authentication profile \"{1}\" doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.errorFormat("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
            return false;
        }
        if (!AuthzUtils.supportsPasswordAuthentication(authnExtension)) {
            log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
    if (!dbUser.isActive()) {
        dbUser.setActive(true);
        log.info(String.format("The user %1$s was reactivated as it was found in authz provider %2$s during login attempt.", dbUser.getLoginName(), dbUser.getDomain()));
    }
    getDbUserDAO().saveOrUpdate(dbUser);
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord);
}
#end_block

#method_before
public ArrayList<DiskImage> getDiskInfoList() {
    return diskInfoList != null ? diskInfoList : new ArrayList<DiskImage>();
}
#method_after
public ArrayList<DiskImage> getDiskInfoList() {
    return diskInfoList;
}
#end_block

#method_before
public void setDiskInfoList(ArrayList<DiskImage> value) {
    diskInfoList = value;
}
#method_after
public void setDiskInfoList(ArrayList<DiskImage> diskInfoList) {
    this.diskInfoList = diskInfoList;
}
#end_block

#method_before
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, Guid domainId) {
    vdsNonOperational(vdsId, reason, logCommand, domainId, null);
}
#method_after
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, Guid domainId) {
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    Map<String, String> customLogValues = null;
    if (storageDomain != null) {
        customLogValues = Collections.singletonMap("StorageDomainNames", storageDomain.getName());
    }
    vdsNonOperational(vdsId, reason, logCommand, domainId, customLogValues);
}
#end_block

#method_before
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, Guid domainId) {
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    Map<String, String> customLogValues = null;
    if (storageDomain != null) {
        customLogValues = new HashMap<>();
        customLogValues.put("StorageDomainNames", storageDomain.getName());
    }
    vdsNonOperational(vdsId, reason, logCommand, domainId, customLogValues);
}
#method_after
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, Guid domainId) {
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    Map<String, String> customLogValues = null;
    if (storageDomain != null) {
        customLogValues = Collections.singletonMap("StorageDomainNames", storageDomain.getName());
    }
    vdsNonOperational(vdsId, reason, logCommand, domainId, customLogValues);
}
#end_block

#method_before
@Override
public void addExternallyManagedVms(List<VmStatic> externalVmList) {
    for (VmStatic currVm : externalVmList) {
        AddVmFromScratchParameters params = new AddVmFromScratchParameters(currVm, null, null);
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmFromScratch, params, ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.debugFormat("Failed adding Externally managed VM {0}", currVm.getName());
        }
    }
}
#method_after
@Override
public void addExternallyManagedVms(List<VmStatic> externalVmList) {
    for (VmStatic currVm : externalVmList) {
        AddVmParameters params = new AddVmParameters(currVm, null, null);
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmFromScratch, params, ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.debugFormat("Failed adding Externally managed VM {0}", currVm.getName());
        }
    }
}
#end_block

#method_before
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    if (AuthzUtils.getAuthzNameFromEntityName(user.getUserName()) == null) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getDomain(user);
    DirectoryUser directoryUser = findDirectoryUser(domain, user);
    if (directoryUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters parameters = new AddUserParameters(new DbUser(directoryUser));
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbUserByUserId, IdQueryParameters.class);
    return performCreate(VdcActionType.AddUser, parameters, resolver, BaseResource.class);
}
#method_after
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    List<String> authzProvidersNames = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
    if (AuthzUtils.getAuthzNameFromEntityName(user.getUserName(), authzProvidersNames) == null) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getAuthzProviderName(user, authzProvidersNames);
    DirectoryUser directoryUser = findDirectoryUser(domain, user);
    if (directoryUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters parameters = new AddUserParameters(new DbUser(directoryUser));
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbUserByUserId, IdQueryParameters.class);
    return performCreate(VdcActionType.AddUser, parameters, resolver, BaseResource.class);
}
#end_block

#method_before
private DirectoryUser findDirectoryUser(String directoryName, User user) {
    DirectoryUser result = null;
    String namespace = user.getNamespace();
    if (user.isSetDomainEntryId()) {
        result = getUserById(directoryName, namespace, user.getDomainEntryId());
    } else if (user.isSetId()) {
        result = getUserById(directoryName, namespace, user.getId());
    } else if (user.isSetPrincipal()) {
        result = getEntity(DirectoryUser.class, VdcQueryType.GetDirectoryUserByPrincipal, new GetDirectoryUserByPrincipalParameters(directoryName, user.getPrincipal()), user.getPrincipal());
    } else if (user.isSetUserName()) {
        result = getEntity(DirectoryUser.class, SearchType.DirectoryUser, getDirectoryUserSearchPattern(AuthzUtils.getEntityNameWithoutAuthz(user.getUserName()), user.getNamespace(), directoryName));
    }
    return result;
}
#method_after
private DirectoryUser findDirectoryUser(String directoryName, User user) {
    DirectoryUser result = null;
    String namespace = user.getNamespace();
    if (user.isSetDomainEntryId()) {
        result = getUserById(directoryName, namespace, user.getDomainEntryId());
    } else if (user.isSetId()) {
        result = getUserById(directoryName, namespace, user.getId());
    } else if (user.isSetPrincipal()) {
        result = getEntity(DirectoryUser.class, VdcQueryType.GetDirectoryUserByPrincipal, new GetDirectoryUserByPrincipalParameters(directoryName, user.getPrincipal()), user.getPrincipal());
    } else if (user.isSetUserName()) {
        result = getEntity(DirectoryUser.class, SearchType.DirectoryUser, getDirectoryUserSearchPattern(AuthzUtils.getEntityNameWithoutAuthz(user.getUserName(), directoryName), user.getNamespace(), directoryName));
    }
    return result;
}
#end_block

#method_before
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (AuthzUtils.getAuthzNameFromEntityName(group.getName()) == null) {
        validateParameters(group, "domain.id|name");
    }
    String directoryName = getDirectoryName(group);
    DirectoryGroup directoryGroup = findDirectoryGroup(directoryName, group);
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in directory " + directoryName).build();
    }
    AddGroupParameters parameters = new AddGroupParameters();
    parameters.setGroupToAdd(new DbGroup(directoryGroup));
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#method_after
@Override
public Response add(Group group) {
    List<String> authzProvidersNames = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
    validateParameters(group, "name");
    if (AuthzUtils.getAuthzNameFromEntityName(group.getName(), authzProvidersNames) == null) {
        validateParameters(group, "domain.id|name");
    }
    String directoryName = getAuthzProviderName(group, authzProvidersNames);
    DirectoryGroup directoryGroup = findDirectoryGroup(directoryName, group);
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in directory " + directoryName).build();
    }
    AddGroupParameters parameters = new AddGroupParameters();
    parameters.setGroupToAdd(new DbGroup(directoryGroup));
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#end_block

#method_before
private DirectoryGroup findDirectoryGroup(String directoryName, Group groupModel) {
    // Try to find a group that matches the identifier contained in the model:
    String namespace = groupModel.getNamespace();
    if (groupModel.isSetId()) {
        return getGroupById(directoryName, namespace, groupModel.getId());
    } else if (groupModel.isSetDomainEntryId()) {
        return getGroupById(directoryName, namespace, groupModel.getDomainEntryId());
    } else if (groupModel.isSetName()) {
        return getEntity(DirectoryGroup.class, SearchType.DirectoryGroup, getDirectoryGroupSearchPattern(AuthzUtils.getEntityNameWithoutAuthz(groupModel.getName()), directoryName));
    }
    return null;
}
#method_after
private DirectoryGroup findDirectoryGroup(String directoryName, Group groupModel) {
    // Try to find a group that matches the identifier contained in the model:
    String namespace = groupModel.getNamespace();
    if (groupModel.isSetId()) {
        return getGroupById(directoryName, namespace, groupModel.getId());
    } else if (groupModel.isSetDomainEntryId()) {
        return getGroupById(directoryName, namespace, groupModel.getDomainEntryId());
    } else if (groupModel.isSetName()) {
        return getEntity(DirectoryGroup.class, SearchType.DirectoryGroup, getDirectoryGroupSearchPattern(AuthzUtils.getEntityNameWithoutAuthz(groupModel.getName(), directoryName), directoryName));
    }
    return null;
}
#end_block

#method_before
@Test
public void testAddGroupWithExplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ":: name=" + GROUP_NAMES_WITH_NO_DOMAIN[0], SearchType.DirectoryGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "GroupToAdd" }, new Object[] { new DbGroup(getDirectoryGroup(0)) }, true, true, GUIDS[0], VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    Group model = new Group();
    model.setName(NAMES[0]);
    model.setDomain(domain);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupWithExplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ":: name=" + GROUP_NAMES_WITH_NO_DOMAIN[0], SearchType.DirectoryGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "GroupToAdd" }, new Object[] { new DbGroup(getDirectoryGroup(0)) }, true, true, GUIDS[0], VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    Group model = new Group();
    model.setName(GROUP_NAMES_WITH_NO_DOMAIN[0]);
    model.setDomain(domain);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#end_block

#method_before
@Test
public void testAddGroupWithImplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ":: name=" + GROUP_NAMES_WITH_NO_DOMAIN[0], SearchType.DirectoryGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "GroupToAdd" }, new Object[] { new DbGroup(getDirectoryGroup(0)) }, true, true, GUIDS[0], VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupWithImplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ":: name=" + GROUP_NAMES_WITH_NO_DOMAIN[0], SearchType.DirectoryGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "GroupToAdd" }, new Object[] { new DbGroup(getDirectoryGroup(0)) }, true, true, GUIDS[0], VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#end_block

#method_before
@Test
public void testAddGroupWithoutDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    Group model = new Group();
    model.setName(NAMES[0]);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(400, wae.getResponse().getStatus());
    }
}
#method_after
@Test
public void testAddGroupWithoutDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    control.replay();
    Group model = new Group();
    model.setName(GROUP_NAMES_WITH_NO_DOMAIN[0]);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(400, wae.getResponse().getStatus());
    }
}
#end_block

#method_before
@Test
public void testAddGroupById() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations(VdcQueryType.GetDirectoryGroupById, DirectoryIdQueryParameters.class, new String[] { "Domain", "Id" }, new Object[] { DOMAIN, DirectoryEntryIdUtils.decode(EXTERNAL_IDS[0]) }, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "GroupToAdd" }, new Object[] { new DbGroup(getDirectoryGroup(0)) }, true, true, GUIDS[0], VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    model.setId(EXTERNAL_IDS[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupById() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpGetEntityExpectations(VdcQueryType.GetDirectoryGroupById, DirectoryIdQueryParameters.class, new String[] { "Domain", "Id" }, new Object[] { DOMAIN, DirectoryEntryIdUtils.decode(EXTERNAL_IDS[0]) }, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "GroupToAdd" }, new Object[] { new DbGroup(getDirectoryGroup(0)) }, true, true, GUIDS[0], VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    model.setId(EXTERNAL_IDS[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#end_block

#method_before
@Test
public void testAddGroupByIdFailure() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations(VdcQueryType.GetDirectoryGroupById, DirectoryIdQueryParameters.class, new String[] { "Domain", "Id" }, new Object[] { DOMAIN, DirectoryEntryIdUtils.decode(NON_EXISTANT_EXTERNAL_ID) }, null);
    control.replay();
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    model.setId(NON_EXISTANT_EXTERNAL_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#method_after
@Test
public void testAddGroupByIdFailure() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpGetEntityExpectations(VdcQueryType.GetDirectoryGroupById, DirectoryIdQueryParameters.class, new String[] { "Domain", "Id" }, new Object[] { DOMAIN, DirectoryEntryIdUtils.decode(NON_EXISTANT_EXTERNAL_ID) }, null);
    control.replay();
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    model.setId(NON_EXISTANT_EXTERNAL_ID);
    try {
        collection.add(model);
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    if (getVdsGroup() != null && getVm().isBalloonEnabled() && !osRepository.isBalloonEnabled(getVm().getStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH, String.format("$clusterArch %1$s", getVdsGroup().getArchitecture()));
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    if (getVm().isBalloonEnabled() && !osRepository.isBalloonEnabled(getVm().getStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean setDomainsForMemoryImages(Map<StorageDomain, Integer> domain2requiredSize) {
    Map<String, String> handledMemoryVolumes = new HashMap<String, String>();
    for (Snapshot snapshot : getVm().getSnapshots()) {
        String memoryVolume = snapshot.getMemoryVolume();
        if (memoryVolume.isEmpty()) {
            continue;
        }
        if (handledMemoryVolumes.containsKey(memoryVolume)) {
            // replace the volume representation with the one with the correct domain & pool
            snapshot.setMemoryVolume(handledMemoryVolumes.get(memoryVolume));
            continue;
        }
        VM vm = getVmFromSnapshot(snapshot);
        int requiredSizeForMemory = (int) Math.ceil((vm.getTotalMemorySizeInBytes() + HibernateVmCommand.META_DATA_SIZE_IN_BYTES) * 1.0 / BYTES_IN_GB);
        StorageDomain storageDomain = VmHandler.findStorageDomainForMemory(getParameters().getStoragePoolId(), requiredSizeForMemory, domain2requiredSize);
        if (storageDomain == null) {
            return false;
        }
        int requiredSizeInDomainIncludingMemoryVolumes = domain2requiredSize.containsKey(storageDomain) ? domain2requiredSize.get(storageDomain) + requiredSizeForMemory : requiredSizeForMemory;
        domain2requiredSize.put(storageDomain, requiredSizeInDomainIncludingMemoryVolumes);
        String modifiedMemoryVolume = MemoryUtils.changeStorageDomainAndPoolInMemoryState(memoryVolume, storageDomain.getId(), getParameters().getStoragePoolId());
        // replace the volume representation with the one with the correct domain & pool
        snapshot.setMemoryVolume(modifiedMemoryVolume);
        // save it in case we'll find other snapshots with the same memory volume
        handledMemoryVolumes.put(memoryVolume, modifiedMemoryVolume);
    }
    return true;
}
#method_after
private boolean setDomainsForMemoryImages(Map<StorageDomain, Integer> domain2requiredSize) {
    Map<String, String> handledMemoryVolumes = new HashMap<String, String>();
    for (Snapshot snapshot : getVm().getSnapshots()) {
        String memoryVolume = snapshot.getMemoryVolume();
        if (memoryVolume.isEmpty()) {
            continue;
        }
        if (handledMemoryVolumes.containsKey(memoryVolume)) {
            // replace the volume representation with the one with the correct domain & pool
            snapshot.setMemoryVolume(handledMemoryVolumes.get(memoryVolume));
            continue;
        }
        VM vm = getVmFromSnapshot(snapshot);
        int requiredSizeForMemory = (int) Math.ceil((vm.getTotalMemorySizeInBytes() + MemoryUtils.META_DATA_SIZE_IN_BYTES) * 1.0 / BYTES_IN_GB);
        StorageDomain storageDomain = VmHandler.findStorageDomainForMemory(getParameters().getStoragePoolId(), requiredSizeForMemory, domain2requiredSize);
        if (storageDomain == null) {
            return false;
        }
        int requiredSizeInDomainIncludingMemoryVolumes = domain2requiredSize.containsKey(storageDomain) ? domain2requiredSize.get(storageDomain) + requiredSizeForMemory : requiredSizeForMemory;
        domain2requiredSize.put(storageDomain, requiredSizeInDomainIncludingMemoryVolumes);
        String modifiedMemoryVolume = MemoryUtils.changeStorageDomainAndPoolInMemoryState(memoryVolume, storageDomain.getId(), getParameters().getStoragePoolId());
        // replace the volume representation with the one with the correct domain & pool
        snapshot.setMemoryVolume(modifiedMemoryVolume);
        // save it in case we'll find other snapshots with the same memory volume
        handledMemoryVolumes.put(memoryVolume, modifiedMemoryVolume);
    }
    return true;
}
#end_block

#method_before
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = getVdsGroup();
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#method_after
private int computeMinAllocatedMem() {
    if (getVm().getMinAllocatedMem() > 0) {
        return getVm().getMinAllocatedMem();
    }
    VDSGroup vdsGroup = getVdsGroup();
    if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
        return (getVm().getMemSizeMb() * 100) / vdsGroup.getmax_vds_memory_over_commit();
    }
    return getVm().getMemSizeMb();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH, String.format("$clusterArch %1$s", getVdsGroup().getArchitecture()));
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
    if (instanceTypeId != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (instanceTypeId != null && !checkInstanceTypeImagePermissions(instanceTypeId)) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && instanceTypeId != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && getInstanceTypeId() != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return isInternalExecution() ? getSucceeded() ? AuditLogType.SYSTEM_UPDATE_VM : AuditLogType.SYSTEM_FAILED_UPDATE_VM : getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH, String.format("$clusterArch %1$s", getVdsGroup().getArchitecture()));
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), !getParameters().isApplyChangesLater()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
private boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.isBalloonEnabled(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.isBalloonEnabled(getVmId());
}
#end_block

#method_before
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDAOGetForStoragePool();
    mockVdsGroupDAOReturnVdsGroup();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<VmManagementParametersBase> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDAOGetForStoragePool();
    mockVdsGroupDAOReturnVdsGroup();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getcompatibility_version());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    mockGetAllSnapshots(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<VmManagementParametersBase> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getcompatibility_version());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    mockGetAllSnapshots(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
protected AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    initCommandMethods(result);
    return result;
}
#method_after
protected AddVmFromTemplateCommand<VmManagementParametersBase> createVmFromTemplateCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase();
    param.setVm(vm);
    AddVmFromTemplateCommand<VmManagementParametersBase> concrete = new AddVmFromTemplateCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<VmManagementParametersBase> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    initCommandMethods(result);
    return result;
}
#end_block

#method_before
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmFromTemplateParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#method_after
private void mockGetAllSnapshots(AddVmFromTemplateCommand<VmManagementParametersBase> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#end_block

#method_before
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskCreationInfo creationInfo) {
    AsyncTasks asyncTask = coco.getByVdsmTaskId(creationInfo.getVdsmTaskId());
    if (asyncTask == null || asyncTask.getActionParameters() == null) {
        asyncTask = new AsyncTasks(AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, creationInfo.getVdsmTaskId(), creationInfo.getStepId(), creationInfo.getStoragePoolID(), creationInfo.getTaskType(), getCommandEntity(coco, asyncTask == null ? Guid.newGuid() : asyncTask.getRootCommandId(), VdcActionType.Unknown, new VdcActionParametersBase()), getCommandEntity(coco, asyncTask == null ? Guid.newGuid() : asyncTask.getRootCommandId(), VdcActionType.Unknown, new VdcActionParametersBase()));
        creationInfo.setTaskType(AsyncTaskType.unknown);
    }
    AsyncTaskParameters asyncTaskParams = new AsyncTaskParameters(creationInfo, asyncTask);
    return construct(coco, creationInfo.getTaskType(), asyncTaskParams, true);
}
#method_after
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskCreationInfo creationInfo) {
    AsyncTask asyncTask = coco.getByVdsmTaskId(creationInfo.getVdsmTaskId());
    if (asyncTask == null || asyncTask.getActionParameters() == null) {
        asyncTask = new AsyncTask(AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, creationInfo.getVdsmTaskId(), creationInfo.getStepId(), creationInfo.getStoragePoolID(), creationInfo.getTaskType(), getCommandEntity(coco, asyncTask == null ? Guid.newGuid() : asyncTask.getRootCommandId()), getCommandEntity(coco, asyncTask == null ? Guid.newGuid() : asyncTask.getCommandId()));
        creationInfo.setTaskType(AsyncTaskType.unknown);
    }
    AsyncTaskParameters asyncTaskParams = new AsyncTaskParameters(creationInfo, asyncTask);
    return construct(coco, creationInfo.getTaskType(), asyncTaskParams, true);
}
#end_block

#method_before
private static CommandEntity getCommandEntity(CommandCoordinator coco, Guid cmdId, VdcActionType actionType, VdcActionParametersBase paramaters) {
    CommandEntity cmdEntity = Guid.isNullOrEmpty(cmdId) ? null : coco.getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = new CommandEntity();
        cmdEntity.setId(cmdId);
        cmdEntity.setCommandType(actionType);
        cmdEntity.setCommandParameters(paramaters);
    }
    return cmdEntity;
}
#method_after
private static CommandEntity getCommandEntity(CommandCoordinator coco, Guid cmdId) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = coco.createCommandEntity(cmdId, VdcActionType.Unknown, new VdcActionParametersBase());
    }
    return cmdEntity;
}
#end_block

#method_before
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskType taskType, AsyncTaskParameters asyncTaskParams, boolean duringInit) {
    try {
        SPMAsyncTask result = null;
        if (taskType == AsyncTaskType.unknown || asyncTaskParams.getDbAsyncTask().getaction_type() == VdcActionType.Unknown) {
            result = new SPMAsyncTask(coco, asyncTaskParams);
        } else {
            result = new CommandAsyncTask(coco, asyncTaskParams, duringInit);
        }
        return result;
    } catch (Exception e) {
        log.error(String.format("AsyncTaskFactory: Failed to get type information using reflection for AsyncTask type: %1$s.", taskType), e);
        return null;
    }
}
#method_after
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskCreationInfo creationInfo, AsyncTask asyncTask) {
    AsyncTaskParameters asyncTaskParams = new AsyncTaskParameters(creationInfo, asyncTask);
    return construct(coco, creationInfo.getTaskType(), asyncTaskParams, true);
}
#end_block

#method_before
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskType taskType, AsyncTaskParameters asyncTaskParams, boolean duringInit) {
    try {
        SPMAsyncTask result = null;
        if (taskType == AsyncTaskType.unknown || asyncTaskParams.getDbAsyncTask().getaction_type() == VdcActionType.Unknown) {
            result = new SPMAsyncTask(coco, asyncTaskParams);
        } else {
            result = new CommandAsyncTask(coco, asyncTaskParams, duringInit);
        }
        return result;
    } catch (Exception e) {
        log.error(String.format("AsyncTaskFactory: Failed to get type information using reflection for AsyncTask type: %1$s.", taskType), e);
        return null;
    }
}
#method_after
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskType taskType, AsyncTaskParameters asyncTaskParams, boolean duringInit) {
    try {
        SPMAsyncTask result = null;
        if (taskType == AsyncTaskType.unknown || asyncTaskParams.getDbAsyncTask().getActionType() == VdcActionType.Unknown) {
            result = new SPMAsyncTask(coco, asyncTaskParams);
        } else {
            result = new CommandAsyncTask(coco, asyncTaskParams, duringInit);
        }
        return result;
    } catch (Exception e) {
        log.error(String.format("AsyncTaskFactory: Failed to get type information using reflection for AsyncTask type: %1$s.", taskType), e);
        return null;
    }
}
#end_block

#method_before
public List<AsyncTasks> getAllAsyncTasksFromDb(CommandCoordinator coco) {
    List<AsyncTasks> asyncTasks = DbFacade.getInstance().getAsyncTaskDao().getAll();
    for (AsyncTasks asyncTask : asyncTasks) {
        asyncTask.setParentCmdEntity(getCommandEntity(asyncTask.getRootCommandId()));
        asyncTask.setChildCmdEntity(getCommandEntity(asyncTask.getCommandId()));
    }
    return asyncTasks;
}
#method_after
public List<AsyncTask> getAllAsyncTasksFromDb(CommandCoordinator coco) {
    List<AsyncTask> asyncTasks = DbFacade.getInstance().getAsyncTaskDao().getAll();
    for (AsyncTask asyncTask : asyncTasks) {
        asyncTask.setRootCmdEntity(getCommandEntity(asyncTask.getRootCommandId()));
        asyncTask.setChildCmdEntity(getCommandEntity(asyncTask.getCommandId()));
    }
    return asyncTasks;
}
#end_block

#method_before
private CommandEntity getCommandEntity(Guid cmdId) {
    CommandEntity cmdEntity = Guid.isNullOrEmpty(cmdId) ? null : coco.getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = new CommandEntity();
        cmdEntity.setId(cmdId);
        cmdEntity.setCommandType(VdcActionType.Unknown);
        cmdEntity.setCommandParameters(new VdcActionParametersBase());
    }
    return cmdEntity;
}
#method_after
private CommandEntity getCommandEntity(Guid cmdId) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = coco.createCommandEntity(cmdId, VdcActionType.Unknown, new VdcActionParametersBase());
    }
    return cmdEntity;
}
#end_block

#method_before
public void saveAsyncTaskToDb(final AsyncTasks asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            DbFacade.getInstance().getAsyncTaskDao().save(asyncTask);
            if (!Guid.isNullOrEmpty(asyncTask.getRootCommandId())) {
                coco.persistCommand(asyncTask.getParentCmdEntity());
            }
            if (!Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                coco.persistCommand(asyncTask.getChildCmdEntity());
            }
            return null;
        }
    });
}
#method_after
public void saveAsyncTaskToDb(final AsyncTask asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            DbFacade.getInstance().getAsyncTaskDao().save(asyncTask);
            coco.persistCommand(asyncTask.getRootCmdEntity());
            coco.persistCommand(asyncTask.getChildCmdEntity());
            return null;
        }
    });
}
#end_block

#method_before
public AsyncTasks getAsyncTaskFromDb(Guid asyncTaskId) {
    AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(asyncTaskId);
    if (asyncTask != null) {
        asyncTask.setParentCmdEntity(getCommandEntity(asyncTask.getRootCommandId()));
        asyncTask.setChildCmdEntity(getCommandEntity(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#method_after
public AsyncTask getAsyncTaskFromDb(Guid asyncTaskId) {
    AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(asyncTaskId);
    if (asyncTask != null) {
        asyncTask.setRootCmdEntity(getCommandEntity(asyncTask.getRootCommandId()));
        asyncTask.setChildCmdEntity(getCommandEntity(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#end_block

#method_before
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallBackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!Guid.isNullOrEmpty(asyncTask.getRootCommandId()) && !coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#method_after
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallBackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#end_block

#method_before
public AsyncTasks getByVdsmTaskId(Guid vdsmTaskId) {
    AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
    if (asyncTask != null) {
        asyncTask.setParentCmdEntity(getCommandEntity(asyncTask.getRootCommandId()));
        asyncTask.setChildCmdEntity(getCommandEntity(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#method_after
public AsyncTask getByVdsmTaskId(Guid vdsmTaskId) {
    AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
    if (asyncTask != null) {
        asyncTask.setRootCmdEntity(getCommandEntity(asyncTask.getRootCommandId()));
        asyncTask.setChildCmdEntity(getCommandEntity(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#end_block

#method_before
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallBackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!Guid.isNullOrEmpty(asyncTask.getRootCommandId()) && !coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#method_after
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallBackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#end_block

#method_before
public void addOrUpdateTaskInDB(final AsyncTasks asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!Guid.isNullOrEmpty(asyncTask.getRootCommandId())) {
                coco.persistCommand(asyncTask.getParentCmdEntity());
            }
            if (!Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                coco.persistCommand(asyncTask.getChildCmdEntity());
            }
            DbFacade.getInstance().getAsyncTaskDao().saveOrUpdate(asyncTask);
            return null;
        }
    });
}
#method_after
public void addOrUpdateTaskInDB(final AsyncTask asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            coco.persistCommand(asyncTask.getRootCmdEntity());
            coco.persistCommand(asyncTask.getChildCmdEntity());
            DbFacade.getInstance().getAsyncTaskDao().saveOrUpdate(asyncTask);
            return null;
        }
    });
}
#end_block

#method_before
public AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTasks asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = getAsyncTaskFromDb(taskId);
    }
    if (asyncTask != null) {
        if (VdcActionType.Unknown.equals(command.getParameters().getCommandType())) {
            command.getParameters().setCommandType(command.getActionType());
        }
        VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
        asyncTask.setaction_type(parentCommand);
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(parentParameters);
        asyncTask.setTaskParameters(command.getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setCommandId(command.getCommandId());
        asyncTask.setRootCommandId(parentParameters.getCommandId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
        asyncTask.setCommandStatus(command.getCommandStatus());
        asyncTask.setCommandType(command.getParameters().getCommandType());
    } else {
        asyncTask = createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#method_after
public AsyncTask getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTask asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = getAsyncTaskFromDb(taskId);
    }
    if (asyncTask != null) {
        if (VdcActionType.Unknown.equals(command.getParameters().getCommandType())) {
            command.getParameters().setCommandType(command.getActionType());
        }
        VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
        asyncTask.setActionType(parentCommand);
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(parentParameters);
        asyncTask.setTaskParameters(command.getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setCommandId(command.getCommandId());
        asyncTask.setRootCommandId(parentParameters.getCommandId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
        asyncTask.setCommandStatus(command.getCommandStatus());
        asyncTask.setCommandType(command.getParameters().getCommandType());
    } else {
        asyncTask = createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#end_block

#method_before
public AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    Guid parentCommandId = command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId();
    VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
    if (VdcActionType.Unknown.equals(command.getParameters().getCommandType())) {
        command.getParameters().setCommandType(command.getActionType());
    }
    AsyncTasks asyncTask = new AsyncTasks(AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), asyncTaskCreationInfo.getStepId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType(), getParentCommandEntity(parentCommandId, parentCommand, parentParameters), getChildCommandEntity(command, parentCommand));
    return asyncTask;
}
#method_after
public AsyncTask createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    Guid parentCommandId = command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId();
    VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
    if (VdcActionType.Unknown.equals(command.getParameters().getCommandType())) {
        command.getParameters().setCommandType(command.getActionType());
    }
    AsyncTask asyncTask = new AsyncTask(AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), asyncTaskCreationInfo.getStepId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType(), getParentCommandEntity(parentCommandId, parentCommand, parentParameters), getChildCommandEntity(command, parentCommand));
    return asyncTask;
}
#end_block

#method_before
private CommandEntity getParentCommandEntity(Guid cmdId, VdcActionType actionType, VdcActionParametersBase parameters) {
    CommandEntity cmdEntity = Guid.isNullOrEmpty(cmdId) ? null : coco.getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = new CommandEntity();
        cmdEntity.setId(cmdId);
        cmdEntity.setCommandType(actionType);
        cmdEntity.setCommandParameters(parameters);
        if (!Guid.isNullOrEmpty(cmdId)) {
            cmdEntity.setCommandStatus(CommandStatus.ACTIVE);
            coco.persistCommand(cmdEntity);
        }
    }
    return cmdEntity;
}
#method_after
private CommandEntity getParentCommandEntity(Guid cmdId, VdcActionType actionType, VdcActionParametersBase parameters) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = coco.createCommandEntity(cmdId, actionType, parameters);
        if (!Guid.isNullOrEmpty(cmdId)) {
            cmdEntity.setCommandStatus(CommandStatus.ACTIVE);
            coco.persistCommand(cmdEntity);
        }
    }
    return cmdEntity;
}
#end_block

#method_before
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    AsyncTasks dbAsyncTask = task.getParameters().getDbAsyncTask();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.getContext().withExecutionContext(context);
    return new DecoratedCommand(command).endAction();
}
#method_after
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    AsyncTask dbAsyncTask = task.getParameters().getDbAsyncTask();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.getContext().withExecutionContext(context);
    return new DecoratedCommand(command).endAction();
}
#end_block

#method_before
private VdcActionType getEndActionType(AsyncTasks dbAsyncTask) {
    VdcActionType commandType = dbAsyncTask.getActionParameters().getCommandType();
    if (!VdcActionType.Unknown.equals(commandType)) {
        return commandType;
    }
    return dbAsyncTask.getaction_type();
}
#method_after
private VdcActionType getEndActionType(AsyncTask dbAsyncTask) {
    VdcActionType commandType = dbAsyncTask.getActionParameters().getCommandType();
    if (!VdcActionType.Unknown.equals(commandType)) {
        return commandType;
    }
    return dbAsyncTask.getActionType();
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getAsyncTaskDao();
    params = new VdcActionParametersBase();
    params.setSessionId("ASESSIONID");
    params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    taskParams = new VdcActionParametersBase();
    taskParams.setSessionId("ASESSIONID");
    taskParams.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    taskParams.setParentParameters(params);
    // create some test data
    newAsyncTask = new AsyncTasks();
    newAsyncTask.setTaskId(Guid.newGuid());
    newAsyncTask.setVdsmTaskId(Guid.newGuid());
    newAsyncTask.setStartTime(new Date());
    newAsyncTask.setaction_type(VdcActionType.AddDisk);
    newAsyncTask.setstatus(AsyncTaskStatusEnum.running);
    newAsyncTask.setresult(AsyncTaskResultEnum.success);
    newAsyncTask.setActionParameters(params);
    newAsyncTask.setTaskParameters(taskParams);
    newAsyncTask.setCommandId(Guid.newGuid());
    newAsyncTask.setRootCommandId(Guid.newGuid());
    newAsyncTask.setTaskType(AsyncTaskType.copyImage);
    newAsyncTask.setStoragePoolId(Guid.newGuid());
    existingAsyncTask = dao.get(FixturesTool.EXISTING_TASK_ID);
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getAsyncTaskDao();
    params = new VdcActionParametersBase();
    params.setSessionId("ASESSIONID");
    params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    taskParams = new VdcActionParametersBase();
    taskParams.setSessionId("ASESSIONID");
    taskParams.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    taskParams.setParentParameters(params);
    // create some test data
    newAsyncTask = new AsyncTask();
    newAsyncTask.setTaskId(Guid.newGuid());
    newAsyncTask.setVdsmTaskId(Guid.newGuid());
    newAsyncTask.setStartTime(new Date());
    newAsyncTask.setActionType(VdcActionType.AddDisk);
    newAsyncTask.setstatus(AsyncTaskStatusEnum.running);
    newAsyncTask.setresult(AsyncTaskResultEnum.success);
    newAsyncTask.setActionParameters(params);
    newAsyncTask.setTaskParameters(taskParams);
    newAsyncTask.setCommandId(Guid.newGuid());
    newAsyncTask.setRootCommandId(Guid.newGuid());
    newAsyncTask.setTaskType(AsyncTaskType.copyImage);
    newAsyncTask.setStoragePoolId(Guid.newGuid());
    existingAsyncTask = dao.get(FixturesTool.EXISTING_TASK_ID);
}
#end_block

#method_before
@Test
public void testGetWithInvalidId() {
    AsyncTasks result = dao.get(Guid.newGuid());
    assertNull(result);
}
#method_after
@Test
public void testGetWithInvalidId() {
    AsyncTask result = dao.get(Guid.newGuid());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetAsyncTaskEntitiesById() {
    List<AsyncTasks> tasks = dao.getTasksByEntity(FixturesTool.ENTITY_WITH_TASKS_ID);
    assertNotNull(tasks);
    assertEquals(tasks.size(), 1);
}
#method_after
@Test
public void testGetAsyncTaskEntitiesById() {
    List<AsyncTask> tasks = dao.getTasksByEntity(FixturesTool.ENTITY_WITH_TASKS_ID);
    assertNotNull(tasks);
    assertEquals(tasks.size(), 1);
}
#end_block

#method_before
@Test
public void testGet() {
    AsyncTasks result = dao.get(existingAsyncTask.getTaskId());
    assertNotNull(result);
    assertEquals(existingAsyncTask, result);
}
#method_after
@Test
public void testGet() {
    AsyncTask result = dao.get(existingAsyncTask.getTaskId());
    assertNotNull(result);
    assertEquals(existingAsyncTask, result);
}
#end_block

#method_before
@Test
public void testGetAll() {
    List<AsyncTasks> result = dao.getAll();
    assertEquals(TASK_COUNT, result.size());
}
#method_after
@Test
public void testGetAll() {
    List<AsyncTask> result = dao.getAll();
    assertEquals(TASK_COUNT, result.size());
}
#end_block

#method_before
@Test
public void testSave() {
    dao.save(newAsyncTask);
    AsyncTasks result = dao.get(newAsyncTask.getTaskId());
    /*
         * //Setting startTime to null is required as DB auto generates //the value of start time //Without this, the
         * comparison would fail result.setStartTime(null);
         */
    assertEquals(newAsyncTask, result);
}
#method_after
@Test
public void testSave() {
    dao.save(newAsyncTask);
    AsyncTask result = dao.get(newAsyncTask.getTaskId());
    /*
         * //Setting startTime to null is required as DB auto generates //the value of start time //Without this, the
         * comparison would fail result.setStartTime(null);
         */
    assertEquals(newAsyncTask, result);
}
#end_block

#method_before
@Test
public void testUpdate() {
    existingAsyncTask.setstatus(AsyncTaskStatusEnum.aborting);
    existingAsyncTask.setresult(AsyncTaskResultEnum.failure);
    dao.update(existingAsyncTask);
    AsyncTasks result = dao.get(existingAsyncTask.getTaskId());
    assertEquals(existingAsyncTask, result);
}
#method_after
@Test
public void testUpdate() {
    existingAsyncTask.setstatus(AsyncTaskStatusEnum.aborting);
    existingAsyncTask.setresult(AsyncTaskResultEnum.failure);
    existingAsyncTask.setActionType(VdcActionType.AddDisk);
    dao.update(existingAsyncTask);
    AsyncTask result = dao.get(existingAsyncTask.getTaskId());
    assertEquals(existingAsyncTask, result);
}
#end_block

#method_before
@Test
public void testRemove() {
    AsyncTasks result = dao.get(existingAsyncTask.getTaskId());
    assertNotNull(result);
    assertEquals(dao.remove(existingAsyncTask.getTaskId()), 1);
    result = dao.get(existingAsyncTask.getTaskId());
    assertNull(result);
    assertEquals(dao.remove(existingAsyncTask.getTaskId()), 0);
    // The removed task is associated with an entity, try to fetch
    // tasks for the entity, and see no task is returned
    List<Guid> taskIds = dao.getAsyncTaskIdsByEntity(FixturesTool.ENTITY_WITH_TASKS_ID);
    assertNotNull(taskIds);
    assertTrue(taskIds.isEmpty());
}
#method_after
@Test
public void testRemove() {
    AsyncTask result = dao.get(existingAsyncTask.getTaskId());
    assertNotNull(result);
    assertEquals(dao.remove(existingAsyncTask.getTaskId()), 1);
    result = dao.get(existingAsyncTask.getTaskId());
    assertNull(result);
    assertEquals(dao.remove(existingAsyncTask.getTaskId()), 0);
    // The removed task is associated with an entity, try to fetch
    // tasks for the entity, and see no task is returned
    List<Guid> taskIds = dao.getAsyncTaskIdsByEntity(FixturesTool.ENTITY_WITH_TASKS_ID);
    assertNotNull(taskIds);
    assertTrue(taskIds.isEmpty());
}
#end_block

#method_before
@Test
public void testGetTaskByVdsmTaskId() {
    AsyncTasks result = dao.getByVdsmTaskId(FixturesTool.EXISTING_VDSM_TASK_ID);
    assertNotNull(result);
    assertEquals(existingAsyncTask, result);
}
#method_after
@Test
public void testGetTaskByVdsmTaskId() {
    AsyncTask result = dao.getByVdsmTaskId(FixturesTool.EXISTING_VDSM_TASK_ID);
    assertNotNull(result);
    assertEquals(existingAsyncTask, result);
}
#end_block

#method_before
@Test
public void testRemoveByVdsmTaskId() {
    AsyncTasks result = dao.getByVdsmTaskId(FixturesTool.EXISTING_VDSM_TASK_ID);
    assertNotNull(result);
    assertEquals(dao.removeByVdsmTaskId(existingAsyncTask.getVdsmTaskId()), 1);
    result = dao.getByVdsmTaskId(existingAsyncTask.getVdsmTaskId());
    assertNull(result);
    assertEquals(dao.removeByVdsmTaskId(existingAsyncTask.getVdsmTaskId()), 0);
    // The removed task is associated with an entity, try to fetch
    // tasks for the entity, and see no task is returned
    List<Guid> taskIds = dao.getAsyncTaskIdsByEntity(FixturesTool.ENTITY_WITH_TASKS_ID);
    assertNotNull(taskIds);
    assertTrue(taskIds.isEmpty());
}
#method_after
@Test
public void testRemoveByVdsmTaskId() {
    AsyncTask result = dao.getByVdsmTaskId(FixturesTool.EXISTING_VDSM_TASK_ID);
    assertNotNull(result);
    assertEquals(dao.removeByVdsmTaskId(existingAsyncTask.getVdsmTaskId()), 1);
    result = dao.getByVdsmTaskId(existingAsyncTask.getVdsmTaskId());
    assertNull(result);
    assertEquals(dao.removeByVdsmTaskId(existingAsyncTask.getVdsmTaskId()), 0);
    // The removed task is associated with an entity, try to fetch
    // tasks for the entity, and see no task is returned
    List<Guid> taskIds = dao.getAsyncTaskIdsByEntity(FixturesTool.ENTITY_WITH_TASKS_ID);
    assertNotNull(taskIds);
    assertTrue(taskIds.isEmpty());
}
#end_block

#method_before
@Test
public void testSaveOrUpdate() {
    existingAsyncTask.setstatus(AsyncTaskStatusEnum.aborting);
    existingAsyncTask.setresult(AsyncTaskResultEnum.failure);
    List<AsyncTasks> tasks = dao.getAll();
    assertNotNull(tasks);
    int tasksNumber = tasks.size();
    dao.saveOrUpdate(existingAsyncTask);
    tasks = dao.getAll();
    assertEquals(tasksNumber, tasks.size());
    AsyncTasks taskFromDb = dao.get(existingAsyncTask.getTaskId());
    assertNotNull(taskFromDb);
    assertEquals(taskFromDb, existingAsyncTask);
    dao.saveOrUpdate(newAsyncTask);
    tasks = dao.getAll();
    assertNotNull(tasks);
    assertEquals(tasksNumber + 1, tasks.size());
    taskFromDb = dao.get(newAsyncTask.getTaskId());
    assertEquals(taskFromDb, newAsyncTask);
}
#method_after
@Test
public void testSaveOrUpdate() {
    existingAsyncTask.setstatus(AsyncTaskStatusEnum.aborting);
    existingAsyncTask.setresult(AsyncTaskResultEnum.failure);
    existingAsyncTask.setActionType(VdcActionType.AddDisk);
    List<AsyncTask> tasks = dao.getAll();
    assertNotNull(tasks);
    int tasksNumber = tasks.size();
    dao.saveOrUpdate(existingAsyncTask);
    tasks = dao.getAll();
    assertEquals(tasksNumber, tasks.size());
    AsyncTask taskFromDb = dao.get(existingAsyncTask.getTaskId());
    assertNotNull(taskFromDb);
    assertEquals(taskFromDb, existingAsyncTask);
    dao.saveOrUpdate(newAsyncTask);
    tasks = dao.getAll();
    assertNotNull(tasks);
    assertEquals(tasksNumber + 1, tasks.size());
    taskFromDb = dao.get(newAsyncTask.getTaskId());
    assertEquals(taskFromDb, newAsyncTask);
}
#end_block

#method_before
@Override
public AsyncTasks mapRow(ResultSet rs, int rowNum) throws SQLException {
    AsyncTasks entity = new AsyncTasks();
    entity.setresult(AsyncTaskResultEnum.forValue(rs.getInt("result")));
    entity.setstatus(AsyncTaskStatusEnum.forValue(rs.getInt("status")));
    entity.setTaskId(getGuidDefaultEmpty(rs, "task_id"));
    entity.setVdsmTaskId(getGuid(rs, "vdsm_task_id"));
    entity.setStepId(getGuid(rs, "step_id"));
    entity.setCommandId(getGuidDefaultEmpty(rs, "command_id"));
    entity.setRootCommandId(getGuidDefaultEmpty(rs, "root_command_id"));
    entity.setStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("started_at")));
    entity.setTaskType(AsyncTaskType.forValue(rs.getInt("task_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    return entity;
}
#method_after
@Override
public AsyncTask mapRow(ResultSet rs, int rowNum) throws SQLException {
    AsyncTask entity = new AsyncTask();
    entity.setresult(AsyncTaskResultEnum.forValue(rs.getInt("result")));
    entity.setstatus(AsyncTaskStatusEnum.forValue(rs.getInt("status")));
    entity.setTaskId(getGuidDefaultEmpty(rs, "task_id"));
    entity.setVdsmTaskId(getGuid(rs, "vdsm_task_id"));
    entity.setStepId(getGuid(rs, "step_id"));
    entity.setCommandId(getGuidDefaultEmpty(rs, "command_id"));
    entity.setRootCommandId(getGuidDefaultEmpty(rs, "root_command_id"));
    entity.setStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("started_at")));
    entity.setTaskType(AsyncTaskType.forValue(rs.getInt("task_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    return entity;
}
#end_block

#method_before
@Override
public AsyncTasks get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("task_id", id);
    return getCallsHandler().executeRead("Getasync_tasksBytask_id", AsyncTaskRowMapper.instance, parameterSource);
}
#method_after
@Override
public AsyncTask get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("task_id", id);
    return getCallsHandler().executeRead("Getasync_tasksBytask_id", AsyncTaskRowMapper.instance, parameterSource);
}
#end_block

#method_before
@Override
public AsyncTasks getByVdsmTaskId(Guid vdsmTaskId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vdsm_task_id", vdsmTaskId);
    return getCallsHandler().executeRead("GetAsyncTasksByVdsmTaskId", AsyncTaskRowMapper.instance, parameterSource);
}
#method_after
@Override
public AsyncTask getByVdsmTaskId(Guid vdsmTaskId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vdsm_task_id", vdsmTaskId);
    return getCallsHandler().executeRead("GetAsyncTasksByVdsmTaskId", AsyncTaskRowMapper.instance, parameterSource);
}
#end_block

#method_before
@Override
public List<AsyncTasks> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetAllFromasync_tasks", AsyncTaskRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<AsyncTask> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetAllFromasync_tasks", AsyncTaskRowMapper.instance, parameterSource);
}
#end_block

#method_before
private AsyncTaskParameterSource getTaskParameterSource(AsyncTasks task) {
    return new AsyncTaskParameterSource(dialect, task);
}
#method_after
private AsyncTaskParameterSource getTaskParameterSource(AsyncTask task) {
    return new AsyncTaskParameterSource(dialect, task);
}
#end_block

#method_before
@Override
public void saveOrUpdate(AsyncTasks task) {
    AsyncTaskParameterSource parameterSource = getTaskParameterSource(task);
    parameterSource.addValue("started_at", task.getStartTime());
    parameterSource.addValue("storage_pool_id", task.getStoragePoolId());
    parameterSource.addValue("async_task_type", task.getTaskType());
    getCallsHandler().executeModification("InsertOrUpdateAsyncTasks", parameterSource);
}
#method_after
@Override
public void saveOrUpdate(AsyncTask task) {
    AsyncTaskParameterSource parameterSource = getTaskParameterSource(task);
    parameterSource.addValue("started_at", task.getStartTime());
    parameterSource.addValue("storage_pool_id", task.getStoragePoolId());
    parameterSource.addValue("async_task_type", task.getTaskType());
    getCallsHandler().executeModification("InsertOrUpdateAsyncTasks", parameterSource);
}
#end_block

#method_before
@Override
public void save(AsyncTasks task) {
    AsyncTaskParameterSource parameterSource = getTaskParameterSource(task);
    parameterSource.addValue("started_at", task.getStartTime());
    parameterSource.addValue("storage_pool_id", task.getStoragePoolId());
    parameterSource.addValue("async_task_type", task.getTaskType());
    getCallsHandler().executeModification("Insertasync_tasks", parameterSource);
}
#method_after
@Override
public void save(AsyncTask task) {
    AsyncTaskParameterSource parameterSource = getTaskParameterSource(task);
    parameterSource.addValue("started_at", task.getStartTime());
    parameterSource.addValue("storage_pool_id", task.getStoragePoolId());
    parameterSource.addValue("async_task_type", task.getTaskType());
    getCallsHandler().executeModification("Insertasync_tasks", parameterSource);
}
#end_block

#method_before
@Override
public void update(AsyncTasks task) {
    logNullParameters(task);
    AsyncTaskParameterSource parameterSource = getTaskParameterSource(task);
    parameterSource.addValue("storage_pool_id", task.getStoragePoolId());
    getCallsHandler().executeModification("Updateasync_tasks", parameterSource);
}
#method_after
@Override
public void update(AsyncTask task) {
    logNullParameters(task);
    AsyncTaskParameterSource parameterSource = getTaskParameterSource(task);
    parameterSource.addValue("storage_pool_id", task.getStoragePoolId());
    getCallsHandler().executeModification("Updateasync_tasks", parameterSource);
}
#end_block

#method_before
private static void logNullParameters(AsyncTasks task) {
    if (task.getActionParameters() == null) {
        StringBuilder sb = new StringBuilder("Null action_parameters:\n");
        StackTraceElement[] st = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : st) {
            sb.append(String.format("\tMethod: %1$s%n", element.getMethodName()));
        }
        log.error(sb.toString());
    }
}
#method_after
private static void logNullParameters(AsyncTask task) {
    if (task.getActionParameters() == null) {
        StringBuilder sb = new StringBuilder("Null action_parameters:\n");
        StackTraceElement[] st = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : st) {
            sb.append(String.format("\tMethod: %1$s%n", element.getMethodName()));
        }
        log.error(sb.toString());
    }
}
#end_block

#method_before
@Override
public List<AsyncTasks> getTasksByEntity(Guid entityId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("entity_id", entityId);
    return getCallsHandler().executeReadList("GetAsyncTasksByEntityId", AsyncTaskRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<AsyncTask> getTasksByEntity(Guid entityId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("entity_id", entityId);
    return getCallsHandler().executeReadList("GetAsyncTasksByEntityId", AsyncTaskRowMapper.instance, parameterSource);
}
#end_block

#method_before
@Override
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    persistCommand(cmdEntity);
    saveCommandContext(cmdEntity.getId(), cmdContext);
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    persistCommand(cmdEntity);
    saveCommandContext(cmdEntity.getId(), cmdContext);
}
#end_block

#method_before
@Override
public void persistCommand(CommandEntity cmdEntity) {
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallBackNotified(existingCmdEntity.isCallBackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallBackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && commandsCache.get(cmdEntity.getRootCommandId()) != null && commandsCache.get(cmdEntity.getRootCommandId()).isCallBackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallBackNotified()) {
            cmdExecutor.addToCallBackMap(cmdEntity);
        }
    }
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallBackNotified(existingCmdEntity.isCallBackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallBackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && commandsCache.get(cmdEntity.getRootCommandId()) != null && commandsCache.get(cmdEntity.getRootCommandId()).isCallBackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallBackNotified()) {
            cmdExecutor.addToCallBackMap(cmdEntity);
        }
    }
}
#end_block

#method_before
@Override
public CommandEntity getCommandEntity(Guid commandId) {
    return commandsCache.get(commandId);
}
#method_after
@Override
public CommandEntity getCommandEntity(Guid commandId) {
    return Guid.isNullOrEmpty(commandId) ? null : commandsCache.get(commandId);
}
#end_block

#method_before
public List<AsyncTasks> getAllAsyncTasksFromDb() {
    return coCoAsyncTaskHelper.getAllAsyncTasksFromDb(this);
}
#method_after
public List<AsyncTask> getAllAsyncTasksFromDb() {
    return coCoAsyncTaskHelper.getAllAsyncTasksFromDb(this);
}
#end_block

#method_before
public void saveAsyncTaskToDb(final AsyncTasks asyncTask) {
    coCoAsyncTaskHelper.saveAsyncTaskToDb(asyncTask);
}
#method_after
public void saveAsyncTaskToDb(final AsyncTask asyncTask) {
    coCoAsyncTaskHelper.saveAsyncTaskToDb(asyncTask);
}
#end_block

#method_before
public AsyncTasks getAsyncTaskFromDb(Guid asyncTaskId) {
    return coCoAsyncTaskHelper.getAsyncTaskFromDb(asyncTaskId);
}
#method_after
public AsyncTask getAsyncTaskFromDb(Guid asyncTaskId) {
    return coCoAsyncTaskHelper.getAsyncTaskFromDb(asyncTaskId);
}
#end_block

#method_before
public AsyncTasks getByVdsmTaskId(Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.getByVdsmTaskId(vdsmTaskId);
}
#method_after
public AsyncTask getByVdsmTaskId(Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.getByVdsmTaskId(vdsmTaskId);
}
#end_block

#method_before
public void addOrUpdateTaskInDB(final AsyncTasks asyncTask) {
    coCoAsyncTaskHelper.addOrUpdateTaskInDB(asyncTask);
}
#method_after
public void addOrUpdateTaskInDB(final AsyncTask asyncTask) {
    coCoAsyncTaskHelper.addOrUpdateTaskInDB(asyncTask);
}
#end_block

#method_before
public AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public AsyncTask getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public AsyncTask createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
@Override
public SPMTask construct(AsyncTaskType taskType, AsyncTaskParameters asyncTaskParams, boolean duringInit) {
    return AsyncTaskFactory.construct(this, taskType, asyncTaskParams, duringInit);
}
#method_after
@Override
public SPMTask construct(AsyncTaskCreationInfo creationInfo, AsyncTask asyncTask) {
    return AsyncTaskFactory.construct(this, creationInfo.getTaskType(), new AsyncTaskParameters(creationInfo, asyncTask), true);
}
#end_block

#method_before
@Override
public void update(int index, ClusterNetworkModel clusterNetworkModel, Boolean value) {
    updateMigrationNetwork(clusterNetworkModel, value);
}
#method_after
@Override
public void update(int index, ClusterNetworkModel clusterNetworkModel, Boolean value) {
    updateMigrationNetwork(clusterNetworkModel, value);
    refreshNetworksTable();
}
#end_block

#method_before
private void updateMigrationNetwork(ClusterNetworkModel clusterNetworkModel, boolean value) {
    networks.asEditor().flush().setMigrationNetwork(clusterNetworkModel, value);
    refreshNetworksTable();
}
#method_after
private void updateMigrationNetwork(ClusterNetworkModel clusterNetworkModel, boolean value) {
    networks.asEditor().flush().setMigrationNetwork(clusterNetworkModel, value);
}
#end_block

#method_before
@Override
public void update(int index, ClusterNetworkModel clusterNetworkModel, Boolean value) {
    updateDisplayNetwork(clusterNetworkModel, value);
}
#method_after
@Override
public void update(int index, ClusterNetworkModel clusterNetworkModel, Boolean value) {
    updateDisplayNetwork(clusterNetworkModel, value);
    refreshNetworksTable();
}
#end_block

#method_before
private void updateDisplayNetwork(ClusterNetworkModel clusterNetworkModel, boolean value) {
    networks.asEditor().flush().setDisplayNetwork(clusterNetworkModel, value);
    refreshNetworksTable();
}
#method_after
private void updateDisplayNetwork(ClusterNetworkModel clusterNetworkModel, boolean value) {
    networks.asEditor().flush().setDisplayNetwork(clusterNetworkModel, value);
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (_vds.isEnableBalloon()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (_vds.isBalloonEnabled()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        if (vmsInfo == null) {
            return;
        }
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (enableBalloon ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && enableBalloon == other.enableBalloon && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setEnableBalloon(isEnableBalloon());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    return vds;
}
#end_block

#method_before
public Date getCpuOverCommitTimestamp() {
    return mVdsStatistics.getcpu_over_commit_time_stamp();
}
#method_after
public Date getCpuOverCommitTimestamp() {
    return mVdsDynamic.getcpu_over_commit_time_stamp();
}
#end_block

#method_before
public void setCpuOverCommitTimestamp(Date value) {
    mVdsStatistics.setcpu_over_commit_time_stamp(value);
}
#method_after
public void setCpuOverCommitTimestamp(Date value) {
    mVdsDynamic.setcpu_over_commit_time_stamp(value);
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setEnableBalloon(rs.getBoolean("enable_balloon"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    return entity;
}
#end_block

#method_before
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        final String baseInterfaceName = NetworkUtils.stripVlan(nic);
        if (nic != null && !removedBonds.containsKey(baseInterfaceName)) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(baseInterfaceName);
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#method_after
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        final String baseInterfaceName = NetworkUtils.stripVlan(nic);
        if (!removedBonds.containsKey(baseInterfaceName)) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(baseInterfaceName);
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#end_block

#method_before
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> existingIfaces = getExistingIfaces();
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(existingIfaces.values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        final String baseInterfaceName = NetworkUtils.stripVlan(nic);
        if (nic != null && !removedBonds.containsKey(baseInterfaceName)) {
            if (NetworkUtils.isVlan(nic)) {
                final VdsNetworkInterface baseInterface = existingIfaces.get(baseInterfaceName);
                validateNicForNotRemovingLabeledNetworks(network, baseInterface);
            } else {
                validateNicForNotRemovingLabeledNetworks(network, nic);
            }
        }
    }
}
#method_after
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> existingIfaces = getExistingIfaces();
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(existingIfaces.values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        final String baseInterfaceName = NetworkUtils.stripVlan(nic);
        if (!removedBonds.containsKey(baseInterfaceName)) {
            if (NetworkUtils.isVlan(nic)) {
                final VdsNetworkInterface baseInterface = existingIfaces.get(baseInterfaceName);
                validateNicForNotRemovingLabeledNetworks(network, baseInterface);
            } else {
                validateNicForNotRemovingLabeledNetworks(network, nic);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            NetworkCluster networkCluster = getParameters().getNetworkCluster();
            getNetworkClusterDAO().remove(getParameters().getVdsGroupId(), networkCluster.getNetworkId());
            if (networkCluster.isDisplay()) {
                getManagementNetworkCluster().setDisplay(true);
            }
            if (networkCluster.isMigration()) {
                getManagementNetworkCluster().setMigration(true);
            }
            if (managementNetworkCluster != null) {
                getNetworkClusterDAO().update(managementNetworkCluster);
            }
            return null;
        }
    });
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getPersistedNetwork(), getVdsGroup().getcompatibility_version())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            NetworkClusterHelper helper = new NetworkClusterHelper(getParameters().getNetworkCluster());
            helper.removeNetworkAndReassignRoles();
            return null;
        }
    });
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getPersistedNetwork(), getVdsGroup().getcompatibility_version())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean runVmAsStateless(VM vmToRunAsStateless) {
    log.infoFormat("Running Vm {0} as stateless", vmToRunAsStateless);
    RunVmParams runVmParams = new RunVmParams(vmToRunAsStateless.getId());
    runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToRunAsStateless.getId()));
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams, ExecutionHandler.createInternalJobContext());
    boolean prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (!prestartingVmSucceeded) {
        AuditLogableBase log = new AuditLogableBase();
        log.setVmId(vmToRunAsStateless.getId());
        log.addCustomValue("VmName", vmToRunAsStateless.getName());
        AuditLogDirector.log(log, AuditLogType.VM_CANNOT_BE_PRESTARTED_NOT_ENOUGH_RESOURCES);
    }
    log.infoFormat("Running Vm {0} as stateless {1}", vmToRunAsStateless, prestartingVmSucceeded ? "succeeded" : "failed");
    return prestartingVmSucceeded;
}
#method_after
private boolean runVmAsStateless(VM vmToRunAsStateless) {
    log.infoFormat("Running Vm {0} as stateless", vmToRunAsStateless);
    RunVmParams runVmParams = new RunVmParams(vmToRunAsStateless.getId());
    runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToRunAsStateless.getId()));
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams, ExecutionHandler.createInternalJobContext());
    boolean prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (!prestartingVmSucceeded) {
        AuditLogableBase log = new AuditLogableBase();
        log.addCustomValue("VmPoolName", vmToRunAsStateless.getVmPoolName());
        AuditLogDirector.log(log, AuditLogType.VM_FAILED_TO_PRESTART_IN_POOL);
    }
    log.infoFormat("Running Vm {0} as stateless {1}", vmToRunAsStateless, prestartingVmSucceeded ? "succeeded" : "failed");
    return prestartingVmSucceeded;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, List<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append(permSubject.getActionGroup().toString());
            }
        }
    }
    return builder;
}
#method_after
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append("Action group " + permSubject.getActionGroup().name() + " with role type " + permSubject.getActionGroup().getRoleType().name());
            }
        }
    }
    return builder;
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    checkPersistCommand();
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    if (getCallBack() != null) {
        persistCommand(getParameters().getParentCommand(), true);
    }
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallBack callBack = command.getCallBack();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.errorFormat("Failed to submit command to executor service, command {0} status has been set to FAILED", command.getCommandId().toString());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallBack callBack = command.getCallBack();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.errorFormat("Failed to submit command to executor service, command {0} status has been set to FAILED", command.getCommandId().toString());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getVdsGroupId())) || !validate(nicValidator.canExternalNetworkVnicBePlugged())) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getVdsGroupId())) || !validate(nicValidator.canVnicWithExternalNetworkBePlugged())) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isVnicAttachedToExternalNetwork() {
    final Network network = findVnicNetwork();
    return (network != null && network.isExternal());
}
#method_after
private boolean isVnicAttachedToExternalNetwork() {
    final Network network = NetworkHelper.getNetworkByVnicProfileId(nic.getVnicProfileId());
    return (network != null && network.isExternal());
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, List<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append(permSubject.getActionGroup().toString());
            }
        }
    }
    return builder;
}
#method_after
private StringBuilder getPermissionSubjectsAsStringBuilder(List<PermissionSubject> permissionSubjects) {
    StringBuilder builder = new StringBuilder();
    // Iterate all over the entities , which should be affected.
    for (PermissionSubject permSubject : permissionSubjects) {
        if (permSubject.getObjectId() != null) {
            // affected.
            if (builder.length() != 0) {
                builder.append(", ");
            }
            builder.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            if (permSubject.getActionGroup() != null) {
                builder.append("Action group " + permSubject.getActionGroup().name() + " with role type " + permSubject.getActionGroup().getRoleType().name());
            }
        }
    }
    return builder;
}
#end_block

#method_before
@NotNull(message = VmNic.VALIDATION_MESSAGE_NAME_NOT_NULL, groups = { CreateEntity.class, UpdateEntity.class })
@ValidNameWithDot(groups = { CreateEntity.class, UpdateEntity.class })
@Override
public String getName() {
    return super.getName();
}
#method_after
@NotNull(message = VALIDATION_MESSAGE_NAME_NOT_NULL, groups = { CreateEntity.class, UpdateEntity.class })
@ValidNameWithDot(groups = { CreateEntity.class, UpdateEntity.class })
@Override
public String getName() {
    return super.getName();
}
#end_block

#method_before
@NotNull(message = VmNic.VALIDATION_MESSAGE_MAC_ADDRESS_NOT_NULL, groups = { UpdateVmNic.class })
@Pattern.List({ @Pattern(regexp = "(^$)|(" + VALID_MAC_ADDRESS_FORMAT + ")", message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { CreateEntity.class }), @Pattern(regexp = "(^$)|(" + NON_MULTICAST_MAC_ADDRESS_FORMAT + ")", message = VALIDATION_VM_NETWORK_MAC_ADDRESS_MULTICAST, groups = { CreateEntity.class }), @Pattern(regexp = VALID_MAC_ADDRESS_FORMAT, message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { UpdateEntity.class }), @Pattern(regexp = NON_MULTICAST_MAC_ADDRESS_FORMAT, message = VALIDATION_VM_NETWORK_MAC_ADDRESS_MULTICAST, groups = { UpdateEntity.class }), @Pattern(regexp = NON_NULLABLE_MAC_ADDRESS_FORMAT, message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { CreateEntity.class, UpdateEntity.class }) })
@Override
public String getMacAddress() {
    return super.getMacAddress();
}
#method_after
@NotNull(message = VALIDATION_MESSAGE_MAC_ADDRESS_NOT_NULL, groups = { UpdateVmNic.class })
@Pattern.List({ @Pattern(regexp = "(^$)|(" + MacAddressValidationPatterns.VALID_MAC_ADDRESS_FORMAT + ")", message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { CreateEntity.class }), @Pattern(regexp = "(^$)|(" + MacAddressValidationPatterns.NON_MULTICAST_MAC_ADDRESS_FORMAT + ")", message = VALIDATION_VM_NETWORK_MAC_ADDRESS_MULTICAST, groups = { CreateEntity.class }), @Pattern(regexp = MacAddressValidationPatterns.VALID_MAC_ADDRESS_FORMAT, message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { UpdateEntity.class }), @Pattern(regexp = MacAddressValidationPatterns.NON_MULTICAST_MAC_ADDRESS_FORMAT, message = VALIDATION_VM_NETWORK_MAC_ADDRESS_MULTICAST, groups = { UpdateEntity.class }), @Pattern(regexp = MacAddressValidationPatterns.NON_NULLABLE_MAC_ADDRESS_FORMAT, message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { CreateEntity.class, UpdateEntity.class }) })
@Override
public String getMacAddress() {
    return super.getMacAddress();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getVdsGroupId().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = getNetworkDAO().getAllForCluster(getParameters().getClusterId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    for (final VmNic iface : interfaces) {
        if (iface.getVnicProfileId() != null) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return ObjectUtils.equals(n.getId(), network.getId());
                }
            });
            // interface connection
            if (net == null) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
    if (vm.getDedicatedVmForVds() != null) {
        vm.setDedicatedVmForVds(null);
        dedicatedHostWasCleared = true;
    }
    vm.setVdsGroupId(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    // change vm cluster should remove the vm from all associated affinity groups
    List<AffinityGroup> allAffinityGroupsByVmId = DbFacade.getInstance().getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    if (!allAffinityGroupsByVmId.isEmpty()) {
        StringBuilder sb = new StringBuilder();
        for (AffinityGroup affinityGroup : allAffinityGroupsByVmId) {
            sb.append(affinityGroup.getName() + " ");
        }
        log.infoFormat("Due to cluster change, removing VM from associated affinity group(s): {0}", sb.toString());
        DbFacade.getInstance().getAffinityGroupDao().removeVmFromAffinityGroups(vm.getId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getVdsGroupId().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = getNetworkDAO().getAllForCluster(getParameters().getClusterId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    for (final VmNic iface : interfaces) {
        if (iface.getVnicProfileId() != null) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return ObjectUtils.equals(n.getId(), network.getId());
                }
            });
            // interface connection
            if (net == null) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
    if (vm.getDedicatedVmForVds() != null) {
        vm.setDedicatedVmForVds(null);
        dedicatedHostWasCleared = true;
    }
    // Since CPU profile is coupled to cluster, when changing a cluster
    // the 'old' CPU profile is invalid. The update VM command is called straight after
    // will validate a right profile for VM and its cluster
    vm.setCpuProfileId(null);
    vm.setVdsGroupId(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    // change vm cluster should remove the vm from all associated affinity groups
    List<AffinityGroup> allAffinityGroupsByVmId = DbFacade.getInstance().getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    if (!allAffinityGroupsByVmId.isEmpty()) {
        StringBuilder sb = new StringBuilder();
        for (AffinityGroup affinityGroup : allAffinityGroupsByVmId) {
            sb.append(affinityGroup.getName() + " ");
        }
        log.infoFormat("Due to cluster change, removing VM from associated affinity group(s): {0}", sb.toString());
        DbFacade.getInstance().getAffinityGroupDao().removeVmFromAffinityGroups(vm.getId());
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean validateStorageDomains(List<DiskImage> vmDisksList) {
    List<DiskImage> memoryDisksList = getMemoryImageBuilder().getDisksToBeCreated();
    List<DiskImage> disksList = getAllDisks(vmDisksList, memoryDisksList);
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
    return validate(sdValidator.allDomainsExistAndActive()) && validate(sdValidator.allDomainsWithinThresholds()) && validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#method_after
private boolean validateStorageDomains(List<DiskImage> vmDisksList, List<DiskImage> memoryDisksList) {
    List<DiskImage> disksList = getAllDisks(vmDisksList, memoryDisksList);
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
    return validate(sdValidator.allDomainsExistAndActive()) && validate(sdValidator.allDomainsWithinThresholds()) && validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#end_block

#method_before
public Guid getStorageDomainIdForVmMemory() {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        long sizeNeeded = getVm().getTotalMemorySizeInBytes() / BYTES_IN_GB;
        StorageDomain storageDomain = VmHandler.findStorageDomainForMemory(getVm().getStoragePoolId(), sizeNeeded);
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#method_after
public Guid getStorageDomainIdForVmMemory(List<DiskImage> memoryDisksList) {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        StorageDomain storageDomain = VmHandler.findStorageDomainForMemory(getVm().getStoragePoolId(), memoryDisksList);
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#end_block

#method_before
private MemoryImageBuilder createMemoryImageBuilder() {
    if (!isMemorySnapshotSupported()) {
        return new NullableMemoryImageBuilder();
    }
    if (getParameters().getSnapshotType() == SnapshotType.STATELESS) {
        return new StatelessSnapshotMemoryImageBuilder(getVm());
    }
    if (getParameters().isSaveMemory() && isLiveSnapshotApplicable()) {
        return new LiveSnapshotMemoryImageBuilder(getVm(), getStorageDomainIdForVmMemory(), getStoragePool(), this);
    }
    return new NullableMemoryImageBuilder();
}
#method_after
private MemoryImageBuilder createMemoryImageBuilder() {
    if (!isMemorySnapshotSupported()) {
        return new NullableMemoryImageBuilder();
    }
    if (getParameters().getSnapshotType() == SnapshotType.STATELESS) {
        return new StatelessSnapshotMemoryImageBuilder(getVm());
    }
    if (getParameters().isSaveMemory() && isLiveSnapshotApplicable()) {
        return new LiveSnapshotMemoryImageBuilder(getVm(), cachedStorageDomainId, getStoragePool(), this);
    }
    return new NullableMemoryImageBuilder();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    if (!validateStorageDomains(disksList)) {
        return false;
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.META_DATA_SIZE_IN_BYTES);
    getStorageDomainIdForVmMemory(memoryDisksList);
    if (getParameters().isSaveMemory() && Guid.Empty.equals(cachedStorageDomainId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    if (!validateStorageDomains(disksList, memoryDisksList)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.MigratingFrom) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_CANCEL_MIGRATION_WHEN_VM_IS_NOT_MIGRATING);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.MigratingFrom) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_CANCEL_MIGRATION_WHEN_VM_IS_NOT_MIGRATING);
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return isInternalExecution() ? getSucceeded() ? AuditLogType.SYSTEM_UPDATE_VM : AuditLogType.SYSTEM_FAILED_UPDATE_VM : getSucceeded() ? AuditLogType.USER_UPDATE_VM : AuditLogType.USER_FAILED_UPDATE_VM;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), !getParameters().isApplyChangesLater()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    // An empty 'cdImagePath' means eject CD
    if (!StringUtils.isEmpty(cdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
    } else {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
    }
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        retValue = false;
    }
    if (retValue && !canRunActionOnNonManagedVm()) {
        retValue = false;
    } else {
        cdImagePath = ImagesHandler.cdPathWindowsToLinux(getParameters().getCdImagePath(), getVm().getStoragePoolId(), getVm().getRunOnVds());
    }
    if (retValue && !getVm().isRunningOrPaused()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'cdImagePath' means eject CD
        if (!StringUtils.isEmpty(cdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    } else if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(cdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    } else if (StringUtils.isNotEmpty(cdImagePath) && !cdImagePath.endsWith(ValidationUtils.ISO_SUFFIX)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CDROM_DISK_FORMAT);
        setSucceeded(false);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(cdImagePath)) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (StringUtils.isNotEmpty(cdImagePath) && !cdImagePath.endsWith(ValidationUtils.ISO_SUFFIX)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CDROM_DISK_FORMAT);
    }
    return true;
}
#end_block

#method_before
@Override
protected void perform() {
    setActionReturnValue(runVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    cdImagePath = ImagesHandler.cdPathWindowsToLinux(getParameters().getCdImagePath(), getVm().getStoragePoolId(), getVm().getRunOnVds());
    setActionReturnValue(runVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#end_block

#method_before
public void initDisks() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    AsyncDataProvider.getInstance().getTemplateDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<DiskImage> disks = (ArrayList<DiskImage>) returnValue;
            Collections.sort(disks, new Linq.DiskByAliasComparer());
            ArrayList<DiskModel> list = new ArrayList<DiskModel>();
            for (Disk disk : disks) {
                DiskModel diskModel = new DiskModel();
                diskModel.getAlias().setEntity(disk.getDiskAlias());
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) disk;
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(diskImage.getSizeInGigabytes());
                    diskModel.setSize(tempVar);
                    ListModel tempVar2 = new ListModel();
                    tempVar2.setItems((diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.getInstance().getVolumeTypeList()));
                    tempVar2.setSelectedItem(diskImage.getVolumeType());
                    diskModel.setVolumeType(tempVar2);
                    diskModel.getVolumeType().setIsAvailable(false);
                }
                diskModel.setDisk(disk);
                list.add(diskModel);
            }
            model.setDisks(list);
            updateIsDisksAvailable();
            initStorageDomains();
        }
    }, getModel().getHash()), template.getId());
}
#method_after
public void initDisks() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    AsyncDataProvider.getInstance().getTemplateDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<DiskImage> disks = (ArrayList<DiskImage>) returnValue;
            Collections.sort(disks, new Linq.DiskByAliasComparer());
            ArrayList<DiskModel> list = new ArrayList<DiskModel>();
            for (Disk disk : disks) {
                DiskModel diskModel = new DiskModel();
                diskModel.getAlias().setEntity(disk.getDiskAlias());
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) disk;
                    EntityModel<Integer> sizeEntity = new EntityModel<Integer>();
                    sizeEntity.setEntity((int) diskImage.getSizeInGigabytes());
                    diskModel.setSize(sizeEntity);
                    ListModel tempVar2 = new ListModel();
                    tempVar2.setItems((diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.getInstance().getVolumeTypeList()));
                    tempVar2.setSelectedItem(diskImage.getVolumeType());
                    diskModel.setVolumeType(tempVar2);
                    diskModel.getVolumeType().setIsAvailable(false);
                }
                diskModel.setDisk(disk);
                list.add(diskModel);
            }
            model.setDisks(list);
            updateIsDisksAvailable();
            initStorageDomains();
        }
    }, getModel().getHash()), template.getId());
}
#end_block

#method_before
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, than it is supposed to use the default
        // determined by vm type
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
}
#method_after
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
}
#end_block

#method_before
private void WatchdogModel_EntityChanged(Object sender, EventArgs args) {
    if ("".equals(getWatchdogModel().getEntity())) {
        getWatchdogAction().setIsChangable(false);
        // $NON-NLS-1$
        getWatchdogAction().setSelectedItem("");
    } else {
        getWatchdogAction().setIsChangable(true);
    }
}
#method_after
private void WatchdogModel_EntityChanged(Object sender, EventArgs args) {
    if (getWatchdogModel().getEntity() == null) {
        getWatchdogAction().setIsChangable(false);
        // $NON-NLS-1$
        getWatchdogAction().setSelectedItem(null);
    } else {
        getWatchdogAction().setIsChangable(true);
    }
}
#end_block

#method_before
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), cluster.getcompatibility_version());
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
}
#method_after
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), cluster.getcompatibility_version());
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
}
#end_block

#method_before
private void updateWatchdogModels() {
    updateWatchdogModels((Integer) getOSType().getSelectedItem());
}
#method_after
private void updateWatchdogModels() {
    updateWatchdogModels(getOSType().getSelectedItem());
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.getInstance().get(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<VmWatchdogType> watchDogModels = new ArrayList<VmWatchdogType>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(vmWatchdogType);
    }
    watchDogModels.add(0, null);
    VmWatchdogType oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setIsFirstRunTabValid(vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isValidTab(TabName.POOL_TAB) ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid());
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setRngTabValid(getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    boolean isValid = behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid() && getTotalCPUCores().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#method_after
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean behaviorValid = behavior.validate();
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    boolean isValid = behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid() && getTotalCPUCores().getIsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
private void resetTabsValidity() {
    setIsGeneralTabValid(true);
    setIsSystemTabValid(true);
    setIsFirstRunTabValid(true);
    setIsDisplayTabValid(true);
    setIsHostTabValid(true);
    setIsAllocationTabValid(true);
    setIsBootSequenceTabValid(true);
    setRngTabValid(true);
    setIsCustomPropertiesTabValid(true);
    getValid().setEntity(true);
}
#method_after
private void resetTabsValidity() {
    setValidTab(TabName.HOST_TAB, true);
    setIsCustomPropertiesTabAvailable(true);
    setValidTab(TabName.TAB_RNG, true);
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, true);
    setValidTab(TabName.BOOT_OPTIONS_TAB, true);
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, true);
    setValidTab(TabName.CONSOLE_TAB, true);
    setValidTab(TabName.INITIAL_RUN_TAB, true);
    setValidTab(TabName.GENERAL_TAB, true);
    getValid().setEntity(true);
}
#end_block

#method_before
public ListModel<String> getWatchdogModel() {
    return watchdogModel;
}
#method_after
public ListModel<VmWatchdogType> getWatchdogModel() {
    return watchdogModel;
}
#end_block

#method_before
public void setWatchdogModel(ListModel<String> watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#method_after
public void setWatchdogModel(ListModel<VmWatchdogType> watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#end_block

#method_before
public ListModel<String> getWatchdogAction() {
    return watchdogAction;
}
#method_after
public ListModel<VmWatchdogAction> getWatchdogAction() {
    return watchdogAction;
}
#end_block

#method_before
public void setWatchdogAction(ListModel<String> watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#method_after
public void setWatchdogAction(ListModel<VmWatchdogAction> watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#end_block

#method_before
public void updateFildsAfterOsChanged() {
    model.startProgress(null);
    deactivate(new ActivatedListener() {

        @Override
        public void activated() {
            model.stopProgress();
        }
    });
    VmBase vmBase = getSource();
    maybeSetSingleQxlPci(vmBase);
    updateWatchdog(vmBase, false);
    updateBalloon(vmBase, false);
    maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
    activate();
}
#method_after
public void updateFildsAfterOsChanged() {
    deactivateAndStartProgress();
    VmBase vmBase = getSource();
    maybeSetSingleQxlPci(vmBase);
    updateWatchdog(vmBase, false);
    updateBalloon(vmBase, false);
    maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
    activate();
}
#end_block

#method_before
private void updateWatchdog(final VmBase vmBase, final boolean continueWithNext) {
    AsyncDataProvider.getInstance().getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            deactivate();
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = val.getReturnValue();
            if (watchdogs.size() == 0) {
                model.getWatchdogAction().setSelectedItem(model.getWatchdogAction().getItems().iterator().next());
                model.getWatchdogModel().setSelectedItem(model.getWatchdogModel().getItems().iterator().next());
            }
            for (VmWatchdog watchdog : watchdogs) {
                if (watchdogAvailable(watchdog.getModel().name())) {
                    model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction().name().toLowerCase());
                    model.getWatchdogModel().setSelectedItem(// $NON-NLS-1$
                    watchdog.getModel() == null ? // $NON-NLS-1$
                    "" : watchdog.getModel().name());
                }
            }
            activate();
            if (continueWithNext) {
                updateBalloon(vmBase, true);
            }
        }
    }), vmBase.getId());
}
#method_after
private void updateWatchdog(final VmBase vmBase, final boolean continueWithNext) {
    AsyncDataProvider.getInstance().getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            deactivate();
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = val.getReturnValue();
            if (watchdogs.size() == 0) {
                model.getWatchdogAction().setSelectedItem(model.getWatchdogAction().getItems().iterator().next());
                model.getWatchdogModel().setSelectedItem(model.getWatchdogModel().getItems().iterator().next());
            }
            for (VmWatchdog watchdog : watchdogs) {
                if (watchdogAvailable(watchdog.getModel())) {
                    model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction());
                    model.getWatchdogModel().setSelectedItem(// $NON-NLS-1$
                    watchdog.getModel() == null ? // $NON-NLS-1$
                    null : watchdog.getModel());
                }
            }
            activate();
            if (continueWithNext) {
                updateBalloon(vmBase, true);
            }
        }
    }), vmBase.getId());
}
#end_block

#method_before
private boolean watchdogAvailable(String watchdogModel) {
    for (String availableWatchdogModel : model.getWatchdogModel().getItems()) {
        if (watchdogModel == null && availableWatchdogModel == null) {
            return true;
        }
        if (watchdogModel != null && availableWatchdogModel != null && watchdogModel.equals(availableWatchdogModel)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean watchdogAvailable(VmWatchdogType watchdogModel) {
    for (VmWatchdogType availableWatchdogModel : model.getWatchdogModel().getItems()) {
        if (watchdogModel == null && availableWatchdogModel == null) {
            return true;
        }
        if (watchdogModel != null && availableWatchdogModel != null && watchdogModel.equals(availableWatchdogModel)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getstorage_type() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = XmlRpcStringUtils.string2Map(mountOptions);
    Set<String> optionsKeys = new HashSet<>();
    for (String optionName : optionsMap.keySet()) {
        optionsKeys.add(optionName.toLowerCase());
    }
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addCanDoActionMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getstorage_type() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = XmlRpcStringUtils.string2Map(mountOptions);
    Set<String> optionsKeys = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
    optionsKeys.addAll(optionsMap.keySet());
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addCanDoActionMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void testNfsConnectionWithInvalidMountOptions() {
    StorageServerConnections newPosixConnection = createConnection(StorageType.NFS, "timeo=30, nfsvers=4");
    params.setStorageServerConnection(newPosixConnection);
    ValidationResult result = command.validateMountOptions();
    assertFalse(result.isValid());
}
#method_after
@Test
public void testNfsConnectionWithInvalidMountOptions() {
    testConnectionMountOptionsValidations(StorageType.NFS, "timeo=30, nfsvers=4", false);
}
#end_block

#method_before
@Test
public void testPosixConnectionWithInvalidMountOptions() {
    StorageServerConnections conn = createConnection(StorageType.POSIXFS, "timeo=30, vfs_type=nfs");
    params.setStorageServerConnection(conn);
    ValidationResult result = command.validateMountOptions();
    assertFalse(result.isValid());
}
#method_after
@Test
public void testPosixConnectionWithInvalidMountOptions() {
    testConnectionMountOptionsValidations(StorageType.POSIXFS, "timeo=30, vfs_type=nfs", false);
}
#end_block

#method_before
@Test
public void testPosixConnectionWithValidMountOptions() {
    StorageServerConnections conn = createConnection(StorageType.POSIXFS, "timeo=30, validoption=666");
    params.setStorageServerConnection(conn);
    ValidationResult result = command.validateMountOptions();
    assertTrue(result.isValid());
}
#method_after
@Test
public void testPosixConnectionWithValidMountOptions() {
    testConnectionMountOptionsValidations(StorageType.POSIXFS, "timeo=30, validoption=666", true);
}
#end_block

#method_before
@Test
public void testNfsConnectionWithValidMountOptions() {
    StorageServerConnections newPosixConnection = createConnection(StorageType.NFS, "timeo=30, validoption=666");
    params.setStorageServerConnection(newPosixConnection);
    ValidationResult result = command.validateMountOptions();
    assertTrue(result.isValid());
}
#method_after
@Test
public void testNfsConnectionWithValidMountOptions() {
    testConnectionMountOptionsValidations(StorageType.NFS, "validoption=30, anothervalidoption=666", true);
}
#end_block

#method_before
protected ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getstorage_type() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = XmlRpcStringUtils.string2Map(mountOptions);
    Set<String> optionsKeys = new HashSet<>();
    for (String optionName : optionsMap.keySet()) {
        optionsKeys.add(optionName.toLowerCase());
    }
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addCanDoActionMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getstorage_type() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = XmlRpcStringUtils.string2Map(mountOptions);
    Set<String> optionsKeys = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
    optionsKeys.addAll(optionsMap.keySet());
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addCanDoActionMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void testConnectionWithValidMountOptionsSucceeds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.NFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(ValidationResult.VALID).when(getCommand()).validateMountOptions();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(getCommand());
}
#method_after
@Test
public void testConnectionWithValidMountOptionsSucceeds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.NFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(ValidationResult.VALID).when(getCommand()).validateMountOptions();
    when(getCommand().getStorageConnDao().get(newPosixConnection.getid())).thenReturn(newPosixConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(getCommand());
}
#end_block

#method_before
@Override
public void setSpiceProxyEnabled(boolean enabled, String reason) {
    enableSpiceProxy.setEnabled(enabled);
    if (!enabled) {
        enableSpiceProxy.setTitle(reason);
    }
}
#method_after
@Override
public void setSpiceProxyEnabled(boolean enabled, String reason) {
    enableSpiceProxy.setEnabled(enabled);
    enableSpiceProxy.setTitle(reason);
}
#end_block

#method_before
private void initView(ConsolePopupModel model) {
    listenOnRadioButtons(model);
    VmConsoles vmConsoles = model.getVmConsoles();
    getView().setSpiceAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    getView().setVncAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.VNC));
    getView().setRdpAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    ConsoleProtocol selectedProtocol = vmConsoles.getSelectedProcotol();
    boolean rdpPreselected = ConsoleProtocol.RDP.equals(selectedProtocol);
    boolean spicePreselected = ConsoleProtocol.SPICE.equals(selectedProtocol);
    boolean vncPreselected = ConsoleProtocol.VNC.equals(selectedProtocol);
    getView().selectSpice(spicePreselected);
    getView().selectRdp(rdpPreselected);
    getView().selectVnc(vncPreselected);
    getView().showSpicePanel(spicePreselected);
    getView().showRdpPanel(rdpPreselected);
    getView().showVncPanel(vncPreselected);
    getView().setDisableSmartcardVisible(model.getVmConsoles().getVm().isSmartcardEnabled());
    ISpice spice = model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class).getspice();
    if (spice != null) {
        if (!spice.isWanOptionsEnabled()) {
            getView().selectWanOptionsEnabled(false);
        }
        spiceProxyUserPreference = vmConsoles.getConsoleModel(SpiceConsoleModel.class).getspice().isSpiceProxyEnabled();
    }
    if (!consoleUtils.isBrowserPluginSupported(ConsoleProtocol.SPICE)) {
        getView().setSpicePluginImplEnabled(false, constants.spicePluginNotSupportedByBrowser());
    }
    getView().setSpiceHtml5ImplEnabled(consoleUtils.isWebSocketProxyDefined(), constants.spiceHtml5OnlyWhenWebsocketProxySet());
    getView().setNoVncEnabled(consoleUtils.isWebSocketProxyDefined(), constants.webSocketProxyNotSet());
    if (!consoleUtils.isBrowserPluginSupported(ConsoleProtocol.RDP)) {
        getView().setRdpPluginImplEnabled(false, constants.rdpPluginNotSupportedByBrowser());
    }
    getView().selectSpiceImplementation(vmConsoles.getConsoleModel(SpiceConsoleModel.class).getClientConsoleMode());
    getView().selectVncImplementation(vmConsoles.getConsoleModel(VncConsoleModel.class).getClientConsoleMode());
    getView().selectRdpImplementation(vmConsoles.getConsoleModel(RdpConsoleModel.class).getClientConsoleMode());
    wanOptionsAvailable = vmConsoles.getConsoleModel(SpiceConsoleModel.class).isWanOptionsAvailableForMyVm();
    if (wanOptionsAvailable) {
        getView().setWanOptionsVisible(true);
    } else {
        getView().setWanOptionsVisible(false);
    }
    getView().setAdditionalConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    getView().setSpiceConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    boolean spiceProxyEnabled = consoleUtils.isSpiceProxyDefined(vmConsoles.getVm()) && vmConsoles.getConsoleModel(SpiceConsoleModel.class).getClientConsoleMode() != SpiceConsoleModel.ClientConsoleMode.Html5;
    getView().setSpiceProxyEnabled(spiceProxyEnabled, constants.spiceProxyCanBeEnabledOnlyWhenDefined());
    registerHandler(getView().getConsoleClientResourcesAnchor().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            // $NON-NLS-1$ $NON-NLS-2$
            Window.open(dynamicMessages.consoleClientResourcesUrl(), "_blank", "resizable=yes,scrollbars=yes");
        }
    }));
    registerHandler(getView().getSpiceProxyEnabledCheckBox().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            spiceProxyUserPreference = booleanValueChangeEvent.getValue();
        }
    }));
}
#method_after
private void initView(ConsolePopupModel model) {
    listenOnRadioButtons(model);
    VmConsoles vmConsoles = model.getVmConsoles();
    getView().setSpiceAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    getView().setVncAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.VNC));
    getView().setRdpAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    ConsoleProtocol selectedProtocol = vmConsoles.getSelectedProcotol();
    boolean rdpPreselected = ConsoleProtocol.RDP.equals(selectedProtocol);
    boolean spicePreselected = ConsoleProtocol.SPICE.equals(selectedProtocol);
    boolean vncPreselected = ConsoleProtocol.VNC.equals(selectedProtocol);
    getView().selectSpice(spicePreselected);
    getView().selectRdp(rdpPreselected);
    getView().selectVnc(vncPreselected);
    getView().showSpicePanel(spicePreselected);
    getView().showRdpPanel(rdpPreselected);
    getView().showVncPanel(vncPreselected);
    getView().setDisableSmartcardVisible(model.getVmConsoles().getVm().isSmartcardEnabled());
    ISpice spice = model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class).getspice();
    if (spice != null) {
        if (!spice.isWanOptionsEnabled()) {
            getView().selectWanOptionsEnabled(false);
        }
        spiceProxyUserPreference = vmConsoles.getConsoleModel(SpiceConsoleModel.class).getspice().isSpiceProxyEnabled();
    }
    if (!consoleUtils.isBrowserPluginSupported(ConsoleProtocol.SPICE)) {
        getView().setSpicePluginImplEnabled(false, constants.spicePluginNotSupportedByBrowser());
    }
    getView().setSpiceHtml5ImplEnabled(consoleUtils.isWebSocketProxyDefined(), constants.spiceHtml5OnlyWhenWebsocketProxySet());
    getView().setNoVncEnabled(consoleUtils.isWebSocketProxyDefined(), constants.webSocketProxyNotSet());
    if (!consoleUtils.isBrowserPluginSupported(ConsoleProtocol.RDP)) {
        getView().setRdpPluginImplEnabled(false, constants.rdpPluginNotSupportedByBrowser());
    }
    spiceProxyDefinedOnCluster = consoleUtils.isSpiceProxyDefined(vmConsoles.getVm());
    selectSpiceImplementation(vmConsoles.getConsoleModel(SpiceConsoleModel.class).getClientConsoleMode());
    getView().selectVncImplementation(vmConsoles.getConsoleModel(VncConsoleModel.class).getClientConsoleMode());
    getView().selectRdpImplementation(vmConsoles.getConsoleModel(RdpConsoleModel.class).getClientConsoleMode());
    wanOptionsAvailable = vmConsoles.getConsoleModel(SpiceConsoleModel.class).isWanOptionsAvailableForMyVm();
    if (wanOptionsAvailable) {
        getView().setWanOptionsVisible(true);
    } else {
        getView().setWanOptionsVisible(false);
    }
    getView().setAdditionalConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    getView().setSpiceConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    registerHandler(getView().getConsoleClientResourcesAnchor().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            // $NON-NLS-1$ $NON-NLS-2$
            Window.open(dynamicMessages.consoleClientResourcesUrl(), "_blank", "resizable=yes,scrollbars=yes");
        }
    }));
    registerHandler(getView().getSpiceProxyEnabledCheckBox().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            spiceProxyUserPreference = booleanValueChangeEvent.getValue();
        }
    }));
}
#end_block

#method_before
protected void listenOnRadioButtons(final ConsolePopupModel model) {
    registerHandler(getView().getRdpRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().showRdpPanel(event.getValue());
        }
    }));
    registerHandler(getView().getVncRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().showVncPanel(event.getValue());
        }
    }));
    registerHandler(getView().getSpiceRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().showSpicePanel(event.getValue());
        }
    }));
    registerHandler(getView().getSpiceAutoImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Auto);
            getView().setSpiceProxyEnabled(true, null);
            getView().setSpiceProxy(spiceProxyUserPreference);
        }
    }));
    registerHandler(getView().getSpiceNativeImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Native);
            getView().setSpiceProxyEnabled(true, null);
            getView().setSpiceProxy(spiceProxyUserPreference);
        }
    }));
    registerHandler(getView().getSpicePluginImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Plugin);
            getView().setSpiceProxyEnabled(true, null);
            getView().setSpiceProxy(spiceProxyUserPreference);
        }
    }));
    registerHandler(getView().getSpiceHtml5ImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Html5);
            getView().setSpiceProxyEnabled(false, constants.spiceProxyCantBeCombinedWithSpiceHtml5());
            getView().setSpiceProxy(false);
        }
    }));
    registerHandler(getView().getNoVncImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectVncImplementation(VncConsoleModel.ClientConsoleMode.NoVnc);
        }
    }));
    registerHandler(getView().getVncNativeImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectVncImplementation(VncConsoleModel.ClientConsoleMode.Native);
        }
    }));
    registerHandler(getView().getRdpAutoImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectRdpImplementation(RdpConsoleModel.ClientConsoleMode.Auto);
        }
    }));
    registerHandler(getView().getRdpNativeImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectRdpImplementation(RdpConsoleModel.ClientConsoleMode.Native);
        }
    }));
    registerHandler(getView().getRdpPluginImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectRdpImplementation(RdpConsoleModel.ClientConsoleMode.Plugin);
        }
    }));
}
#method_after
protected void listenOnRadioButtons(final ConsolePopupModel model) {
    registerHandler(getView().getRdpRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().showRdpPanel(event.getValue());
        }
    }));
    registerHandler(getView().getVncRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().showVncPanel(event.getValue());
        }
    }));
    registerHandler(getView().getSpiceRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().showSpicePanel(event.getValue());
        }
    }));
    registerHandler(getView().getSpiceAutoImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Auto);
        }
    }));
    registerHandler(getView().getSpiceNativeImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Native);
        }
    }));
    registerHandler(getView().getSpicePluginImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Plugin);
        }
    }));
    registerHandler(getView().getSpiceHtml5ImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            boolean previousSpicePreference = getView().getSpiceProxy();
            selectSpiceImplementation(SpiceConsoleModel.ClientConsoleMode.Html5);
            spiceProxyUserPreference = previousSpicePreference;
        }
    }));
    registerHandler(getView().getNoVncImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectVncImplementation(VncConsoleModel.ClientConsoleMode.NoVnc);
        }
    }));
    registerHandler(getView().getVncNativeImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectVncImplementation(VncConsoleModel.ClientConsoleMode.Native);
        }
    }));
    registerHandler(getView().getRdpAutoImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectRdpImplementation(RdpConsoleModel.ClientConsoleMode.Auto);
        }
    }));
    registerHandler(getView().getRdpNativeImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectRdpImplementation(RdpConsoleModel.ClientConsoleMode.Native);
        }
    }));
    registerHandler(getView().getRdpPluginImplRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            getView().selectRdpImplementation(RdpConsoleModel.ClientConsoleMode.Plugin);
        }
    }));
}
#end_block

#method_before
public List<GlusterGeoRepSessionDetails> getSessionDetails() {
    return sessionDetails;
}
#method_after
public ArrayList<GlusterGeoRepSessionDetails> getSessionDetails() {
    return sessionDetails;
}
#end_block

#method_before
public void setSessionDetails(List<GlusterGeoRepSessionDetails> sessionDetails) {
    this.sessionDetails = sessionDetails;
}
#method_after
public void setSessionDetails(ArrayList<GlusterGeoRepSessionDetails> sessionDetails) {
    this.sessionDetails = sessionDetails;
}
#end_block

#method_before
public List<Long> allocateAvailableMacs(int numberOfMacs) {
    if (getAvailableMacsCount() < numberOfMacs) {
        throw new VdcBLLException(VdcBllErrors.MAC_POOL_NO_MACS_LEFT);
    }
    final List<Long> result = new ArrayList<>(numberOfMacs);
    int remainingMacs = numberOfMacs;
    while (remainingMacs > 0) {
        /*this is not needed, rangeWithAvailableMac won't be null, unless there's an error for which NPE should be
            thrown, but Coverity detects dereferencing hypothetical null as a problem.*/
        final Range rangeWithAvailableMac = getRangeWithAvailableMac();
        if (rangeWithAvailableMac == null) {
            continue;
        }
        final List<Long> allocatedMacs = rangeWithAvailableMac.allocateMacs(remainingMacs);
        remainingMacs -= allocatedMacs.size();
        result.addAll(allocatedMacs);
    }
    return result;
}
#method_after
public List<Long> allocateAvailableMacs(int numberOfMacs) {
    if (getAvailableMacsCount() < numberOfMacs) {
        throw new VdcBLLException(VdcBllErrors.MAC_POOL_NO_MACS_LEFT);
    }
    final List<Long> result = new ArrayList<>(numberOfMacs);
    int remainingMacs = numberOfMacs;
    while (remainingMacs > 0) {
        final Range rangeWithAvailableMac = getRangeWithAvailableMac();
        Validate.notNull(rangeWithAvailableMac);
        final List<Long> allocatedMacs = rangeWithAvailableMac.allocateMacs(remainingMacs);
        remainingMacs -= allocatedMacs.size();
        result.addAll(allocatedMacs);
    }
    return result;
}
#end_block

#method_before
public String getVdsName() {
    if (mVdsName == null && getVds() != null) {
        mVdsName = getVds().getName();
    }
    return mVdsName;
}
#method_after
public String getVdsName() {
    if (mVdsName == null) {
        if (getVdsNoLoad() == null) {
            if (getVdsStatic() != null) {
                mVdsName = getVdsStatic().getName();
            }
        } else {
            if (getVds() != null) {
                mVdsName = getVds().getName();
            }
        }
    }
    return mVdsName;
}
#end_block

#method_before
protected VdsStatic getVdsStatic() {
    if (mVdsStatic == null && ((mVdsId != null && !Guid.Empty.equals(mVdsId)) || (getVm() != null && getVm().getRunOnVds() != null))) {
        if (mVdsId == null || Guid.Empty.equals(mVdsId)) {
            mVdsId = getVm().getRunOnVds();
        }
        try {
            mVdsStatic = getVdsStaticDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.infoFormat("Failed to get vds {0}\n{1}", mVdsId, e.getMessage());
        }
    }
    return mVdsStatic;
}
#method_after
protected VdsStatic getVdsStatic() {
    if (cachedVdsStatic == null && ((mVdsId != null && !Guid.Empty.equals(mVdsId)) || (getVm() != null && getVm().getRunOnVds() != null))) {
        if (mVdsId == null || Guid.Empty.equals(mVdsId)) {
            mVdsId = getVm().getRunOnVds();
        }
        try {
            cachedVdsStatic = getVdsStaticDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.infoFormat("Failed to get vds {0}\n{1}", mVdsId, e.getMessage());
        }
    }
    return cachedVdsStatic;
}
#end_block

#method_before
@Override
public void updateIfNeeded(VdsDynamic vdsDynamic) {
    VdsDynamic dbData = get(vdsDynamic.getId());
    if (!dbData.equals(vdsDynamic)) {
        dbData.setcpu_over_commit_time_stamp(vdsDynamic.getcpu_over_commit_time_stamp());
        if (dbData.equals(vdsDynamic)) {
            // Update just the cpu_over_commit in the DB
            updateCpuOverCommit(vdsDynamic.getId(), vdsDynamic.getcpu_over_commit_time_stamp());
        } else {
            update(vdsDynamic);
        }
    } else {
        log.debug("Ignored an unneeded update of VdsDynamic");
    }
}
#method_after
@Override
public void updateIfNeeded(VdsDynamic vdsDynamic) {
    VdsDynamic dbData = get(vdsDynamic.getId());
    if (!dbData.equals(vdsDynamic)) {
        update(vdsDynamic);
    } else {
        log.debug("Ignored an unneeded update of VdsDynamic");
    }
}
#end_block

#method_before
private void initInfoIcon(ApplicationConstants constants) {
    consoleAddressInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.enableConsoleAddressOverrideHelpMessage()), resources);
    providerSearchInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.providerSearchInfo()), resources);
}
#method_after
private void initInfoIcon(ApplicationConstants constants) {
    consoleAddressInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.enableConsoleAddressOverrideHelpMessage()), resources);
    providerSearchInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.providerSearchInfo()), resources);
    provisionedHostInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.provisionedHostInfo()), resources);
    discoveredHostInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.discoveredHostInfoIcon()), resources);
}
#end_block

#method_before
private void addStyles() {
    overrideIpTablesEditor.addContentWidgetStyleName(style.overrideIpStyle());
    externalHostProviderEnabledEditor.addContentWidgetStyleName(style.checkBox());
    providerSearchFilterEditor.addContentWidgetStyleName(style.searchFilter());
    providerSearchFilterEditor.setStyleName(style.searchFilterLabel());
    providerSearchFilterEditor.setLabelStyleName(style.emptyEditor());
    providerSearchFilterLabel.addContentWidgetStyleName(style.emptyEditor());
    providerSearchFilterLabel.setStyleName(style.searchFilterLabel());
    fetchSshFingerprint.addContentWidgetStyleName(style.fingerprintEditor());
    expanderContent.setStyleName(style.expanderContent());
    publicKeyEditor.setCustomStyle(style.pkStyle());
}
#method_after
private void addStyles() {
    overrideIpTablesEditor.addContentWidgetStyleName(style.overrideIpStyle());
    protocolEditor.addContentWidgetStyleName(style.protocolStyle());
    externalHostProviderEnabledEditor.addContentWidgetStyleName(style.checkBox());
    providerSearchFilterEditor.addContentWidgetStyleName(style.searchFilter());
    providerSearchFilterEditor.setStyleName(style.searchFilterLabel());
    providerSearchFilterEditor.setLabelStyleName(style.emptyEditor());
    providerSearchFilterLabel.addContentWidgetStyleName(style.emptyEditor());
    providerSearchFilterLabel.setStyleName(style.searchFilterLabel());
    fetchSshFingerprint.addContentWidgetStyleName(style.fingerprintEditor());
    expanderContent.setStyleName(style.expanderContent());
    publicKeyEditor.setCustomStyle(style.pkStyle());
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool storagePool) {
            return storagePool.getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<VDSGroup>(new NullSafeRenderer<VDSGroup>() {

        @Override
        public String renderNullSafe(VDSGroup vdsGroup) {
            return vdsGroup.getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS vds) {
            return vds.getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Provider>(new NullSafeRenderer<Provider>() {

        @Override
        public String renderNullSafe(Provider provider) {
            return provider.getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<String>(new StringRenderer<String>());
    pmTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    pmSecondaryTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool storagePool) {
            return storagePool.getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<VDSGroup>(new NullSafeRenderer<VDSGroup>() {

        @Override
        public String renderNullSafe(VDSGroup vdsGroup) {
            return vdsGroup.getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS vds) {
            return vds.getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Provider>(new NullSafeRenderer<Provider>() {

        @Override
        public String renderNullSafe(Provider provider) {
            return provider.getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<String>(new StringRenderer<String>());
    pmTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    pmSecondaryTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rbPassword.setText(constants.hostPopupPasswordLabel());
    rbPublicKey.setText(constants.hostPopupPublicKeyLable());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
}
#method_after
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rbPassword.setText(constants.hostPopupPasswordLabel());
    rbPublicKey.setText(constants.hostPopupPublicKeyLable());
    rbProvisionedHost.setText(constants.provisionedHostsLabel());
    rbDiscoveredHost.setText(constants.discoveredHostsLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    protocolEditor.setLabel(constants.hostPopupProtocolLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText(object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText(object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscorveredHosts().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (Boolean.TRUE.equals(object.getIsDiscorveredHosts().getEntity())) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
private void initExternalHostProviderWidgets(boolean isAvailable) {
    // When the widgets should be enabled, only the "enable/disable" one should appear.
    // All the rest shouldn't be visible
    externalHostProviderEnabledEditor.setVisible(isAvailable);
    externalHostNameEditor.setVisible(false);
    providersEditor.setVisible(false);
    searchProviderPanel.setVisible(false);
}
#method_after
private void initExternalHostProviderWidgets(boolean isAvailable) {
    // When the widgets should be enabled, only the "enable/disable" one should appear.
    // All the rest shouldn't be visible
    externalHostProviderEnabledEditor.setVisible(isAvailable);
    provisionedHostSection.setVisible(false);
    discoveredHostSection.setVisible(false);
    providersEditor.setVisible(false);
    discoveredHostsPanel.setVisible(false);
    searchProviderPanel.setVisible(false);
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    rbProvisionedHost.setTabIndex(nextTabIndex++);
    rbDiscoveredHost.setTabIndex(nextTabIndex++);
    externalDiscoveredHostsEditor.setTabIndex(nextTabIndex++);
    externalHostGroupsEditor.setTabIndex(nextTabIndex++);
    externalComputeResourceEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected void populateTabMap() {
    getTabNameMapping().put(HostModel.HostTabNames.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(HostModel.HostTabNames.POWER_MANAGEMENT_TAB, this.powerManagementTab);
    getTabNameMapping().put(HostModel.HostTabNames.NETWORK_PROVIDER_TAB, this.networkProviderTab);
    getTabNameMapping().put(HostModel.HostTabNames.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(HostModel.HostTabNames.SPM_TAB, this.spmTab);
}
#method_after
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(TabName.POWER_MANAGEMENT_TAB, this.powerManagementTab);
    getTabNameMapping().put(TabName.NETWORK_PROVIDER_TAB, this.networkProviderTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.SPM_TAB, this.spmTab);
}
#end_block

#method_before
@Override
protected void populateTabMap() {
    getTabNameMapping().put(ConfigureLocalStorageModel.ConfigureLocalStorageTabNames.GENERAL_TAB, generalTab);
    getTabNameMapping().put(ConfigureLocalStorageModel.ConfigureLocalStorageTabNames.OPTIMIZATION_TAB, optimizationTab);
}
#method_after
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, generalTab);
    getTabNameMapping().put(TabName.OPTIMIZATION_TAB, optimizationTab);
}
#end_block

#method_before
@Override
public Event getPropertyChangedEvent() {
    return privatePropertyChangedEvent;
}
#method_after
@Override
public Event<PropertyChangedEventArgs> getPropertyChangedEvent() {
    return privatePropertyChangedEvent;
}
#end_block

#method_before
private void setPropertyChangedEvent(Event value) {
    privatePropertyChangedEvent = value;
}
#method_after
private void setPropertyChangedEvent(Event<PropertyChangedEventArgs> value) {
    privatePropertyChangedEvent = value;
}
#end_block

#method_before
private void setProgress(ProgressModel value) {
    if (progress != value) {
        progress = value;
        onPropertyChanged(new PropertyChangedEventArgs(PropertyChangedEventArgs.Args.PROGRESS.toString()));
    }
}
#method_after
private void setProgress(ProgressModel value) {
    if (progress != value) {
        progress = value;
        onPropertyChanged(new PropertyChangedEventArgs(PropertyChangedEventArgs.PROGRESS));
    }
}
#end_block

#method_before
@Override
protected void onPropertyChanged(PropertyChangedEventArgs e) {
    super.onPropertyChanged(e);
    getPropertyChangedEvent().raise(this, e);
}
#method_after
protected void onPropertyChanged(PropertyChangedEventArgs e) {
    getPropertyChangedEvent().raise(this, e);
}
#end_block

#method_before
@Override
public void init(UnitVmModel model) {
    super.init(model);
    initAdvancedModeFromLocalStorage(model);
    swithAccordingToMode(model);
    initListeners(model);
}
#method_after
@Override
public void init(UnitVmModel model) {
    super.init(model);
    initAdvancedModeFromLocalStorage(model);
    swithAccordingToMode(model);
    initToCreateInstanceMode(model);
    initListeners(model);
}
#end_block

#method_before
private void initListeners(final UnitVmModel model) {
    model.getAdvancedMode().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(org.ovirt.engine.ui.uicompat.Event ev, Object sender, EventArgs args) {
            storeAdvancedModeToLocalStorage(model);
            swithAccordingToMode(model);
        }
    });
    model.getAttachedToInstanceType().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            swithAttachToInstanceType(model);
        }
    });
}
#method_after
private void initListeners(final UnitVmModel model) {
    model.getAdvancedMode().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(org.ovirt.engine.ui.uicompat.Event ev, Object sender, EventArgs args) {
            storeAdvancedModeToLocalStorage(model);
            swithAccordingToMode(model);
        }
    });
    model.getAttachedToInstanceType().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            swithAttachToInstanceType(model);
        }
    });
    model.getValid().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            switchToAdvancedIfNeeded(model);
        }
    });
}
#end_block

#method_before
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            }
        }
    });
    getView().toggleSubnetVisibility(model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility(model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
    getView().getQosButton().setCommand(model.getAddQosCommand());
    getView().getQosButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getQosButton().getCommand().execute();
        }
    });
}
#method_after
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            }
        }
    });
    getView().toggleSubnetVisibility(model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility(model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
    getView().getQosButton().setCommand(model.getAddQosCommand());
    getView().getQosButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getQosButton().getCommand().execute();
        }
    });
    getView().addMtuEditor();
}
#end_block

#method_before
public int getMemoryOverCommit() {
    if (getOptimizationNone_IsSelected().getEntity()) {
        return getOptimizationNone().getEntity();
    }
    if (getOptimizationForServer_IsSelected().getEntity()) {
        return getOptimizationForServer().getEntity();
    }
    if (getOptimizationForDesktop_IsSelected().getEntity()) {
        return getOptimizationForDesktop().getEntity();
    }
    if (getOptimizationCustom_IsSelected().getEntity()) {
        return getOptimizationCustom().getEntity();
    }
    return AsyncDataProvider.getClusterDefaultMemoryOverCommit();
}
#method_after
public int getMemoryOverCommit() {
    if (getOptimizationNone_IsSelected().getEntity()) {
        return getOptimizationNone().getEntity();
    }
    if (getOptimizationForServer_IsSelected().getEntity()) {
        return getOptimizationForServer().getEntity();
    }
    if (getOptimizationForDesktop_IsSelected().getEntity()) {
        return getOptimizationForDesktop().getEntity();
    }
    if (getOptimizationCustom_IsSelected().getEntity()) {
        return getOptimizationCustom().getEntity();
    }
    return AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit();
}
#end_block

#method_before
public String getSchedulerOptimizationInfoMessage() {
    return ConstantsManager.getInstance().getMessages().schedulerOptimizationInfo(AsyncDataProvider.getOptimizeSchedulerForSpeedPendingRequests());
}
#method_after
public String getSchedulerOptimizationInfoMessage() {
    return ConstantsManager.getInstance().getMessages().schedulerOptimizationInfo(AsyncDataProvider.getInstance().getOptimizeSchedulerForSpeedPendingRequests());
}
#end_block

#method_before
public String getAllowOverbookingInfoMessage() {
    return ConstantsManager.getInstance().getMessages().schedulerAllowOverbookingInfo(AsyncDataProvider.getSchedulerAllowOverbookingPendingRequestsThreshold());
}
#method_after
public String getAllowOverbookingInfoMessage() {
    return ConstantsManager.getInstance().getMessages().schedulerAllowOverbookingInfo(AsyncDataProvider.getInstance().getSchedulerAllowOverbookingPendingRequestsThreshold());
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setValidTab(TabName.GENERAL_TAB, true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void fetchFingerprint(String hostAddress) {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getGlusterHostFingerprint().setEntity((String) result);
                setIsFingerprintVerified(true);
            } else {
                getGlusterHostFingerprint().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
                setIsFingerprintVerified(false);
            }
        }
    };
    AsyncDataProvider.getHostFingerprint(aQuery, hostAddress);
    getGlusterHostFingerprint().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
}
#method_after
private void fetchFingerprint(String hostAddress) {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getGlusterHostFingerprint().setEntity((String) result);
                setIsFingerprintVerified(true);
            } else {
                getGlusterHostFingerprint().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
                setIsFingerprintVerified(false);
            }
        }
    };
    AsyncDataProvider.getInstance().getHostFingerprint(aQuery, hostAddress);
    getGlusterHostFingerprint().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getFencingEnabledModel().setEntity(getEntity().getFencingPolicy().isFencingEnabled());
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfConnectivityBroken());
    getHostsWithBrokenConnectivityThreshold().setSelectedItem(getEntity().getFencingPolicy().getHostsWithBrokenConnectivityThreshold());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    updateFencingPolicyContent(version);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
private void updateMigrateOnError() {
    ServerCpu cpu = getCPU().getSelectedItem();
    Version version = getVersion().getSelectedItem();
    if (version == null) {
        return;
    }
    if (cpu == null) {
        return;
    }
    getMigrateOnErrorOption_NO().setIsAvailable(true);
    if (AsyncDataProvider.isMigrationSupported(cpu.getArchitecture(), version)) {
        getMigrateOnErrorOption_YES().setIsAvailable(true);
        getMigrateOnErrorOption_HA_ONLY().setIsAvailable(true);
    } else {
        getMigrateOnErrorOption_YES().setIsAvailable(false);
        getMigrateOnErrorOption_HA_ONLY().setIsAvailable(false);
        setMigrateOnErrorOption(MigrateOnErrorOptions.NO);
    }
}
#method_after
private void updateMigrateOnError() {
    ServerCpu cpu = getCPU().getSelectedItem();
    Version version = getVersion().getSelectedItem();
    if (version == null) {
        return;
    }
    if (cpu == null) {
        return;
    }
    getMigrateOnErrorOption_NO().setIsAvailable(true);
    if (AsyncDataProvider.getInstance().isMigrationSupported(cpu.getArchitecture(), version)) {
        getMigrateOnErrorOption_YES().setIsAvailable(true);
        getMigrateOnErrorOption_HA_ONLY().setIsAvailable(true);
    } else {
        getMigrateOnErrorOption_YES().setIsAvailable(false);
        getMigrateOnErrorOption_HA_ONLY().setIsAvailable(false);
        setMigrateOnErrorOption(MigrateOnErrorOptions.NO);
    }
}
#end_block

#method_before
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getcompatibility_version()) > 0) {
                clusterModel.getVersion().setSelectedItem(selectedDataCenter.getcompatibility_version());
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#method_after
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getcompatibility_version()) > 0) {
                if (ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly)) {
                    clusterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(versions));
                } else {
                    clusterModel.getVersion().setSelectedItem(selectedDataCenter.getcompatibility_version());
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#end_block

#method_before
private void clusterPolicyChanged() {
    ClusterPolicy clusterPolicy = getClusterPolicy().getSelectedItem();
    ArrayList<String> lines = new ArrayList<String>();
    Map<Guid, PolicyUnit> allPolicyUnits = new HashMap<Guid, PolicyUnit>();
    if (clusterPolicy.getFilters() != null) {
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            allPolicyUnits.put(policyUnitId, policyUnitMap.get(policyUnitId));
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            allPolicyUnits.put(pair.getFirst(), policyUnitMap.get(pair.getFirst()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        allPolicyUnits.put(clusterPolicy.getBalance(), policyUnitMap.get(clusterPolicy.getBalance()));
    }
    for (PolicyUnit policyUnit : allPolicyUnits.values()) {
        if (policyUnit.getParameterRegExMap() != null) {
            for (Map.Entry<String, String> keyValue : policyUnit.getParameterRegExMap().entrySet()) {
                lines.add(keyValue.getKey() + '=' + keyValue.getValue());
            }
        }
    }
    getCustomPropertySheet().setKeyValueString(lines);
    if (getIsEdit() && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(getEntity().getClusterPolicyProperties()));
    } else {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(clusterPolicy.getParameterMap()));
    }
}
#method_after
private void clusterPolicyChanged() {
    ClusterPolicy clusterPolicy = getClusterPolicy().getSelectedItem();
    Map<String, String> policyProperties = new HashMap<String, String>();
    Map<Guid, PolicyUnit> allPolicyUnits = new HashMap<Guid, PolicyUnit>();
    if (clusterPolicy.getFilters() != null) {
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            allPolicyUnits.put(policyUnitId, policyUnitMap.get(policyUnitId));
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            allPolicyUnits.put(pair.getFirst(), policyUnitMap.get(pair.getFirst()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        allPolicyUnits.put(clusterPolicy.getBalance(), policyUnitMap.get(clusterPolicy.getBalance()));
    }
    for (PolicyUnit policyUnit : allPolicyUnits.values()) {
        if (policyUnit.getParameterRegExMap() != null) {
            policyProperties.putAll(policyUnit.getParameterRegExMap());
        }
    }
    getCustomPropertySheet().setKeyValueMap(policyProperties);
    if (getIsEdit() && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(getEntity().getClusterPolicyProperties()));
    } else {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(clusterPolicy.getParameterMap()));
    }
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    ValidationCompleteEvent.fire(getEventBus(), this);
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid();
}
#end_block

#method_before
public void fetchPublicKey() {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String pk = (String) result;
            if (pk != null && pk.length() > 0) {
                getPublicKey().setEntity(pk);
            }
        }
    };
    AsyncDataProvider.getHostPublicKey(aQuery);
}
#method_after
public void fetchPublicKey() {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String pk = (String) result;
            if (pk != null && pk.length() > 0) {
                getPublicKey().setEntity(pk);
            }
        }
    };
    AsyncDataProvider.getInstance().getHostPublicKey(aQuery);
}
#end_block

#method_before
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    getFetchSshFingerprint().setEntity(ConstantsManager.getInstance().getConstants().empty());
    getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().empty());
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(fingerprint);
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getHostFingerprint(aQuery, getHost().getEntity());
    }
}
#method_after
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    getFetchSshFingerprint().setEntity(ConstantsManager.getInstance().getConstants().empty());
    getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().empty());
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(fingerprint);
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getInstance().getHostFingerprint(aQuery, getHost().getEntity());
    }
}
#end_block

#method_before
private void initSpmPriorities() {
    AsyncDataProvider.getMaxSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.maxSpmPriority = (Integer) returnValue;
            initSpmPriorities1();
        }
    }));
}
#method_after
private void initSpmPriorities() {
    AsyncDataProvider.getInstance().getMaxSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.maxSpmPriority = (Integer) returnValue;
            initSpmPriorities1();
        }
    }));
}
#end_block

#method_before
private void initSpmPriorities1() {
    AsyncDataProvider.getDefaultSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.defaultSpmPriority = (Integer) returnValue;
            if (postponedSpmPriority != null) {
                updateSpmPriority(postponedSpmPriority);
            }
            spmInitialized = true;
        }
    }));
}
#method_after
private void initSpmPriorities1() {
    AsyncDataProvider.getInstance().getDefaultSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.defaultSpmPriority = (Integer) returnValue;
            if (postponedSpmPriority != null) {
                updateSpmPriority(postponedSpmPriority);
            }
            spmInitialized = true;
        }
    }));
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getInstance().getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getInstance().getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#end_block

#method_before
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getcompatibility_version());
    }
}
#method_after
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getcompatibility_version());
    }
}
#end_block

#method_before
private HashMap<String, String> getPmOptionsMapInternal(EntityModel<String> port, EntityModel<String> slot, EntityModel<Boolean> secure, EntityModel<String> options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    if (getIsPm().getEntity()) {
        // Add well known pm options.
        if (port.getIsAvailable() && port.getEntity() != null) {
            dict.put(PmPortKey, port.getEntity());
        }
        if (slot.getIsAvailable() && slot.getEntity() != null) {
            dict.put(PmSlotKey, slot.getEntity());
        }
        if (secure.getIsAvailable()) {
            dict.put(PmSecureKey, secure.getEntity().toString());
        }
        // Add unknown pm options.
        // Assume Validate method was called before this getter.
        String pmOptions = options.getEntity();
        if (!StringHelper.isNullOrEmpty(pmOptions)) {
            for (// $NON-NLS-1$
            String pair : // $NON-NLS-1$
            pmOptions.split("[,]", -1)) {
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                if (array.length == 2) {
                    dict.put(array[0], array[1]);
                } else if (array.length == 1) {
                    // $NON-NLS-1$
                    dict.put(array[0], "");
                }
            }
        }
    }
    return dict;
}
#method_after
private HashMap<String, String> getPmOptionsMapInternal(EntityModel<String> port, EntityModel<String> slot, EntityModel<Boolean> secure, EntityModel<String> options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    // Add well known pm options.
    if (port.getIsAvailable() && port.getEntity() != null) {
        dict.put(PmPortKey, port.getEntity());
    }
    if (slot.getIsAvailable() && slot.getEntity() != null) {
        dict.put(PmSlotKey, slot.getEntity());
    }
    if (secure.getIsAvailable()) {
        dict.put(PmSecureKey, secure.getEntity().toString());
    }
    // Add unknown pm options.
    // Assume Validate method was called before this getter.
    String pmOptions = options.getEntity();
    if (!StringHelper.isNullOrEmpty(pmOptions)) {
        for (// $NON-NLS-1$
        String pair : // $NON-NLS-1$
        pmOptions.split("[,]", -1)) {
            // $NON-NLS-1$
            String[] array = pair.split("[=]", -1);
            if (array.length == 2) {
                dict.put(array[0], array[1]);
            } else if (array.length == 1) {
                // $NON-NLS-1$
                dict.put(array[0], "");
            }
        }
    }
    return dict;
}
#end_block

#method_before
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    // $NON-NLS-1$
    final String ciscoUcsValue = "cisco_ucs";
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable(getIsPm().getEntity());
    String proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = getCluster().getSelectedItem();
    String version = AsyncDataProvider.getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
        setCiscoUcsPrimaryPmTypeSelected(pmType.equals(ciscoUcsValue));
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangable(isPm);
    String pmSecondaryType = getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
        setCiscoUcsSecondaryPmTypeSelected(pmSecondaryType.equals(ciscoUcsValue));
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getPmKdumpDetection().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#method_after
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    // $NON-NLS-1$
    final String ciscoUcsValue = "cisco_ucs";
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable(getIsPm().getEntity());
    String proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = getCluster().getSelectedItem();
    String version = AsyncDataProvider.getInstance().getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
        setCiscoUcsPrimaryPmTypeSelected(pmType.equals(ciscoUcsValue));
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangable(isPm);
    String pmSecondaryType = getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
        setCiscoUcsSecondaryPmTypeSelected(pmSecondaryType.equals(ciscoUcsValue));
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getPmKdumpDetection().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    param.setPmProxyPreferences(getPmProxyPreferences());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#end_block

#method_before
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation() });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#method_after
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50) });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if (getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getConsoleAddress().getIsValid());
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid());
    setValidTab(TabName.POWER_MANAGEMENT_TAB, getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValidTab(TabName.GENERAL_TAB) && isValidTab(TabName.POWER_MANAGEMENT_TAB) && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsAvailable(showTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void initExternalProviderList() {
    startProgress(null);
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            List<Provider> providers = (List<Provider>) result;
            getExternalProviders().setItems(providers);
            selectExternalProvider();
            stopProgress();
        }
    };
    AsyncDataProvider.getAllNetworkProviders(getProvidersQuery);
}
#method_after
private void initExternalProviderList() {
    startProgress(null);
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            List<Provider> providers = (List<Provider>) result;
            getExternalProviders().setItems(providers);
            selectExternalProvider();
            stopProgress();
        }
    };
    AsyncDataProvider.getInstance().getAllNetworkProviders(getProvidersQuery);
}
#end_block

#method_before
public EntityModel<Integer> getMtu() {
    return privateMtu;
}
#method_after
public EntityModel<Integer> getMtu() {
    return mtu;
}
#end_block

#method_before
private void setMtu(EntityModel<Integer> value) {
    privateMtu = value;
}
#method_after
private void setMtu(EntityModel<Integer> value) {
    mtu = value;
}
#end_block

#method_before
public void setMTUOverrideSupported(boolean mtuOverrideSupported) {
    if (!mtuOverrideSupported) {
        getHasMtu().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().mtuOverrideNotSupported(getSelectedDc().getcompatibility_version().toString()));
        getHasMtu().setIsChangable(false);
        getMtu().setIsChangable(false);
        getHasMtu().setEntity(false);
        getMtu().setEntity(null);
    } else {
        if (this.mtuOverrideSupported != mtuOverrideSupported) {
            initMtu();
        }
        getHasMtu().setIsChangable(true);
    }
    this.mtuOverrideSupported = mtuOverrideSupported;
}
#method_after
public void setMTUOverrideSupported(boolean mtuOverrideSupported) {
    this.mtuOverrideSupported = mtuOverrideSupported;
    updateMtuSelectorsChangeability();
}
#end_block

#method_before
private void setIsGeneralTabValid(boolean value) {
    if (value) {
        invalidTabs.remove(NetworkModelTabNames.GENERAL_TAB);
    } else {
        invalidTabs.add(NetworkModelTabNames.GENERAL_TAB);
    }
}
#method_after
public void setIsGeneralTabValid(boolean value) {
    if (isGeneralTabValid != value) {
        isGeneralTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsGeneralTabValid"));
    }
}
#end_block

#method_before
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if (getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if (getExport().getEntity() && getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    setIsGeneralTabValid(getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && subnetValid && profilesValid && getNetworkLabel().getIsValid());
    ValidationCompleteEvent.fire(getEventBus(), this);
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && subnetValid && profilesValid && getNetworkLabel().getIsValid();
}
#method_after
private boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    IntegerValidation tempVar5 = new IntegerValidation();
    tempVar5.setMinimum(68);
    getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if (getExport().getEntity() && getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getNetworkLabel().getIsValid());
    setValidTab(TabName.SUBNET_TAB, subnetValid);
    setValidTab(TabName.PROFILES_TAB, profilesValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid();
}
#end_block

#method_before
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    AsyncQuery query = new AsyncQuery();
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<NetworkQoS> qos = (Collection<NetworkQoS>) returnValue;
            getQos().setItems(qos);
            getQos().setSelectedItem(Linq.findNetworkQosById(qos, getNetwork().getQosId()));
        }
    };
    AsyncDataProvider.getAllNetworkQos(dc.getId(), query);
    updateDcLabels();
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#method_after
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    AsyncQuery query = new AsyncQuery();
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<NetworkQoS> qos = (Collection<NetworkQoS>) returnValue;
            getQos().setItems(qos);
            getQos().setSelectedItem(Linq.findNetworkQosById(qos, getNetwork().getQosId()));
        }
    };
    AsyncDataProvider.getInstance().getAllNetworkQos(dc.getId(), query);
    updateDcLabels();
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#end_block

#method_before
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName(getName().getEntity());
    network.setStp(getIsStpEnabled().getEntity());
    network.setDescription(getDescription().getEntity());
    network.setComment(getComment().getEntity());
    network.setVmNetwork(getIsVmNetwork().getEntity());
    String label = getNetworkLabel().getSelectedItem();
    network.setLabel(label == null || !label.isEmpty() ? label : null);
    network.setMtu(0);
    if (getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if (getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#method_after
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName(getName().getEntity());
    network.setStp(getIsStpEnabled().getEntity());
    network.setDescription(getDescription().getEntity());
    network.setComment(getComment().getEntity());
    network.setVmNetwork(getIsVmNetwork().getEntity());
    String label = getExport().getEntity() ? getNeutronPhysicalNetwork().getEntity() : getNetworkLabel().getSelectedItem();
    network.setLabel(label == null || !label.isEmpty() ? label : null);
    network.setMtu(0);
    if (getMtu().getIsChangable()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if (getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#end_block

#method_before
protected void onExportChanged() {
    boolean externalNetwork = getExport().getEntity();
    getQos().setIsChangable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    String label = getNetworkLabel().getSelectedItem();
    getNetworkLabel().setItems(externalNetwork ? new HashSet<String>() : dcLabels);
    getNetworkLabel().setSelectedItem(label);
}
#method_after
protected void onExportChanged() {
    boolean externalNetwork = getExport().getEntity();
    getNetworkLabel().setIsChangable(!externalNetwork);
    getNeutronPhysicalNetwork().setIsChangable(externalNetwork);
    getQos().setIsChangable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    updateMtuSelectorsChangeability();
}
#end_block

#method_before
private void updateDcLabels() {
    startProgress(null);
    AsyncDataProvider.getNetworkLabelsByDataCenterId(getSelectedDc().getId(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            dcLabels = (Collection<String>) returnValue;
            stopProgress();
            onExportChanged();
        }
    }));
}
#method_after
private void updateDcLabels() {
    startProgress(null);
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getSelectedDc().getId(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            String label = getNetworkLabel().getSelectedItem();
            getNetworkLabel().setItems((Collection<String>) returnValue);
            getNetworkLabel().setSelectedItem(label);
            stopProgress();
            onExportChanged();
        }
    }));
}
#end_block

#method_before
protected void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.generalTabNetworkPopup());
    clusterTab.setLabel(constants.clusterTabNetworkPopup());
    profilesTab.setLabel(constants.profilesTabNetworkPopup());
    subnetTab.setLabel(constants.subnetTabNetworkPopup());
    dataCenterEditor.setLabel(constants.networkPopupDataCenterLabel());
    assignLabel.setText(constants.networkPopupAssignLabel());
    nameEditor.setLabel(constants.nameLabel());
    descriptionEditor.setLabel(constants.descriptionLabel());
    exportLabel.setText(constants.exportLabel());
    exportEditor.setLabel(constants.exportCheckboxLabel());
    externalProviderEditor.setLabel(constants.externalProviderLabel());
    networkLabelLabel.setText(constants.networkLabel());
    commentEditor.setLabel(constants.commentLabel());
    isVmNetworkEditor.setLabel(constants.vmNetworkLabel());
    vlanTagging.setLabel(constants.enableVlanTagLabel());
    hasMtuEditor.setLabel(constants.overrideMtuLabel());
    qosEditor.setLabel(constants.hostNetworkQos());
    createSubnetEditor.setLabel(constants.createSubnetLabel());
    profilesLabel.setText(constants.profilesLabel());
}
#method_after
protected void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.generalTabNetworkPopup());
    clusterTab.setLabel(constants.clusterTabNetworkPopup());
    profilesTab.setLabel(constants.profilesTabNetworkPopup());
    subnetTab.setLabel(constants.subnetTabNetworkPopup());
    dataCenterEditor.setLabel(constants.networkPopupDataCenterLabel());
    assignLabel.setText(constants.networkPopupAssignLabel());
    nameEditor.setLabel(constants.nameLabel());
    descriptionEditor.setLabel(constants.descriptionLabel());
    exportLabel.setText(constants.exportLabel());
    exportEditor.setLabel(constants.exportCheckboxLabel());
    externalProviderEditor.setLabel(constants.externalProviderLabel());
    neutronPhysicalNetwork.setLabel(constants.neutronPhysicalNetwork());
    networkLabel.setLabel(constants.networkLabel());
    commentEditor.setLabel(constants.commentLabel());
    isVmNetworkEditor.setLabel(constants.vmNetworkLabel());
    vlanTagging.setLabel(constants.enableVlanTagLabel());
    mtuSelectorEditor.setLabel(constants.mtuLabel());
    qosEditor.setLabel(constants.hostNetworkQos());
    createSubnetEditor.setLabel(constants.createSubnetLabel());
    profilesLabel.setText(constants.profilesLabel());
}
#end_block

#method_before
protected void addStyles() {
    vlanTag.addContentWidgetStyleName(style.valueBox());
    mtuEditor.addContentWidgetStyleName(style.valueBox());
    networkLabel.addContentWidgetStyleName(style.valueBox());
    qosEditor.addContentWidgetStyleName(style.valueBox());
    isVmNetworkEditor.addContentWidgetStyleName(style.vmNetworkStyle());
    isVmNetworkEditor.asCheckBox().addStyleName(style.vmNetworkStyle());
    vlanTagging.addContentWidgetStyleName(style.checkBox());
    vlanTagging.asCheckBox().addStyleName(style.checkBox());
    hasMtuEditor.addContentWidgetStyleName(style.checkBox());
    hasMtuEditor.asCheckBox().addStyleName(style.checkBox());
    networkLabelLabel.addStyleName(style.checkBox());
    networkLabelLabel.addStyleName(style.inlineLabel());
    qosEditor.addLabelStyleName(style.checkBox());
    qosEditor.addLabelStyleName(style.inlineLabel());
}
#method_after
protected void addStyles() {
    vlanTag.addContentWidgetStyleName(style.valueBox());
    mtuSelectorEditor.addLabelStyleName(style.noPadding());
    mtuSelectorEditor.addLabelStyleName(style.mtuLabel());
    mtuSelectorEditor.addContentWidgetStyleName(style.mtuSelector());
    mtuEditor.addContentWidgetStyleName(style.valueBox());
    mtuEditor.addWrapperStyleName(style.inlineBlock());
    networkLabel.addContentWidgetStyleName(style.valueBox());
    qosEditor.addContentWidgetStyleName(style.valueBox());
    isVmNetworkEditor.addContentWidgetStyleName(style.vmNetworkStyle());
    isVmNetworkEditor.asCheckBox().addStyleName(style.vmNetworkStyle());
    vlanTagging.addContentWidgetStyleName(style.noPadding());
    vlanTagging.asCheckBox().addStyleName(style.noPadding());
    networkLabel.addLabelStyleName(style.noPadding());
    networkLabel.addLabelStyleName(style.inlineBlock());
    qosEditor.addLabelStyleName(style.noPadding());
    qosEditor.addLabelStyleName(style.inlineBlock());
}
#end_block

#method_before
@Override
protected void populateTabMap() {
    getTabNameMapping().put(NetworkModel.NetworkModelTabNames.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(NetworkModel.NetworkModelTabNames.CLUSTERS_TAB, this.clusterTab);
    getTabNameMapping().put(NetworkModel.NetworkModelTabNames.PROFILES_TAB, this.profilesTab);
    getTabNameMapping().put(NetworkModel.NetworkModelTabNames.SUBNET_TAB, this.subnetTab);
}
#method_after
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(TabName.CLUSTERS_TAB, this.clusterTab);
    getTabNameMapping().put(TabName.PROFILES_TAB, this.profilesTab);
    getTabNameMapping().put(TabName.SUBNET_TAB, this.subnetTab);
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getCpuProfiles().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public Map<Version, List<String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#method_after
public Map<Version, Map<String, String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#end_block

#method_before
public void setCustomPropertiesKeysList(Map<Version, List<String>> value) {
    privateCustomPropertiesKeysList = value;
}
#method_after
public void setCustomPropertiesKeysList(Map<Version, Map<String, String>> value) {
    privateCustomPropertiesKeysList = value;
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void WatchdogModel_EntityChanged(Object sender, EventArgs args) {
    if ("".equals(getWatchdogModel().getEntity())) {
        getWatchdogAction().setIsChangable(false);
        // $NON-NLS-1$
        getWatchdogAction().setSelectedItem("");
    } else {
        getWatchdogAction().setIsChangable(true);
    }
}
#method_after
private void WatchdogModel_EntityChanged(Object sender, EventArgs args) {
    if (getWatchdogModel().getEntity() == null) {
        getWatchdogAction().setIsChangable(false);
        // $NON-NLS-1$
        getWatchdogAction().setSelectedItem(null);
    } else {
        getWatchdogAction().setIsChangable(true);
    }
}
#end_block

#method_before
protected void initNumOfMonitors() {
    AsyncDataProvider.getNumOfMonitorList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            Integer oldNumOfMonitors = null;
            if (model.getNumOfMonitors().getSelectedItem() != null) {
                oldNumOfMonitors = model.getNumOfMonitors().getSelectedItem();
            }
            ArrayList<Integer> numOfMonitors = (ArrayList<Integer>) returnValue;
            model.getNumOfMonitors().setItems(numOfMonitors);
            if (oldNumOfMonitors != null) {
                model.getNumOfMonitors().setSelectedItem(oldNumOfMonitors);
            }
        }
    }, getHash()));
}
#method_after
protected void initNumOfMonitors() {
    AsyncDataProvider.getInstance().getNumOfMonitorList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            Integer oldNumOfMonitors = null;
            if (model.getNumOfMonitors().getSelectedItem() != null) {
                oldNumOfMonitors = model.getNumOfMonitors().getSelectedItem();
            }
            ArrayList<Integer> numOfMonitors = (ArrayList<Integer>) returnValue;
            model.getNumOfMonitors().setItems(numOfMonitors);
            if (oldNumOfMonitors != null) {
                model.getNumOfMonitors().setSelectedItem(oldNumOfMonitors);
            }
        }
    }, getHash()));
}
#end_block

#method_before
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#method_after
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.getInstance().isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.getInstance().isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#end_block

#method_before
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Boolean isMigrationSupported = AsyncDataProvider.isMigrationSupported(cluster.getArchitecture(), cluster.getcompatibility_version());
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
}
#method_after
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), cluster.getcompatibility_version());
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
}
#end_block

#method_before
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#method_after
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsAvailable(isVncSelected());
}
#method_after
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsAvailable(isVncSelected());
}
#end_block

#method_before
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getcompatibility_version();
        final boolean supported = AsyncDataProvider.isBootMenuSupported(version.toString());
        if (!supported) {
            getBootMenuEnabled().setEntity(false);
            getBootMenuEnabled().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootMenuNotSupported(version.toString(2)));
        }
        getBootMenuEnabled().setIsChangable(supported);
    }
}
#method_after
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getcompatibility_version();
        final boolean supported = AsyncDataProvider.getInstance().isBootMenuSupported(version.toString());
        if (!supported) {
            getBootMenuEnabled().setEntity(false);
            getBootMenuEnabled().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootMenuNotSupported(version.toString(2)));
        }
        getBootMenuEnabled().setIsChangable(supported);
    }
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.getInstance().isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.getInstance().isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#end_block

#method_before
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#method_after
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getInstance().getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.createAndTranslate(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<VmWatchdogType> watchDogModels = new ArrayList<VmWatchdogType>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(vmWatchdogType);
    }
    watchDogModels.add(0, null);
    VmWatchdogType oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel<BootSequence> entityModel = getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = entityModel.getEntity();
    List<EntityModel<BootSequence>> list = new ArrayList<EntityModel<BootSequence>>();
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() != firstDevice) {
            list.add(item);
        }
    }
    EntityModel<BootSequence> tempVar = new EntityModel<BootSequence>();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel<BootSequence> noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    getSecondBootDevice().setSelectedItem(noneOption);
}
#method_after
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel<BootSequence> entityModel = getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = entityModel.getEntity();
    EntityModel<BootSequence> prevItem = null;
    List<EntityModel<BootSequence>> list = new ArrayList<EntityModel<BootSequence>>();
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() != firstDevice) {
            list.add(item);
            if (getSecondBootDevice().getSelectedItem() != null && item.getEntity() == getSecondBootDevice().getSelectedItem().getEntity()) {
                prevItem = item;
            }
        }
    }
    EntityModel<BootSequence> tempVar = new EntityModel<BootSequence>();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel<BootSequence> noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    if (prevItem != null) {
        getSecondBootDevice().setSelectedItem(prevItem);
    } else {
        getSecondBootDevice().setSelectedItem(noneOption);
    }
}
#end_block

#method_before
private DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#method_after
public DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#end_block

#method_before
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    ValidationCompleteEvent.fire(getEventBus(), this);
    return hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isValidTab(TabName.POOL_TAB) ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid());
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
public boolean validateHwPart() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    return behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid();
}
#method_after
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean behaviorValid = behavior.validate();
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    boolean isValid = behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid() && getTotalCPUCores().getIsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
public ListModel<String> getWatchdogModel() {
    return watchdogModel;
}
#method_after
public ListModel<VmWatchdogType> getWatchdogModel() {
    return watchdogModel;
}
#end_block

#method_before
public void setWatchdogModel(ListModel<String> watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#method_after
public void setWatchdogModel(ListModel<VmWatchdogType> watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#end_block

#method_before
public ListModel<String> getWatchdogAction() {
    return watchdogAction;
}
#method_after
public ListModel<VmWatchdogAction> getWatchdogAction() {
    return watchdogAction;
}
#end_block

#method_before
public void setWatchdogAction(ListModel<String> watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#method_after
public void setWatchdogAction(ListModel<VmWatchdogAction> watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#end_block

#method_before
@Override
public void init(final HostModel model) {
    super.init(model);
    addTestButtonListener();
    addUpdateHostsListener(model);
    addPowerManagementListener(model);
    addHostProviderListener(model);
    addCiscoUcsPmTypeListener(model);
}
#method_after
@Override
public void init(final HostModel model) {
    super.init(model);
    addTestButtonListener();
    addUpdateHostsListener(model);
    addPowerManagementListener(model);
    addHostProviderListener(model);
    addCiscoUcsPmTypeListener(model);
    addRadioButtonsListeners(model);
}
#end_block

#method_before
private void addPowerManagementListener(final HostModel model) {
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if (!"IsPowerManagementTabSelected".equals(propName)) {
                // $NON-NLS-1$
                return;
            }
            if (model.getIsPowerManagementTabSelected()) {
                getView().showPowerManagement();
            }
        }
    });
}
#method_after
@SuppressWarnings("unchecked")
private void addPowerManagementListener(final HostModel model) {
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if (!"IsPowerManagementTabSelected".equals(propName)) {
                // $NON-NLS-1$
                return;
            }
            if (model.getIsPowerManagementTabSelected()) {
                getView().showPowerManagement();
            }
        }
    });
}
#end_block

#method_before
private void addCiscoUcsPmTypeListener(final HostModel model) {
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsCiscoUcsPrimaryPmTypeSelected".equals(propName)) {
                // $NON-NLS-1$
                getView().updatePrimaryPmSlotLabelText(model.isCiscoUcsPrimaryPmTypeSelected());
            } else if ("IsCiscoUcsSecondaryPmTypeSelected".equals(propName)) {
                // $NON-NLS-1$
                getView().updateSecondaryPmSlotLabelText(model.isCiscoUcsSecondaryPmTypeSelected());
            }
        }
    });
}
#method_after
@SuppressWarnings("unchecked")
private void addCiscoUcsPmTypeListener(final HostModel model) {
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsCiscoUcsPrimaryPmTypeSelected".equals(propName)) {
                // $NON-NLS-1$
                getView().updatePrimaryPmSlotLabelText(model.isCiscoUcsPrimaryPmTypeSelected());
            } else if ("IsCiscoUcsSecondaryPmTypeSelected".equals(propName)) {
                // $NON-NLS-1$
                getView().updateSecondaryPmSlotLabelText(model.isCiscoUcsSecondaryPmTypeSelected());
            }
        }
    });
}
#end_block

#method_before
private void addHostProviderListener(final HostModel model) {
    model.getProviderSearchFilter().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().setHostProviderVisibility(model.getProviderSearchFilter().getIsAvailable());
            }
        }
    });
}
#method_after
@SuppressWarnings("unchecked")
private void addHostProviderListener(final HostModel model) {
    model.getProviderSearchFilter().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().setHostProviderVisibility(model.getProviderSearchFilter().getIsAvailable());
            }
        }
    });
}
#end_block

#method_before
public void init(final T model) {
    this.model = model;
    // Set up model command invoker
    this.modelCommandInvoker = new DeferredModelCommandInvoker(model) {

        @Override
        protected void commandFailed(UICommand command) {
            // Clear Window and ConfirmWindow models when "Cancel" command execution fails
            if (command.getIsCancel() && command.getTarget() instanceof Model) {
                Model source = (Model) command.getTarget();
                source.setWindow(null);
                source.setConfirmWindow(null);
            }
        }

        @Override
        protected void commandFinished(UICommand command) {
            // Enforce popup close after executing "Cancel" command
            if (command.getIsCancel()) {
                hideAndUnbind();
            }
        }
    };
    // Set common popup properties
    updateTitle(model);
    updateMessage(model);
    updateItems(model);
    updateHashName(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Title".equals(propName)) {
                // $NON-NLS-1$
                updateTitle(model);
            } else if ("Message".equals(propName)) {
                // $NON-NLS-1$
                updateMessage(model);
            } else if ("Items".equals(propName)) {
                // $NON-NLS-1$
                updateItems(model);
            } else if ("HashName".equals(propName)) {
                // $NON-NLS-1$
                updateHashName(model);
            } else if ("OpenDocumentation".equals(propName)) {
                // $NON-NLS-1$
                openDocumentation(model);
            }
        }
    });
    // Add popup footer buttons
    addFooterButtons(model);
    if (model.getCommands() instanceof ObservableCollection) {
        ObservableCollection<UICommand> commands = (ObservableCollection<UICommand>) model.getCommands();
        commands.getCollectionChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                getView().removeButtons();
                addFooterButtons(model);
                getView().updateTabIndexes();
            }
        });
    }
    // Register dialog model property change listener
    popupHandler.addDialogModelListener(model);
    // Initialize popup contents from the model
    getView().edit(model);
    getView().updateTabIndexes();
    model.setEventBus((EventBus) getEventBus());
}
#method_after
public void init(final T model) {
    this.model = model;
    // Set up model command invoker
    this.modelCommandInvoker = new DeferredModelCommandInvoker(model) {

        @Override
        protected void commandFailed(UICommand command) {
            // Clear Window and ConfirmWindow models when "Cancel" command execution fails
            if (command.getIsCancel() && command.getTarget() instanceof Model) {
                Model source = (Model) command.getTarget();
                source.setWindow(null);
                source.setConfirmWindow(null);
            }
        }

        @Override
        protected void commandFinished(UICommand command) {
            // Enforce popup close after executing "Cancel" command
            if (command.getIsCancel()) {
                hideAndUnbind();
            }
        }
    };
    // Set common popup properties
    updateTitle(model);
    updateMessage(model);
    updateItems(model);
    updateHashName(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Title".equals(propName)) {
                // $NON-NLS-1$
                updateTitle(model);
            } else if ("Message".equals(propName)) {
                // $NON-NLS-1$
                updateMessage(model);
            } else if ("Items".equals(propName)) {
                // $NON-NLS-1$
                updateItems(model);
            } else if ("HashName".equals(propName)) {
                // $NON-NLS-1$
                updateHashName(model);
            } else if ("OpenDocumentation".equals(propName)) {
                // $NON-NLS-1$
                openDocumentation(model);
            }
        }
    });
    // Add popup footer buttons
    addFooterButtons(model);
    if (model.getCommands() instanceof ObservableCollection) {
        ObservableCollection<UICommand> commands = (ObservableCollection<UICommand>) model.getCommands();
        commands.getCollectionChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                getView().removeButtons();
                addFooterButtons(model);
                getView().updateTabIndexes();
            }
        });
    }
    // Register dialog model property change listener
    popupHandler.addDialogModelListener(model);
    // Initialize popup contents from the model
    getView().edit(model);
    getView().updateTabIndexes();
    if (!model.hasEventBusSet()) {
        model.setEventBus((EventBus) getEventBus());
    }
}
#end_block

#method_before
protected void openDocumentation(T model) {
    String helpTag = model.getHelpTag().name;
    String documentationPath = DocumentationPathTranslator.getPath(helpTag);
    String documentationLibURL = model.getConfigurator().getDocumentationLibURL();
    // $NON-NLS-1$
    WebUtils.openUrlInNewWindow("_blank", documentationLibURL + documentationPath);
}
#method_after
protected void openDocumentation(T model) {
    String helpTag = model.getHelpTag().name;
    String documentationPath = DocumentationPathTranslator.getPath(helpTag);
    String documentationLibURL = model.getConfigurator().getDocumentationLibURL();
    // $NON-NLS-1$
    WebUtils.openUrlInNewWindow(// $NON-NLS-1$
    "_blank", // $NON-NLS-1$
    documentationLibURL + documentationPath, WebUtils.OPTION_SCROLLBARS);
}
#end_block

#method_before
public Event getEntityChangedEvent() {
    return privateEntityChangedEvent;
}
#method_after
public Event<EventArgs> getEntityChangedEvent() {
    return privateEntityChangedEvent;
}
#end_block

#method_before
private void setEntityChangedEvent(Event value) {
    privateEntityChangedEvent = value;
}
#method_after
private void setEntityChangedEvent(Event<EventArgs> value) {
    privateEntityChangedEvent = value;
}
#end_block

#method_before
@Override
public Map<TabName, DialogTab> getTabNameMapping() {
    return tabMap;
}
#method_after
@Override
public final Map<TabName, DialogTab> getTabNameMapping() {
    return tabMap;
}
#end_block

#method_before
public boolean validate() {
    RegexValidation validation = new RegexValidation();
    // $NON-NLS-1$
    validation.setExpression("^[A-Za-z0-9_-]+$");
    validation.setMessage(ConstantsManager.getInstance().getConstants().asciiNameValidationMsg());
    getFormattedStorageName().validateEntity(new IValidation[] { validation });
    if (getFormattedStorageName().getEntity() != null && Linq.firstOrDefault(context.storageList, new Linq.StorageNamePredicate(getFormattedStorageName().getEntity())) != null) {
        getFormattedStorageName().setIsValid(false);
        getFormattedStorageName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
    }
    boolean isStorageValid = getStorage().validate() && getFormattedStorageName().getIsValid();
    boolean isDataCenterValid = true;
    if (getCandidateDataCenter() == null) {
        isDataCenterValid = getDataCenter().validate();
    }
    boolean isClusterValid = true;
    if (getCandidateCluster() == null) {
        isClusterValid = getCluster().validate(false, true, false);
    }
    setIsGeneralTabValid(isStorageValid && isDataCenterValid && isClusterValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isStorageValid && isDataCenterValid && isClusterValid;
}
#method_after
public boolean validate() {
    RegexValidation validation = new RegexValidation();
    // $NON-NLS-1$
    validation.setExpression("^[A-Za-z0-9_-]+$");
    validation.setMessage(ConstantsManager.getInstance().getConstants().asciiNameValidationMsg());
    getFormattedStorageName().validateEntity(new IValidation[] { validation });
    if (getFormattedStorageName().getEntity() != null && Linq.firstOrDefault(context.storageList, new Linq.StorageNamePredicate(getFormattedStorageName().getEntity())) != null) {
        getFormattedStorageName().setIsValid(false);
        getFormattedStorageName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
    }
    boolean isStorageValid = getStorage().validate() && getFormattedStorageName().getIsValid();
    boolean isDataCenterValid = true;
    if (getCandidateDataCenter() == null) {
        isDataCenterValid = getDataCenter().validate();
    }
    boolean isClusterValid = true;
    if (getCandidateCluster() == null) {
        isClusterValid = getCluster().validate(false, true, false);
    }
    setValidTab(TabName.GENERAL_TAB, isStorageValid && isDataCenterValid && isClusterValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isStorageValid && isDataCenterValid && isClusterValid;
}
#end_block

#method_before
private void setDefaultNames7() {
    // Get all clusters.
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            context.storageList = (ArrayList<StorageDomain>) returnValue;
            setDefaultNames8();
        }
    }, frontendHash));
}
#method_after
private void setDefaultNames7() {
    // Get all clusters.
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            context.storageList = (ArrayList<StorageDomain>) returnValue;
            setDefaultNames8();
        }
    }, frontendHash));
}
#end_block

#method_before
public void setDefaultNames6() {
    // Fill map of local storage host by data center.
    context.clusterListByDataCenterMap = new HashMap<StoragePool, ArrayList<VDSGroup>>();
    AsyncIterator<StoragePool> iterator = new AsyncIterator<StoragePool>(context.dataCenterList);
    iterator.setComplete(new AsyncIteratorComplete<StoragePool>() {

        @Override
        public void run(StoragePool item, Object value) {
            setDefaultNames7();
        }
    });
    iterator.iterate(new AsyncIteratorFunc<StoragePool>() {

        @Override
        public void run(StoragePool item, AsyncIteratorCallback callback) {
            AsyncDataProvider.getClusterList(callback.getAsyncQuery(), item.getId());
        }
    }, new AsyncIteratorPredicate<StoragePool>() {

        @Override
        public boolean match(StoragePool item, Object value) {
            context.clusterListByDataCenterMap.put(item, (ArrayList<VDSGroup>) value);
            return false;
        }
    }, frontendHash);
}
#method_after
public void setDefaultNames6() {
    // Fill map of local storage host by data center.
    context.clusterListByDataCenterMap = new HashMap<StoragePool, ArrayList<VDSGroup>>();
    AsyncIterator<StoragePool> iterator = new AsyncIterator<StoragePool>(context.dataCenterList);
    iterator.setComplete(new AsyncIteratorComplete<StoragePool>() {

        @Override
        public void run(StoragePool item, Object value) {
            setDefaultNames7();
        }
    });
    iterator.iterate(new AsyncIteratorFunc<StoragePool>() {

        @Override
        public void run(StoragePool item, AsyncIteratorCallback callback) {
            AsyncDataProvider.getInstance().getClusterList(callback.getAsyncQuery(), item.getId());
        }
    }, new AsyncIteratorPredicate<StoragePool>() {

        @Override
        public boolean match(StoragePool item, Object value) {
            context.clusterListByDataCenterMap.put(item, (ArrayList<VDSGroup>) value);
            return false;
        }
    }, frontendHash);
}
#end_block

#method_before
public void setDefaultNames5() {
    // Fill map of local storage host by data center.
    context.localStorageHostByDataCenterMap = new HashMap<StoragePool, VDS>();
    AsyncIterator<StoragePool> iterator = new AsyncIterator<StoragePool>(context.dataCenterList);
    iterator.setComplete(new AsyncIteratorComplete<StoragePool>() {

        @Override
        public void run(StoragePool item, Object value) {
            setDefaultNames6();
        }
    });
    iterator.iterate(new AsyncIteratorFunc<StoragePool>() {

        @Override
        public void run(StoragePool item, AsyncIteratorCallback callback) {
            AsyncDataProvider.getLocalStorageHost(callback.getAsyncQuery(), item.getName());
        }
    }, new AsyncIteratorPredicate<StoragePool>() {

        @Override
        public boolean match(StoragePool item, Object value) {
            context.localStorageHostByDataCenterMap.put(item, (VDS) value);
            return false;
        }
    }, frontendHash);
}
#method_after
public void setDefaultNames5() {
    // Fill map of local storage host by data center.
    context.localStorageHostByDataCenterMap = new HashMap<StoragePool, VDS>();
    AsyncIterator<StoragePool> iterator = new AsyncIterator<StoragePool>(context.dataCenterList);
    iterator.setComplete(new AsyncIteratorComplete<StoragePool>() {

        @Override
        public void run(StoragePool item, Object value) {
            setDefaultNames6();
        }
    });
    iterator.iterate(new AsyncIteratorFunc<StoragePool>() {

        @Override
        public void run(StoragePool item, AsyncIteratorCallback callback) {
            AsyncDataProvider.getInstance().getLocalStorageHost(callback.getAsyncQuery(), item.getName());
        }
    }, new AsyncIteratorPredicate<StoragePool>() {

        @Override
        public boolean match(StoragePool item, Object value) {
            context.localStorageHostByDataCenterMap.put(item, (VDS) value);
            return false;
        }
    }, frontendHash);
}
#end_block

#method_before
public void setDefaultNames4() {
    // Get data centers containing 'local' in name.
    AsyncDataProvider.getDataCenterListByName(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            context.dataCenterList = (ArrayList<StoragePool>) returnValue;
            setDefaultNames5();
        }
    }, frontendHash), // $NON-NLS-1$
    getCommonName() + "*");
}
#method_after
public void setDefaultNames4() {
    // Get data centers containing 'local' in name.
    AsyncDataProvider.getInstance().getDataCenterListByName(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            context.dataCenterList = (ArrayList<StoragePool>) returnValue;
            setDefaultNames5();
        }
    }, frontendHash), // $NON-NLS-1$
    getCommonName() + "*");
}
#end_block

#method_before
public void setDefaultNames3() {
    // Get all clusters.
    AsyncDataProvider.getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            context.clusterList = (ArrayList<VDSGroup>) returnValue;
            setDefaultNames4();
        }
    }, frontendHash));
}
#method_after
public void setDefaultNames3() {
    // Get all clusters.
    AsyncDataProvider.getInstance().getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            context.clusterList = (ArrayList<VDSGroup>) returnValue;
            setDefaultNames4();
        }
    }, frontendHash));
}
#end_block

#method_before
public void setDefaultNames2() {
    VDS host = context.host;
    // Get cluster of the host.
    if (host.getVdsGroupId() != null) {
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                context.hostCluster = (VDSGroup) returnValue;
                setDefaultNames3();
            }
        }, frontendHash), host.getVdsGroupId());
    } else {
        setDefaultNames3();
    }
}
#method_after
public void setDefaultNames2() {
    VDS host = context.host;
    // Get cluster of the host.
    if (host.getVdsGroupId() != null) {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                context.hostCluster = (VDSGroup) returnValue;
                setDefaultNames3();
            }
        }, frontendHash), host.getVdsGroupId());
    } else {
        setDefaultNames3();
    }
}
#end_block

#method_before
public void setDefaultNames1() {
    VDS host = context.host;
    // Get data center of the host.
    if (host.getStoragePoolId() != null) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                context.hostDataCenter = (StoragePool) returnValue;
                setDefaultNames2();
            }
        }, frontendHash), host.getStoragePoolId());
    } else {
        setDefaultNames2();
    }
}
#method_after
public void setDefaultNames1() {
    VDS host = context.host;
    // Get data center of the host.
    if (host.getStoragePoolId() != null) {
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                context.hostDataCenter = (StoragePool) returnValue;
                setDefaultNames2();
            }
        }, frontendHash), host.getStoragePoolId());
    } else {
        setDefaultNames2();
    }
}
#end_block

#method_before
@Override
public void init(final ClusterModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("AllowClusterWithVirtGlusterEnabled".equals(propName)) {
                // $NON-NLS-1$
                getView().allowClusterWithVirtGlusterEnabled(model.getAllowClusterWithVirtGlusterEnabled());
            }
        }
    });
    String spiceProxyInConfig = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SpiceProxyDefault);
    String spiceProxyMessage = StringHelper.isNullOrEmpty(spiceProxyInConfig) ? messages.noSpiceProxyDefined() : spiceProxyInConfig;
    getView().setSpiceProxyOverrideExplanation(messages.consoleOverrideSpiceProxyMessage(messages.consoleOverrideDefinedInGlobalConfig(), spiceProxyMessage));
}
#method_after
@Override
public void init(final ClusterModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("AllowClusterWithVirtGlusterEnabled".equals(propName)) {
                // $NON-NLS-1$
                getView().allowClusterWithVirtGlusterEnabled(model.getAllowClusterWithVirtGlusterEnabled());
            }
        }
    });
    String spiceProxyInConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.SpiceProxyDefault);
    String spiceProxyMessage = StringHelper.isNullOrEmpty(spiceProxyInConfig) ? messages.noSpiceProxyDefined() : spiceProxyInConfig;
    getView().setSpiceProxyOverrideExplanation(messages.consoleOverrideSpiceProxyMessage(messages.consoleOverrideDefinedInGlobalConfig(), spiceProxyMessage));
}
#end_block

#method_before
protected void populateTabMap() {
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.GENERAL_TAB, generalTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.BOOT_OPTIONS_TAB, this.bootOptionsTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.HIGH_AVAILABILITY_TAB, this.highAvailabilityTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.HOST_TAB, this.hostTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.INITIAL_RUN_TAB, this.initialRunTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.POOL_TAB, this.poolTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.RESOURCE_ALLOCATION_TAB, this.resourceAllocationTab);
    getTabNameMapping().put(UnitVmModel.UnitVmTabNames.SYSTEM_TAB, this.systemTab);
}
#method_after
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, generalTab);
    getTabNameMapping().put(TabName.BOOT_OPTIONS_TAB, this.bootOptionsTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab);
    getTabNameMapping().put(TabName.HIGH_AVAILABILITY_TAB, this.highAvailabilityTab);
    getTabNameMapping().put(TabName.HOST_TAB, this.hostTab);
    getTabNameMapping().put(TabName.INITIAL_RUN_TAB, this.initialRunTab);
    getTabNameMapping().put(TabName.POOL_TAB, this.poolTab);
    getTabNameMapping().put(TabName.RESOURCE_ALLOCATION_TAB, this.resourceAllocationTab);
    getTabNameMapping().put(TabName.SYSTEM_TAB, this.systemTab);
}
#end_block

#method_before
private void initDetachableFields() {
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isSmartcardEnabledEditorWithDetachable = new EntityModelDetachableWidget(isSmartcardEnabledEditor, Align.RIGHT);
    isSoundcardEnabledEditorWithDetachable = new EntityModelDetachableWidget(isSoundcardEnabledEditor, Align.RIGHT);
    isConsoleDeviceEnabledEditorWithDetachable = new EntityModelDetachableWidget(isConsoleDeviceEnabledEditor, Align.RIGHT);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    isVirtioScsiEnabledWithDetachable = new EntityModelDetachableWidget(isVirtioScsiEnabled, Align.RIGHT);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.RIGHT);
}
#method_after
private void initDetachableFields() {
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isSmartcardEnabledEditorWithDetachable = new EntityModelDetachableWidget(isSmartcardEnabledEditor, Align.RIGHT);
    isSoundcardEnabledEditorWithDetachable = new EntityModelDetachableWidget(isSoundcardEnabledEditor, Align.RIGHT);
    isConsoleDeviceEnabledEditorWithDetachable = new EntityModelDetachableWidget(isConsoleDeviceEnabledEditor, Align.RIGHT);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    isVirtioScsiEnabledWithDetachable = new EntityModelDetachableWidget(isVirtioScsiEnabled, Align.RIGHT);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.RIGHT);
    StringEntityModelLabel rnglabel = new StringEntityModelLabel();
    rnglabel.setText(constants.rngDevEnabled());
    isRngEnabledCheckboxWithInfoIcon = new EntityModelDetachableWidgetWithInfo<String>(rnglabel, isRngEnabledEditor);
    isRngEnabledCheckboxWithInfoIcon.setExplanation(SafeHtmlUtils.fromTrustedString(constants.rngDevExplanation()));
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor(new NullSafeRenderer<CpuProfile>() {

        @Override
        protected String renderNullSafe(CpuProfile object) {
            return object.getName();
        }
    });
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
}
#end_block

#method_before
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    VDSGroup vdsGroup = object.getSelectedCluster();
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroup != null && vdsGroup.getcompatibility_version() != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroup.getcompatibility_version().getValue()));
}
#method_after
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    Version vdsGroupVersion = clusterVersionOrNull(object);
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroupVersion != null && !(Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroupVersion.getValue()));
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    rngSourceRandom.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceRandom().setEntity(true);
            vm.getRngSourceHwrng().setEntity(false);
        }
    });
    rngSourceHwrng.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceHwrng().setEntity(true);
            vm.getRngSourceRandom().setEntity(false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#end_block

#method_before
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.createAndTranslate(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#method_after
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.getInstance().get(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceFileTransferEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceCopyPasteEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#end_block

#method_before
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, highAvailabilityTab, poolTab, systemTab);
}
#method_after
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, rngDeviceTab, highAvailabilityTab, poolTab, systemTab);
}
#end_block

#method_before
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isSmartcardEnabledEditorWithDetachable, isConsoleDeviceEnabledEditorWithDetachable, isSoundcardEnabledEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, isVirtioScsiEnabledWithDetachable, detachableMemSizeEditor, overrideMigrationDowntimeEditorWithDetachable, watchdogLabel);
}
#method_after
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isSmartcardEnabledEditorWithDetachable, isConsoleDeviceEnabledEditorWithDetachable, isSoundcardEnabledEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, isVirtioScsiEnabledWithDetachable, detachableMemSizeEditor, overrideMigrationDowntimeEditorWithDetachable, watchdogLabel, isRngEnabledCheckboxWithInfoIcon);
}
#end_block

#method_before
protected void disableAllTabs() {
    generalTab.disableContent();
    poolTab.disableContent();
    initialRunTab.disableContent();
    consoleTab.disableContent();
    hostTab.disableContent();
    highAvailabilityTab.disableContent();
    resourceAllocationTab.disableContent();
    bootOptionsTab.disableContent();
    customPropertiesTab.disableContent();
    systemTab.disableContent();
    oSTypeEditor.setEnabled(false);
    quotaEditor.setEnabled(false);
    dataCenterWithClusterEditor.setEnabled(false);
    templateEditor.setEnabled(false);
    baseTemplateEditor.setEnabled(false);
    vmTypeEditor.setEnabled(false);
    instanceTypesEditor.setEnabled(false);
}
#method_after
protected void disableAllTabs() {
    for (DialogTab dialogTab : allDialogTabs()) {
        dialogTab.disableContent();
    }
    oSTypeEditor.setEnabled(false);
    quotaEditor.setEnabled(false);
    dataCenterWithClusterEditor.setEnabled(false);
    templateEditor.setEnabled(false);
    baseTemplateEditor.setEnabled(false);
    vmTypeEditor.setEnabled(false);
    instanceTypesEditor.setEnabled(false);
}
#end_block

#method_before
@Override
protected void populateTabMap() {
    getTabNameMapping().put(ClusterModel.ClusterTabNames.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(ClusterModel.ClusterTabNames.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(ClusterModel.ClusterTabNames.CLUSTER_POLICY_TAB, this.clusterPolicyTab);
    getTabNameMapping().put(ClusterModel.ClusterTabNames.OPTIMIZATION_TAB, this.optimizationTab);
    getTabNameMapping().put(ClusterModel.ClusterTabNames.RESILIENCE_POLICY_TAB, this.resiliencePolicyTab);
}
#method_after
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CLUSTER_POLICY_TAB, this.clusterPolicyTab);
    getTabNameMapping().put(TabName.OPTIMIZATION_TAB, this.optimizationTab);
    getTabNameMapping().put(TabName.RESILIENCE_POLICY_TAB, this.resiliencePolicyTab);
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    fencingEnabledCheckBox.setLabel(constants.fencingEnabled());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
    skipFencingIfConnectivityBrokenCheckBox.setLabel(constants.skipFencingWhenConnectivityBroken());
    hostsWithBrokenConnectivityThresholdEditor.setLabel(constants.hostsWithBrokenConnectivityThresholdLabel());
}
#end_block

#method_before
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool object) {
            return object.getName();
        }
    });
    cpuEditor = new ListModelListBoxEditor<ServerCpu>(new NullSafeRenderer<ServerCpu>() {

        @Override
        public String renderNullSafe(ServerCpu object) {
            return object.getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Version>(new NullSafeRenderer<Version>() {

        @Override
        public String renderNullSafe(Version object) {
            return object.toString();
        }
    });
    architectureEditor = new ListModelListBoxEditor<ArchitectureType>(new NullSafeRenderer<ArchitectureType>() {

        @Override
        public String renderNullSafe(ArchitectureType object) {
            return object.toString();
        }
    });
    clusterPolicyEditor = new ListModelListBoxEditor<ClusterPolicy>(new NullSafeRenderer<ClusterPolicy>() {

        @Override
        public String renderNullSafe(ClusterPolicy object) {
            return object.getName();
        }
    });
}
#method_after
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool object) {
            return object.getName();
        }
    });
    cpuEditor = new ListModelListBoxEditor<ServerCpu>(new NullSafeRenderer<ServerCpu>() {

        @Override
        public String renderNullSafe(ServerCpu object) {
            return object.getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Version>(new NullSafeRenderer<Version>() {

        @Override
        public String renderNullSafe(Version object) {
            return object.toString();
        }
    });
    architectureEditor = new ListModelListBoxEditor<ArchitectureType>(new NullSafeRenderer<ArchitectureType>() {

        @Override
        public String renderNullSafe(ArchitectureType object) {
            return object.toString();
        }
    });
    clusterPolicyEditor = new ListModelListBoxEditor<ClusterPolicy>(new NullSafeRenderer<ClusterPolicy>() {

        @Override
        public String renderNullSafe(ClusterPolicy object) {
            return object.getName();
        }
    });
    hostsWithBrokenConnectivityThresholdEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    });
    // $NON-NLS-1$
    hostsWithBrokenConnectivityThresholdEditor.getContentWidgetContainer().setWidth("75px");
}
#end_block

#method_before
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
}
#method_after
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    fencingEnabledCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    fencingEnabledCheckBox.getContentWidgetContainer().setWidth("150px");
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfSDActiveCheckBox.getContentWidgetContainer().setWidth("300px");
    skipFencingIfConnectivityBrokenCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfConnectivityBrokenCheckBox.getContentWidgetContainer().setWidth("305px");
}
#end_block

#method_before
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    // $NON-NLS-1$
    label.setWidth("250px");
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabled);
}
#method_after
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    // $NON-NLS-1$
    label.setWidth("250px");
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabled);
    fencingEnabledInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.fencingEnabledInfo()), resources);
    skipFencingIfSDActiveInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.skipFencingIfSDActiveInfo()), resources);
    skipFencingIfConnectivityBrokenInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.skipFencingWhenConnectivityBrokenInfo()), resources);
}
#end_block

#method_before
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#method_after
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        consoleTab.setVisible(false);
        fencingPolicyTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank);
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.getInstance().isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
}
#end_block

#method_before
private void optimizationForServerFormatter(ClusterModel object) {
    if (object.getOptimizationForServer() != null && object.getOptimizationForServer().getEntity() != null) {
        optimizationForServerEditor.asRadioButton().setHTML(templates.radioButtonLabel(messages.clusterPopupMemoryOptimizationForServerLabel(object.getOptimizationForServer().getEntity().toString())));
    }
}
#method_after
private void optimizationForServerFormatter(ClusterModel object) {
    if (object.getOptimizationForServer() != null && object.getOptimizationForServer().getEntity() != null) {
        optimizationForServerEditor.setLabel(messages.clusterPopupMemoryOptimizationForServerLabel(object.getOptimizationForServer().getEntity().toString()));
    }
}
#end_block

#method_before
private void optimizationForDesktopFormatter(ClusterModel object) {
    if (object.getOptimizationForDesktop() != null && object.getOptimizationForDesktop().getEntity() != null) {
        optimizationForDesktopEditor.asRadioButton().setHTML(templates.radioButtonLabel(messages.clusterPopupMemoryOptimizationForDesktopLabel(object.getOptimizationForDesktop().getEntity().toString())));
    }
}
#method_after
private void optimizationForDesktopFormatter(ClusterModel object) {
    if (object.getOptimizationForDesktop() != null && object.getOptimizationForDesktop().getEntity() != null) {
        optimizationForDesktopEditor.setLabel(messages.clusterPopupMemoryOptimizationForDesktopLabel(object.getOptimizationForDesktop().getEntity().toString()));
    }
}
#end_block

#method_before
private void optimizationCustomFormatter(ClusterModel object) {
    if (object.getOptimizationCustom() != null && object.getOptimizationCustom().getEntity() != null) {
        // Use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.asRadioButton().setHTML(templates.radioButtonLabel(messages.clusterPopupMemoryOptimizationCustomLabel(String.valueOf(object.getMemoryOverCommit()))));
    }
}
#method_after
private void optimizationCustomFormatter(ClusterModel object) {
    if (object.getOptimizationCustom() != null && object.getOptimizationCustom().getEntity() != null) {
        // Use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(messages.clusterPopupMemoryOptimizationCustomLabel(String.valueOf(object.getMemoryOverCommit())));
    }
}
#end_block

