192
#method_before
public static String operatorReplace(String response) {
    if (response == null) {
        // this shouldn't passed, check your ril class
        return response;
    }
    // along with sanity checking
    if (storedOperators != null && stored != null && stored.equals(response)) {
        return storedOperators;
    }
    stored = response;
    try {
        // this will find out if it a number then it will catch it based
        // on invalid chars.
        Integer.parseInt(response);
    } catch (NumberFormatException E) {
        // not a number, pass it along to stored operator until the next
        // round.
        storedOperators = response;
        return storedOperators;
    }
    // this code will be taking care of when garbage collection start
    Operators init = new Operators();
    Map<String, String> operators = init.initList();
    storedOperators = operators.containsKey(response) ? operators.get(response) : response;
    return storedOperators;
}
#method_after
public static String operatorReplace(String response) {
    // if it is null, check your ril class.
    if (response == null || (5 != response.length() && response.length() != 6)) {
        return response;
    }
    // along with sanity checking
    if (storedOperators != null && stored != null && stored.equals(response)) {
        return storedOperators;
    }
    stored = response;
    try {
        // this will find out if it a number then it will catch it based
        // on invalid chars.
        Integer.parseInt(response);
    } catch (NumberFormatException E) {
        // not a number, pass it along to stored operator until the next
        // round.
        storedOperators = response;
        return storedOperators;
    }
    // this code will be taking care of when garbage collection start
    Operators init = new Operators();
    Map<String, String> operators = init.initList();
    storedOperators = operators.containsKey(response) ? operators.get(response) : response;
    return storedOperators;
}
#end_block

#method_before
private Object operatorCheck(Parcel p) {
    String[] response = (String[]) responseStrings(p);
    for (int i = 0; i < 3; i++) {
        if (response[i] != null) {
            if (i < 2) {
                if (response[i].equals("       Empty") || (response[i].equals("") && !isGSM)) {
                    response[i] = operator;
                } else {
                    response[i] = Operators.operatorReplace(response[i]);
                }
            } else if (response[i].equals("31000") || response[i].equals("11111") || response[i].equals("123456") || response[i].equals("31099") || ((response[i].length() < 5 || response[i].length() > 6) && !isGSM)) {
                response[i] = homeOperator;
            }
        }
    }
    return response;
}
#method_after
private Object operatorCheck(Parcel p) {
    String[] response = (String[]) responseStrings(p);
    for (int i = 0; i < 2; i++) {
        if (response[i] != null) {
            response[i] = Operators.operatorReplace(response[i]);
        }
    }
    return response;
}
#end_block

#method_before
private ArrayList<ApnSetting> buildWaitingApns(String requestedApnType, int radioTech) {
    if (DBG)
        log("buildWaitingApns: E requestedApnType=" + requestedApnType);
    ArrayList<ApnSetting> apnList = new ArrayList<ApnSetting>();
    if (requestedApnType.equals(PhoneConstants.APN_TYPE_DUN)) {
        ApnSetting dun = fetchDunApn();
        if (dun != null) {
            apnList.add(dun);
            if (DBG)
                log("buildWaitingApns: X added APN_TYPE_DUN apnList=" + apnList);
            return apnList;
        }
    }
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    // This is a workaround for a bug (7305641) where we don't failover to other
    // suitable APNs if our preferred APN fails.  On prepaid ATT sims we need to
    // failover to a provisioning APN, but once we've used their default data
    // connection we are locked to it for life.  This change allows ATT devices
    // to say they don't want to use preferred at all.
    boolean usePreferred = true;
    try {
        usePreferred = !mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_dontPreferApn);
    } catch (Resources.NotFoundException e) {
        if (DBG)
            log("buildWaitingApns: usePreferred NotFoundException set to true");
        usePreferred = true;
    }
    if (DBG) {
        log("buildWaitingApns: usePreferred=" + usePreferred + " canSetPreferApn=" + mCanSetPreferApn + " mPreferredApn=" + mPreferredApn + " operator=" + operator + " radioTech=" + radioTech + " IccRecords r=" + r);
    }
    if (usePreferred && mCanSetPreferApn && mPreferredApn != null && mPreferredApn.canHandleType(requestedApnType)) {
        if (DBG) {
            log("buildWaitingApns: Preferred APN:" + operator + ":" + mPreferredApn.numeric + ":" + mPreferredApn);
        }
        if (mPreferredApn.numeric.equals(operator)) {
            if (mPreferredApn.bearer == 0 || mPreferredApn.bearer == radioTech) {
                apnList.add(mPreferredApn);
                if (DBG)
                    log("buildWaitingApns: X added preferred apnList=" + apnList);
                return apnList;
            } else {
                if (DBG)
                    log("buildWaitingApns: no preferred APN");
                setPreferredApn(-1);
                mPreferredApn = null;
            }
        } else {
            if (DBG)
                log("buildWaitingApns: no preferred APN");
            setPreferredApn(-1);
            mPreferredApn = null;
        }
    }
    if (mAllApnSettings != null) {
        if (DBG)
            log("buildWaitingApns: mAllApnSettings=" + mAllApnSettings);
        for (ApnSetting apn : mAllApnSettings) {
            if (DBG)
                log("buildWaitingApns: apn=" + apn);
            if (apn.canHandleType(requestedApnType)) {
                if (apn.bearer == 0 || apn.bearer == radioTech) {
                    if (DBG)
                        log("buildWaitingApns: adding apn=" + apn.toString());
                    apnList.add(apn);
                } else {
                    if (DBG) {
                        log("buildWaitingApns: bearer:" + apn.bearer + " != " + "radioTech:" + radioTech);
                    }
                }
            } else {
                if (DBG) {
                    log("buildWaitingApns: couldn't handle requesedApnType=" + requestedApnType);
                }
            }
        }
    } else {
        loge("mAllApnSettings is empty!");
    }
    if (DBG)
        log("buildWaitingApns: X apnList=" + apnList);
    return apnList;
}
#method_after
private ArrayList<ApnSetting> buildWaitingApns(String requestedApnType, int radioTech) {
    if (DBG)
        log("buildWaitingApns: E requestedApnType=" + requestedApnType);
    ArrayList<ApnSetting> apnList = new ArrayList<ApnSetting>();
    if (requestedApnType.equals(PhoneConstants.APN_TYPE_DUN)) {
        ApnSetting dun = fetchDunApn();
        if (dun != null) {
            apnList.add(dun);
            if (DBG)
                log("buildWaitingApns: X added APN_TYPE_DUN apnList=" + apnList);
            return apnList;
        }
    }
    IccRecords r = mIccRecords.get();
    String homeOperator = "";
    if (isNvSubscription()) {
        homeOperator = SystemProperties.get("ro.cdma.home.operator.numeric");
    }
    String operator = (r != null) ? r.getOperatorNumeric() : homeOperator;
    // This is a workaround for a bug (7305641) where we don't failover to other
    // suitable APNs if our preferred APN fails.  On prepaid ATT sims we need to
    // failover to a provisioning APN, but once we've used their default data
    // connection we are locked to it for life.  This change allows ATT devices
    // to say they don't want to use preferred at all.
    boolean usePreferred = true;
    try {
        usePreferred = !mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_dontPreferApn);
    } catch (Resources.NotFoundException e) {
        if (DBG)
            log("buildWaitingApns: usePreferred NotFoundException set to true");
        usePreferred = true;
    }
    if (DBG) {
        log("buildWaitingApns: usePreferred=" + usePreferred + " canSetPreferApn=" + mCanSetPreferApn + " mPreferredApn=" + mPreferredApn + " operator=" + operator + " radioTech=" + radioTech + " IccRecords r=" + r);
    }
    if (usePreferred && mCanSetPreferApn && mPreferredApn != null && mPreferredApn.canHandleType(requestedApnType)) {
        if (DBG) {
            log("buildWaitingApns: Preferred APN:" + operator + ":" + mPreferredApn.numeric + ":" + mPreferredApn);
        }
        if (mPreferredApn.numeric.equals(operator)) {
            if (mPreferredApn.bearer == 0 || mPreferredApn.bearer == radioTech) {
                apnList.add(mPreferredApn);
                if (DBG)
                    log("buildWaitingApns: X added preferred apnList=" + apnList);
                return apnList;
            } else {
                if (DBG)
                    log("buildWaitingApns: no preferred APN");
                setPreferredApn(-1);
                mPreferredApn = null;
            }
        } else {
            if (DBG)
                log("buildWaitingApns: no preferred APN");
            setPreferredApn(-1);
            mPreferredApn = null;
        }
    }
    if (mAllApnSettings != null) {
        if (DBG)
            log("buildWaitingApns: mAllApnSettings=" + mAllApnSettings);
        for (ApnSetting apn : mAllApnSettings) {
            if (DBG)
                log("buildWaitingApns: apn=" + apn);
            if (apn.canHandleType(requestedApnType)) {
                if (apn.bearer == 0 || apn.bearer == radioTech) {
                    if (DBG)
                        log("buildWaitingApns: adding apn=" + apn.toString());
                    apnList.add(apn);
                } else {
                    if (DBG) {
                        log("buildWaitingApns: bearer:" + apn.bearer + " != " + "radioTech:" + radioTech);
                    }
                }
            } else {
                if (DBG) {
                    log("buildWaitingApns: couldn't handle requesedApnType=" + requestedApnType);
                }
            }
        }
    } else {
        loge("mAllApnSettings is empty!");
    }
    if (DBG)
        log("buildWaitingApns: X apnList=" + apnList);
    return apnList;
}
#end_block

#method_before
@Override
public void onRecordLoaded(AsyncResult ar) {
    byte[] data = (byte[]) ar.result;
    if (data == null || data.length < 10) {
        log("Invalid IMSI from EF_CSIM_IMSIM " + IccUtils.bytesToHexString(data));
        mImsi = null;
        mMin = null;
        return;
    }
    if (DBG)
        log("CSIM_IMSIM=" + IccUtils.bytesToHexString(data));
    // C.S0065 section 5.2.2 for IMSI_M encoding
    // C.S0005 section 2.3.1 for MIN encoding in IMSI_M.
    boolean provisioned = ((data[7] & 0x80) == 0x80);
    if (provisioned) {
        mImsi = decodeImsi(data);
        if (null != mImsi) {
            mMin = mImsi.substring(5, 15);
        }
        log("IMSI: " + mImsi.substring(0, 5) + "xxxxxxxxx");
    } else {
        if (DBG)
            log("IMSI not provisioned in card");
    }
    // Update MccTable with the retrieved IMSI
    String operatorNumeric = getOperatorNumeric();
    if (operatorNumeric != null) {
        if (operatorNumeric.length() <= 6) {
            MccTable.updateMccMncConfiguration(mContext, operatorNumeric);
        }
    }
    mImsiReadyRegistrants.notifyRegistrants();
}
#method_after
@Override
public void onRecordLoaded(AsyncResult ar) {
    byte[] data = (byte[]) ar.result;
    if (data == null || data.length < 10) {
        log("Invalid IMSI from EF_CSIM_IMSIM " + IccUtils.bytesToHexString(data));
        mImsi = null;
        mMin = null;
        return;
    }
    if (DBG)
        log("CSIM_IMSIM=" + IccUtils.bytesToHexString(data));
    // C.S0065 section 5.2.2 for IMSI_M encoding
    // C.S0005 section 2.3.1 for MIN encoding in IMSI_M.
    boolean provisioned = ((data[7] & 0x80) == 0x80);
    if (provisioned) {
        mImsi = decodeImsi(data);
        if (null != mImsi) {
            mMin = mImsi.substring(5, 15);
        }
        log("IMSI: " + mImsi.substring(0, 5) + "xxxxxxxxx");
    } else {
        if (DBG)
            log("IMSI not provisioned in card");
    }
    // Update MccTable with the retrieved IMSI
    String operatorNumeric = getOperatorNumeric();
    if (operatorNumeric != null) {
        if (operatorNumeric.length() <= 6) {
            mMSIMRecordeEnabled = true;
            MccTable.updateMccMncConfiguration(mContext, operatorNumeric);
        }
    }
    mImsiReadyRegistrants.notifyRegistrants();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_GET_DEVICE_IDENTITY_DONE:
                log("Event EVENT_GET_DEVICE_IDENTITY_DONE Received");
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxxxx");
                String operatorNumeric = getOperatorNumeric();
                log("SHAREEFdebug: " + operatorNumeric);
                if (operatorNumeric != null) {
                    if (operatorNumeric.length() <= 6) {
                        log("SHAREEFdebugpass ");
                        MccTable.updateMccMncConfiguration(mContext, operatorNumeric);
                    }
                }
                break;
            case EVENT_GET_CDMA_SUBSCRIPTION_DONE:
                ar = (AsyncResult) msg.obj;
                String[] localTemp = (String[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mMyMobileNumber = localTemp[0];
                mMin2Min1 = localTemp[3];
                mPrlVersion = localTemp[4];
                log("MDN: " + mMyMobileNumber + " MIN: " + mMin2Min1);
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                log("iccid: " + mIccId);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    Rlog.i(LOG_TAG, "RuimRecords update failed", ar.exception);
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
            case EVENT_MARK_SMS_READ_DONE:
            case EVENT_SMS_ON_RUIM:
            case EVENT_GET_SMS_DONE:
                Rlog.w(LOG_TAG, "Event not supported: " + msg.what);
                break;
            // TODO: probably EF_CST should be read instead
            case EVENT_GET_SST_DONE:
                log("Event EVENT_GET_SST_DONE Received");
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing RUIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_GET_DEVICE_IDENTITY_DONE:
                log("Event EVENT_GET_DEVICE_IDENTITY_DONE Received");
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxxxx");
                String operatorNumeric = getOperatorNumeric();
                if (operatorNumeric != null) {
                    if (operatorNumeric.length() <= 6) {
                        MccTable.updateMccMncConfiguration(mContext, operatorNumeric);
                    }
                }
                break;
            case EVENT_GET_CDMA_SUBSCRIPTION_DONE:
                ar = (AsyncResult) msg.obj;
                String[] localTemp = (String[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mMyMobileNumber = localTemp[0];
                mMin2Min1 = localTemp[3];
                mPrlVersion = localTemp[4];
                log("MDN: " + mMyMobileNumber + " MIN: " + mMin2Min1);
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                log("iccid: " + mIccId);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    Rlog.i(LOG_TAG, "RuimRecords update failed", ar.exception);
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
            case EVENT_MARK_SMS_READ_DONE:
            case EVENT_SMS_ON_RUIM:
            case EVENT_GET_SMS_DONE:
                Rlog.w(LOG_TAG, "Event not supported: " + msg.what);
                break;
            // TODO: probably EF_CST should be read instead
            case EVENT_GET_SST_DONE:
                log("Event EVENT_GET_SST_DONE Received");
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing RUIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
private void fetchRuimRecords() {
    /* Don't read records if we don't expect
         * anyone to ask for them
         *
         * If records are not required by anyone OR
         * the app is not ready then bail
         */
    if (!mRecordsRequired || AppState.APPSTATE_READY != mParentApp.getState()) {
        if (DBG)
            log("fetchRuimRecords: Abort fetching records rRecordsRequested = " + mRecordsRequested + " state = " + mParentApp.getState() + " required = " + mRecordsRequired);
        return;
    }
    mRecordsRequested = true;
    if (DBG)
        log("fetchRuimRecords " + mRecordsToLoad);
    mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_PL, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfPlLoaded()));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSIM_LI, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimLiLoaded()));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSIM_SPN, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimSpnLoaded()));
    mRecordsToLoad++;
    mFh.loadEFLinearFixed(EF_CSIM_MDN, 1, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimMdnLoaded()));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSIM_IMSIM, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimImsimLoaded()));
    mRecordsToLoad++;
    mFh.loadEFLinearFixedAll(EF_CSIM_CDMAHOME, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimCdmaHomeLoaded()));
    mRecordsToLoad++;
    // Entire PRL could be huge. We are only interested in
    // the first 4 bytes of the record.
    mFh.loadEFTransparent(EF_CSIM_EPRL, 4, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimEprlLoaded()));
    mRecordsToLoad++;
    if (DBG)
        log("fetchRuimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
// Further records that can be inserted are Operator/OEM dependent
}
#method_after
private void fetchRuimRecords() {
    /* Don't read records if we don't expect
         * anyone to ask for them
         *
         * If records are not required by anyone OR
         * the app is not ready then bail
         */
    if (!mRecordsRequired || AppState.APPSTATE_READY != mParentApp.getState()) {
        if (DBG)
            log("fetchRuimRecords: Abort fetching records rRecordsRequested = " + mRecordsRequested + " state = " + mParentApp.getState() + " required = " + mRecordsRequired);
        return;
    }
    mRecordsRequested = true;
    if (DBG)
        log("fetchRuimRecords " + mRecordsToLoad);
    if (!mMSIMRecordeEnabled) {
        mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
        mRecordsToLoad++;
    }
    mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_PL, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfPlLoaded()));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSIM_LI, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimLiLoaded()));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSIM_SPN, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimSpnLoaded()));
    mRecordsToLoad++;
    mFh.loadEFLinearFixed(EF_CSIM_MDN, 1, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimMdnLoaded()));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSIM_IMSIM, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimImsimLoaded()));
    mRecordsToLoad++;
    mFh.loadEFLinearFixedAll(EF_CSIM_CDMAHOME, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimCdmaHomeLoaded()));
    mRecordsToLoad++;
    // Entire PRL could be huge. We are only interested in
    // the first 4 bytes of the record.
    mFh.loadEFTransparent(EF_CSIM_EPRL, 4, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimEprlLoaded()));
    mRecordsToLoad++;
    if (DBG)
        log("fetchRuimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
// Further records that can be inserted are Operator/OEM dependent
}
#end_block

#method_before
@Override
protected void sendMultipartText(String destAddr, String scAddr, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, int priority) {
    if (isCdmaMo()) {
        mCdmaDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, priority);
    } else {
        mGsmDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, priority);
    }
}
#method_after
@Override
protected void sendMultipartText(String destAddr, String scAddr, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, int priority, boolean isExpectMore, int validityPeriod) {
    if (isCdmaMo()) {
        mCdmaDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, priority, isExpectMore, validityPeriod);
    } else {
        mGsmDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, priority, isExpectMore, validityPeriod);
    }
}
#end_block

#method_before
@Override
protected void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority) {
    Rlog.d(TAG, "sendText");
    if (isCdmaMo()) {
        mCdmaDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, priority);
    } else {
        mGsmDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, priority);
    }
}
#method_after
@Override
protected void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority, boolean isExpectMore, int validityPeriod) {
    Rlog.d(TAG, "sendText");
    if (isCdmaMo()) {
        mCdmaDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, priority, isExpectMore, validityPeriod);
    } else {
        mGsmDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, priority, isExpectMore, validityPeriod);
    }
}
#end_block

#method_before
@Override
public void sendRetrySms(SmsTracker tracker) {
    String oldFormat = tracker.mFormat;
    // newFormat will be based on voice technology
    String newFormat = (PhoneConstants.PHONE_TYPE_CDMA == mPhone.getPhoneType()) ? mCdmaDispatcher.getFormat() : mGsmDispatcher.getFormat();
    // was previously sent sms format match with voice tech?
    if (oldFormat.equals(newFormat)) {
        if (isCdmaFormat(newFormat)) {
            Rlog.d(TAG, "old format matched new format (cdma)");
            mCdmaDispatcher.sendSms(tracker);
            return;
        } else {
            Rlog.d(TAG, "old format matched new format (gsm)");
            mGsmDispatcher.sendSms(tracker);
            return;
        }
    }
    // format didn't match, need to re-encode.
    HashMap map = tracker.mData;
    // data and destPort if originally sent as sendData.
    if (!(map.containsKey("scAddr") && map.containsKey("destAddr") && (map.containsKey("text") || (map.containsKey("data") && map.containsKey("destPort"))))) {
        // should never come here...
        Rlog.e(TAG, "sendRetrySms failed to re-encode per missing fields!");
        if (tracker.mSentIntent != null) {
            int error = RESULT_ERROR_GENERIC_FAILURE;
            // Done retrying; return an error to the app.
            try {
                tracker.mSentIntent.send(mContext, error, null);
            } catch (CanceledException ex) {
            }
        }
        return;
    }
    String scAddr = (String) map.get("scAddr");
    String destAddr = (String) map.get("destAddr");
    SmsMessageBase.SubmitPduBase pdu = null;
    // figure out from tracker if this was sendText/Data
    if (map.containsKey("text")) {
        Rlog.d(TAG, "sms failed was text");
        String text = (String) map.get("text");
        if (isCdmaFormat(newFormat)) {
            Rlog.d(TAG, "old format (gsm) ==> new format (cdma)");
            pdu = com.android.internal.telephony.cdma.SmsMessage.getSubmitPdu(scAddr, destAddr, text, (tracker.mDeliveryIntent != null), null);
        } else {
            Rlog.d(TAG, "old format (cdma) ==> new format (gsm)");
            pdu = com.android.internal.telephony.gsm.SmsMessage.getSubmitPdu(scAddr, destAddr, text, (tracker.mDeliveryIntent != null), null);
        }
    } else if (map.containsKey("data")) {
        Rlog.d(TAG, "sms failed was data");
        byte[] data = (byte[]) map.get("data");
        Integer destPort = (Integer) map.get("destPort");
        if (isCdmaFormat(newFormat)) {
            Rlog.d(TAG, "old format (gsm) ==> new format (cdma)");
            pdu = com.android.internal.telephony.cdma.SmsMessage.getSubmitPdu(scAddr, destAddr, destPort.intValue(), data, (tracker.mDeliveryIntent != null));
        } else {
            Rlog.d(TAG, "old format (cdma) ==> new format (gsm)");
            pdu = com.android.internal.telephony.gsm.SmsMessage.getSubmitPdu(scAddr, destAddr, destPort.intValue(), data, (tracker.mDeliveryIntent != null));
        }
    }
    // replace old smsc and pdu with newly encoded ones
    map.put("smsc", pdu.encodedScAddress);
    map.put("pdu", pdu.encodedMessage);
    SMSDispatcher dispatcher = (isCdmaFormat(newFormat)) ? mCdmaDispatcher : mGsmDispatcher;
    tracker.mFormat = dispatcher.getFormat();
    dispatcher.sendSms(tracker);
}
#method_after
@Override
public void sendRetrySms(SmsTracker tracker) {
    String oldFormat = tracker.mFormat;
    // newFormat will be based on voice technology
    String newFormat = (PhoneConstants.PHONE_TYPE_CDMA == mPhone.getPhoneType()) ? mCdmaDispatcher.getFormat() : mGsmDispatcher.getFormat();
    // was previously sent sms format match with voice tech?
    if (oldFormat.equals(newFormat)) {
        if (isCdmaFormat(newFormat)) {
            Rlog.d(TAG, "old format matched new format (cdma)");
            shouldSendSmsOverIms();
            mCdmaDispatcher.sendSms(tracker);
            return;
        } else {
            Rlog.d(TAG, "old format matched new format (gsm)");
            mGsmDispatcher.sendSms(tracker);
            return;
        }
    }
    // format didn't match, need to re-encode.
    HashMap map = tracker.mData;
    // data and destPort if originally sent as sendData.
    if (!(map.containsKey("scAddr") && map.containsKey("destAddr") && (map.containsKey("text") || (map.containsKey("data") && map.containsKey("destPort"))))) {
        // should never come here...
        Rlog.e(TAG, "sendRetrySms failed to re-encode per missing fields!");
        if (tracker.mSentIntent != null) {
            int error = RESULT_ERROR_GENERIC_FAILURE;
            // Done retrying; return an error to the app.
            try {
                tracker.mSentIntent.send(mContext, error, null);
            } catch (CanceledException ex) {
            }
        }
        return;
    }
    String scAddr = (String) map.get("scAddr");
    String destAddr = (String) map.get("destAddr");
    SmsMessageBase.SubmitPduBase pdu = null;
    // figure out from tracker if this was sendText/Data
    if (map.containsKey("text")) {
        Rlog.d(TAG, "sms failed was text");
        String text = (String) map.get("text");
        if (isCdmaFormat(newFormat)) {
            Rlog.d(TAG, "old format (gsm) ==> new format (cdma)");
            pdu = com.android.internal.telephony.cdma.SmsMessage.getSubmitPdu(scAddr, destAddr, text, (tracker.mDeliveryIntent != null), null);
            shouldSendSmsOverIms();
        } else {
            Rlog.d(TAG, "old format (cdma) ==> new format (gsm)");
            pdu = com.android.internal.telephony.gsm.SmsMessage.getSubmitPdu(scAddr, destAddr, text, (tracker.mDeliveryIntent != null), null);
        }
    } else if (map.containsKey("data")) {
        Rlog.d(TAG, "sms failed was data");
        byte[] data = (byte[]) map.get("data");
        Integer destPort = (Integer) map.get("destPort");
        if (isCdmaFormat(newFormat)) {
            Rlog.d(TAG, "old format (gsm) ==> new format (cdma)");
            pdu = com.android.internal.telephony.cdma.SmsMessage.getSubmitPdu(scAddr, destAddr, destPort.intValue(), data, (tracker.mDeliveryIntent != null));
            shouldSendSmsOverIms();
        } else {
            Rlog.d(TAG, "old format (cdma) ==> new format (gsm)");
            pdu = com.android.internal.telephony.gsm.SmsMessage.getSubmitPdu(scAddr, destAddr, destPort.intValue(), data, (tracker.mDeliveryIntent != null));
        }
    }
    // replace old smsc and pdu with newly encoded ones
    map.put("smsc", pdu.encodedScAddress);
    map.put("pdu", pdu.encodedMessage);
    SMSDispatcher dispatcher = (isCdmaFormat(newFormat)) ? mCdmaDispatcher : mGsmDispatcher;
    tracker.mFormat = dispatcher.getFormat();
    dispatcher.sendSms(tracker);
}
#end_block

#method_before
@Override
protected void sendNewSubmitPdu(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int format, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, int priority) {
    Rlog.e(TAG, "Error! Not implemented for IMS.");
}
#method_after
@Override
protected void sendNewSubmitPdu(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int format, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, int priority, boolean isExpectMore, int validityPeriod) {
    Rlog.e(TAG, "Error! Not implemented for IMS.");
}
#end_block

#method_before
private byte[][] getPdus(String scAddress, String senderAddress, String msg) {
    // If we have a valid senderAddress, use it to get a valid SubmitPdu. Otherwise, we
    // should relay in a MOCK_ADDRESS to ensure a valid SubmitPdu
    SubmitPdu submitPdu = null;
    if (PhoneNumberUtils.isWellFormedSmsAddress(senderAddress)) {
        submitPdu = android.telephony.SmsMessage.getSubmitPdu(scAddress, senderAddress, msg, false);
    } else {
        submitPdu = android.telephony.SmsMessage.getSubmitPdu(scAddress, MOCK_ADDRESS, msg, false);
    }
    // Translate the submit data to a received PDU
    int dataLen = android.telephony.SmsMessage.calculateLength(msg, true)[1];
    // Locate protocol + data encoding scheme
    byte[] pds = { (byte) 0, (byte) 0, (byte) dataLen };
    int dataPos = new String(submitPdu.encodedMessage).indexOf(new String(pds), 4) + 2;
    // Set arrays dimension
    byte[] encSc = submitPdu.encodedScAddress;
    byte[] encMsg = new byte[submitPdu.encodedMessage.length - dataPos];
    System.arraycopy(submitPdu.encodedMessage, dataPos, encMsg, 0, submitPdu.encodedMessage.length - dataPos);
    byte[] encSender = null;
    // Check if the senderAddress is a vanish number
    if (!PhoneNumberUtils.isWellFormedSmsAddress(senderAddress)) {
        try {
            byte[] sender7BitPacked = GsmAlphabet.stringToGsm7BitPacked(senderAddress);
            encSender = new byte[2 + sender7BitPacked.length - 1];
            encSender[0] = (byte) ((sender7BitPacked.length - 1) * 2);
            // Alphabetic sender
            encSender[1] = (byte) 0xD0;
            System.arraycopy(sender7BitPacked, 1, encSender, 2, sender7BitPacked.length - 1);
        } catch (EncodeException e) {
            Log.e(TAG, "Failed to decode sender address. Using default.", e);
            encSender = new byte[dataPos - 4];
            System.arraycopy(submitPdu.encodedMessage, 2, encSender, 0, dataPos - 4);
        }
    } else {
        encSender = new byte[dataPos - 4];
        System.arraycopy(submitPdu.encodedMessage, 2, encSender, 0, dataPos - 4);
    }
    byte[] encTs = bcdTimestamp();
    byte[] pdu = new byte[encSc.length + 1 + /**
     * SMS-DELIVER *
     */
    encSender.length + 2 + /**
     * Protocol + Data Encoding Scheme *
     */
    encTs.length + encMsg.length];
    // Copy the SC address
    int c = 0;
    System.arraycopy(encSc, 0, pdu, c, encSc.length);
    c += encSc.length;
    // SMS-DELIVER
    pdu[c] = 0x04;
    c++;
    // Sender
    System.arraycopy(encSender, 0, pdu, c, encSender.length);
    c += encSender.length;
    // Protocol + Data encoding scheme
    pdu[c] = 0x00;
    c++;
    pdu[c] = 0x00;
    c++;
    // Timestamp
    System.arraycopy(encTs, 0, pdu, c, encTs.length);
    c += encTs.length;
    // Message
    System.arraycopy(encMsg, 0, pdu, c, encMsg.length);
    // Return the PDUs
    return new byte[][] { pdu };
}
#method_after
private byte[][] getPdus(String scAddress, String senderAddress, String msg) {
    // If we have a valid senderAddress, use it to get a valid SubmitPdu. Otherwise, we
    // should relay in a MOCK_ADDRESS to ensure a valid SubmitPdu
    boolean isWellFormed = PhoneNumberUtils.isWellFormedSmsAddress(senderAddress);
    String pduSenderAddress = isWellFormed ? senderAddress : MOCK_ADDRESS;
    SubmitPdu submitPdu = android.telephony.SmsMessage.getSubmitPdu(scAddress, pduSenderAddress, msg, false);
    // Translate the submit data to a received PDU
    int dataLen = android.telephony.SmsMessage.calculateLength(msg, true)[1];
    // Locate protocol + data encoding scheme
    byte[] pds = { (byte) 0, (byte) 0, (byte) dataLen };
    int dataPos = new String(submitPdu.encodedMessage).indexOf(new String(pds), 4) + 2;
    // Set arrays dimension
    byte[] encSc = submitPdu.encodedScAddress;
    byte[] encMsg = new byte[submitPdu.encodedMessage.length - dataPos];
    System.arraycopy(submitPdu.encodedMessage, dataPos, encMsg, 0, submitPdu.encodedMessage.length - dataPos);
    byte[] encSender = null;
    // Check if the senderAddress is a vanish number
    if (!isWellFormed) {
        try {
            byte[] sender7BitPacked = GsmAlphabet.stringToGsm7BitPacked(senderAddress);
            encSender = new byte[2 + sender7BitPacked.length - 1];
            encSender[0] = (byte) ((sender7BitPacked.length - 1) * 2);
            // Alphabetic sender
            encSender[1] = (byte) 0xD0;
            System.arraycopy(sender7BitPacked, 1, encSender, 2, sender7BitPacked.length - 1);
        } catch (EncodeException e) {
            Log.e(TAG, "Failed to decode sender address. Using default.", e);
            encSender = new byte[dataPos - 4];
            System.arraycopy(submitPdu.encodedMessage, 2, encSender, 0, dataPos - 4);
        }
    } else {
        encSender = new byte[dataPos - 4];
        System.arraycopy(submitPdu.encodedMessage, 2, encSender, 0, dataPos - 4);
    }
    byte[] encTs = bcdTimestamp();
    byte[] pdu = new byte[encSc.length + 1 + /**
     * SMS-DELIVER *
     */
    encSender.length + 2 + /**
     * Protocol + Data Encoding Scheme *
     */
    encTs.length + encMsg.length];
    // Copy the SC address
    int c = 0;
    System.arraycopy(encSc, 0, pdu, c, encSc.length);
    c += encSc.length;
    // SMS-DELIVER
    pdu[c] = 0x04;
    c++;
    // Sender
    System.arraycopy(encSender, 0, pdu, c, encSender.length);
    c += encSender.length;
    // Protocol + Data encoding scheme
    pdu[c] = 0x00;
    c++;
    pdu[c] = 0x00;
    c++;
    // Timestamp
    System.arraycopy(encTs, 0, pdu, c, encTs.length);
    c += encTs.length;
    // Message
    System.arraycopy(encMsg, 0, pdu, c, encMsg.length);
    // Return the PDUs
    return new byte[][] { pdu };
}
#end_block

#method_before
private void loadSpnOverrides() {
    FileReader spnReader = null;
    final File spnFile = new File(Environment.getRootDirectory(), PARTNER_SPN_OVERRIDE_PATH);
    try {
        spnReader = new FileReader(spnFile);
    } catch (FileNotFoundException e) {
        Rlog.w(LOG_TAG, "Can not open " + Environment.getRootDirectory() + "/" + PARTNER_SPN_OVERRIDE_PATH);
        closeQuietly(spnReader);
        return;
    }
    try {
        XmlPullParser parser = Xml.newPullParser();
        parser.setInput(spnReader);
        XmlUtils.beginDocument(parser, "spnOverrides");
        while (true) {
            XmlUtils.nextElement(parser);
            String name = parser.getName();
            if (!"spnOverride".equals(name)) {
                break;
            }
            String numeric = parser.getAttributeValue(null, "numeric");
            String data = parser.getAttributeValue(null, "spn");
            mCarrierSpnMap.put(numeric, data);
        }
    } catch (XmlPullParserException e) {
        Rlog.w(LOG_TAG, "Exception in spn-conf parser " + e);
    } catch (IOException e) {
        Rlog.w(LOG_TAG, "Exception in spn-conf parser " + e);
    } finally {
        closeQuietly(spnReader);
    }
}
#method_after
private void loadSpnOverrides() {
    FileReader spnReader = null;
    final File spnFile = new File(Environment.getRootDirectory(), PARTNER_SPN_OVERRIDE_PATH);
    try {
        spnReader = new FileReader(spnFile);
        XmlPullParser parser = Xml.newPullParser();
        parser.setInput(spnReader);
        XmlUtils.beginDocument(parser, "spnOverrides");
        while (true) {
            XmlUtils.nextElement(parser);
            String name = parser.getName();
            if (!"spnOverride".equals(name)) {
                break;
            }
            String numeric = parser.getAttributeValue(null, "numeric");
            String data = parser.getAttributeValue(null, "spn");
            mCarrierSpnMap.put(numeric, data);
        }
    } catch (FileNotFoundException e) {
        Rlog.w(LOG_TAG, "Can not open " + Environment.getRootDirectory() + "/" + PARTNER_SPN_OVERRIDE_PATH);
        return;
    } catch (XmlPullParserException e) {
        Rlog.w(LOG_TAG, "Exception in spn-conf parser " + e);
    } catch (IOException e) {
        Rlog.w(LOG_TAG, "Exception in spn-conf parser " + e);
    } finally {
        closeQuietly(spnReader);
    }
}
#end_block

#method_before
/**
 * Returns the 5 or 6 digit MCC/MNC of the operator that
 *  provided the RUIM card. Returns null of RUIM is not yet ready
 */
@Override
public String getOperatorNumeric() {
    if (mImsi == null) {
        return null;
    }
    String Imsi = "";
    int mnclength = 0;
    Imsi = SystemProperties.get("gsm.sim.operator.imsi", "");
    mnclength = SystemProperties.getInt("gsm.sim.operator.mnclength", 0);
    if (Imsi.length() > 0) {
        log("Returning getOperatorNumeric " + Imsi.substring(0, 3 + mnclength));
        return Imsi.substring(0, 3 + mnclength);
    }
    if (mMncLength != UNINITIALIZED && mMncLength != UNKNOWN) {
        // length of mcc = 3 (3GPP2 C.S0005 - Section 2.3)
        return mImsi.substring(0, 3 + mMncLength);
    }
    // Guess the MNC length based on the MCC if we don't
    // have a valid value in ef[ad]
    int mcc = Integer.parseInt(mImsi.substring(0, 3));
    return mImsi.substring(0, 3 + CSIM_IMSI_MNC_LENGTH);
}
#method_after
/**
 * Returns the 5 or 6 digit MCC/MNC of the operator that
 *  provided the RUIM card. Returns null of RUIM is not yet ready
 */
@Override
public String getOperatorNumeric() {
    if (mImsi == null) {
        return null;
    }
    if (SystemProperties.getBoolean("ro.telephony.get_imsi_from_sim", false)) {
        String imsi = mParentApp.getUICCConfig().getImsi();
        int mnclength = mParentApp.getUICCConfig().getMncLength();
        // If we are LTE over CDMA (Verizon), then pull the correct info from SIMRecords
        if (imsi != null) {
            log("Overriding with Operator Numeric: " + imsi.substring(0, 3 + mnclength));
            return imsi.substring(0, 3 + mnclength);
        }
    }
    if (mMncLength != UNINITIALIZED && mMncLength != UNKNOWN) {
        // length of mcc = 3 (3GPP2 C.S0005 - Section 2.3)
        return mImsi.substring(0, 3 + mMncLength);
    }
    // Guess the MNC length based on the MCC if we don't
    // have a valid value in ef[ad]
    int mcc = Integer.parseInt(mImsi.substring(0, 3));
    return mImsi.substring(0, 3 + CSIM_IMSI_MNC_LENGTH);
}
#end_block

#method_before
protected void resetRecords() {
    mImsi = null;
    mMsisdn = null;
    mVoiceMailNum = null;
    mMncLength = UNINITIALIZED;
    mIccId = null;
    // -1 means no EF_SPN found; treat accordingly.
    mSpnDisplayCondition = -1;
    mEfMWIS = null;
    mEfCPHS_MWI = null;
    mSpdiNetworks = null;
    mPnnHomeName = null;
    mGid1 = null;
    mAdnCache.reset();
    log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
    setSystemProperty(PROPERTY_ICC_OPERATOR_NUMERIC, null);
    setSystemProperty(PROPERTY_APN_SIM_OPERATOR_NUMERIC, null);
    setSystemProperty(PROPERTY_ICC_OPERATOR_ALPHA, null);
    setSystemProperty(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, null);
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mRecordsRequested = false;
}
#method_after
protected void resetRecords() {
    mImsi = null;
    mMsisdn = null;
    mVoiceMailNum = null;
    mMncLength = UNINITIALIZED;
    mIccId = null;
    // -1 means no EF_SPN found; treat accordingly.
    mSpnDisplayCondition = -1;
    mEfMWIS = null;
    mEfCPHS_MWI = null;
    mSpdiNetworks = null;
    mPnnHomeName = null;
    mGid1 = null;
    mAdnCache.reset();
    log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
    setSystemProperty(PROPERTY_ICC_OPERATOR_NUMERIC, null);
    setSystemProperty(PROPERTY_APN_SIM_OPERATOR_NUMERIC, null);
    setSystemProperty(PROPERTY_ICC_OPERATOR_ALPHA, null);
    setSystemProperty(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, null);
    mParentApp.getUICCConfig().setImsi(mImsi);
    mParentApp.getUICCConfig().setMncLength(mMncLength);
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mRecordsRequested = false;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: " + /* imsi.substring(0, 6) +*/
                "xxxxxxx");
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI!");
                    }
                }
                setSystemProperty("gsm.sim.operator.imsi", mImsi);
                if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                    setSystemProperty("gsm.sim.operator.mnclength", "3");
                } else {
                    setSystemProperty("gsm.sim.operator.mnclength", Integer.toString(mMncLength));
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
                    // finally have both the imsi and the mncLength and can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                "xxxxxxx");
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                log("iccid: " + mIccId);
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mMncLength = data[3] & 0xf;
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                    } else {
                        setSystemProperty("gsm.sim.operator.mnclength", Integer.toString(mMncLength));
                    }
                } finally {
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI!");
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD");
                        }
                    }
                    if (mImsi != null && mMncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                mEfCff = data;
                // if EF_CFIS is valid, prefer it to EF_CFF_CPHS
                if (!validEfCfis(mEfCfis)) {
                    mCallForwardingEnabled = ((data[0] & CFF_LINE1_MASK) == CFF_UNCONDITIONAL_ACTIVE);
                    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
                } else {
                    log("EVENT_GET_CFF_DONE: EF_CFIS is valid, ignoring EF_CFF_CPHS");
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null)
                    break;
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                    * we only need notify caller once if both updating are
                    * successful.
                    *
                    * so if set_mbdn successful, notify caller here and set
                    * onCphsCompleted to null
                    */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                if (validEfCfis(data)) {
                    mEfCfis = data;
                    // Refer TS 51.011 Section 10.3.46 for the content description
                    mCallForwardingEnabled = ((data[1] & 0x01) != 0);
                    log("EF_CFIS: callForwardingEnabled=" + mCallForwardingEnabled);
                    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
                } else {
                    log("EF_CFIS: invalid data=" + IccUtils.bytesToHexString(data));
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: " + /* imsi.substring(0, 6) +*/
                "xxxxxxx");
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI!");
                    }
                }
                mParentApp.getUICCConfig().setImsi(mImsi);
                if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                    // We need to default to something that seems common
                    mParentApp.getUICCConfig().setMncLength(3);
                } else {
                    mParentApp.getUICCConfig().setMncLength(mMncLength);
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
                    // finally have both the imsi and the mncLength and can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                "xxxxxxx");
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                log("iccid: " + mIccId);
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mMncLength = data[3] & 0xf;
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                    } else {
                        mParentApp.getUICCConfig().setMncLength(mMncLength);
                    }
                } finally {
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI!");
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD");
                        }
                    }
                    if (mImsi != null && mMncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                mEfCff = data;
                // if EF_CFIS is valid, prefer it to EF_CFF_CPHS
                if (!validEfCfis(mEfCfis)) {
                    mCallForwardingEnabled = ((data[0] & CFF_LINE1_MASK) == CFF_UNCONDITIONAL_ACTIVE);
                    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
                } else {
                    log("EVENT_GET_CFF_DONE: EF_CFIS is valid, ignoring EF_CFF_CPHS");
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null)
                    break;
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                    * we only need notify caller once if both updating are
                    * successful.
                    *
                    * so if set_mbdn successful, notify caller here and set
                    * onCphsCompleted to null
                    */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                if (validEfCfis(data)) {
                    mEfCfis = data;
                    // Refer TS 51.011 Section 10.3.46 for the content description
                    mCallForwardingEnabled = ((data[1] & 0x01) != 0);
                    log("EF_CFIS: callForwardingEnabled=" + mCallForwardingEnabled);
                    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
                } else {
                    log("EF_CFIS: invalid data=" + IccUtils.bytesToHexString(data));
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
    synchronized (mLock) {
        CardState oldState = mCardState;
        mCardState = ics.mCardState;
        mUniversalPinState = ics.mUniversalPinState;
        mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
        mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
        mImsSubscriptionAppIndex = ics.mImsSubscriptionAppIndex;
        mContext = c;
        mCi = ci;
        // update applications
        if (DBG)
            log(ics.mApplications.length + " applications");
        for (int i = 0; i < mUiccApplications.length; i++) {
            if (mUiccApplications[i] == null) {
                // Create newly added Applications
                if (i < ics.mApplications.length) {
                    mUiccApplications[i] = new UiccCardApplication(this, ics.mApplications[i], mContext, mCi);
                }
            } else if (i >= ics.mApplications.length) {
                // Delete removed applications
                mUiccApplications[i].dispose();
                mUiccApplications[i] = null;
            } else {
                // Update the rest
                mUiccApplications[i].update(ics.mApplications[i], mContext, mCi);
            }
        }
        createAndUpdateCatService();
        // Reload the carrier privilege rules if necessary.
        log("Before privilege rules: " + mCarrierPrivilegeRules + " : " + mCardState);
        if (mCarrierPrivilegeRules == null && mCardState == CardState.CARDSTATE_PRESENT) {
            mCarrierPrivilegeRules = new UiccCarrierPrivilegeRules(this, mHandler.obtainMessage(EVENT_CARRIER_PRIVILIGES_LOADED));
        } else if (mCarrierPrivilegeRules != null && mCardState != CardState.CARDSTATE_PRESENT) {
            mCarrierPrivilegeRules = null;
        }
        sanitizeApplicationIndexes();
        RadioState radioState = mCi.getRadioState();
        if (DBG)
            log("update: radioState=" + radioState + " mLastRadioState=" + mLastRadioState);
        // No notifications while radio is off or we just powering up
        if (radioState == RadioState.RADIO_ON && mLastRadioState == RadioState.RADIO_ON) {
            if (oldState != CardState.CARDSTATE_ABSENT && mCardState == CardState.CARDSTATE_ABSENT) {
                if (DBG)
                    log("update: notify card removed");
                mAbsentRegistrants.notifyRegistrants();
                mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_REMOVED, null));
            } else if (oldState == CardState.CARDSTATE_ABSENT && mCardState != CardState.CARDSTATE_ABSENT) {
                if (DBG)
                    log("update: notify card added");
                mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_ADDED, null));
            }
        }
        if (radioState == RadioState.RADIO_ON && mCardState == CardState.CARDSTATE_PRESENT && mUiccApplications.length > 0 && mGsmUmtsSubscriptionAppIndex < 0 && mCdmaSubscriptionAppIndex < 0 && mImsSubscriptionAppIndex < 0) {
            // Activate/Deactivate first 3GPP and 3GPP2 app in the sim, if available
            for (int i = 0; i < mUiccApplications.length; i++) {
                AppType appType = mUiccApplications[i].getType();
                if (!m3GPPAppActivated && (appType == AppType.APPTYPE_USIM || appType == AppType.APPTYPE_SIM)) {
                    mCi.setUiccSubscription(i, true, null);
                    m3GPPAppActivated = true;
                } else if (!m3GPP2AppActivated && (appType == AppType.APPTYPE_CSIM || appType == AppType.APPTYPE_RUIM)) {
                    mCi.setUiccSubscription(i, true, null);
                    m3GPPAppActivated = true;
                }
            }
        }
        mLastRadioState = radioState;
    }
}
#method_after
public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
    synchronized (mLock) {
        CardState oldState = mCardState;
        mCardState = ics.mCardState;
        mUniversalPinState = ics.mUniversalPinState;
        mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
        mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
        mImsSubscriptionAppIndex = ics.mImsSubscriptionAppIndex;
        mContext = c;
        mCi = ci;
        // update applications
        if (DBG)
            log(ics.mApplications.length + " applications");
        for (int i = 0; i < mUiccApplications.length; i++) {
            if (mUiccApplications[i] == null) {
                // Create newly added Applications
                if (i < ics.mApplications.length) {
                    mUiccApplications[i] = new UiccCardApplication(this, ics.mApplications[i], mContext, mCi);
                }
            } else if (i >= ics.mApplications.length) {
                // Delete removed applications
                mUiccApplications[i].dispose();
                mUiccApplications[i] = null;
            } else {
                // Update the rest
                mUiccApplications[i].update(ics.mApplications[i], mContext, mCi);
            }
        }
        createAndUpdateCatService();
        // Reload the carrier privilege rules if necessary.
        log("Before privilege rules: " + mCarrierPrivilegeRules + " : " + mCardState);
        if (mCarrierPrivilegeRules == null && mCardState == CardState.CARDSTATE_PRESENT) {
            mCarrierPrivilegeRules = new UiccCarrierPrivilegeRules(this, mHandler.obtainMessage(EVENT_CARRIER_PRIVILIGES_LOADED));
        } else if (mCarrierPrivilegeRules != null && mCardState != CardState.CARDSTATE_PRESENT) {
            mCarrierPrivilegeRules = null;
        }
        sanitizeApplicationIndexes();
        RadioState radioState = mCi.getRadioState();
        if (DBG)
            log("update: radioState=" + radioState + " mLastRadioState=" + mLastRadioState);
        // No notifications while radio is off or we just powering up
        if (radioState == RadioState.RADIO_ON && mLastRadioState == RadioState.RADIO_ON) {
            if (oldState != CardState.CARDSTATE_ABSENT && mCardState == CardState.CARDSTATE_ABSENT) {
                if (DBG)
                    log("update: notify card removed");
                mAbsentRegistrants.notifyRegistrants();
                mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_REMOVED, null));
            } else if (oldState == CardState.CARDSTATE_ABSENT && mCardState != CardState.CARDSTATE_ABSENT) {
                if (DBG)
                    log("update: notify card added");
                mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_ADDED, null));
            }
        }
        if (mGsmUmtsSubscriptionAppIndex < 0 && mCdmaSubscriptionAppIndex < 0 && mCardState == CardState.CARDSTATE_PRESENT && mCi.needsOldRilFeature("simactivation")) {
            // Activate/Deactivate first 3GPP and 3GPP2 app in the SIM, if available
            for (int i = 0; i < mUiccApplications.length; i++) {
                if (mUiccApplications[i] == null) {
                    continue;
                }
                AppType appType = mUiccApplications[i].getType();
                if (!m3GPPAppActivated && (appType == AppType.APPTYPE_USIM || appType == AppType.APPTYPE_SIM)) {
                    mCi.setUiccSubscription(i, true, null);
                    m3GPPAppActivated = true;
                } else if (!m3GPP2AppActivated && (appType == AppType.APPTYPE_CSIM || appType == AppType.APPTYPE_RUIM)) {
                    mCi.setUiccSubscription(i, true, null);
                    m3GPP2AppActivated = true;
                }
                if (m3GPPAppActivated && m3GPP2AppActivated) {
                    break;
                }
            }
        } else {
            // SIM removed, reset activation flags to make sure
            // to re-run the activation at the next insertion
            m3GPPAppActivated = false;
            m3GPP2AppActivated = false;
        }
        mLastRadioState = radioState;
    }
}
#end_block

#method_before
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mInstanceId == null || mInstanceId == 0) {
                rilSocket = SOCKET_NAME_RIL[0];
            } else {
                rilSocket = SOCKET_NAME_RIL[mInstanceId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    Rlog.e(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#method_after
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mInstanceId == null || mInstanceId == 0) {
                rilSocket = SOCKET_NAME_RIL[0];
            } else {
                rilSocket = SOCKET_NAME_RIL[mInstanceId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    Rlog.e(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '" + rilSocket + "' socket");
            /* Compatibility with qcom's DSDS (Dual SIM) stack */
            if (needsOldRilFeature("qcomdsds")) {
                String str = "SUB1";
                byte[] data = str.getBytes();
                try {
                    mSocket.getOutputStream().write(data);
                    Rlog.i(RILJ_LOG_TAG, "Data sent!!");
                } catch (IOException ex) {
                    Rlog.e(RILJ_LOG_TAG, "IOException", ex);
                } catch (RuntimeException exc) {
                    Rlog.e(RILJ_LOG_TAG, "Uncaught exception ", exc);
                }
            }
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#end_block

#method_before
@Override
public void supplyIccPinForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(pin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPinForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 1 : 2);
    rr.mParcel.writeString(pin);
    if (!oldRil)
        rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin);
    if (!oldRil)
        rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void supplyIccPin2ForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(pin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPin2ForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 1 : 2);
    rr.mParcel.writeString(pin);
    if (!oldRil)
        rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin2);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin2);
    if (!oldRil)
        rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(oldPin);
    rr.mParcel.writeString(newPin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(oldPin);
    rr.mParcel.writeString(newPin);
    if (!oldRil)
        rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(oldPin2);
    rr.mParcel.writeString(newPin2);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(oldPin2);
    rr.mParcel.writeString(newPin2);
    if (!oldRil)
        rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void getIMSIForApp(String aid, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> getIMSI: " + requestToString(rr.mRequest) + " aid: " + aid);
    send(rr);
}
#method_after
@Override
public void getIMSIForApp(String aid, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
    boolean skipNullAid = needsOldRilFeature("skipnullaid");
    boolean writeAidOnly = needsOldRilFeature("writeaidonly");
    if (!writeAidOnly && (aid != null || !skipNullAid)) {
        rr.mParcel.writeInt(1);
        rr.mParcel.writeString(aid);
    }
    if (writeAidOnly)
        rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> getIMSI: " + requestToString(rr.mRequest) + " aid: " + aid);
    send(rr);
}
#end_block

#method_before
@Override
public void writeSmsToRuim(int status, String pdu, Message response) {
    status = translateStatus(status);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, response);
    rr.mParcel.writeInt(status);
    rr.mParcel.writeString(pdu);
    if (RILJ_LOGV)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + status);
    send(rr);
}
#method_after
@Override
public void writeSmsToRuim(int status, String pdu, Message response) {
    status = translateStatus(status);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, response);
    rr.mParcel.writeInt(status);
    constructCdmaWriteSmsRilRequest(rr, IccUtils.hexStringToBytes(pdu));
    if (RILJ_LOGV)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + status);
    send(rr);
}
#end_block

#method_before
@Override
public void queryFacilityLockForApp(String facility, String password, int serviceClass, String appId, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + serviceClass + " " + appId + "]");
    // count strings
    rr.mParcel.writeInt(4);
    rr.mParcel.writeString(facility);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    rr.mParcel.writeString(appId);
    send(rr);
}
#method_after
@Override
public void queryFacilityLockForApp(String facility, String password, int serviceClass, String appId, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    // count strings
    rr.mParcel.writeInt(oldRil ? 3 : 4);
    rr.mParcel.writeString(facility);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    if (!oldRil)
        rr.mParcel.writeString(appId);
    send(rr);
}
#end_block

#method_before
@Override
public void setFacilityLockForApp(String facility, boolean lockState, String password, int serviceClass, String appId, Message response) {
    String lockString;
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + lockState + " " + serviceClass + " " + appId + "]");
    // count strings
    rr.mParcel.writeInt(5);
    rr.mParcel.writeString(facility);
    lockString = (lockState) ? "1" : "0";
    rr.mParcel.writeString(lockString);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    rr.mParcel.writeString(appId);
    send(rr);
}
#method_after
@Override
public void setFacilityLockForApp(String facility, boolean lockState, String password, int serviceClass, String appId, Message response) {
    String lockString;
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + lockState + " " + serviceClass + " " + appId + "]");
    boolean oldRil = needsOldRilFeature("facilitylock");
    // count strings
    rr.mParcel.writeInt(oldRil ? 4 : 5);
    rr.mParcel.writeString(facility);
    lockString = (lockState) ? "1" : "0";
    rr.mParcel.writeString(lockString);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    if (!oldRil)
        rr.mParcel.writeString(appId);
    send(rr);
}
#end_block

#method_before
private void sendScreenState(boolean on) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(on ? 1 : 0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + on);
    send(rr);
}
#method_after
protected void sendScreenState(boolean on) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(on ? 1 : 0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + on);
    send(rr);
}
#end_block

#method_before
private RadioState getRadioStateFromInt(int stateInt) {
    RadioState state;
    /* RIL_RadioState ril.h */
    switch(stateInt) {
        case 0:
            state = RadioState.RADIO_OFF;
            break;
        case 1:
            state = RadioState.RADIO_UNAVAILABLE;
            break;
        case 10:
            state = RadioState.RADIO_ON;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_RadioState: " + stateInt);
    }
    return state;
}
#method_after
protected RadioState getRadioStateFromInt(int stateInt) {
    RadioState state;
    /* RIL_RadioState ril.h */
    switch(stateInt) {
        case 0:
            state = RadioState.RADIO_OFF;
            break;
        case 1:
            state = RadioState.RADIO_UNAVAILABLE;
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
            state = RadioState.RADIO_ON;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_RadioState: " + stateInt);
    }
    return state;
}
#end_block

#method_before
private void switchToRadioState(RadioState newState) {
    setRadioState(newState);
}
#method_after
protected void switchToRadioState(RadioState newState) {
    setRadioState(newState);
}
#end_block

#method_before
private void send(RILRequest rr) {
    Message msg;
    if (mSocket == null) {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
        return;
    }
    msg = mSender.obtainMessage(EVENT_SEND, rr);
    acquireWakeLock();
    msg.sendToTarget();
}
#method_after
protected void send(RILRequest rr) {
    Message msg;
    if (mSocket == null) {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
        return;
    }
    msg = mSender.obtainMessage(EVENT_SEND, rr);
    acquireWakeLock();
    msg.sendToTarget();
}
#end_block

#method_before
private void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED) {
        processUnsolicited(p);
    } else if (type == RESPONSE_SOLICITED) {
        RILRequest rr = processSolicited(p);
        if (rr != null) {
            rr.release();
            decrementWakeLock();
        }
    }
}
#method_after
protected void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED) {
        processUnsolicited(p);
    } else if (type == RESPONSE_SOLICITED) {
        RILRequest rr = processSolicited(p);
        if (rr != null) {
            rr.release();
            decrementWakeLock();
        }
    }
}
#end_block

#method_before
private void clearRequestList(int error, boolean loggable) {
    RILRequest rr;
    synchronized (mRequestList) {
        int count = mRequestList.size();
        if (RILJ_LOGD && loggable) {
            Rlog.d(RILJ_LOG_TAG, "clearRequestList " + " mWakeLockCount=" + mWakeLockCount + " mRequestList=" + count);
        }
        for (int i = 0; i < count; i++) {
            rr = mRequestList.valueAt(i);
            if (RILJ_LOGD && loggable) {
                Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
            }
            rr.onError(error, null);
            rr.release();
            decrementWakeLock();
        }
        mRequestList.clear();
    }
}
#method_after
protected void clearRequestList(int error, boolean loggable) {
    RILRequest rr;
    synchronized (mRequestList) {
        int count = mRequestList.size();
        if (RILJ_LOGD && loggable) {
            Rlog.d(RILJ_LOG_TAG, "clearRequestList " + " mWakeLockCount=" + mWakeLockCount + " mRequestList=" + count);
        }
        for (int i = 0; i < count; i++) {
            rr = mRequestList.valueAt(i);
            if (RILJ_LOGD && loggable) {
                Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
            }
            rr.onError(error, null);
            rr.release();
            decrementWakeLock();
        }
        mRequestList.clear();
    }
}
#end_block

#method_before
private RILRequest findAndRemoveRequestFromList(int serial) {
    RILRequest rr = null;
    synchronized (mRequestList) {
        rr = mRequestList.get(serial);
        if (rr != null) {
            mRequestList.remove(serial);
        }
    }
    return rr;
}
#method_after
protected RILRequest findAndRemoveRequestFromList(int serial) {
    RILRequest rr = null;
    synchronized (mRequestList) {
        rr = mRequestList.get(serial);
        if (rr != null) {
            mRequestList.remove(serial);
        }
    }
    return rr;
}
#end_block

#method_before
private RILRequest processSolicited(Parcel p) {
    int serial, error;
    boolean found = false;
    serial = p.readInt();
    error = p.readInt();
    RILRequest rr;
    rr = findAndRemoveRequestFromList(serial);
    if (rr == null) {
        Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: " + serial + " error: " + error);
        return null;
    }
    Object ret = null;
    if (error == 0 || p.dataAvail() > 0) {
        // either command succeeds or command fails but with data payload
        try {
            switch(rr.mRequest) {
                /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
             */
                case RIL_REQUEST_GET_SIM_STATUS:
                    ret = responseIccCardStatus(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CURRENT_CALLS:
                    ret = responseCallList(p);
                    break;
                case RIL_REQUEST_DIAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMSI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_HANGUP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
                    {
                        if (mTestingEmergencyCall.getAndSet(false)) {
                            if (mEmergencyCallbackModeRegistrant != null) {
                                riljLog("testing emergency call, notify ECM Registrants");
                                mEmergencyCallbackModeRegistrant.notifyRegistrant();
                            }
                        }
                        ret = responseVoid(p);
                        break;
                    }
                case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CONFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_UDUB:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
                    ret = responseFailCause(p);
                    break;
                case RIL_REQUEST_SIGNAL_STRENGTH:
                    ret = responseSignalStrength(p);
                    break;
                case RIL_REQUEST_VOICE_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_DATA_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_OPERATOR:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_RADIO_POWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SETUP_DATA_CALL:
                    ret = responseSetupDataCall(p);
                    break;
                case RIL_REQUEST_SIM_IO:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SEND_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CANCEL_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_CLIR:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CLIR:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
                    ret = responseCallForward(p);
                    break;
                case RIL_REQUEST_SET_CALL_FORWARD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_WAITING:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CALL_WAITING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMEI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_GET_IMEISV:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ANSWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEACTIVATE_DATA_CALL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
                    ret = responseOperatorInfos(p);
                    break;
                case RIL_REQUEST_DTMF_START:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF_STOP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_BASEBAND_VERSION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SEPARATE_CONNECTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_MUTE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_MUTE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_QUERY_CLIP:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DATA_CALL_LIST:
                    ret = responseDataCallList(p);
                    break;
                case RIL_REQUEST_RESET_RADIO:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_RAW:
                    ret = responseRaw(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_STRINGS:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_SCREEN_STATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_WRITE_SMS_TO_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DELETE_SMS_ON_SIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_BAND_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_STK_GET_PROFILE:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SET_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
                    ret = responseGetPreferredNetworkType(p);
                    break;
                case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
                    ret = responseCellList(p);
                    break;
                case RIL_REQUEST_SET_LOCATION_UPDATES:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_TTY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_TTY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_FLASH:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BURST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
                    ret = responseGmsBroadcastConfig(p);
                    break;
                case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
                    ret = responseCdmaBroadcastConfig(p);
                    break;
                case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SUBSCRIPTION:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEVICE_IDENTITY:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_GET_SMSC_ADDRESS:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SET_SMSC_ADDRESS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ISIM_AUTHENTICATION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_VOICE_RADIO_TECH:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CELL_INFO_LIST:
                    ret = responseCellInfoList(p);
                    break;
                case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_DATA_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_IMS_REGISTRATION_STATE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_IMS_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_OPEN_CHANNEL:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SIM_CLOSE_CHANNEL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_GET_ATR:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_READ_ITEM:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_WRITE_ITEM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_WRITE_CDMA_PRL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_RESET_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_ALLOW_DATA:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_HARDWARE_CONFIG:
                    ret = responseHardwareConfig(p);
                    break;
                case RIL_REQUEST_SIM_AUTHENTICATION:
                    ret = responseICC_IOBase64(p);
                    break;
                case RIL_REQUEST_SHUTDOWN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_SET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_START_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_STOP_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_PULL_LCEDATA:
                    ret = responseLceData(p);
                    break;
                case RIL_REQUEST_GET_ACTIVITY_INFO:
                    ret = responseActivityData(p);
                    break;
                default:
                    throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
            }
        } catch (Throwable tr) {
            // Exceptions here usually mean invalid RIL responses
            Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< " + requestToString(rr.mRequest) + " exception, possible invalid RIL response", tr);
            if (rr.mResult != null) {
                AsyncResult.forMessage(rr.mResult, null, tr);
                rr.mResult.sendToTarget();
            }
            return rr;
        }
    }
    if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
        // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
        // regardless of error code to continue shutdown procedure.
        riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " + error + " Setting Radio State to Unavailable regardless of error.");
        setRadioState(RadioState.RADIO_UNAVAILABLE);
    }
    // screen when the pin or puk is entered incorrectly.
    switch(rr.mRequest) {
        case RIL_REQUEST_ENTER_SIM_PUK:
        case RIL_REQUEST_ENTER_SIM_PUK2:
            if (mIccStatusChangedRegistrants != null) {
                if (RILJ_LOGD) {
                    riljLog("ON enter sim puk fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                }
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
    }
    if (error != 0) {
        switch(rr.mRequest) {
            case RIL_REQUEST_ENTER_SIM_PIN:
            case RIL_REQUEST_ENTER_SIM_PIN2:
            case RIL_REQUEST_CHANGE_SIM_PIN:
            case RIL_REQUEST_CHANGE_SIM_PIN2:
            case RIL_REQUEST_SET_FACILITY_LOCK:
                if (mIccStatusChangedRegistrants != null) {
                    if (RILJ_LOGD) {
                        riljLog("ON some errors fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                    }
                    mIccStatusChangedRegistrants.notifyRegistrants();
                }
                break;
            case RIL_REQUEST_GET_RADIO_CAPABILITY:
                {
                    // TODO - remove GENERIC_FAILURE catching: b/21079604
                    if (REQUEST_NOT_SUPPORTED == error || GENERIC_FAILURE == error) {
                        // we should construct the RAF bitmask the radio
                        // supports based on preferred network bitmasks
                        ret = makeStaticRadioCapability();
                        error = 0;
                    }
                    break;
                }
            case RIL_REQUEST_GET_ACTIVITY_INFO:
                ret = new ModemActivityInfo(0, 0, 0, new int[ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
                error = 0;
                break;
        }
        if (error != 0)
            rr.onError(error, ret);
    }
    if (error == 0) {
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "< " + requestToString(rr.mRequest) + " " + retToString(rr.mRequest, ret));
        if (rr.mResult != null) {
            AsyncResult.forMessage(rr.mResult, ret, null);
            rr.mResult.sendToTarget();
        }
    }
    return rr;
}
#method_after
protected RILRequest processSolicited(Parcel p) {
    int serial, error;
    boolean found = false;
    serial = p.readInt();
    error = p.readInt();
    RILRequest rr;
    rr = findAndRemoveRequestFromList(serial);
    if (rr == null) {
        Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: " + serial + " error: " + error);
        return null;
    }
    Object ret = null;
    if (error == 0 || p.dataAvail() > 0) {
        // either command succeeds or command fails but with data payload
        try {
            switch(rr.mRequest) {
                /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
             */
                case RIL_REQUEST_GET_SIM_STATUS:
                    ret = responseIccCardStatus(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CURRENT_CALLS:
                    ret = responseCallList(p);
                    break;
                case RIL_REQUEST_DIAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMSI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_HANGUP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
                    {
                        if (mTestingEmergencyCall.getAndSet(false)) {
                            if (mEmergencyCallbackModeRegistrant != null) {
                                riljLog("testing emergency call, notify ECM Registrants");
                                mEmergencyCallbackModeRegistrant.notifyRegistrant();
                            }
                        }
                        ret = responseVoid(p);
                        break;
                    }
                case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CONFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_UDUB:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
                    ret = responseFailCause(p);
                    break;
                case RIL_REQUEST_SIGNAL_STRENGTH:
                    ret = responseSignalStrength(p);
                    break;
                case RIL_REQUEST_VOICE_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_DATA_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_OPERATOR:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_RADIO_POWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SETUP_DATA_CALL:
                    ret = responseSetupDataCall(p);
                    break;
                case RIL_REQUEST_SIM_IO:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SEND_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CANCEL_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_CLIR:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CLIR:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
                    ret = responseCallForward(p);
                    break;
                case RIL_REQUEST_SET_CALL_FORWARD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_WAITING:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CALL_WAITING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMEI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_GET_IMEISV:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ANSWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEACTIVATE_DATA_CALL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
                    ret = responseOperatorInfos(p);
                    break;
                case RIL_REQUEST_DTMF_START:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF_STOP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_BASEBAND_VERSION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SEPARATE_CONNECTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_MUTE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_MUTE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_QUERY_CLIP:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DATA_CALL_LIST:
                    ret = responseDataCallList(p);
                    break;
                case RIL_REQUEST_RESET_RADIO:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_RAW:
                    ret = responseRaw(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_STRINGS:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_SCREEN_STATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_WRITE_SMS_TO_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DELETE_SMS_ON_SIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_BAND_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_STK_GET_PROFILE:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SET_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
                    ret = responseGetPreferredNetworkType(p);
                    break;
                case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
                    ret = responseCellList(p);
                    break;
                case RIL_REQUEST_SET_LOCATION_UPDATES:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_TTY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_TTY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_FLASH:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BURST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
                    ret = responseGmsBroadcastConfig(p);
                    break;
                case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
                    ret = responseCdmaBroadcastConfig(p);
                    break;
                case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SUBSCRIPTION:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEVICE_IDENTITY:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_GET_SMSC_ADDRESS:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SET_SMSC_ADDRESS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ISIM_AUTHENTICATION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_VOICE_RADIO_TECH:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CELL_INFO_LIST:
                    ret = responseCellInfoList(p);
                    break;
                case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_DATA_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_IMS_REGISTRATION_STATE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_IMS_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_OPEN_CHANNEL:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SIM_CLOSE_CHANNEL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_GET_ATR:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_READ_ITEM:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_WRITE_ITEM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_WRITE_CDMA_PRL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_RESET_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_ALLOW_DATA:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_HARDWARE_CONFIG:
                    ret = responseHardwareConfig(p);
                    break;
                case RIL_REQUEST_SIM_AUTHENTICATION:
                    ret = responseICC_IOBase64(p);
                    break;
                case RIL_REQUEST_SHUTDOWN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_SET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_START_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_STOP_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_PULL_LCEDATA:
                    ret = responseLceData(p);
                    break;
                case RIL_REQUEST_GET_ACTIVITY_INFO:
                    ret = responseActivityData(p);
                    break;
                default:
                    throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
            }
        } catch (Throwable tr) {
            // Exceptions here usually mean invalid RIL responses
            Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< " + requestToString(rr.mRequest) + " exception, possible invalid RIL response", tr);
            if (rr.mResult != null) {
                AsyncResult.forMessage(rr.mResult, null, tr);
                rr.mResult.sendToTarget();
            }
            return rr;
        }
    }
    if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
        // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
        // regardless of error code to continue shutdown procedure.
        riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " + error + " Setting Radio State to Unavailable regardless of error.");
        setRadioState(RadioState.RADIO_UNAVAILABLE);
    }
    // screen when the pin or puk is entered incorrectly.
    switch(rr.mRequest) {
        case RIL_REQUEST_ENTER_SIM_PUK:
        case RIL_REQUEST_ENTER_SIM_PUK2:
            if (mIccStatusChangedRegistrants != null) {
                if (RILJ_LOGD) {
                    riljLog("ON enter sim puk fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                }
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
    }
    if (error != 0) {
        switch(rr.mRequest) {
            case RIL_REQUEST_ENTER_SIM_PIN:
            case RIL_REQUEST_ENTER_SIM_PIN2:
            case RIL_REQUEST_CHANGE_SIM_PIN:
            case RIL_REQUEST_CHANGE_SIM_PIN2:
            case RIL_REQUEST_SET_FACILITY_LOCK:
                if (mIccStatusChangedRegistrants != null) {
                    if (RILJ_LOGD) {
                        riljLog("ON some errors fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                    }
                    mIccStatusChangedRegistrants.notifyRegistrants();
                }
                break;
            case RIL_REQUEST_GET_RADIO_CAPABILITY:
                {
                    // TODO - remove GENERIC_FAILURE catching: b/21079604
                    if (REQUEST_NOT_SUPPORTED == error || GENERIC_FAILURE == error) {
                        // we should construct the RAF bitmask the radio
                        // supports based on preferred network bitmasks
                        ret = makeStaticRadioCapability();
                        error = 0;
                    }
                    break;
                }
            case RIL_REQUEST_GET_ACTIVITY_INFO:
                ret = new ModemActivityInfo(0, 0, 0, new int[ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
                error = 0;
                break;
        }
        if (error != 0)
            rr.onError(error, ret);
    }
    if (error == 0) {
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "< " + requestToString(rr.mRequest) + " " + retToString(rr.mRequest, ret));
        if (rr.mResult != null) {
            AsyncResult.forMessage(rr.mResult, ret, null);
            rr.mResult.sendToTarget();
        }
    }
    return rr;
}
#end_block

#method_before
private void processUnsolicited(Parcel p) {
    int response;
    Object ret;
    response = p.readInt();
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#method_after
protected void processUnsolicited(Parcel p) {
    int response;
    Object ret;
    response = p.readInt();
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            boolean oldRil = needsOldRilFeature("skipbrokendatacall");
            if (oldRil && "IP".equals(((ArrayList<DataCallResponse>) ret).get(0).type))
                break;
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#end_block

#method_before
private void notifyRegistrantsRilConnectionChanged(int rilVer) {
    mRilVersion = rilVer;
    if (mRilConnectedRegistrants != null) {
        mRilConnectedRegistrants.notifyRegistrants(new AsyncResult(null, new Integer(rilVer), null));
    }
}
#method_after
protected void notifyRegistrantsRilConnectionChanged(int rilVer) {
    mRilVersion = rilVer;
    if (mRilConnectedRegistrants != null) {
        mRilConnectedRegistrants.notifyRegistrants(new AsyncResult(null, new Integer(rilVer), null));
    }
}
#end_block

#method_before
private Object responseInts(Parcel p) {
    int numInts;
    int[] response;
    numInts = p.readInt();
    response = new int[numInts];
    for (int i = 0; i < numInts; i++) {
        response[i] = p.readInt();
    }
    return response;
}
#method_after
protected Object responseInts(Parcel p) {
    int numInts;
    int[] response;
    numInts = p.readInt();
    response = new int[numInts];
    for (int i = 0; i < numInts; i++) {
        response[i] = p.readInt();
    }
    return response;
}
#end_block

#method_before
private Object responseVoid(Parcel p) {
    return null;
}
#method_after
protected Object responseVoid(Parcel p) {
    return null;
}
#end_block

#method_before
private Object responseCallForward(Parcel p) {
    int numInfos;
    CallForwardInfo[] infos;
    numInfos = p.readInt();
    infos = new CallForwardInfo[numInfos];
    for (int i = 0; i < numInfos; i++) {
        infos[i] = new CallForwardInfo();
        infos[i].status = p.readInt();
        infos[i].reason = p.readInt();
        infos[i].serviceClass = p.readInt();
        infos[i].toa = p.readInt();
        infos[i].number = p.readString();
        infos[i].timeSeconds = p.readInt();
    }
    return infos;
}
#method_after
protected Object responseCallForward(Parcel p) {
    int numInfos;
    CallForwardInfo[] infos;
    numInfos = p.readInt();
    infos = new CallForwardInfo[numInfos];
    for (int i = 0; i < numInfos; i++) {
        infos[i] = new CallForwardInfo();
        infos[i].status = p.readInt();
        infos[i].reason = p.readInt();
        infos[i].serviceClass = p.readInt();
        infos[i].toa = p.readInt();
        infos[i].number = p.readString();
        infos[i].timeSeconds = p.readInt();
    }
    return infos;
}
#end_block

#method_before
private Object responseSuppServiceNotification(Parcel p) {
    SuppServiceNotification notification = new SuppServiceNotification();
    notification.notificationType = p.readInt();
    notification.code = p.readInt();
    notification.index = p.readInt();
    notification.type = p.readInt();
    notification.number = p.readString();
    return notification;
}
#method_after
protected Object responseSuppServiceNotification(Parcel p) {
    SuppServiceNotification notification = new SuppServiceNotification();
    notification.notificationType = p.readInt();
    notification.code = p.readInt();
    notification.index = p.readInt();
    notification.type = p.readInt();
    notification.number = p.readString();
    return notification;
}
#end_block

#method_before
private Object responseCdmaSms(Parcel p) {
    SmsMessage sms;
    sms = SmsMessage.newFromParcel(p);
    return sms;
}
#method_after
protected Object responseCdmaSms(Parcel p) {
    SmsMessage sms;
    sms = SmsMessage.newFromParcel(p);
    return sms;
}
#end_block

#method_before
private Object responseString(Parcel p) {
    String response;
    response = p.readString();
    return response;
}
#method_after
protected Object responseString(Parcel p) {
    String response;
    response = p.readString();
    return response;
}
#end_block

#method_before
private Object responseStrings(Parcel p) {
    int num;
    String[] response;
    response = p.readStringArray();
    return response;
}
#method_after
protected Object responseStrings(Parcel p) {
    int num;
    String[] response;
    response = p.readStringArray();
    return response;
}
#end_block

#method_before
private Object responseRaw(Parcel p) {
    int num;
    byte[] response;
    response = p.createByteArray();
    return response;
}
#method_after
protected Object responseRaw(Parcel p) {
    int num;
    byte[] response;
    response = p.createByteArray();
    return response;
}
#end_block

#method_before
private Object responseSMS(Parcel p) {
    int messageRef, errorCode;
    String ackPDU;
    messageRef = p.readInt();
    ackPDU = p.readString();
    errorCode = p.readInt();
    SmsResponse response = new SmsResponse(messageRef, ackPDU, errorCode);
    return response;
}
#method_after
protected Object responseSMS(Parcel p) {
    int messageRef, errorCode;
    String ackPDU;
    messageRef = p.readInt();
    ackPDU = p.readString();
    errorCode = p.readInt();
    SmsResponse response = new SmsResponse(messageRef, ackPDU, errorCode);
    return response;
}
#end_block

#method_before
private Object responseICC_IO(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, s);
}
#method_after
protected Object responseICC_IO(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, s);
}
#end_block

#method_before
private Object responseICC_IOBase64(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, (s != null) ? android.util.Base64.decode(s, android.util.Base64.DEFAULT) : (byte[]) null);
}
#method_after
protected Object responseICC_IOBase64(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, (s != null) ? android.util.Base64.decode(s, android.util.Base64.DEFAULT) : (byte[]) null);
}
#end_block

#method_before
private Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus;
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    cardStatus.mImsSubscriptionAppIndex = p.readInt();
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    for (int i = 0; i < numApplications; i++) {
        appStatus = new IccCardApplicationStatus();
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        cardStatus.mApplications[i] = appStatus;
    }
    return cardStatus;
}
#method_after
protected Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus;
    boolean oldRil = needsOldRilFeature("icccardstatus");
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    if (!oldRil)
        cardStatus.mImsSubscriptionAppIndex = p.readInt();
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    for (int i = 0; i < numApplications; i++) {
        appStatus = new IccCardApplicationStatus();
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        cardStatus.mApplications[i] = appStatus;
    }
    return cardStatus;
}
#end_block

#method_before
private Object responseSimRefresh(Parcel p) {
    IccRefreshResponse response = new IccRefreshResponse();
    response.refreshResult = p.readInt();
    response.efId = p.readInt();
    response.aid = p.readString();
    return response;
}
#method_after
protected Object responseSimRefresh(Parcel p) {
    IccRefreshResponse response = new IccRefreshResponse();
    response.refreshResult = p.readInt();
    response.efId = p.readInt();
    response.aid = p.readString();
    return response;
}
#end_block

#method_before
private Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt();
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 == voiceSettings) ? false : true;
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        // according to ril.h, namePresentation should be handled as numberPresentation;
        dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#method_after
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt();
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 == voiceSettings) ? false : true;
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        // according to ril.h, namePresentation should be handled as numberPresentation;
        dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#end_block

#method_before
private DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
    } else {
        dataCall.status = p.readInt();
        dataCall.suggestedRetryTime = p.readInt();
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#method_after
protected DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        if (version < 4 || needsOldRilFeature("datacallapn")) {
            // APN - not used
            p.readString();
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        // DataCallState needs an ifname. Since we don't have one use the name from the ThrottleService resource (default=rmnet0).
        dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
    } else {
        dataCall.status = p.readInt();
        if (needsOldRilFeature("usehcradio"))
            dataCall.suggestedRetryTime = -1;
        else
            dataCall.suggestedRetryTime = p.readInt();
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#end_block

#method_before
private Object responseDataCallList(Parcel p) {
    ArrayList<DataCallResponse> response;
    int ver = p.readInt();
    int num = p.readInt();
    riljLog("responseDataCallList ver=" + ver + " num=" + num);
    response = new ArrayList<DataCallResponse>(num);
    for (int i = 0; i < num; i++) {
        response.add(getDataCallResponse(p, ver));
    }
    return response;
}
#method_after
protected Object responseDataCallList(Parcel p) {
    ArrayList<DataCallResponse> response;
    boolean oldRil = needsOldRilFeature("datacall");
    int ver = (oldRil ? 3 : p.readInt());
    int num = p.readInt();
    riljLog("responseDataCallList ver=" + ver + " num=" + num);
    response = new ArrayList<DataCallResponse>(num);
    for (int i = 0; i < num; i++) {
        response.add(getDataCallResponse(p, ver));
    }
    return response;
}
#end_block

#method_before
private Object responseSetupDataCall(Parcel p) {
    int ver = p.readInt();
    int num = p.readInt();
    if (RILJ_LOGV)
        riljLog("responseSetupDataCall ver=" + ver + " num=" + num);
    DataCallResponse dataCall;
    if (ver < 5) {
        dataCall = new DataCallResponse();
        dataCall.version = ver;
        dataCall.cid = Integer.parseInt(p.readString());
        dataCall.ifname = p.readString();
        if (TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        if (num >= 4) {
            String dnses = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got dnses=" + dnses);
            if (!TextUtils.isEmpty(dnses)) {
                dataCall.dnses = dnses.split(" ");
            }
        }
        if (num >= 5) {
            String gateways = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got gateways=" + gateways);
            if (!TextUtils.isEmpty(gateways)) {
                dataCall.gateways = gateways.split(" ");
            }
        }
        if (num >= 6) {
            String pcscf = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got pcscf=" + pcscf);
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
    } else {
        if (num != 1) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response expecting 1 RIL_Data_Call_response_v5" + " got " + num);
        }
        dataCall = getDataCallResponse(p, ver);
    }
    return dataCall;
}
#method_after
protected Object responseSetupDataCall(Parcel p) {
    boolean oldRil = needsOldRilFeature("datacall");
    int ver = (oldRil ? 3 : p.readInt());
    int num = p.readInt();
    if (RILJ_LOGV)
        riljLog("responseSetupDataCall ver=" + ver + " num=" + num);
    DataCallResponse dataCall;
    if (ver < 5) {
        dataCall = new DataCallResponse();
        dataCall.version = ver;
        dataCall.cid = Integer.parseInt(p.readString());
        dataCall.ifname = p.readString();
        if (TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        if (num >= 4) {
            String dnses = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got dnses=" + dnses);
            if (!TextUtils.isEmpty(dnses)) {
                dataCall.dnses = dnses.split(" ");
            }
        }
        if (num >= 5) {
            String gateways = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got gateways=" + gateways);
            if (!TextUtils.isEmpty(gateways)) {
                dataCall.gateways = gateways.split(" ");
            }
        }
        if (num >= 6) {
            String pcscf = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got pcscf=" + pcscf);
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
    } else {
        if (num != 1) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response expecting 1 RIL_Data_Call_response_v5" + " got " + num);
        }
        dataCall = getDataCallResponse(p, ver);
    }
    return dataCall;
}
#end_block

#method_before
private Object responseOperatorInfos(Parcel p) {
    String[] strings = (String[]) responseStrings(p);
    ArrayList<OperatorInfo> ret;
    if (strings.length % 4 != 0) {
        throw new RuntimeException("RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got " + strings.length + " strings, expected multible of 4");
    }
    ret = new ArrayList<OperatorInfo>(strings.length / 4);
    for (int i = 0; i < strings.length; i += 4) {
        ret.add(new OperatorInfo(strings[i + 0], strings[i + 1], strings[i + 2], strings[i + 3]));
    }
    return ret;
}
#method_after
protected Object responseOperatorInfos(Parcel p) {
    String[] strings = (String[]) responseStrings(p);
    ArrayList<OperatorInfo> ret;
    if (strings.length % mQANElements != 0) {
        throw new RuntimeException("RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got " + strings.length + " strings, expected multiple of " + mQANElements);
    }
    ret = new ArrayList<OperatorInfo>(strings.length / mQANElements);
    for (int i = 0; i < strings.length; i += mQANElements) {
        ret.add(new OperatorInfo(strings[i + 0], strings[i + 1], strings[i + 2], strings[i + 3]));
    }
    return ret;
}
#end_block

#method_before
private Object responseCellList(Parcel p) {
    int num, rssi;
    String location;
    ArrayList<NeighboringCellInfo> response;
    NeighboringCellInfo cell;
    num = p.readInt();
    response = new ArrayList<NeighboringCellInfo>();
    // Determine the radio access type
    int[] subId = SubscriptionManager.getSubId(mInstanceId);
    int radioType = ((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).getDataNetworkType(subId[0]);
    // Interpret the location based on radio access type
    if (radioType != NETWORK_TYPE_UNKNOWN) {
        for (int i = 0; i < num; i++) {
            rssi = p.readInt();
            location = p.readString();
            cell = new NeighboringCellInfo(rssi, location, radioType);
            response.add(cell);
        }
    }
    return response;
}
#method_after
protected Object responseCellList(Parcel p) {
    int num, rssi;
    String location;
    ArrayList<NeighboringCellInfo> response;
    NeighboringCellInfo cell;
    num = p.readInt();
    response = new ArrayList<NeighboringCellInfo>();
    // Determine the radio access type
    int[] subId = SubscriptionManager.getSubId(mInstanceId);
    int radioType = ((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).getDataNetworkType(subId[0]);
    // Interpret the location based on radio access type
    if (radioType != NETWORK_TYPE_UNKNOWN) {
        for (int i = 0; i < num; i++) {
            rssi = p.readInt();
            location = p.readString();
            cell = new NeighboringCellInfo(rssi, location, radioType);
            response.add(cell);
        }
    }
    return response;
}
#end_block

#method_before
private Object responseGetPreferredNetworkType(Parcel p) {
    int[] response = (int[]) responseInts(p);
    if (response.length >= 1) {
        // Since this is the response for getPreferredNetworkType
        // we'll assume that it should be the value we want the
        // vendor ril to take if we reestablish a connection to it.
        mPreferredNetworkType = response[0];
    }
    return response;
}
#method_after
protected Object responseGetPreferredNetworkType(Parcel p) {
    int[] response = (int[]) responseInts(p);
    if (response.length >= 1) {
        // Since this is the response for getPreferredNetworkType
        // we'll assume that it should be the value we want the
        // vendor ril to take if we reestablish a connection to it.
        mPreferredNetworkType = response[0];
    }
    return response;
}
#end_block

#method_before
private Object responseGmsBroadcastConfig(Parcel p) {
    int num;
    ArrayList<SmsBroadcastConfigInfo> response;
    SmsBroadcastConfigInfo info;
    num = p.readInt();
    response = new ArrayList<SmsBroadcastConfigInfo>(num);
    for (int i = 0; i < num; i++) {
        int fromId = p.readInt();
        int toId = p.readInt();
        int fromScheme = p.readInt();
        int toScheme = p.readInt();
        boolean selected = (p.readInt() == 1);
        info = new SmsBroadcastConfigInfo(fromId, toId, fromScheme, toScheme, selected);
        response.add(info);
    }
    return response;
}
#method_after
protected Object responseGmsBroadcastConfig(Parcel p) {
    int num;
    ArrayList<SmsBroadcastConfigInfo> response;
    SmsBroadcastConfigInfo info;
    num = p.readInt();
    response = new ArrayList<SmsBroadcastConfigInfo>(num);
    for (int i = 0; i < num; i++) {
        int fromId = p.readInt();
        int toId = p.readInt();
        int fromScheme = p.readInt();
        int toScheme = p.readInt();
        boolean selected = (p.readInt() == 1);
        info = new SmsBroadcastConfigInfo(fromId, toId, fromScheme, toScheme, selected);
        response.add(info);
    }
    return response;
}
#end_block

#method_before
private Object responseCdmaBroadcastConfig(Parcel p) {
    int numServiceCategories;
    int[] response;
    numServiceCategories = p.readInt();
    if (numServiceCategories == 0) {
        // TODO: The logic of providing default values should
        // not be done by this transport layer. And needs to
        // be done by the vendor ril or application logic.
        int numInts;
        numInts = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES * CDMA_BSI_NO_OF_INTS_STRUCT + 1;
        response = new int[numInts];
        // Faking a default record for all possible records.
        response[0] = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES;
        // default language and selection status to false for all.
        for (int i = 1; i < numInts; i += CDMA_BSI_NO_OF_INTS_STRUCT) {
            response[i + 0] = i / CDMA_BSI_NO_OF_INTS_STRUCT;
            response[i + 1] = 1;
            response[i + 2] = 0;
        }
    } else {
        int numInts;
        numInts = (numServiceCategories * CDMA_BSI_NO_OF_INTS_STRUCT) + 1;
        response = new int[numInts];
        response[0] = numServiceCategories;
        for (int i = 1; i < numInts; i++) {
            response[i] = p.readInt();
        }
    }
    return response;
}
#method_after
protected Object responseCdmaBroadcastConfig(Parcel p) {
    int numServiceCategories;
    int[] response;
    numServiceCategories = p.readInt();
    if (numServiceCategories == 0) {
        // TODO: The logic of providing default values should
        // not be done by this transport layer. And needs to
        // be done by the vendor ril or application logic.
        int numInts;
        numInts = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES * CDMA_BSI_NO_OF_INTS_STRUCT + 1;
        response = new int[numInts];
        // Faking a default record for all possible records.
        response[0] = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES;
        // default language and selection status to false for all.
        for (int i = 1; i < numInts; i += CDMA_BSI_NO_OF_INTS_STRUCT) {
            response[i + 0] = i / CDMA_BSI_NO_OF_INTS_STRUCT;
            response[i + 1] = 1;
            response[i + 2] = 0;
        }
    } else {
        int numInts;
        numInts = (numServiceCategories * CDMA_BSI_NO_OF_INTS_STRUCT) + 1;
        response = new int[numInts];
        response[0] = numServiceCategories;
        for (int i = 1; i < numInts; i++) {
            response[i] = p.readInt();
        }
    }
    return response;
}
#end_block

#method_before
private Object responseSignalStrength(Parcel p) {
    // Assume this is gsm, but doesn't matter as ServiceStateTracker
    // sets the proper value.
    SignalStrength signalStrength = SignalStrength.makeSignalStrengthFromRilParcel(p);
    return signalStrength;
}
#method_after
protected Object responseSignalStrength(Parcel p) {
    // Assume this is gsm, but doesn't matter as ServiceStateTracker
    // sets the proper value.
    SignalStrength signalStrength = SignalStrength.makeSignalStrengthFromRilParcel(p);
    return signalStrength;
}
#end_block

#method_before
private ArrayList<CdmaInformationRecords> responseCdmaInformationRecord(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CdmaInformationRecords> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CdmaInformationRecords>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CdmaInformationRecords InfoRec = new CdmaInformationRecords(p);
        response.add(InfoRec);
    }
    return response;
}
#method_after
protected ArrayList<CdmaInformationRecords> responseCdmaInformationRecord(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CdmaInformationRecords> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CdmaInformationRecords>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CdmaInformationRecords InfoRec = new CdmaInformationRecords(p);
        response.add(InfoRec);
    }
    return response;
}
#end_block

#method_before
private Object responseCdmaCallWaiting(Parcel p) {
    CdmaCallWaitingNotification notification = new CdmaCallWaitingNotification();
    notification.number = p.readString();
    notification.numberPresentation = CdmaCallWaitingNotification.presentationFromCLIP(p.readInt());
    notification.name = p.readString();
    notification.namePresentation = notification.numberPresentation;
    notification.isPresent = p.readInt();
    notification.signalType = p.readInt();
    notification.alertPitch = p.readInt();
    notification.signal = p.readInt();
    notification.numberType = p.readInt();
    notification.numberPlan = p.readInt();
    return notification;
}
#method_after
protected Object responseCdmaCallWaiting(Parcel p) {
    CdmaCallWaitingNotification notification = new CdmaCallWaitingNotification();
    notification.number = p.readString();
    notification.numberPresentation = CdmaCallWaitingNotification.presentationFromCLIP(p.readInt());
    notification.name = p.readString();
    notification.namePresentation = notification.numberPresentation;
    notification.isPresent = p.readInt();
    notification.signalType = p.readInt();
    notification.alertPitch = p.readInt();
    notification.signal = p.readInt();
    notification.numberType = p.readInt();
    notification.numberPlan = p.readInt();
    return notification;
}
#end_block

#method_before
private Object responseCallRing(Parcel p) {
    char[] response = new char[4];
    // isPresent
    response[0] = (char) p.readInt();
    // signalType
    response[1] = (char) p.readInt();
    // alertPitch
    response[2] = (char) p.readInt();
    // signal
    response[3] = (char) p.readInt();
    return response;
}
#method_after
protected Object responseCallRing(Parcel p) {
    char[] response = new char[4];
    // isPresent
    response[0] = (char) p.readInt();
    // signalType
    response[1] = (char) p.readInt();
    // alertPitch
    response[2] = (char) p.readInt();
    // signal
    response[3] = (char) p.readInt();
    return response;
}
#end_block

#method_before
private void notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
    int response = RIL_UNSOL_CDMA_INFO_REC;
    if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
        if (mDisplayInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mDisplayInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaSignalInfoRec) {
        if (mSignalInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mSignalInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaNumberInfoRec) {
        if (mNumberInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mNumberInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaRedirectingNumberInfoRec) {
        if (mRedirNumInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mRedirNumInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaLineControlInfoRec) {
        if (mLineControlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mLineControlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53ClirInfoRec) {
        if (mT53ClirInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53ClirInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53AudioControlInfoRec) {
        if (mT53AudCntrlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53AudCntrlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    }
}
#method_after
protected void notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
    int response = RIL_UNSOL_CDMA_INFO_REC;
    if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
        if (mDisplayInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mDisplayInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaSignalInfoRec) {
        if (mSignalInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mSignalInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaNumberInfoRec) {
        if (mNumberInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mNumberInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaRedirectingNumberInfoRec) {
        if (mRedirNumInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mRedirNumInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaLineControlInfoRec) {
        if (mLineControlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mLineControlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53ClirInfoRec) {
        if (mT53ClirInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53ClirInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53AudioControlInfoRec) {
        if (mT53AudCntrlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53AudCntrlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    }
}
#end_block

#method_before
private ArrayList<CellInfo> responseCellInfoList(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CellInfo> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CellInfo>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        response.add(InfoRec);
    }
    return response;
}
#method_after
protected ArrayList<CellInfo> responseCellInfoList(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CellInfo> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CellInfo>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        response.add(InfoRec);
    }
    return response;
}
#end_block

#method_before
private Object responseHardwareConfig(Parcel p) {
    int num;
    ArrayList<HardwareConfig> response;
    HardwareConfig hw;
    num = p.readInt();
    response = new ArrayList<HardwareConfig>(num);
    if (RILJ_LOGV) {
        riljLog("responseHardwareConfig: num=" + num);
    }
    for (int i = 0; i < num; i++) {
        int type = p.readInt();
        switch(type) {
            case HardwareConfig.DEV_HARDWARE_TYPE_MODEM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignModem(p.readString(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt());
                    break;
                }
            case HardwareConfig.DEV_HARDWARE_TYPE_SIM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignSim(p.readString(), p.readInt(), p.readString());
                    break;
                }
            default:
                {
                    throw new RuntimeException("RIL_REQUEST_GET_HARDWARE_CONFIG invalid hardward type:" + type);
                }
        }
        response.add(hw);
    }
    return response;
}
#method_after
protected Object responseHardwareConfig(Parcel p) {
    int num;
    ArrayList<HardwareConfig> response;
    HardwareConfig hw;
    num = p.readInt();
    response = new ArrayList<HardwareConfig>(num);
    if (RILJ_LOGV) {
        riljLog("responseHardwareConfig: num=" + num);
    }
    for (int i = 0; i < num; i++) {
        int type = p.readInt();
        switch(type) {
            case HardwareConfig.DEV_HARDWARE_TYPE_MODEM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignModem(p.readString(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt());
                    break;
                }
            case HardwareConfig.DEV_HARDWARE_TYPE_SIM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignSim(p.readString(), p.readInt(), p.readString());
                    break;
                }
            default:
                {
                    throw new RuntimeException("RIL_REQUEST_GET_HARDWARE_CONFIG invalid hardward type:" + type);
                }
        }
        response.add(hw);
    }
    return response;
}
#end_block

#method_before
private void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
protected void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#end_block

#method_before
private void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
protected void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#end_block

#method_before
private void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#method_after
protected void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#end_block

#method_before
private void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#method_after
protected void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#end_block

#method_before
private void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
protected void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
private void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
protected void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
@Override
public void iccOpenLogicalChannel(String AID, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL, response);
    rr.mParcel.writeString(AID);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void iccOpenLogicalChannel(String AID, Message response) {
    if (mRilVersion < 10) {
        if (response != null) {
            CommandException ex = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response, null, ex);
            response.sendToTarget();
        }
        return;
    }
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL, response);
    rr.mParcel.writeString(AID);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

#method_before
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    iccTransmitApduHelper(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, channel, cla, instruction, p1, p2, p3, data, response);
}
#method_after
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    if (mRilVersion < 10) {
        if (response != null) {
            CommandException ex = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response, null, ex);
            response.sendToTarget();
        }
        return;
    }
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    iccTransmitApduHelper(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, channel, cla, instruction, p1, p2, p3, data, response);
}
#end_block

#method_before
private void iccTransmitApduHelper(int rilCommand, int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    RILRequest rr = RILRequest.obtain(rilCommand, response);
    rr.mParcel.writeInt(channel);
    rr.mParcel.writeInt(cla);
    rr.mParcel.writeInt(instruction);
    rr.mParcel.writeInt(p1);
    rr.mParcel.writeInt(p2);
    rr.mParcel.writeInt(p3);
    rr.mParcel.writeString(data);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
private void iccTransmitApduHelper(int rilCommand, int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    if (mRilVersion < 10) {
        if (response != null) {
            CommandException ex = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response, null, ex);
            response.sendToTarget();
        }
        return;
    }
    RILRequest rr = RILRequest.obtain(rilCommand, response);
    rr.mParcel.writeInt(channel);
    rr.mParcel.writeInt(cla);
    rr.mParcel.writeInt(instruction);
    rr.mParcel.writeInt(p1);
    rr.mParcel.writeInt(p2);
    rr.mParcel.writeInt(p3);
    rr.mParcel.writeString(data);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

#method_before
@Override
protected void pollStateDone() {
    updateRoamingState();
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    log("pollStateDone: lte 1 ss=[" + mSS + "] newSS=[" + mNewSS + "]");
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((isRatLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && isRatLte(mNewSS.getRilDataRadioTechnology())));
    boolean hasMultiApnSupport = ((isRatLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!isRatLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
    boolean hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeegistered=" + hasDeregistered + " hasCdmaDataConnectionAttached=" + hasCdmaDataConnectionAttached + " hasCdmaDataConnectionDetached=" + hasCdmaDataConnectionDetached + " hasCdmaDataConnectionChanged=" + hasCdmaDataConnectionChanged + " hasVoiceRadioTechnologyChanged= " + hasVoiceRadioTechnologyChanged + " hasDataRadioTechnologyChanged=" + hasDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState() || mSS.getDataRegState() != mNewSS.getDataRegState()) {
        EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    ServiceState tss;
    tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    CdmaCellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    if (hasVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
    }
    if (hasChanged) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) == null ? false : (mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null);
        boolean forceEriFromXml = SystemProperties.getBoolean("ro.ril.force_eri_from_xml", false);
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!isRatLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name)) && (!mIsSubscriptionFromRuim || forceEriFromXml)) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlphaLong();
            // new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && ((mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) || (mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE)) && !isRatLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null && !TextUtils.isEmpty(mIccRecords.getServiceProviderName())) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
        String operatorNumeric;
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        // try to fix the invalid Operator Numeric
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            int sid = mSS.getSystemId();
            operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric is null");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
        } else {
            String isoCountryCode = "";
            String mcc = operatorNumeric.substring(0, 3);
            try {
                isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
            } catch (NumberFormatException ex) {
                loge("countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
            mGotCountryCode = true;
            setOperatorIdd(operatorNumeric);
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZone)) {
                fixTimeZone(isoCountryCode);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        updateSpnDisplay();
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
    }
    // data call on "attached" notification.
    if (hasCdmaDataConnectionDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if ((hasCdmaDataConnectionChanged || hasDataRadioTechnologyChanged)) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasCdmaDataConnectionAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (hasCssIndicatorChanged) {
        mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
    }
    ArrayList<CellInfo> arrayCi = new ArrayList<CellInfo>();
    synchronized (mCellInfo) {
        CellInfoLte cil = (CellInfoLte) mCellInfo;
        boolean cidChanged = !mNewCellIdentityLte.equals(mLasteCellIdentityLte);
        if (hasRegistered || hasDeregistered || cidChanged) {
            // TODO: Handle the absence of LteCellIdentity
            long timeStamp = SystemClock.elapsedRealtime() * 1000;
            boolean registered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
            mLasteCellIdentityLte = mNewCellIdentityLte;
            cil.setRegistered(registered);
            cil.setCellIdentity(mLasteCellIdentityLte);
            if (DBG) {
                log("pollStateDone: hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " cidChanged=" + cidChanged + " mCellInfo=" + mCellInfo);
            }
            arrayCi.add(mCellInfo);
        }
        mPhoneBase.notifyCellInfo(arrayCi);
    }
}
#method_after
@Override
protected void pollStateDone() {
    updateRoamingState();
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    log("pollStateDone: lte 1 ss=[" + mSS + "] newSS=[" + mNewSS + "]");
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((isRatLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && isRatLte(mNewSS.getRilDataRadioTechnology())));
    boolean hasMultiApnSupport = ((isRatLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!isRatLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
    boolean hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeegistered=" + hasDeregistered + " hasCdmaDataConnectionAttached=" + hasCdmaDataConnectionAttached + " hasCdmaDataConnectionDetached=" + hasCdmaDataConnectionDetached + " hasCdmaDataConnectionChanged=" + hasCdmaDataConnectionChanged + " hasVoiceRadioTechnologyChanged= " + hasVoiceRadioTechnologyChanged + " hasDataRadioTechnologyChanged=" + hasDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState() || mSS.getDataRegState() != mNewSS.getDataRegState()) {
        EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    ServiceState tss;
    tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    CdmaCellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    if (hasVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
    }
    if (hasChanged) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) == null ? false : (mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null);
        boolean forceEriFromXml = SystemProperties.getBoolean("ro.ril.force_eri_from_xml", false);
        if ((!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!isRatLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name)) && !mIsSubscriptionFromRuim) || forceEriFromXml) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlphaLong();
            // new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && ((mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) || (mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE)) && !isRatLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null && !TextUtils.isEmpty(mIccRecords.getServiceProviderName())) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
        String operatorNumeric;
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        // try to fix the invalid Operator Numeric
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            int sid = mSS.getSystemId();
            operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric is null");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
        } else {
            String isoCountryCode = "";
            String mcc = operatorNumeric.substring(0, 3);
            try {
                isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
            } catch (NumberFormatException ex) {
                loge("countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
            mGotCountryCode = true;
            setOperatorIdd(operatorNumeric);
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZone)) {
                fixTimeZone(isoCountryCode);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        updateSpnDisplay();
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
    }
    // data call on "attached" notification.
    if (hasCdmaDataConnectionDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if ((hasCdmaDataConnectionChanged || hasDataRadioTechnologyChanged)) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasCdmaDataConnectionAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (hasCssIndicatorChanged) {
        mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
    }
    ArrayList<CellInfo> arrayCi = new ArrayList<CellInfo>();
    synchronized (mCellInfo) {
        CellInfoLte cil = (CellInfoLte) mCellInfo;
        boolean cidChanged = !mNewCellIdentityLte.equals(mLasteCellIdentityLte);
        if (hasRegistered || hasDeregistered || cidChanged) {
            // TODO: Handle the absence of LteCellIdentity
            long timeStamp = SystemClock.elapsedRealtime() * 1000;
            boolean registered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
            mLasteCellIdentityLte = mNewCellIdentityLte;
            cil.setRegistered(registered);
            cil.setCellIdentity(mLasteCellIdentityLte);
            if (DBG) {
                log("pollStateDone: hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " cidChanged=" + cidChanged + " mCellInfo=" + mCellInfo);
            }
            arrayCi.add(mCellInfo);
        }
        mPhoneBase.notifyCellInfo(arrayCi);
    }
}
#end_block

#method_before
protected void onProcessRequest() {
    // process all requests
    // 1. Check all requests and find subscription of the top priority
    // request
    // 2. Is current data allowed on the selected subscription
    // 2-1. If yes, execute all the requests of the sub
    // 2-2. If no, set data not allow on the current PS subscription
    // 2-2-1. Set data allow on the selected subscription
    int requestedPhoneId = getTopPriorityRequestPhoneId();
    int activePhoneId = getActivePhoneId();
    logd("onProcessRequest requestedPhoneId=" + requestedPhoneId + ", activePhoneId=" + activePhoneId);
    if (requestedPhoneId == INVALID_PHONE_INDEX) {
        // we have no network request - don't bother with this
        return;
    }
    // if we have no active phones or the active phone is the desired, make requests
    if (activePhoneId == INVALID_PHONE_INDEX || activePhoneId == requestedPhoneId) {
        Iterator<Integer> iterator = mRequestInfos.get(requestedPhoneId).keySet().iterator();
        while (iterator.hasNext()) {
            RequestInfo requestInfo = mRequestInfos.get(requestedPhoneId).get(iterator.next());
            if (getRequestPhoneId(requestInfo.request) == requestedPhoneId && !requestInfo.executed) {
                mDcSwitchAsyncChannel[requestedPhoneId].connect(requestInfo);
                Phone phone = mPhones[requestedPhoneId].getActivePhone();
                if ((phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) && (activePhoneId == -1)) {
                    /* Traditionally modem reports data registered on CDMA sub even when it is
                         * non-dds because CDMA network does not have PS ATTACH/DETACH concept.
                         *
                         * So when CDMA sub becomes DDS from non-dds the state-machine is expacting
                         * onDataConnectionAttach() call from serviceStateTracker. It would never
                         * happen since cdma SST did not notice change in registration during DDS
                         * switch.
                         *
                         * Hence we need to fake the ATTACH to move/progress DcSwitchStateMachine.
                         */
                    logd("Active phone is CDMA, fake ATTACH");
                    mDcSwitchAsyncChannel[requestedPhoneId].notifyDataAttached();
                }
            }
        }
    } else {
        mDcSwitchAsyncChannel[activePhoneId].disconnectAll();
    }
}
#method_after
protected void onProcessRequest() {
    // process all requests
    // 1. Check all requests and find subscription of the top priority
    // request
    // 2. Is current data allowed on the selected subscription
    // 2-1. If yes, execute all the requests of the sub
    // 2-2. If no, set data not allow on the current PS subscription
    // 2-2-1. Set data allow on the selected subscription
    int requestedPhoneId = getTopPriorityRequestPhoneId();
    int activePhoneId = INVALID_PHONE_INDEX;
    for (int i = 0; i < mDcSwitchStateMachine.length; i++) {
        if (!mDcSwitchAsyncChannel[i].isIdleSync()) {
            activePhoneId = i;
            break;
        }
    }
    logd("onProcessRequest requestedPhoneId=" + requestedPhoneId + ", activePhoneId=" + activePhoneId);
    if (requestedPhoneId == INVALID_PHONE_INDEX) {
        // we have no network request - don't bother with this
        return;
    }
    // if we have no active phones or the active phone is the desired, make requests
    if (activePhoneId == INVALID_PHONE_INDEX || activePhoneId == requestedPhoneId) {
        Iterator<Integer> iterator = mRequestInfos.get(requestedPhoneId).keySet().iterator();
        while (iterator.hasNext()) {
            RequestInfo requestInfo = mRequestInfos.get(requestedPhoneId).get(iterator.next());
            if (getRequestPhoneId(requestInfo.request) == requestedPhoneId && !requestInfo.executed) {
                mDcSwitchAsyncChannel[requestedPhoneId].connect(requestInfo);
                Phone phone = mPhones[requestedPhoneId].getActivePhone();
                if ((phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) && (activePhoneId == -1)) {
                    /* Traditionally modem reports data registered on CDMA sub even when it is
                         * non-dds because CDMA network does not have PS ATTACH/DETACH concept.
                         *
                         * So when CDMA sub becomes DDS from non-dds the state-machine is expacting
                         * onDataConnectionAttach() call from serviceStateTracker. It would never
                         * happen since cdma SST did not notice change in registration during DDS
                         * switch.
                         *
                         * Hence we need to fake the ATTACH to move/progress DcSwitchStateMachine.
                         */
                    logd("Active phone is CDMA, fake ATTACH");
                    mDcSwitchAsyncChannel[requestedPhoneId].notifyDataAttached();
                }
            }
        }
    } else {
        mDcSwitchAsyncChannel[activePhoneId].disconnectAll();
    }
}
#end_block

#method_before
protected void onSettingsChanged() {
    // Sub Selection
    int dataSubId = mSubController.getDefaultDataSubId();
    int activePhoneId = getActivePhoneId();
    logd("onSettingsChange, activePhoneId = " + activePhoneId);
    deactivateDdsRequests();
    // Try to handle pending request when settings changed
    for (int i = 0; i < mPhoneNum; ++i) {
        ((DctController.TelephonyNetworkFactory) mNetworkFactory[i]).evalPendingRequest();
    }
    processRequests();
}
#method_after
protected void onSettingsChanged() {
    // Sub Selection
    int dataSubId = mSubController.getDefaultDataSubId();
    int activePhoneId = -1;
    for (int i = 0; i < mDcSwitchStateMachine.length; i++) {
        if (!mDcSwitchAsyncChannel[i].isIdleSync()) {
            activePhoneId = i;
            break;
        }
    }
    logd("onSettingsChange, activePhoneId = " + activePhoneId);
    deactivateDdsRequests();
    // Try to handle pending request when settings changed
    for (int i = 0; i < mPhoneNum; ++i) {
        ((DctController.TelephonyNetworkFactory) mNetworkFactory[i]).evalPendingRequest();
    }
    processRequests();
}
#end_block

#method_before
public void setSMSPromptEnabled(boolean bool) {
    ISms iccISms = null;
    try {
        iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
        iccISms.setSMSPromptEnabled(bool);
    } catch (RemoteException ex) {
    // ignore it
    }
}
#method_after
public void setSMSPromptEnabled(boolean bool) {
    ISms iccISms = null;
    try {
        iccISms = ISms.Stub.asInterface(ServiceManager.getService("isms"));
        iccISms.setSMSPromptEnabled(bool);
    } catch (RemoteException ex) {
    // ignore it
    } catch (NullPointerException ex) {
    // ignore it
    }
}
#end_block

#method_before
private void setDefaultDataSubNetworkType(int slotId, int subId) {
    if (subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
        Rlog.e(LOG_TAG, "setDefaultDataSubNetworkType called with DEFAULT_SUB_ID");
        return;
    }
    int networkType = RILConstants.PREFERRED_NETWORK_MODE;
    // to be more relevant instead of default mode
    try {
        networkType = android.provider.Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId);
    } catch (SettingNotFoundException snfe) {
        logd("Settings Exception reading value at subid for" + " Settings.Global.PREFERRED_NETWORK_MODE");
        try {
            networkType = TelephonyManager.getIntAtIndex(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, slotId);
        } catch (SettingNotFoundException retrySnfe) {
            Rlog.d(LOG_TAG, "Settings Exception Reading Value At Index for" + " Settings.Global.PREFERRED_NETWORK_MODE");
        }
    }
    // Get users NW type, let it override if need be
    int userNwType = SubscriptionController.getInstance().getUserNwMode(subId);
    if (userNwType != networkType) {
        networkType = userNwType;
    }
    boolean isDsds = TelephonyManager.getDefault().getMultiSimConfiguration() == TelephonyManager.MultiSimVariants.DSDS;
    if (DBG)
        Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] subId=" + subId);
    if (DBG)
        Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] isDSDS=" + isDsds);
    boolean isMultiRat = SystemProperties.getBoolean("ro.ril.multi_rat_capable", false);
    if (isDsds && !isMultiRat) {
        // Hardcoded due to modem limitation
        int networkType2 = Phone.NT_MODE_GSM_ONLY;
        int slotId1 = SubscriptionManager.DEFAULT_SIM_SLOT_INDEX;
        int slotId2 = SubscriptionManager.DEFAULT_SIM_SLOT_INDEX;
        int subId1 = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
        int subId2 = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
        // Since this is DSDS, there are 2 phones
        for (int targetSlotId = 0; targetSlotId < PROJECT_SIM_NUM; targetSlotId++) {
            Phone phone = mPhone[targetSlotId];
            int id = phone.getSubId();
            if (id == subId) {
                slotId1 = targetSlotId;
                subId1 = id;
                if (DBG)
                    Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] networkType1: " + networkType + ", slotId1: " + slotId1);
            } else {
                subId2 = id;
                slotId2 = targetSlotId;
                if (DBG)
                    Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] networkType2: " + networkType2 + ", slotId2: " + slotId2);
            }
        }
        setPreferredNwModeForSlot(slotId1, subId1, networkType);
        setPreferredNwModeForSlot(slotId2, subId2, networkType2);
    } else {
        // Set the modem network mode
        setPreferredNwModeForSlot(slotId, subId, networkType);
    }
    // Only support automatic selection mode on SIM change.
    mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
}
#method_after
private void setDefaultDataSubNetworkType(int slotId, int subId) {
    if (subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
        Rlog.e(LOG_TAG, "setDefaultDataSubNetworkType called with DEFAULT_SUB_ID");
        return;
    }
    int networkType = RILConstants.PREFERRED_NETWORK_MODE;
    // to be more relevant instead of default mode
    try {
        networkType = android.provider.Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId);
    } catch (SettingNotFoundException snfe) {
        logd("Settings Exception reading value at subid for" + " Settings.Global.PREFERRED_NETWORK_MODE");
        try {
            networkType = TelephonyManager.getIntAtIndex(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, slotId);
        } catch (SettingNotFoundException retrySnfe) {
            Rlog.d(LOG_TAG, "Settings Exception Reading Value At Index for" + " Settings.Global.PREFERRED_NETWORK_MODE");
        }
    }
    // Get users NW type, let it override if its not the default NW mode (-1)
    int userNwType = SubscriptionController.getInstance().getUserNwMode(subId);
    if (userNwType != SubscriptionManager.DEFAULT_NW_MODE && userNwType != networkType) {
        networkType = userNwType;
    }
    boolean isDsds = TelephonyManager.getDefault().getMultiSimConfiguration() == TelephonyManager.MultiSimVariants.DSDS;
    if (DBG)
        Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] subId=" + subId);
    if (DBG)
        Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] isDSDS=" + isDsds);
    boolean isMultiRat = SystemProperties.getBoolean("ro.ril.multi_rat_capable", false);
    if (isDsds && !isMultiRat) {
        // Hardcoded due to modem limitation
        int networkType2 = Phone.NT_MODE_GSM_ONLY;
        int slotId1 = SubscriptionManager.DEFAULT_SIM_SLOT_INDEX;
        int slotId2 = SubscriptionManager.DEFAULT_SIM_SLOT_INDEX;
        int subId1 = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
        int subId2 = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
        // Since this is DSDS, there are 2 phones
        for (int targetSlotId = 0; targetSlotId < PROJECT_SIM_NUM; targetSlotId++) {
            Phone phone = mPhone[targetSlotId];
            int id = phone.getSubId();
            if (id == subId) {
                slotId1 = targetSlotId;
                subId1 = id;
                if (DBG)
                    Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] networkType1: " + networkType + ", slotId1: " + slotId1);
            } else {
                subId2 = id;
                slotId2 = targetSlotId;
                if (DBG)
                    Rlog.d(LOG_TAG, "[setDefaultDataSubNetworkType] networkType2: " + networkType2 + ", slotId2: " + slotId2);
            }
        }
        setPreferredNwModeForSlot(slotId1, subId1, networkType);
        setPreferredNwModeForSlot(slotId2, subId2, networkType2);
    } else {
        // Set the modem network mode
        setPreferredNwModeForSlot(slotId, subId, networkType);
    }
    // Only support automatic selection mode on SIM change.
    mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
}
#end_block

#method_before
public int getUserNwMode(int subId) {
    SubscriptionInfo subInfo = getActiveSubscriptionInfo(subId);
    if (subInfo != null) {
        return subInfo.mUserNwMode;
    } else {
        loge("getUserNwMode: invalid subId = " + subId);
        return SubscriptionManager.DEFAULT_NW_MODE;
    }
}
#method_after
public int getUserNwMode(int subId) {
    SubscriptionInfo subInfo = getActiveSubscriptionInfo(subId, mContext.getOpPackageName());
    if (subInfo != null) {
        return subInfo.mUserNwMode;
    } else {
        loge("getUserNwMode: invalid subId = " + subId);
        return SubscriptionManager.DEFAULT_NW_MODE;
    }
}
#end_block

#method_before
public static void makeDefaultPhone(Context context) {
    synchronized (sLockProxyPhones) {
        if (!sMadeDefaults) {
            sContext = context;
            // create the telephony device controller.
            TelephonyDevController.create();
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            // Get preferred network mode
            int preferredNetworkMode = RILConstants.PREFERRED_NETWORK_MODE;
            if (TelephonyManager.getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                preferredNetworkMode = Phone.NT_MODE_GLOBAL;
            }
            if (TelephonyManager.getLteOnGsmModeStatic() != 0) {
                preferredNetworkMode = Phone.NT_MODE_LTE_GSM_WCDMA;
            }
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            /* In case of multi SIM mode two instances of PhoneProxy, RIL are created,
                   where as in single SIM mode only instance. isMultiSimEnabled() function checks
                   whether it is single SIM or multi SIM mode */
            int numPhones = TelephonyManager.getDefault().getPhoneCount();
            int[] networkModes = new int[numPhones];
            sProxyPhones = new PhoneProxy[numPhones];
            sCommandsInterfaces = new RIL[numPhones];
            String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
            Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
            for (int i = 0; i < numPhones; i++) {
                // Get preferred network type.
                try {
                    networkModes[i] = TelephonyManager.getIntAtIndex(context.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, i);
                } catch (SettingNotFoundException snfe) {
                    Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for" + " Settings.Global.PREFERRED_NETWORK_MODE");
                    networkModes[i] = preferredNetworkMode;
                }
                // Get users NW type, let it override if its not the default NW mode (-1)
                int userNwType = SubscriptionController.getInstance().getUserNwMode(sProxyPhones[i].getSubId());
                if (userNwType != SubscriptionManager.DEFAULT_NW_MODE && userNwType != networkModes[i]) {
                    networkModes[i] = userNwType;
                }
                Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
                // Use reflection to construct the RIL class (defaults to RIL)
                try {
                    sCommandsInterfaces[i] = instantiateCustomRIL(sRILClassname, context, networkModes[i], cdmaSubscription, i);
                } catch (Exception e) {
                    // The log message should make it clear why the radio is broken
                    while (true) {
                        Rlog.e(LOG_TAG, "Unable to construct custom RIL class", e);
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException ie) {
                        }
                    }
                }
            }
            Rlog.i(LOG_TAG, "Creating SubscriptionController");
            TelephonyPluginDelegate.getInstance().initSubscriptionController(context, sCommandsInterfaces);
            // Instantiate UiccController so that all other classes can just
            // call getInstance()
            mUiccController = UiccController.make(context, sCommandsInterfaces);
            for (int i = 0; i < numPhones; i++) {
                PhoneBase phone = null;
                int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                    phone = TelephonyPluginDelegate.getInstance().makeGSMPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i);
                } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                    phone = TelephonyPluginDelegate.getInstance().makeCDMALTEPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i);
                }
                Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
                sProxyPhones[i] = new PhoneProxy(phone);
            }
            mProxyController = ProxyController.getInstance(context, sProxyPhones, mUiccController, sCommandsInterfaces);
            // Set the default phone in base class.
            // FIXME: This is a first best guess at what the defaults will be. It
            // FIXME: needs to be done in a more controlled manner in the future.
            sProxyPhone = sProxyPhones[0];
            sCommandsInterface = sCommandsInterfaces[0];
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
            Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
            sSubInfoRecordUpdater = TelephonyPluginDelegate.getInstance().makeSubscriptionInfoUpdater(context, sProxyPhones, sCommandsInterfaces);
            SubscriptionController.getInstance().updatePhonesAvailability(sProxyPhones);
            TelephonyPluginDelegate.getInstance().initExtTelephonyClasses(context, sProxyPhones, sCommandsInterfaces);
            // because ImsService might need it when it is being opened.
            for (int i = 0; i < numPhones; i++) {
                sProxyPhones[i].startMonitoringImsService();
            }
        }
    }
}
#method_after
public static void makeDefaultPhone(Context context) {
    synchronized (sLockProxyPhones) {
        if (!sMadeDefaults) {
            sContext = context;
            // create the telephony device controller.
            TelephonyDevController.create();
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            // Get preferred network mode
            int preferredNetworkMode = RILConstants.PREFERRED_NETWORK_MODE;
            if (TelephonyManager.getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                preferredNetworkMode = Phone.NT_MODE_GLOBAL;
            }
            if (TelephonyManager.getLteOnGsmModeStatic() != 0) {
                preferredNetworkMode = Phone.NT_MODE_LTE_GSM_WCDMA;
            }
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            /* In case of multi SIM mode two instances of PhoneProxy, RIL are created,
                   where as in single SIM mode only instance. isMultiSimEnabled() function checks
                   whether it is single SIM or multi SIM mode */
            int numPhones = TelephonyManager.getDefault().getPhoneCount();
            int[] networkModes = new int[numPhones];
            sProxyPhones = new PhoneProxy[numPhones];
            sCommandsInterfaces = new RIL[numPhones];
            String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
            Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
            for (int i = 0; i < numPhones; i++) {
                // Get preferred network type.
                try {
                    networkModes[i] = TelephonyManager.getIntAtIndex(context.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, i);
                } catch (SettingNotFoundException snfe) {
                    Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for" + " Settings.Global.PREFERRED_NETWORK_MODE");
                    networkModes[i] = preferredNetworkMode;
                }
                Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
                // Use reflection to construct the RIL class (defaults to RIL)
                try {
                    sCommandsInterfaces[i] = instantiateCustomRIL(sRILClassname, context, networkModes[i], cdmaSubscription, i);
                } catch (Exception e) {
                    // The log message should make it clear why the radio is broken
                    while (true) {
                        Rlog.e(LOG_TAG, "Unable to construct custom RIL class", e);
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException ie) {
                        }
                    }
                }
            }
            Rlog.i(LOG_TAG, "Creating SubscriptionController");
            TelephonyPluginDelegate.getInstance().initSubscriptionController(context, sCommandsInterfaces);
            // Instantiate UiccController so that all other classes can just
            // call getInstance()
            mUiccController = UiccController.make(context, sCommandsInterfaces);
            for (int i = 0; i < numPhones; i++) {
                PhoneBase phone = null;
                int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                    phone = TelephonyPluginDelegate.getInstance().makeGSMPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i);
                } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                    phone = TelephonyPluginDelegate.getInstance().makeCDMALTEPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i);
                }
                Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
                sProxyPhones[i] = new PhoneProxy(phone);
            }
            mProxyController = ProxyController.getInstance(context, sProxyPhones, mUiccController, sCommandsInterfaces);
            // Set the default phone in base class.
            // FIXME: This is a first best guess at what the defaults will be. It
            // FIXME: needs to be done in a more controlled manner in the future.
            sProxyPhone = sProxyPhones[0];
            sCommandsInterface = sCommandsInterfaces[0];
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
            Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
            sSubInfoRecordUpdater = TelephonyPluginDelegate.getInstance().makeSubscriptionInfoUpdater(context, sProxyPhones, sCommandsInterfaces);
            SubscriptionController.getInstance().updatePhonesAvailability(sProxyPhones);
            TelephonyPluginDelegate.getInstance().initExtTelephonyClasses(context, sProxyPhones, sCommandsInterfaces);
            // because ImsService might need it when it is being opened.
            for (int i = 0; i < numPhones; i++) {
                sProxyPhones[i].startMonitoringImsService();
                // Get users NW type, let it override if its not the default NW mode (-1)
                int userNwType = SubscriptionController.getInstance().getUserNwMode(sProxyPhones[i].getSubId());
                if (userNwType != SubscriptionManager.DEFAULT_NW_MODE && userNwType != networkModes[i]) {
                    sProxyPhones[i].setPreferredNetworkType(userNwType, null);
                }
            }
        }
    }
}
#end_block

#method_before
private void handleSimLoaded(int slotId) {
    logd("handleSimStateLoadedInternal: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("onRecieve: IccRecords null");
        return;
    }
    if (records.getIccId() == null) {
        logd("onRecieve: IccID null");
        return;
    }
    mIccId[slotId] = records.getIccId();
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    int subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
    int[] subIds = SubscriptionController.getInstance().getSubId(slotId);
    if (subIds != null) {
        // Why an array?
        subId = subIds[0];
    }
    if (SubscriptionManager.isValidSubscriptionId(subId)) {
        String operator = records.getOperatorNumeric();
        if (operator != null) {
            if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                MccTable.updateMccMncConfiguration(mContext, operator, false);
            }
            SubscriptionController.getInstance().setMccMnc(operator, subId);
        } else {
            logd("EVENT_RECORDS_LOADED Operator name is null");
        }
        TelephonyManager tm = TelephonyManager.getDefault();
        String msisdn = tm.getLine1NumberForSubscriber(subId);
        ContentResolver contentResolver = mContext.getContentResolver();
        if (msisdn != null) {
            ContentValues number = new ContentValues(1);
            number.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
        }
        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
        String nameToSet;
        String simCarrierName = tm.getSimOperatorNameForSubscription(subId);
        ContentValues name = new ContentValues(1);
        if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
            if (!TextUtils.isEmpty(simCarrierName)) {
                nameToSet = simCarrierName;
            } else {
                nameToSet = "CARD " + Integer.toString(slotId + 1);
            }
            name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
            logd("sim name = " + nameToSet);
            contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
        }
        /* Update preferred network type and network selection mode on SIM change.
             * Storing last subId in SharedPreference for now to detect SIM change. */
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
        int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
        if (storedSubId != subId) {
            int networkType = RILConstants.PREFERRED_NETWORK_MODE;
            // to be more relevant instead of default mode
            try {
                networkType = android.provider.Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId);
            } catch (SettingNotFoundException snfe) {
                logd("Settings Exception reading value at subid for" + " Settings.Global.PREFERRED_NETWORK_MODE");
                try {
                    networkType = TelephonyManager.getIntAtIndex(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, slotId);
                } catch (SettingNotFoundException retrySnfe) {
                    Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for" + " Settings.Global.PREFERRED_NETWORK_MODE");
                }
            }
            // Set the modem network mode
            mPhone[slotId].setPreferredNetworkType(networkType, null);
            Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
            // Only support automatic selection mode on SIM change.
            mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
            // Update stored subId
            SharedPreferences.Editor editor = sp.edit();
            editor.putInt(CURR_SUBID + slotId, subId);
            editor.apply();
        }
    } else {
        logd("Invalid subId, could not update ContentResolver");
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#method_after
private void handleSimLoaded(int slotId) {
    logd("handleSimStateLoadedInternal: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("onRecieve: IccRecords null");
        return;
    }
    if (records.getIccId() == null) {
        logd("onRecieve: IccID null");
        return;
    }
    mIccId[slotId] = records.getIccId();
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    int subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
    int[] subIds = SubscriptionController.getInstance().getSubId(slotId);
    if (subIds != null) {
        // Why an array?
        subId = subIds[0];
    }
    if (SubscriptionManager.isValidSubscriptionId(subId)) {
        String operator = records.getOperatorNumeric();
        if (operator != null) {
            if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                MccTable.updateMccMncConfiguration(mContext, operator, false);
            }
            SubscriptionController.getInstance().setMccMnc(operator, subId);
        } else {
            logd("EVENT_RECORDS_LOADED Operator name is null");
        }
        TelephonyManager tm = TelephonyManager.getDefault();
        String msisdn = tm.getLine1NumberForSubscriber(subId);
        ContentResolver contentResolver = mContext.getContentResolver();
        if (msisdn != null) {
            ContentValues number = new ContentValues(1);
            number.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
        }
        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
        String nameToSet;
        String simCarrierName = tm.getSimOperatorNameForSubscription(subId);
        ContentValues name = new ContentValues(1);
        if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
            if (!TextUtils.isEmpty(simCarrierName)) {
                nameToSet = simCarrierName;
            } else {
                nameToSet = "CARD " + Integer.toString(slotId + 1);
            }
            name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
            logd("sim name = " + nameToSet);
            contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
        }
        /* Update preferred network type and network selection mode on SIM change.
             * Storing last subId in SharedPreference for now to detect SIM change. */
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
        int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
        if (storedSubId != subId) {
            setDefaultDataSubNetworkType(slotId, subId);
            // Update stored subId
            SharedPreferences.Editor editor = sp.edit();
            editor.putInt(CURR_SUBID + slotId, subId);
            editor.apply();
        }
    } else {
        logd("Invalid subId, could not update ContentResolver");
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#end_block

#method_before
@Override
protected boolean isDataAllowed() {
    final boolean internalDataEnabled;
    synchronized (mDataEnabledLock) {
        internalDataEnabled = mInternalDataEnabled;
    }
    boolean attachedState = mAttached.get();
    boolean desiredPowerState = mPhone.getServiceStateTracker().getDesiredPowerState();
    IccRecords r = mIccRecords.get();
    boolean recordsLoaded = (r != null) ? r.getRecordsLoaded() : false;
    boolean subscriptionFromNv = isNvSubscription();
    int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
    if (radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
        desiredPowerState = true;
    }
    if (r != null) {
        recordsLoaded = r.getRecordsLoaded();
        if (DBG && !recordsLoaded)
            log("isDataAllowed getRecordsLoaded=" + recordsLoaded);
    }
    int dataSub = SubscriptionManager.getDefaultDataSubId();
    boolean defaultDataSelected = SubscriptionManager.isValidSubscriptionId(dataSub);
    PhoneConstants.State state = PhoneConstants.State.IDLE;
    // voiceCallStateAllowDataCall, or dataCallAllowed or something similar.
    if (mPhone.getCallTracker() != null) {
        state = mPhone.getCallTracker().getState();
    }
    boolean allowed = (attachedState || (mAutoAttachOnCreation.get() && (mPhone.getSubId() == dataSub))) && (subscriptionFromNv || recordsLoaded) && (state == PhoneConstants.State.IDLE || mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) && internalDataEnabled && defaultDataSelected && !mIsPsRestricted && desiredPowerState;
    if (!allowed && DBG) {
        String reason = "";
        if (!(attachedState || mAutoAttachOnCreation.get())) {
            reason += " - Attached= " + attachedState;
        }
        if (!(subscriptionFromNv || recordsLoaded)) {
            reason += " - SIM not loaded and not NV subscription";
        }
        if (state != PhoneConstants.State.IDLE && !mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) {
            reason += " - PhoneState= " + state;
            reason += " - Concurrent voice and data not allowed";
        }
        if (!internalDataEnabled)
            reason += " - mInternalDataEnabled= false";
        if (!defaultDataSelected)
            reason += " - defaultDataSelected= false";
        if (mIsPsRestricted)
            reason += " - mIsPsRestricted= true";
        if (!desiredPowerState)
            reason += " - desiredPowerState= false";
        if (DBG)
            log("isDataAllowed: not allowed due to" + reason);
    }
    return allowed;
}
#method_after
@Override
protected boolean isDataAllowed() {
    final boolean internalDataEnabled;
    synchronized (mDataEnabledLock) {
        internalDataEnabled = mInternalDataEnabled;
    }
    boolean attachedState = mAttached.get();
    boolean desiredPowerState = mPhone.getServiceStateTracker().getDesiredPowerState();
    IccRecords r = mIccRecords.get();
    boolean recordsLoaded = (r != null) ? r.getRecordsLoaded() : false;
    boolean subscriptionFromNv = isNvSubscription();
    int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
    if (radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
        desiredPowerState = true;
    }
    if (r != null) {
        recordsLoaded = r.getRecordsLoaded();
        if (DBG && !recordsLoaded)
            log("isDataAllowed getRecordsLoaded=" + recordsLoaded);
    }
    int dataSub = SubscriptionManager.getDefaultDataSubId();
    boolean defaultDataSelected = SubscriptionManager.isValidSubscriptionId(dataSub);
    PhoneConstants.State state = PhoneConstants.State.IDLE;
    // voiceCallStateAllowDataCall, or dataCallAllowed or something similar.
    if (mPhone.getCallTracker() != null) {
        state = mPhone.getCallTracker().getState();
    }
    boolean allowed = (attachedState || (mAutoAttachOnCreation.get() && (mPhone.getSubId() == dataSub))) && (subscriptionFromNv || recordsLoaded) && (state == PhoneConstants.State.IDLE || mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) && internalDataEnabled && defaultDataSelected && !mIsPsRestricted && desiredPowerState;
    if (!allowed && DBG) {
        String reason = "";
        if (!(attachedState || mAutoAttachOnCreation.get())) {
            reason += " - Attached= " + attachedState;
        }
        if (!recordsLoaded)
            reason += " - SIM not loaded";
        if (!(subscriptionFromNv || recordsLoaded)) {
            reason += " - SIM not loaded and not NV subscription";
        }
        if (state != PhoneConstants.State.IDLE && !mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) {
            reason += " - PhoneState= " + state;
            reason += " - Concurrent voice and data not allowed";
        }
        if (!internalDataEnabled)
            reason += " - mInternalDataEnabled= false";
        if (!defaultDataSelected)
            reason += " - defaultDataSelected= false";
        if (mIsPsRestricted)
            reason += " - mIsPsRestricted= true";
        if (!desiredPowerState)
            reason += " - desiredPowerState= false";
        if (DBG)
            log("isDataAllowed: not allowed due to" + reason);
    }
    return allowed;
}
#end_block

#method_before
protected int getApnProfileID(String apnType) {
    if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IMS)) {
        return RILConstants.DATA_PROFILE_IMS;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_FOTA)) {
        return RILConstants.DATA_PROFILE_FOTA;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_CBS)) {
        return RILConstants.DATA_PROFILE_CBS;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IA)) {
        // DEFAULT for now
        return RILConstants.DATA_PROFILE_DEFAULT;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) {
        return RILConstants.DATA_PROFILE_TETHERED;
    } else {
        return RILConstants.DATA_PROFILE_DEFAULT;
    }
}
#method_after
protected int getApnProfileID(String apnType) {
    if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IMS)) {
        return RILConstants.DATA_PROFILE_IMS;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_FOTA)) {
        return RILConstants.DATA_PROFILE_FOTA;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_CBS)) {
        return RILConstants.DATA_PROFILE_CBS;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_IA)) {
        // DEFAULT for now
        return RILConstants.DATA_PROFILE_DEFAULT;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) {
        return RILConstants.DATA_PROFILE_TETHERED;
    } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS)) {
        return MMS_DATA_PROFILE;
    } else {
        return RILConstants.DATA_PROFILE_DEFAULT;
    }
}
#end_block

#method_before
private void onCheckForNetworkSelectionModeAutomatic(Message fromRil) {
    AsyncResult ar = (AsyncResult) fromRil.obj;
    Message response = (Message) ar.userObj;
    boolean doAutomatic = true;
    if (ar.exception == null && ar.result != null) {
        try {
            int[] modes = (int[]) ar.result;
            if (modes[0] == 0) {
                // already confirmed to be in automatic mode - don't resend
                doAutomatic = false;
            }
        } catch (Exception e) {
        // send the setting on error
        }
    }
    // wrap the response message in our own message along with
    // an empty string (to indicate automatic selection) for the
    // operator's id.
    NetworkSelectMessage nsm = new NetworkSelectMessage();
    nsm.message = response;
    nsm.operatorNumeric = "";
    nsm.operatorAlphaLong = "";
    nsm.operatorAlphaShort = "";
    if (doAutomatic) {
        Message msg = obtainMessage(EVENT_SET_NETWORK_AUTOMATIC_COMPLETE, nsm);
        mCi.setNetworkSelectionModeAutomatic(msg);
    } else {
        Rlog.d(LOG_TAG, "setNetworkSelectionModeAutomatic - already auto, ignoring");
        ar.userObj = nsm;
        handleSetSelectNetwork(ar);
    }
}
#method_after
private void onCheckForNetworkSelectionModeAutomatic(Message fromRil) {
    AsyncResult ar = (AsyncResult) fromRil.obj;
    Message response = (Message) ar.userObj;
    boolean doAutomatic = true;
    if (ar.exception == null && ar.result != null) {
        try {
            int[] modes = (int[]) ar.result;
            if (modes[0] == 0) {
                // already confirmed to be in automatic mode - don't resend
                doAutomatic = false;
            }
        } catch (Exception e) {
        // send the setting on error
        }
    }
    // wrap the response message in our own message along with
    // an empty string (to indicate automatic selection) for the
    // operator's id.
    NetworkSelectMessage nsm = new NetworkSelectMessage();
    nsm.message = response;
    nsm.operatorNumeric = "";
    nsm.operatorAlphaLong = "";
    nsm.operatorAlphaShort = "";
    if (doAutomatic) {
        Message msg = obtainMessage(EVENT_SET_NETWORK_AUTOMATIC_COMPLETE, nsm);
        mCi.setNetworkSelectionModeAutomatic(msg);
    } else {
        Rlog.d(LOG_TAG, "setNetworkSelectionModeAutomatic - already auto, ignoring");
        ar.userObj = nsm;
        handleSetSelectNetwork(ar);
    }
    updateSavedNetworkOperator(nsm);
}
#end_block

#method_before
@Override
public void radioCapabilityUpdated(RadioCapability rc) {
    // Called when radios first become available or after a capability switch
    // Update the cached value
    mRadioCapability.set(rc);
    if (SubscriptionManager.isValidSubscriptionId(getSubId())) {
        sendSubscriptionSettings(true);
    }
}
#method_after
@Override
public void radioCapabilityUpdated(RadioCapability rc) {
    // Called when radios first become available or after a capability switch
    // Update the cached value
    mRadioCapability.set(rc);
    if (SubscriptionManager.isValidSubscriptionId(getSubId())) {
        updatePreferredType();
        sendSubscriptionSettings(true);
    }
}
#end_block

#method_before
public void sendSubscriptionSettings(boolean restoreNetworkSelection) {
    updatePreferredType();
    // Send settings down
    int type = PhoneFactory.calculatePreferredNetworkType(mContext, getSubId());
    setPreferredNetworkType(type, null);
    if (restoreNetworkSelection) {
        restoreSavedNetworkSelection(null);
    }
    mDcTracker.setDataEnabled(getDataEnabled());
}
#method_after
public void sendSubscriptionSettings(boolean restoreNetworkSelection) {
    // Send settings down
    int type = PhoneFactory.calculatePreferredNetworkType(mContext, getSubId());
    setPreferredNetworkType(type, null);
    if (restoreNetworkSelection) {
        restoreSavedNetworkSelection(null);
    }
    mDcTracker.setDataEnabled(getDataEnabled());
}
#end_block

#method_before
synchronized protected void updateSubscriptionInfoByIccId() {
    logd("updateSubscriptionInfoByIccId:+ Start");
    mSubscriptionManager.clearSubscriptionInfo();
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        mInsertSimState[i] = SIM_NOT_CHANGE;
    }
    int insertedSimCount = PROJECT_SIM_NUM;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (ICCID_STRING_FOR_NO_SIM.equals(mIccId[i])) {
            insertedSimCount--;
            mInsertSimState[i] = SIM_NOT_INSERT;
        }
    }
    logd("insertedSimCount = " + insertedSimCount);
    int index = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            continue;
        }
        index = 2;
        for (int j = i + 1; j < PROJECT_SIM_NUM; j++) {
            if (mInsertSimState[j] == SIM_NOT_CHANGE && mIccId[i].equals(mIccId[j])) {
                mInsertSimState[i] = 1;
                mInsertSimState[j] = index;
                index++;
            }
        }
    }
    ContentResolver contentResolver = mContext.getContentResolver();
    String[] oldIccId = new String[PROJECT_SIM_NUM];
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        oldIccId[i] = null;
        List<SubscriptionInfo> oldSubInfo = SubscriptionController.getInstance().getSubInfoUsingSlotIdWithCheck(i, false, mContext.getOpPackageName());
        if (oldSubInfo != null) {
            oldIccId[i] = oldSubInfo.get(0).getIccId();
            logd("updateSubscriptionInfoByIccId: oldSubId = " + oldSubInfo.get(0).getSubscriptionId());
            if (mInsertSimState[i] == SIM_NOT_CHANGE && !mIccId[i].equals(oldIccId[i])) {
                mInsertSimState[i] = SIM_CHANGED;
            }
            if (mInsertSimState[i] != SIM_NOT_CHANGE) {
                ContentValues value = new ContentValues(1);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.INVALID_SIM_SLOT_INDEX);
                contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(oldSubInfo.get(0).getSubscriptionId()), null);
            }
        } else {
            if (mInsertSimState[i] == SIM_NOT_CHANGE) {
                // no SIM inserted last time, but there is one SIM inserted now
                mInsertSimState[i] = SIM_CHANGED;
            }
            oldIccId[i] = ICCID_STRING_FOR_NO_SIM;
            logd("updateSubscriptionInfoByIccId: No SIM in slot " + i + " last time");
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        logd("updateSubscriptionInfoByIccId: oldIccId[" + i + "] = " + oldIccId[i] + ", sIccId[" + i + "] = " + mIccId[i]);
    }
    // check if the inserted SIM is new SIM
    int nNewCardCount = 0;
    int nNewSimStatus = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            logd("updateSubscriptionInfoByIccId: No SIM inserted in slot " + i + " this time");
        } else {
            if (mInsertSimState[i] > 0) {
                // some special SIMs may have the same IccIds, add suffix to distinguish them
                // FIXME: addSubInfoRecord can return an error.
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i] + Integer.toString(mInsertSimState[i]), i);
                logd("SUB" + (i + 1) + " has invalid IccId");
            } else /*if (sInsertSimState[i] != SIM_NOT_INSERT)*/
            {
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i], i);
            }
            if (isNewSim(mIccId[i], oldIccId)) {
                nNewCardCount++;
                switch(i) {
                    case PhoneConstants.SUB1:
                        nNewSimStatus |= STATUS_SIM1_INSERTED;
                        break;
                    case PhoneConstants.SUB2:
                        nNewSimStatus |= STATUS_SIM2_INSERTED;
                        break;
                    case PhoneConstants.SUB3:
                        nNewSimStatus |= STATUS_SIM3_INSERTED;
                        break;
                }
                mInsertSimState[i] = SIM_NEW;
            }
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_CHANGED) {
            mInsertSimState[i] = SIM_REPOSITION;
        }
        logd("updateSubscriptionInfoByIccId: sInsertSimState[" + i + "] = " + mInsertSimState[i]);
    }
    List<SubscriptionInfo> subInfos = mSubscriptionManager.getActiveSubscriptionInfoList();
    int nSubCount = (subInfos == null) ? 0 : subInfos.size();
    logd("updateSubscriptionInfoByIccId: nSubCount = " + nSubCount);
    for (int i = 0; i < nSubCount; i++) {
        SubscriptionInfo temp = subInfos.get(i);
        String msisdn = TelephonyManager.getDefault().getLine1NumberForSubscriber(temp.getSubscriptionId());
        if (msisdn != null) {
            ContentValues value = new ContentValues(1);
            value.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(temp.getSubscriptionId()), null);
        }
    }
    if (insertedSimCount == 1) {
        SubscriptionInfo sir = subInfos.get(0);
        int subId = sir.getSubscriptionId();
        mSubscriptionManager.setDefaultDataSubId(subId);
        mSubscriptionManager.setDefaultVoiceSubId(subId);
        mSubscriptionManager.setDefaultSmsSubId(subId);
    } else {
        // Ensure the modems are mapped correctly
        mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubId());
    }
    SubscriptionController.getInstance().notifySubscriptionInfoChanged();
    logd("updateSubscriptionInfoByIccId:- SsubscriptionInfo update complete");
}
#method_after
synchronized protected void updateSubscriptionInfoByIccId() {
    logd("updateSubscriptionInfoByIccId:+ Start");
    mSubscriptionManager.clearSubscriptionInfo();
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        mInsertSimState[i] = SIM_NOT_CHANGE;
    }
    int insertedSimCount = PROJECT_SIM_NUM;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (ICCID_STRING_FOR_NO_SIM.equals(mIccId[i])) {
            insertedSimCount--;
            mInsertSimState[i] = SIM_NOT_INSERT;
        }
    }
    logd("insertedSimCount = " + insertedSimCount);
    int index = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            continue;
        }
        index = 2;
        for (int j = i + 1; j < PROJECT_SIM_NUM; j++) {
            if (mInsertSimState[j] == SIM_NOT_CHANGE && mIccId[i].equals(mIccId[j])) {
                mInsertSimState[i] = 1;
                mInsertSimState[j] = index;
                index++;
            }
        }
    }
    ContentResolver contentResolver = mContext.getContentResolver();
    String[] oldIccId = new String[PROJECT_SIM_NUM];
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        oldIccId[i] = null;
        List<SubscriptionInfo> oldSubInfo = SubscriptionController.getInstance().getSubInfoUsingSlotIdWithCheck(i, false, mContext.getOpPackageName());
        if (oldSubInfo != null) {
            oldIccId[i] = oldSubInfo.get(0).getIccId();
            logd("updateSubscriptionInfoByIccId: oldSubId = " + oldSubInfo.get(0).getSubscriptionId());
            if (mInsertSimState[i] == SIM_NOT_CHANGE && !mIccId[i].equals(oldIccId[i])) {
                mInsertSimState[i] = SIM_CHANGED;
            }
            if (mInsertSimState[i] != SIM_NOT_CHANGE) {
                ContentValues value = new ContentValues(1);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.INVALID_SIM_SLOT_INDEX);
                contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(oldSubInfo.get(0).getSubscriptionId()), null);
            }
        } else {
            if (mInsertSimState[i] == SIM_NOT_CHANGE) {
                // no SIM inserted last time, but there is one SIM inserted now
                mInsertSimState[i] = SIM_CHANGED;
            }
            oldIccId[i] = ICCID_STRING_FOR_NO_SIM;
            logd("updateSubscriptionInfoByIccId: No SIM in slot " + i + " last time");
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        logd("updateSubscriptionInfoByIccId: oldIccId[" + i + "] = " + oldIccId[i] + ", sIccId[" + i + "] = " + mIccId[i]);
    }
    // check if the inserted SIM is new SIM
    int nNewCardCount = 0;
    int nNewSimStatus = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            logd("updateSubscriptionInfoByIccId: No SIM inserted in slot " + i + " this time");
        } else {
            if (mInsertSimState[i] > 0) {
                // some special SIMs may have the same IccIds, add suffix to distinguish them
                // FIXME: addSubInfoRecord can return an error.
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i] + Integer.toString(mInsertSimState[i]), i);
                logd("SUB" + (i + 1) + " has invalid IccId");
            } else /*if (sInsertSimState[i] != SIM_NOT_INSERT)*/
            {
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i], i);
            }
            if (isNewSim(mIccId[i], oldIccId)) {
                nNewCardCount++;
                switch(i) {
                    case PhoneConstants.SUB1:
                        nNewSimStatus |= STATUS_SIM1_INSERTED;
                        break;
                    case PhoneConstants.SUB2:
                        nNewSimStatus |= STATUS_SIM2_INSERTED;
                        break;
                    case PhoneConstants.SUB3:
                        nNewSimStatus |= STATUS_SIM3_INSERTED;
                        break;
                }
                mInsertSimState[i] = SIM_NEW;
            }
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_CHANGED) {
            mInsertSimState[i] = SIM_REPOSITION;
        }
        logd("updateSubscriptionInfoByIccId: sInsertSimState[" + i + "] = " + mInsertSimState[i]);
    }
    List<SubscriptionInfo> subInfos = mSubscriptionManager.getActiveSubscriptionInfoList();
    int nSubCount = (subInfos == null) ? 0 : subInfos.size();
    logd("updateSubscriptionInfoByIccId: nSubCount = " + nSubCount);
    for (int i = 0; i < nSubCount; i++) {
        SubscriptionInfo temp = subInfos.get(i);
        String msisdn = TelephonyManager.getDefault().getLine1NumberForSubscriber(temp.getSubscriptionId());
        if (msisdn != null) {
            ContentValues value = new ContentValues(1);
            value.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(temp.getSubscriptionId()), null);
        }
    }
    if (!mIsShutdown && insertedSimCount == 1) {
        SubscriptionInfo sir = subInfos.get(0);
        int subId = sir.getSubscriptionId();
        mSubscriptionManager.setDefaultDataSubId(subId);
        mSubscriptionManager.setDefaultVoiceSubId(subId);
        mSubscriptionManager.setDefaultSmsSubId(subId);
    } else {
        // Ensure the modems are mapped correctly
        mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubId());
    }
    SubscriptionController.getInstance().notifySubscriptionInfoChanged();
    logd("updateSubscriptionInfoByIccId:- SsubscriptionInfo update complete");
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    boolean retVal;
    switch(msg.what) {
        case DcSwitchAsyncChannel.REQ_CONNECT:
            {
                ConnectInfo connectInfo = (ConnectInfo) msg.obj;
                RequestInfo apnRequest = connectInfo.request;
                apnRequest.log("DcSwitchStateMachine.AttachingState: REQ_CONNECT");
                if (DBG)
                    log("AttachingState: REQ_CONNECT, apnRequest=" + apnRequest);
                final PhoneBase pb = (PhoneBase) ((PhoneProxy) mPhone).getActivePhone();
                if (pb.mDcTracker.getAutoAttachOnCreation() == false) {
                // do nothing - wait til we attach and then we'll execute all requests
                } else {
                    apnRequest.log("DcSwitchStateMachine processing due to autoAttach");
                    DctController.getInstance().executeRequest(apnRequest);
                }
                retVal = HANDLED;
                break;
            }
        case EVENT_DATA_ALLOWED:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (mCurrentAllowedSequence != msg.arg1) {
                    loge("EVENT_DATA_ALLOWED ignored arg1=" + msg.arg1 + ", seq=" + mCurrentAllowedSequence);
                } else {
                    boolean dataAllowFailed = false;
                    if (ar.exception != null) {
                        dataAllowFailed = true;
                        if (ar.exception instanceof CommandException) {
                            CommandException.Error err = ((CommandException) (ar.exception)).getCommandError();
                            if (err == CommandException.Error.REQUEST_NOT_SUPPORTED) {
                                dataAllowFailed = false;
                            }
                        }
                    }
                    if (dataAllowFailed) {
                        loge("EVENT_DATA_ALLOWED failed, " + ar.exception);
                        if (mResponseMsg != null) {
                            // Inform DctController about the failure.
                            Message responseMsg = Message.obtain(mResponseMsg);
                            responseMsg.obj = new AsyncResult(null, null, ar.exception);
                            responseMsg.sendToTarget();
                        }
                    } else {
                        logd("EVENT_DATA_ALLOWED success");
                        mResponseMsg = null;
                        /* If the data service state is IN_SERVICE then move to
                             * ATTACHED state.
                             */
                        int dataState = mPhone.getServiceState().getDataRegState();
                        if (dataState == ServiceState.STATE_IN_SERVICE) {
                            logd("AttachingState: Already attached, move to ATTACHED state");
                            transitionTo(mAttachedState);
                        }
                    }
                }
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.EVENT_RESET:
            {
                if (DBG)
                    log("AttachingState requested abort/reset");
                transitionTo(mIdleState);
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.REQ_RETRY_CONNECT:
            {
                if (DBG)
                    log("AttachingState going to retry");
                doEnter();
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.EVENT_DATA_ATTACHED:
            {
                if (DBG) {
                    log("AttachingState: EVENT_DATA_ATTACHED");
                }
                transitionTo(mAttachedState);
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.REQ_DISCONNECT_ALL:
            {
                if (DBG) {
                    log("AttachingState: REQ_DISCONNECT_ALL");
                }
                final PhoneBase pb = (PhoneBase) ((PhoneProxy) mPhone).getActivePhone();
                if (pb.mDcTracker.getAutoAttachOnCreation()) {
                    // here in that case.
                    if (DBG)
                        log("releasingAll due to autoAttach");
                    DctController.getInstance().releaseAllRequests(mId);
                }
                transitionTo(mIdleState);
                retVal = HANDLED;
                break;
            }
        default:
            if (VDBG) {
                log("AttachingState: nothandled msg.what=0x" + Integer.toHexString(msg.what));
            }
            retVal = NOT_HANDLED;
            break;
    }
    return retVal;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    boolean retVal;
    switch(msg.what) {
        case DcSwitchAsyncChannel.REQ_CONNECT:
            {
                ConnectInfo connectInfo = (ConnectInfo) msg.obj;
                RequestInfo apnRequest = connectInfo.request;
                apnRequest.log("DcSwitchStateMachine.AttachingState: REQ_CONNECT");
                if (DBG)
                    log("AttachingState: REQ_CONNECT, apnRequest=" + apnRequest);
                final PhoneBase pb = (PhoneBase) ((PhoneProxy) mPhone).getActivePhone();
                if (pb.mDcTracker.getAutoAttachOnCreation() == false) {
                // do nothing - wait til we attach and then we'll execute all requests
                } else {
                    apnRequest.log("DcSwitchStateMachine processing due to autoAttach");
                    DctController.getInstance().executeRequest(apnRequest);
                }
                retVal = HANDLED;
                break;
            }
        case EVENT_DATA_ALLOWED:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (mCurrentAllowedSequence != msg.arg1) {
                    loge("EVENT_DATA_ALLOWED ignored arg1=" + msg.arg1 + ", seq=" + mCurrentAllowedSequence);
                } else {
                    boolean requestNotSupported = (ar.exception != null && ar.exception instanceof CommandException && ((CommandException) (ar.exception)).getCommandError() == CommandException.Error.REQUEST_NOT_SUPPORTED);
                    if (ar.exception != null && !requestNotSupported) {
                        loge("EVENT_DATA_ALLOWED failed, " + ar.exception);
                        if (mResponseMsg != null) {
                            // Inform DctController about the failure.
                            Message responseMsg = Message.obtain(mResponseMsg);
                            responseMsg.obj = new AsyncResult(null, null, ar.exception);
                            responseMsg.sendToTarget();
                        }
                    } else {
                        logd("EVENT_DATA_ALLOWED success");
                        mResponseMsg = null;
                        /* If the data service state is IN_SERVICE then move to
                             * ATTACHED state.
                             */
                        int dataState = mPhone.getServiceState().getDataRegState();
                        if (dataState == ServiceState.STATE_IN_SERVICE) {
                            logd("AttachingState: Already attached, move to ATTACHED state");
                            transitionTo(mAttachedState);
                        }
                    }
                }
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.EVENT_RESET:
            {
                if (DBG)
                    log("AttachingState requested abort/reset");
                transitionTo(mIdleState);
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.REQ_RETRY_CONNECT:
            {
                if (DBG)
                    log("AttachingState going to retry");
                doEnter();
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.EVENT_DATA_ATTACHED:
            {
                if (DBG) {
                    log("AttachingState: EVENT_DATA_ATTACHED");
                }
                transitionTo(mAttachedState);
                retVal = HANDLED;
                break;
            }
        case DcSwitchAsyncChannel.REQ_DISCONNECT_ALL:
            {
                if (DBG) {
                    log("AttachingState: REQ_DISCONNECT_ALL");
                }
                final PhoneBase pb = (PhoneBase) ((PhoneProxy) mPhone).getActivePhone();
                if (pb.mDcTracker.getAutoAttachOnCreation()) {
                    // here in that case.
                    if (DBG)
                        log("releasingAll due to autoAttach");
                    DctController.getInstance().releaseAllRequests(mId);
                }
                transitionTo(mIdleState);
                retVal = HANDLED;
                break;
            }
        default:
            if (VDBG) {
                log("AttachingState: nothandled msg.what=0x" + Integer.toHexString(msg.what));
            }
            retVal = NOT_HANDLED;
            break;
    }
    return retVal;
}
#end_block

#method_before
private boolean processEventNotify(CommandDetails cmdDet, List<ComprehensionTlv> ctlvs) throws ResultException {
    CatLog.d(this, "process EventNotify");
    TextMessage textMsg = new TextMessage();
    IconId iconId = null;
    ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID, ctlvs);
    textMsg.text = ValueParser.retrieveAlphaId(ctlv);
    ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
    if (ctlv != null) {
        iconId = ValueParser.retrieveIconId(ctlv);
        textMsg.iconSelfExplanatory = iconId.selfExplanatory;
    }
    textMsg.responseNeeded = false;
    // Samsung STK
    AppInterface.CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    boolean isSamsungStk = Resources.getSystem().getBoolean(com.android.internal.R.bool.config_samsung_stk);
    if (cmdType == AppInterface.CommandType.SEND_SMS && isSamsungStk) {
        String smscAddress = null;
        String pdu = null;
        ctlv = searchForTag(ComprehensionTlvTag.ADDRESS, ctlvs);
        if (ctlv != null) {
            smscAddress = ValueParser.retrieveSMSCaddress(ctlv);
            CatLog.d(this, "The smsc address is " + smscAddress);
        } else {
            CatLog.d(this, "The smsc address is null");
        }
        ctlv = searchForTag(ComprehensionTlvTag.SMS_TPDU, ctlvs);
        if (ctlv != null) {
            pdu = ValueParser.retrieveSMSTPDU(ctlv);
            CatLog.d(this, "The SMS tpdu is " + pdu);
        } else {
            CatLog.d(this, "The SMS tpdu is null");
        }
        mCmdParams = new SendSMSParams(cmdDet, textMsg, smscAddress, pdu);
    } else if (cmdType == AppInterface.CommandType.SEND_USSD && isSamsungStk) {
        String ussdString = null;
        ctlv = searchForTag(ComprehensionTlvTag.USSD_STRING, ctlvs);
        if (ctlv != null) {
            ussdString = ValueParser.retrieveUSSDString(ctlv);
            CatLog.d(this, "The ussd string is " + ussdString);
        } else {
            CatLog.d(this, "The ussd string is null");
        }
        mCmdParams = new SendUSSDParams(cmdDet, textMsg, ussdString);
    } else {
        mCmdParams = new DisplayTextParams(cmdDet, textMsg);
    }
    if (iconId != null) {
        mloadIcon = true;
        mIconLoadState = LOAD_SINGLE_ICON;
        mIconLoader.loadIcon(iconId.recordNumber, this.obtainMessage(MSG_ID_LOAD_ICON_DONE));
        return true;
    }
    return false;
}
#method_after
private boolean processEventNotify(CommandDetails cmdDet, List<ComprehensionTlv> ctlvs) throws ResultException {
    CatLog.d(this, "process EventNotify");
    TextMessage textMsg = new TextMessage();
    IconId iconId = null;
    ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID, ctlvs);
    textMsg.text = ValueParser.retrieveAlphaId(ctlv);
    ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
    if (ctlv != null) {
        iconId = ValueParser.retrieveIconId(ctlv);
        textMsg.iconSelfExplanatory = iconId.selfExplanatory;
    }
    textMsg.responseNeeded = false;
    // Samsung STK
    if (Resources.getSystem().getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
        AppInterface.CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
        if (cmdType == AppInterface.CommandType.SEND_SMS) {
            String smscAddress = null;
            String pdu = null;
            ctlv = searchForTag(ComprehensionTlvTag.ADDRESS, ctlvs);
            if (ctlv != null) {
                smscAddress = ValueParser.retrieveSMSCaddress(ctlv);
                CatLog.d(this, "The smsc address is " + smscAddress);
            } else {
                CatLog.d(this, "The smsc address is null");
            }
            ctlv = searchForTag(ComprehensionTlvTag.SMS_TPDU, ctlvs);
            if (ctlv != null) {
                pdu = ValueParser.retrieveSMSTPDU(ctlv);
                CatLog.d(this, "The SMS tpdu is " + pdu);
            } else {
                CatLog.d(this, "The SMS tpdu is null");
            }
            mCmdParams = new SendSMSParams(cmdDet, textMsg, smscAddress, pdu);
        } else if (cmdType == AppInterface.CommandType.SEND_USSD) {
            String ussdString = null;
            ctlv = searchForTag(ComprehensionTlvTag.USSD_STRING, ctlvs);
            if (ctlv != null) {
                ussdString = ValueParser.retrieveUSSDString(ctlv);
                CatLog.d(this, "The ussd string is " + ussdString);
            } else {
                CatLog.d(this, "The ussd string is null");
            }
            mCmdParams = new SendUSSDParams(cmdDet, textMsg, ussdString);
        } else {
            mCmdParams = new DisplayTextParams(cmdDet, textMsg);
        }
    } else {
        mCmdParams = new DisplayTextParams(cmdDet, textMsg);
    }
    if (iconId != null) {
        mloadIcon = true;
        mIconLoadState = LOAD_SINGLE_ICON;
        mIconLoader.loadIcon(iconId.recordNumber, this.obtainMessage(MSG_ID_LOAD_ICON_DONE));
        return true;
    }
    return false;
}
#end_block

#method_before
static String retrieveSMSCaddress(ComprehensionTlv ctlv) throws ResultException {
    byte[] rawValue = ctlv.getRawValue();
    int valueIndex = ctlv.getValueIndex();
    int length = ctlv.getLength();
    byte[] outputValue = new byte[length + 1];
    for (int k = 0; k <= length; k++) {
        try {
            outputValue[k] = rawValue[k + (valueIndex - 1)];
        } catch (IndexOutOfBoundsException indexoutofboundsexception) {
            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        }
    }
    if (length != 0)
        return IccUtils.bytesToHexString(outputValue);
    else
        throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
}
#method_after
static String retrieveSMSCaddress(ComprehensionTlv ctlv) throws ResultException {
    byte[] rawValue = ctlv.getRawValue();
    int valueIndex = ctlv.getValueIndex();
    int length = ctlv.getLength();
    byte[] outputValue = new byte[length + 1];
    for (int k = 0; k <= length; k++) {
        try {
            outputValue[k] = rawValue[k + (valueIndex - 1)];
        } catch (IndexOutOfBoundsException indexoutofboundsexception) {
            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        }
    }
    if (length != 0) {
        return IccUtils.bytesToHexString(outputValue);
    } else {
        throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
    }
}
#end_block

#method_before
static String retrieveSMSTPDU(ComprehensionTlv ctlv) throws ResultException {
    byte[] rawValue = ctlv.getRawValue();
    int valueIndex = ctlv.getValueIndex();
    int pduLength = ctlv.getLength();
    byte[] outputValue;
    int k;
    String result;
    if (rawValue[valueIndex + 2] % 2 == 0)
        k = rawValue[valueIndex + 2] / 2;
    else
        k = (1 + rawValue[valueIndex + 2]) / 2;
    if (pduLength == k + 6)
        outputValue = new byte[pduLength + 1];
    else
        outputValue = new byte[pduLength];
    for (int l = 0; l < pduLength; l++) {
        try {
            outputValue[l] = rawValue[valueIndex + l];
        } catch (IndexOutOfBoundsException ex) {
            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        }
    }
    if (pduLength != 0)
        result = IccUtils.bytesToHexString(outputValue);
    else
        throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
    return result;
}
#method_after
static String retrieveSMSTPDU(ComprehensionTlv ctlv) throws ResultException {
    byte[] rawValue = ctlv.getRawValue();
    int valueIndex = ctlv.getValueIndex();
    int pduLength = ctlv.getLength();
    byte[] outputValue;
    int k;
    String result;
    if (rawValue[valueIndex + 2] % 2 == 0) {
        k = rawValue[valueIndex + 2] / 2;
    } else {
        k = (1 + rawValue[valueIndex + 2]) / 2;
    }
    if (pduLength == k + 6) {
        outputValue = new byte[pduLength + 1];
    } else {
        outputValue = new byte[pduLength];
    }
    for (int l = 0; l < pduLength; l++) {
        try {
            outputValue[l] = rawValue[valueIndex + l];
        } catch (IndexOutOfBoundsException ex) {
            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        }
    }
    if (pduLength != 0) {
        result = IccUtils.bytesToHexString(outputValue);
    } else {
        throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
    }
    return result;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    CatLog.d(this, "handleMessage[" + msg.what + "]");
    switch(msg.what) {
        case MSG_ID_SESSION_END:
        case MSG_ID_PROACTIVE_COMMAND:
        case MSG_ID_EVENT_NOTIFY:
        case MSG_ID_REFRESH:
            CatLog.d(this, "ril message arrived,slotid:" + mSlotId);
            String data = null;
            if (msg.obj != null) {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (ar != null && ar.result != null) {
                    try {
                        data = (String) ar.result;
                    } catch (ClassCastException e) {
                        break;
                    }
                }
            }
            mMsgDecoder.sendStartDecodingMessageParams(new RilMessage(msg.what, data));
            break;
        case MSG_ID_CALL_SETUP:
            mMsgDecoder.sendStartDecodingMessageParams(new RilMessage(msg.what, null));
            break;
        case MSG_ID_ICC_RECORDS_LOADED:
            break;
        case MSG_ID_RIL_MSG_DECODED:
            handleRilMsg((RilMessage) msg.obj);
            break;
        case MSG_ID_RESPONSE:
            handleCmdResponse((CatResponseMessage) msg.obj);
            break;
        case MSG_ID_ICC_CHANGED:
            CatLog.d(this, "MSG_ID_ICC_CHANGED");
            updateIccAvailability();
            break;
        case MSG_ID_ICC_REFRESH:
            if (msg.obj != null) {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (ar != null && ar.result != null) {
                    broadcastCardStateAndIccRefreshResp(CardState.CARDSTATE_PRESENT, (IccRefreshResponse) ar.result);
                } else {
                    CatLog.d(this, "Icc REFRESH with exception: " + ar.exception);
                }
            } else {
                CatLog.d(this, "IccRefresh Message is null");
            }
            break;
        case MSG_ID_ALPHA_NOTIFY:
            CatLog.d(this, "Received CAT CC Alpha message from card");
            if (msg.obj != null) {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (ar != null && ar.result != null) {
                    broadcastAlphaMessage((String) ar.result);
                } else {
                    CatLog.d(this, "CAT Alpha message: ar.result is null");
                }
            } else {
                CatLog.d(this, "CAT Alpha message: msg.obj is null");
            }
            break;
        case // Should only be called for Samsung STK
        MSG_ID_TIMEOUT:
            if (mTimeoutDest == WAITING_SMS_RESULT) {
                CatLog.d(this, "SMS SEND TIMEOUT");
                if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED)
                    sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                else
                    sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                break;
            }
            break;
        case // Samsung STK SEND_SMS
        MSG_ID_SEND_SMS_RESULT:
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
                int[] sendResult;
                AsyncResult ar;
                CatLog.d(this, "handleMsg : MSG_ID_SEND_SMS_RESULT");
                cancelTimeOut();
                CatLog.d(this, "The Msg ID data:" + msg.what);
                ar = (AsyncResult) msg.obj;
                if (ar == null || ar.result == null || mCurrntCmd == null || mCurrntCmd.mCmdDet == null)
                    break;
                sendResult = (int[]) ar.result;
                if (sendResult.length == 0)
                    break;
                switch(sendResult[0]) {
                    default:
                        CatLog.d(this, "SMS SEND GENERIC FAIL");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED)
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        else
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                        break;
                    case // '\0'
                    SMS_SEND_OK:
                        CatLog.d(this, "SMS SEND OK");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED)
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        else
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.OK, false, 0, null);
                        break;
                    case SMS_SEND_FAIL:
                        CatLog.d(this, "SMS SEND FAIL - MEMORY NOT AVAILABLE");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED)
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        else
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                        break;
                    case SMS_SEND_RETRY:
                        CatLog.d(this, "SMS SEND FAIL RETRY");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED)
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        else
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.NETWORK_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                        break;
                }
            }
            break;
        default:
            throw new AssertionError("Unrecognized CAT command: " + msg.what);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    CatLog.d(this, "handleMessage[" + msg.what + "]");
    switch(msg.what) {
        case MSG_ID_SESSION_END:
        case MSG_ID_PROACTIVE_COMMAND:
        case MSG_ID_EVENT_NOTIFY:
        case MSG_ID_REFRESH:
            CatLog.d(this, "ril message arrived,slotid:" + mSlotId);
            String data = null;
            if (msg.obj != null) {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (ar != null && ar.result != null) {
                    try {
                        data = (String) ar.result;
                    } catch (ClassCastException e) {
                        break;
                    }
                }
            }
            mMsgDecoder.sendStartDecodingMessageParams(new RilMessage(msg.what, data));
            break;
        case MSG_ID_CALL_SETUP:
            mMsgDecoder.sendStartDecodingMessageParams(new RilMessage(msg.what, null));
            break;
        case MSG_ID_ICC_RECORDS_LOADED:
            break;
        case MSG_ID_RIL_MSG_DECODED:
            handleRilMsg((RilMessage) msg.obj);
            break;
        case MSG_ID_RESPONSE:
            handleCmdResponse((CatResponseMessage) msg.obj);
            break;
        case MSG_ID_ICC_CHANGED:
            CatLog.d(this, "MSG_ID_ICC_CHANGED");
            updateIccAvailability();
            break;
        case MSG_ID_ICC_REFRESH:
            if (msg.obj != null) {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (ar != null && ar.result != null) {
                    broadcastCardStateAndIccRefreshResp(CardState.CARDSTATE_PRESENT, (IccRefreshResponse) ar.result);
                } else {
                    CatLog.d(this, "Icc REFRESH with exception: " + ar.exception);
                }
            } else {
                CatLog.d(this, "IccRefresh Message is null");
            }
            break;
        case MSG_ID_ALPHA_NOTIFY:
            CatLog.d(this, "Received CAT CC Alpha message from card");
            if (msg.obj != null) {
                AsyncResult ar = (AsyncResult) msg.obj;
                if (ar != null && ar.result != null) {
                    broadcastAlphaMessage((String) ar.result);
                } else {
                    CatLog.d(this, "CAT Alpha message: ar.result is null");
                }
            } else {
                CatLog.d(this, "CAT Alpha message: msg.obj is null");
            }
            break;
        case // Should only be called for Samsung STK
        MSG_ID_TIMEOUT:
            if (mTimeoutDest == WAITING_SMS_RESULT) {
                CatLog.d(this, "SMS SEND TIMEOUT");
                if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
                    sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                } else {
                    sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                }
            }
            break;
        case // Samsung STK SEND_SMS
        MSG_ID_SEND_SMS_RESULT:
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
                int[] sendResult;
                AsyncResult ar;
                CatLog.d(this, "handleMsg : MSG_ID_SEND_SMS_RESULT");
                cancelTimeOut();
                CatLog.d(this, "The Msg ID data:" + msg.what);
                ar = (AsyncResult) msg.obj;
                if (ar == null || ar.result == null || mCurrntCmd == null || mCurrntCmd.mCmdDet == null) {
                    break;
                }
                sendResult = (int[]) ar.result;
                if (sendResult.length == 0) {
                    break;
                }
                switch(sendResult[0]) {
                    default:
                        CatLog.d(this, "SMS SEND GENERIC FAIL");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        } else {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                        }
                        break;
                    case // '\0'
                    SMS_SEND_OK:
                        CatLog.d(this, "SMS SEND OK");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        } else {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.OK, false, 0, null);
                        }
                        break;
                    case SMS_SEND_FAIL:
                        CatLog.d(this, "SMS SEND FAIL - MEMORY NOT AVAILABLE");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        } else {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                        }
                        break;
                    case SMS_SEND_RETRY:
                        CatLog.d(this, "SMS SEND FAIL RETRY");
                        if (CallControlResult.fromInt(mCallControlResultCode) == CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
                        } else {
                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.NETWORK_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
                        }
                        break;
                }
            }
            break;
        default:
            throw new AssertionError("Unrecognized CAT command: " + msg.what);
    }
}
#end_block

#method_before
private void getImsService() {
    if (DBG)
        log("getImsService");
    mImsManager = ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId());
    try {
        mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
        // Get the ECBM interface and set IMSPhone's listener object for notifications
        getEcbmInterface().setEcbmStateListener(mPhone.mImsEcbmStateListener);
        if (mPhone.isInEcm()) {
            // Call exit ECBM which will invoke onECBMExited
            mPhone.exitEmergencyCallbackMode();
        }
        int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
        mImsManager.setUiTTYMode(mPhone.getContext(), mServiceId, mPreferredTtyMode, null);
        mImsManager.setVolteFeatureEnabled(isVolteEnabled());
    } catch (ImsException e) {
        loge("getImsService: " + e);
        // Leave mImsManager as null, then CallStateException will be thrown when dialing
        mImsManager = null;
    }
}
#method_after
private void getImsService() {
    if (DBG)
        log("getImsService");
    mImsManager = ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId());
    try {
        mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
        // Get the ECBM interface and set IMSPhone's listener object for notifications
        getEcbmInterface().setEcbmStateListener(mPhone.mImsEcbmStateListener);
        if (mPhone.isInEcm()) {
            // Call exit ECBM which will invoke onECBMExited
            mPhone.exitEmergencyCallbackMode();
        }
        int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
        mImsManager.setUiTTYMode(mPhone.getContext(), mServiceId, mPreferredTtyMode, null);
    } catch (ImsException e) {
        loge("getImsService: " + e);
        // Leave mImsManager as null, then CallStateException will be thrown when dialing
        mImsManager = null;
    }
}
#end_block

#method_before
private synchronized void removeConnection(ImsPhoneConnection conn) {
    mConnections.remove(conn);
    // If not emergency call is remaining, notify emergency call registrants
    if (mIsInEmergencyCall) {
        boolean isEmergencyCallInList = false;
        // if no emergency calls pending, set this to false
        for (ImsPhoneConnection imsPhoneConnection : mConnections) {
            if (imsPhoneConnection != null && imsPhoneConnection.isEmergency() == true) {
                isEmergencyCallInList = true;
                break;
            }
        }
        mIsInEmergencyCall = isEmergencyCallInList;
    }
}
#method_after
private synchronized void removeConnection(ImsPhoneConnection conn) {
    mConnections.remove(conn);
    // If not emergency call is remaining, notify emergency call registrants
    if (mIsInEmergencyCall) {
        boolean isEmergencyCallInList = false;
        // if no emergency calls pending, set this to false
        for (ImsPhoneConnection imsPhoneConnection : mConnections) {
            if (imsPhoneConnection != null && imsPhoneConnection.isEmergency() == true) {
                isEmergencyCallInList = true;
                break;
            }
        }
        if (!isEmergencyCallInList) {
            mIsInEmergencyCall = false;
            mPhone.mDefaultPhone.sendEmergencyCallStateChange(false);
        }
    }
}
#end_block

#method_before
private synchronized void addConnection(ImsPhoneConnection conn) {
    mConnections.add(conn);
    if (conn.isEmergency()) {
        mIsInEmergencyCall = true;
    }
}
#method_after
private synchronized void addConnection(ImsPhoneConnection conn) {
    mConnections.add(conn);
    if (conn.isEmergency()) {
        mIsInEmergencyCall = true;
        mPhone.mDefaultPhone.sendEmergencyCallStateChange(true);
    }
}
#end_block

#method_before
@Override
public int addSubInfoRecord(String iccId, int slotId) {
    if (DBG)
        logdl("[addSubInfoRecord]+ iccId:" + iccId + " slotId:" + slotId);
    enforceModifyPhoneState("addSubInfoRecord");
    // Now that all security checks passes, perform the operation as ourselves.
    final long identity = Binder.clearCallingIdentity();
    try {
        if (iccId == null) {
            if (DBG)
                logdl("[addSubInfoRecord]- null iccId");
            return -1;
        }
        ContentResolver resolver = mContext.getContentResolver();
        Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[] { SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE }, SubscriptionManager.ICC_ID + "=?", new String[] { iccId }, null);
        int color = getUnusedColor(mContext.getOpPackageName());
        boolean setDisplayName = false;
        try {
            if (cursor == null || !cursor.moveToFirst()) {
                setDisplayName = true;
                ContentValues value = new ContentValues();
                value.put(SubscriptionManager.ICC_ID, iccId);
                // default SIM color differs between slots
                value.put(SubscriptionManager.COLOR, color);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                value.put(SubscriptionManager.CARRIER_NAME, "");
                Uri uri = resolver.insert(SubscriptionManager.CONTENT_URI, value);
                if (DBG)
                    logdl("[addSubInfoRecord] New record created: " + uri);
            } else {
                int subId = cursor.getInt(0);
                int oldSimInfoId = cursor.getInt(1);
                int nameSource = cursor.getInt(2);
                ContentValues value = new ContentValues();
                if (slotId != oldSimInfoId) {
                    value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                }
                if (nameSource != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                    setDisplayName = true;
                }
                if (value.size() > 0) {
                    resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                }
                if (DBG)
                    logdl("[addSubInfoRecord] Record already exists");
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        cursor = resolver.query(SubscriptionManager.CONTENT_URI, null, SubscriptionManager.SIM_SLOT_INDEX + "=?", new String[] { String.valueOf(slotId) }, null);
        try {
            if (cursor != null && cursor.moveToFirst()) {
                do {
                    int subId = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
                    // If sSlotIdxToSubId already has a valid subId for a slotId/phoneId,
                    // do not add another subId for same slotId/phoneId.
                    Integer currentSubId = sSlotIdxToSubId.get(slotId);
                    if (currentSubId == null || !SubscriptionManager.isValidSubscriptionId(currentSubId)) {
                        // TODO While two subs active, if user deactivats first
                        // one, need to update the default subId with second one.
                        // FIXME: Currently we assume phoneId == slotId which in the future
                        // may not be true, for instance with multiple subs per slot.
                        // But is true at the moment.
                        sSlotIdxToSubId.put(slotId, subId);
                        int subIdCountMax = getActiveSubInfoCountMax();
                        int defaultSubId = getDefaultSubId();
                        if (DBG) {
                            logdl("[addSubInfoRecord]" + " sSlotIdxToSubId.size=" + sSlotIdxToSubId.size() + " slotId=" + slotId + " subId=" + subId + " defaultSubId=" + defaultSubId + " simCount=" + subIdCountMax);
                        }
                        // Also set default sub, if current default subId is not active
                        if (!SubscriptionManager.isValidSubscriptionId(defaultSubId) || subIdCountMax == 1 || (!isActiveSubId(defaultSubId))) {
                            setDefaultFallbackSubId(subId);
                        }
                        // If single sim device, set this subscription as the default for everything
                        if (subIdCountMax == 1) {
                            if (DBG) {
                                logdl("[addSubInfoRecord] one sim set defaults to subId=" + subId);
                            }
                            setDefaultDataSubId(subId);
                            setDefaultSmsSubId(subId);
                            setDefaultVoiceSubId(subId);
                        }
                        // FIXME: Workaround the scenario where default sms subid is not
                        // being set externally
                        // CYNGNOS-2185
                        int phoneId = SubscriptionController.getInstance().getPhoneId(getDefaultSmsSubId());
                        if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
                            Rlog.i(LOG_TAG, "Subscription is invalid. Set default to " + subId);
                            setDefaultSmsSubId(subId);
                            PhoneFactory.setSMSPromptEnabled(true);
                        }
                    } else {
                        if (DBG) {
                            logdl("[addSubInfoRecord] currentSubId != null" + " && currentSubId is valid, IGNORE");
                        }
                    }
                    if (DBG)
                        logdl("[addSubInfoRecord] hashmap(" + slotId + "," + subId + ")");
                } while (cursor.moveToNext());
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        // Set Display name after sub id is set above so as to get valid simCarrierName
        int[] subIds = getSubId(slotId);
        if (subIds == null || subIds.length == 0) {
            if (DBG) {
                logdl("[addSubInfoRecord]- getSubId failed subIds == null || length == 0 subIds=" + subIds);
            }
            return -1;
        }
        if (setDisplayName) {
            String simCarrierName = mTelephonyManager.getSimOperatorNameForSubscription(subIds[0]);
            String nameToSet;
            if (!TextUtils.isEmpty(simCarrierName)) {
                nameToSet = simCarrierName;
            } else {
                nameToSet = "CARD " + Integer.toString(slotId + 1);
            }
            ContentValues value = new ContentValues();
            value.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
            resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subIds[0]), null);
            if (DBG)
                logdl("[addSubInfoRecord] sim name = " + nameToSet);
        }
        // Once the records are loaded, notify DcTracker
        updateAllDataConnectionTrackers();
        if (DBG)
            logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    return 0;
}
#method_after
@Override
public int addSubInfoRecord(String iccId, int slotId) {
    if (DBG)
        logdl("[addSubInfoRecord]+ iccId:" + iccId + " slotId:" + slotId);
    enforceModifyPhoneState("addSubInfoRecord");
    // Now that all security checks passes, perform the operation as ourselves.
    final long identity = Binder.clearCallingIdentity();
    try {
        if (iccId == null) {
            if (DBG)
                logdl("[addSubInfoRecord]- null iccId");
            return -1;
        }
        ContentResolver resolver = mContext.getContentResolver();
        Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[] { SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE }, SubscriptionManager.ICC_ID + "=?", new String[] { iccId }, null);
        int color = getUnusedColor(mContext.getOpPackageName());
        boolean setDisplayName = false;
        try {
            if (cursor == null || !cursor.moveToFirst()) {
                setDisplayName = true;
                ContentValues value = new ContentValues();
                value.put(SubscriptionManager.ICC_ID, iccId);
                // default SIM color differs between slots
                value.put(SubscriptionManager.COLOR, color);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                value.put(SubscriptionManager.CARRIER_NAME, "");
                Uri uri = resolver.insert(SubscriptionManager.CONTENT_URI, value);
                if (DBG)
                    logdl("[addSubInfoRecord] New record created: " + uri);
            } else {
                int subId = cursor.getInt(0);
                int oldSimInfoId = cursor.getInt(1);
                int nameSource = cursor.getInt(2);
                ContentValues value = new ContentValues();
                if (slotId != oldSimInfoId) {
                    value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                }
                if (nameSource != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                    setDisplayName = true;
                }
                if (value.size() > 0) {
                    resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                }
                if (DBG)
                    logdl("[addSubInfoRecord] Record already exists");
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        cursor = resolver.query(SubscriptionManager.CONTENT_URI, null, SubscriptionManager.SIM_SLOT_INDEX + "=?", new String[] { String.valueOf(slotId) }, null);
        try {
            if (cursor != null && cursor.moveToFirst()) {
                do {
                    int subId = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
                    // If sSlotIdxToSubId already has a valid subId for a slotId/phoneId,
                    // do not add another subId for same slotId/phoneId.
                    Integer currentSubId = sSlotIdxToSubId.get(slotId);
                    if (currentSubId == null || !SubscriptionManager.isValidSubscriptionId(currentSubId)) {
                        // TODO While two subs active, if user deactivats first
                        // one, need to update the default subId with second one.
                        // FIXME: Currently we assume phoneId == slotId which in the future
                        // may not be true, for instance with multiple subs per slot.
                        // But is true at the moment.
                        sSlotIdxToSubId.put(slotId, subId);
                        int subIdCountMax = getActiveSubInfoCountMax();
                        int defaultSubId = getDefaultSubId();
                        if (DBG) {
                            logdl("[addSubInfoRecord]" + " sSlotIdxToSubId.size=" + sSlotIdxToSubId.size() + " slotId=" + slotId + " subId=" + subId + " defaultSubId=" + defaultSubId + " simCount=" + subIdCountMax);
                        }
                        // Also set default sub, if current default subId is not active
                        if (!SubscriptionManager.isValidSubscriptionId(defaultSubId) || subIdCountMax == 1 || (!isActiveSubId(defaultSubId))) {
                            setDefaultFallbackSubId(subId);
                        }
                        // If single sim device, set this subscription as the default for everything
                        if (subIdCountMax == 1) {
                            if (DBG) {
                                logdl("[addSubInfoRecord] one sim set defaults to subId=" + subId);
                            }
                            setDefaultDataSubId(subId);
                            setDefaultSmsSubId(subId);
                            setDefaultVoiceSubId(subId);
                        }
                        // FIXME: Workaround the scenario where default sms subid is not
                        // being set externally
                        // CYNGNOS-2185
                        int phoneId = SubscriptionController.getInstance().getPhoneId(getDefaultSmsSubId());
                        if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
                            Rlog.i(LOG_TAG, "Subscription is invalid. Set default to " + subId);
                            setDefaultSmsSubId(subId);
                            PhoneFactory.setSMSPromptEnabled(subIdCountMax > 1);
                        }
                    } else {
                        if (DBG) {
                            logdl("[addSubInfoRecord] currentSubId != null" + " && currentSubId is valid, IGNORE");
                        }
                    }
                    if (DBG)
                        logdl("[addSubInfoRecord] hashmap(" + slotId + "," + subId + ")");
                } while (cursor.moveToNext());
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        // Set Display name after sub id is set above so as to get valid simCarrierName
        int[] subIds = getSubId(slotId);
        if (subIds == null || subIds.length == 0) {
            if (DBG) {
                logdl("[addSubInfoRecord]- getSubId failed subIds == null || length == 0 subIds=" + subIds);
            }
            return -1;
        }
        if (setDisplayName) {
            String simCarrierName = mTelephonyManager.getSimOperatorNameForSubscription(subIds[0]);
            String nameToSet;
            if (!TextUtils.isEmpty(simCarrierName)) {
                nameToSet = simCarrierName;
            } else {
                nameToSet = "CARD " + Integer.toString(slotId + 1);
            }
            ContentValues value = new ContentValues();
            value.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
            resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subIds[0]), null);
            if (DBG)
                logdl("[addSubInfoRecord] sim name = " + nameToSet);
        }
        // Once the records are loaded, notify DcTracker
        updateAllDataConnectionTrackers();
        if (DBG)
            logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
        if (sSlotIdxToSubId.size() <= 1) {
            PhoneFactory.setSMSPromptEnabled(false);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    return 0;
}
#end_block

#method_before
@Override
public void setDefaultDataSubId(int subId) {
    enforceModifyPhoneState("setDefaultDataSubId");
    String flexMapSupportType = SystemProperties.get("persist.radio.flexmap_type", "dds");
    if (subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
        throw new RuntimeException("setDefaultDataSubId called with DEFAULT_SUB_ID");
    }
    if (DBG)
        logdl("[setDefaultDataSubId] subId=" + subId);
    ProxyController proxyController = ProxyController.getInstance();
    int len = sProxyPhones.length;
    logdl("[setDefaultDataSubId] num phones=" + len + " dds flex map = " + flexMapSupportType);
    // Initiate flex map process only if the flexmap support type is "dds".
    if (SubscriptionManager.isValidSubscriptionId(subId) && flexMapSupportType.equals("dds")) {
        // Only re-map modems if the new default data sub is valid
        RadioAccessFamily[] rafs = new RadioAccessFamily[len];
        boolean atLeastOneMatch = false;
        int slotId = PhoneConstants.DEFAULT_CARD_INDEX;
        for (int phoneId = 0; phoneId < len; phoneId++) {
            PhoneProxy phone = sProxyPhones[phoneId];
            int raf;
            int id = phone.getSubId();
            if (id == subId) {
                // TODO Handle the general case of N modems and M subscriptions.
                raf = proxyController.getMaxRafSupported();
                atLeastOneMatch = true;
                slotId = phoneId;
            } else {
                // TODO Handle the general case of N modems and M subscriptions.
                raf = proxyController.getMinRafSupported();
            }
            logdl("[setDefaultDataSubId] phoneId=" + phoneId + " subId=" + id + " RAF=" + raf);
            rafs[phoneId] = new RadioAccessFamily(phoneId, raf);
        }
        if (atLeastOneMatch) {
            proxyController.setRadioCapability(rafs);
            updateDataSubNetworkType(slotId, subId);
        } else {
            if (DBG)
                logdl("[setDefaultDataSubId] no valid subId's found - not updating.");
        }
    }
    // FIXME is this still needed?
    updateAllDataConnectionTrackers();
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, subId);
    broadcastDefaultDataSubIdChanged(subId);
}
#method_after
@Override
public void setDefaultDataSubId(int subId) {
    enforceModifyPhoneState("setDefaultDataSubId");
    String flexMapSupportType = SystemProperties.get("persist.radio.flexmap_type", "dds");
    if (subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
        throw new RuntimeException("setDefaultDataSubId called with DEFAULT_SUB_ID");
    }
    if (DBG)
        logdl("[setDefaultDataSubId] subId=" + subId);
    ProxyController proxyController = ProxyController.getInstance();
    int len = sProxyPhones.length;
    logdl("[setDefaultDataSubId] num phones=" + len + " dds flex map = " + flexMapSupportType);
    // Initiate flex map process only if the flexmap support type is "dds".
    if (SubscriptionManager.isValidSubscriptionId(subId) && flexMapSupportType.equals("dds")) {
        // Only re-map modems if the new default data sub is valid
        RadioAccessFamily[] rafs = new RadioAccessFamily[len];
        boolean atLeastOneMatch = false;
        int slotId = PhoneConstants.DEFAULT_CARD_INDEX;
        for (int phoneId = 0; phoneId < len; phoneId++) {
            PhoneProxy phone = sProxyPhones[phoneId];
            int raf;
            int id = phone.getSubId();
            if (id == subId) {
                // TODO Handle the general case of N modems and M subscriptions.
                raf = proxyController.getMaxRafSupported();
                atLeastOneMatch = true;
                slotId = phoneId;
            } else {
                // TODO Handle the general case of N modems and M subscriptions.
                raf = proxyController.getMinRafSupported();
            }
            logdl("[setDefaultDataSubId] phoneId=" + phoneId + " subId=" + id + " RAF=" + raf);
            rafs[phoneId] = new RadioAccessFamily(phoneId, raf);
        }
        if (atLeastOneMatch) {
            proxyController.setRadioCapability(rafs);
            if (!SystemProperties.getBoolean("ro.ril.multi_rat_capable", true)) {
                updateDataSubNetworkType(slotId, subId);
            }
        } else {
            if (DBG)
                logdl("[setDefaultDataSubId] no valid subId's found - not updating.");
        }
    }
    // FIXME is this still needed?
    updateAllDataConnectionTrackers();
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, subId);
    broadcastDefaultDataSubIdChanged(subId);
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange) {
    mEnabled.set(Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.SMS_SHORT_CODE_CONFIRMATION, 1) != 0);
}
#method_after
@Override
public void onChange(boolean selfChange) {
    mEnabled.set(Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.SMS_SHORT_CODE_CONFIRMATION, 1) != 0);
    mLimit.set(Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.SMS_OUTGOING_CHECK_MAX_COUNT, DEFAULT_SMS_MAX_COUNT));
    mPeriod.set(Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.SMS_OUTGOING_CHECK_INTERVAL_MS, DEFAULT_SMS_CHECK_PERIOD));
}
#end_block

#method_before
private void removeExpiredTimestamps() {
    long beginCheckPeriod = System.currentTimeMillis() - mCheckPeriod;
    synchronized (mSmsStamp) {
        Iterator<Map.Entry<String, ArrayList<Long>>> iter = mSmsStamp.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry<String, ArrayList<Long>> entry = iter.next();
            ArrayList<Long> oldList = entry.getValue();
            if (oldList.isEmpty() || oldList.get(oldList.size() - 1) < beginCheckPeriod) {
                iter.remove();
            }
        }
    }
}
#method_after
private void removeExpiredTimestamps() {
    long beginCheckPeriod = System.currentTimeMillis() - mCheckPeriod.get();
    synchronized (mSmsStamp) {
        Iterator<Map.Entry<String, ArrayList<Long>>> iter = mSmsStamp.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry<String, ArrayList<Long>> entry = iter.next();
            ArrayList<Long> oldList = entry.getValue();
            if (oldList.isEmpty() || oldList.get(oldList.size() - 1) < beginCheckPeriod) {
                iter.remove();
            }
        }
    }
}
#end_block

#method_before
private boolean isUnderLimit(ArrayList<Long> sent, int smsWaiting) {
    Long ct = System.currentTimeMillis();
    long beginCheckPeriod = ct - mCheckPeriod;
    if (VDBG)
        log("SMS send size=" + sent.size() + " time=" + ct);
    while (!sent.isEmpty() && sent.get(0) < beginCheckPeriod) {
        sent.remove(0);
    }
    if ((sent.size() + smsWaiting) <= mMaxAllowed.get()) {
        for (int i = 0; i < smsWaiting; i++) {
            sent.add(ct);
        }
        return true;
    }
    return false;
}
#method_after
private boolean isUnderLimit(ArrayList<Long> sent, int smsWaiting) {
    Long ct = System.currentTimeMillis();
    long beginCheckPeriod = ct - mCheckPeriod.get();
    if (VDBG)
        log("SMS send size=" + sent.size() + " time=" + ct);
    while (!sent.isEmpty() && sent.get(0) < beginCheckPeriod) {
        sent.remove(0);
    }
    if ((sent.size() + smsWaiting) <= mMaxAllowed.get()) {
        for (int i = 0; i < smsWaiting; i++) {
            sent.add(ct);
        }
        return true;
    }
    return false;
}
#end_block

#method_before
protected ApnSetting getPreferredApn(ArrayList<ApnSetting> apnList) {
    if (apnList == null || apnList.isEmpty()) {
        log("getPreferredApn: apnList is " + ((apnList == null) ? "null" : "empty"));
        return null;
    }
    String subId = Long.toString(mPhone.getSubId());
    String imsi = mPhone.getSubscriberId();
    Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID_IMSI, subId);
    uri = Uri.withAppendedPath(uri, imsi);
    Cursor cursor = mPhone.getContext().getContentResolver().query(uri, new String[] { "_id", "name", "apn" }, null, null, Telephony.Carriers.DEFAULT_SORT_ORDER);
    if (cursor != null) {
        mCanSetPreferApn = true;
    } else {
        mCanSetPreferApn = false;
    }
    log("getPreferredApn: mRequestedApnType=" + mRequestedApnType + " cursor=" + cursor + " cursor.count=" + ((cursor != null) ? cursor.getCount() : 0));
    if (mCanSetPreferApn && cursor.getCount() > 0) {
        int pos;
        cursor.moveToFirst();
        pos = cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers._ID));
        for (ApnSetting p : apnList) {
            log("getPreferredApn: apnSetting=" + p);
            if (p.id == pos && p.canHandleType(mRequestedApnType)) {
                log("getPreferredApn: X found apnSetting" + p);
                cursor.close();
                return p;
            }
        }
    }
    if (cursor != null) {
        cursor.close();
    }
    // fall back without imsi
    uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
    try (Cursor fallback = mPhone.getContext().getContentResolver().query(uri, new String[] { "_id", "name", "apn" }, null, null, Telephony.Carriers.DEFAULT_SORT_ORDER)) {
        if (fallback != null) {
            log("getPreferredApn: mRequestedApnType=" + mRequestedApnType + " cursor(fallback)=" + fallback + " cursor(fallback).count=" + ((fallback != null) ? fallback.getCount() : 0));
            if (fallback.getCount() > 0) {
                int pos;
                fallback.moveToFirst();
                pos = fallback.getInt(fallback.getColumnIndexOrThrow(Telephony.Carriers._ID));
                for (ApnSetting p : apnList) {
                    log("getPreferredApn: apnSetting=" + p);
                    if (p.id == pos && p.canHandleType(mRequestedApnType)) {
                        log("getPreferredApn: X found apnSetting" + p);
                        return p;
                    }
                }
            }
        }
    }
    log("getPreferredApn: X not found");
    return null;
}
#method_after
protected ApnSetting getPreferredApn(ArrayList<ApnSetting> apnList) {
    if (apnList == null || apnList.isEmpty()) {
        log("getPreferredApn: apnList is " + ((apnList == null) ? "null" : "empty"));
        return null;
    }
    String subId = Long.toString(mPhone.getSubId());
    String imsi = mPhone.getSubscriberId();
    Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID_IMSI, subId);
    uri = Uri.withAppendedPath(uri, imsi);
    Cursor cursor = mPhone.getContext().getContentResolver().query(uri, new String[] { "_id", "name", "apn" }, null, null, Telephony.Carriers.DEFAULT_SORT_ORDER);
    if (cursor != null) {
        mCanSetPreferApn = true;
    } else {
        mCanSetPreferApn = false;
    }
    log("getPreferredApn: mRequestedApnType=" + mRequestedApnType + " cursor=" + cursor + " cursor.count=" + ((cursor != null) ? cursor.getCount() : 0));
    if (mCanSetPreferApn && cursor.getCount() > 0) {
        int pos;
        cursor.moveToFirst();
        pos = cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers._ID));
        for (ApnSetting p : apnList) {
            log("getPreferredApn: apnSetting=" + p);
            if (p.id == pos && p.canHandleType(mRequestedApnType)) {
                log("getPreferredApn: X found apnSetting" + p);
                cursor.close();
                return p;
            }
        }
    }
    if (cursor != null) {
        cursor.close();
    }
    // fall back without imsi
    uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
    try (Cursor fallback = mPhone.getContext().getContentResolver().query(uri, new String[] { "_id", "name", "apn" }, null, null, Telephony.Carriers.DEFAULT_SORT_ORDER)) {
        if (fallback != null) {
            mCanSetPreferApn = true;
        } else {
            mCanSetPreferApn = false;
        }
        log("getPreferredApn: mRequestedApnType=" + mRequestedApnType + " cursor(fallback)=" + fallback + " cursor(fallback).count=" + ((fallback != null) ? fallback.getCount() : 0));
        if (mCanSetPreferApn && fallback.getCount() > 0) {
            int pos;
            fallback.moveToFirst();
            pos = fallback.getInt(fallback.getColumnIndexOrThrow(Telephony.Carriers._ID));
            for (ApnSetting p : apnList) {
                log("getPreferredApn: apnSetting=" + p);
                if (p.id == pos && p.canHandleType(mRequestedApnType)) {
                    log("getPreferredApn: X found apnSetting" + p);
                    return p;
                }
            }
        }
    }
    log("getPreferredApn: X not found");
    return null;
}
#end_block

#method_before
// ***** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    IccIoResult result;
    Message response = null;
    String str;
    LoadLinearFixedContext lc;
    byte[] data;
    int size;
    int fileid;
    int[] recordSize;
    String path = null;
    try {
        switch(msg.what) {
            case EVENT_GET_EF_LINEAR_RECORD_SIZE_DONE:
                ar = (AsyncResult) msg.obj;
                lc = (LoadLinearFixedContext) ar.userObj;
                result = (IccIoResult) ar.result;
                response = lc.mOnLoaded;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                data = result.payload;
                if (UiccTlvData.isUiccTlvData(data)) {
                    UiccTlvData tlvData = UiccTlvData.parse(data);
                    if (tlvData.isIncomplete()) {
                        throw new IccFileTypeMismatch();
                    }
                    recordSize = new int[3];
                    recordSize[0] = tlvData.mRecordSize;
                    recordSize[1] = tlvData.mFileSize;
                    recordSize[2] = tlvData.mNumRecords;
                } else if (TYPE_EF == data[RESPONSE_DATA_FILE_TYPE] && EF_TYPE_LINEAR_FIXED == data[RESPONSE_DATA_STRUCTURE]) {
                    recordSize = new int[3];
                    recordSize[0] = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
                    recordSize[1] = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8) + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
                    recordSize[2] = recordSize[1] / recordSize[0];
                } else {
                    throw new IccFileTypeMismatch();
                }
                sendResult(response, recordSize, null);
                break;
            case EVENT_GET_RECORD_SIZE_IMG_DONE:
            case EVENT_GET_RECORD_SIZE_DONE:
                ar = (AsyncResult) msg.obj;
                lc = (LoadLinearFixedContext) ar.userObj;
                result = (IccIoResult) ar.result;
                response = lc.mOnLoaded;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                data = result.payload;
                path = lc.mPath;
                if (UiccTlvData.isUiccTlvData(data)) {
                    UiccTlvData tlvData = UiccTlvData.parse(data);
                    if (tlvData.isIncomplete()) {
                        throw new IccFileTypeMismatch();
                    }
                    lc.mRecordSize = tlvData.mRecordSize;
                    lc.mCountRecords = tlvData.mNumRecords;
                    size = tlvData.mFileSize;
                } else if (TYPE_EF == data[RESPONSE_DATA_FILE_TYPE]) {
                    if (EF_TYPE_LINEAR_FIXED != data[RESPONSE_DATA_STRUCTURE]) {
                        throw new IccFileTypeMismatch();
                    }
                    lc.mRecordSize = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
                    size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8) + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
                    lc.mCountRecords = size / lc.mRecordSize;
                } else {
                    throw new IccFileTypeMismatch();
                }
                if (lc.mLoadAll) {
                    lc.results = new ArrayList<byte[]>(lc.mCountRecords);
                } else if (lc.mLoadPart) {
                    lc.initLCResults(lc.mCountRecords);
                }
                if (path == null) {
                    path = getEFPath(lc.mEfid);
                }
                mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path, lc.mRecordNum, READ_RECORD_MODE_ABSOLUTE, lc.mRecordSize, null, null, mAid, obtainMessage(EVENT_READ_RECORD_DONE, lc));
                break;
            case EVENT_GET_BINARY_SIZE_DONE:
                ar = (AsyncResult) msg.obj;
                response = (Message) ar.userObj;
                result = (IccIoResult) ar.result;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                data = result.payload;
                fileid = msg.arg1;
                if (UiccTlvData.isUiccTlvData(data)) {
                    UiccTlvData tlvData = UiccTlvData.parse(data);
                    if (tlvData.mFileSize < 0) {
                        throw new IccFileTypeMismatch();
                    }
                    size = tlvData.mFileSize;
                } else if (TYPE_EF == data[RESPONSE_DATA_FILE_TYPE]) {
                    if (EF_TYPE_TRANSPARENT != data[RESPONSE_DATA_STRUCTURE]) {
                        throw new IccFileTypeMismatch();
                    }
                    size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8) + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
                } else {
                    throw new IccFileTypeMismatch();
                }
                mCi.iccIOForApp(COMMAND_READ_BINARY, fileid, getEFPath(fileid), 0, 0, size, null, null, mAid, obtainMessage(EVENT_READ_BINARY_DONE, fileid, 0, response));
                break;
            case EVENT_READ_IMG_DONE:
            case EVENT_READ_RECORD_DONE:
                ar = (AsyncResult) msg.obj;
                lc = (LoadLinearFixedContext) ar.userObj;
                result = (IccIoResult) ar.result;
                response = lc.mOnLoaded;
                path = lc.mPath;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                if (lc.mLoadAll) {
                    lc.results.add(result.payload);
                    lc.mRecordNum++;
                    if (lc.mRecordNum > lc.mCountRecords) {
                        sendResult(response, lc.results, null);
                    } else {
                        if (path == null) {
                            path = getEFPath(lc.mEfid);
                        }
                        mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path, lc.mRecordNum, READ_RECORD_MODE_ABSOLUTE, lc.mRecordSize, null, null, mAid, obtainMessage(EVENT_READ_RECORD_DONE, lc));
                    }
                } else if (lc.mLoadPart) {
                    lc.results.set(lc.mRecordNum - 1, result.payload);
                    lc.mCount++;
                    if (lc.mCount < lc.mCountLoadrecords) {
                        lc.mRecordNum = lc.mRecordNums.get(lc.mCount);
                        if (lc.mRecordNum <= lc.mCountRecords) {
                            if (path == null) {
                                path = getEFPath(lc.mEfid);
                            }
                            mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path, lc.mRecordNum, READ_RECORD_MODE_ABSOLUTE, lc.mRecordSize, null, null, mAid, obtainMessage(EVENT_READ_RECORD_DONE, lc));
                        } else {
                            sendResult(response, lc.results, null);
                        }
                    } else {
                        sendResult(response, lc.results, null);
                    }
                } else {
                    sendResult(response, result.payload, null);
                }
                break;
            case EVENT_READ_BINARY_DONE:
            case EVENT_READ_ICON_DONE:
                ar = (AsyncResult) msg.obj;
                response = (Message) ar.userObj;
                result = (IccIoResult) ar.result;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                sendResult(response, result.payload, null);
                break;
        }
    } catch (Exception exc) {
        if (response != null) {
            sendResult(response, null, exc);
        } else {
            loge("uncaught exception" + exc);
        }
    }
}
#method_after
// ***** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    IccIoResult result;
    Message response = null;
    String str;
    LoadLinearFixedContext lc;
    byte[] data;
    int size;
    int fileid;
    int[] recordSize;
    String path = null;
    try {
        switch(msg.what) {
            case EVENT_GET_EF_LINEAR_RECORD_SIZE_DONE:
                ar = (AsyncResult) msg.obj;
                lc = (LoadLinearFixedContext) ar.userObj;
                result = (IccIoResult) ar.result;
                response = lc.mOnLoaded;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                data = result.payload;
                if (UiccTlvData.isUiccTlvData(data)) {
                    UiccTlvData tlvData = UiccTlvData.parse(data);
                    if (tlvData.isIncomplete()) {
                        throw new IccFileTypeMismatch();
                    }
                    recordSize = new int[3];
                    recordSize[0] = tlvData.mRecordSize;
                    recordSize[1] = tlvData.mFileSize;
                    recordSize[2] = tlvData.mNumRecords;
                } else {
                    if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE] || EF_TYPE_LINEAR_FIXED != data[RESPONSE_DATA_STRUCTURE]) {
                        throw new IccFileTypeMismatch();
                    }
                    recordSize = new int[3];
                    recordSize[0] = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
                    recordSize[1] = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8) + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
                    recordSize[2] = recordSize[1] / recordSize[0];
                }
                sendResult(response, recordSize, null);
                break;
            case EVENT_GET_RECORD_SIZE_IMG_DONE:
            case EVENT_GET_RECORD_SIZE_DONE:
                ar = (AsyncResult) msg.obj;
                lc = (LoadLinearFixedContext) ar.userObj;
                result = (IccIoResult) ar.result;
                response = lc.mOnLoaded;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                data = result.payload;
                path = lc.mPath;
                if (UiccTlvData.isUiccTlvData(data)) {
                    UiccTlvData tlvData = UiccTlvData.parse(data);
                    if (tlvData.isIncomplete()) {
                        throw new IccFileTypeMismatch();
                    }
                    lc.mRecordSize = tlvData.mRecordSize;
                    lc.mCountRecords = tlvData.mNumRecords;
                    size = tlvData.mFileSize;
                } else {
                    if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE]) {
                        throw new IccFileTypeMismatch();
                    }
                    if (EF_TYPE_LINEAR_FIXED != data[RESPONSE_DATA_STRUCTURE]) {
                        throw new IccFileTypeMismatch();
                    }
                    lc.mRecordSize = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
                    size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8) + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
                    lc.mCountRecords = size / lc.mRecordSize;
                }
                if (lc.mLoadAll) {
                    lc.results = new ArrayList<byte[]>(lc.mCountRecords);
                } else if (lc.mLoadPart) {
                    lc.initLCResults(lc.mCountRecords);
                }
                if (path == null) {
                    path = getEFPath(lc.mEfid);
                }
                mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path, lc.mRecordNum, READ_RECORD_MODE_ABSOLUTE, lc.mRecordSize, null, null, mAid, obtainMessage(EVENT_READ_RECORD_DONE, lc));
                break;
            case EVENT_GET_BINARY_SIZE_DONE:
                ar = (AsyncResult) msg.obj;
                response = (Message) ar.userObj;
                result = (IccIoResult) ar.result;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                data = result.payload;
                fileid = msg.arg1;
                if (UiccTlvData.isUiccTlvData(data)) {
                    UiccTlvData tlvData = UiccTlvData.parse(data);
                    if (tlvData.mFileSize < 0) {
                        throw new IccFileTypeMismatch();
                    }
                    size = tlvData.mFileSize;
                } else {
                    if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE]) {
                        throw new IccFileTypeMismatch();
                    }
                    if (EF_TYPE_TRANSPARENT != data[RESPONSE_DATA_STRUCTURE]) {
                        throw new IccFileTypeMismatch();
                    }
                    size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8) + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
                }
                mCi.iccIOForApp(COMMAND_READ_BINARY, fileid, getEFPath(fileid), 0, 0, size, null, null, mAid, obtainMessage(EVENT_READ_BINARY_DONE, fileid, 0, response));
                break;
            case EVENT_READ_IMG_DONE:
            case EVENT_READ_RECORD_DONE:
                ar = (AsyncResult) msg.obj;
                lc = (LoadLinearFixedContext) ar.userObj;
                result = (IccIoResult) ar.result;
                response = lc.mOnLoaded;
                path = lc.mPath;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                if (lc.mLoadAll) {
                    lc.results.add(result.payload);
                    lc.mRecordNum++;
                    if (lc.mRecordNum > lc.mCountRecords) {
                        sendResult(response, lc.results, null);
                    } else {
                        if (path == null) {
                            path = getEFPath(lc.mEfid);
                        }
                        mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path, lc.mRecordNum, READ_RECORD_MODE_ABSOLUTE, lc.mRecordSize, null, null, mAid, obtainMessage(EVENT_READ_RECORD_DONE, lc));
                    }
                } else if (lc.mLoadPart) {
                    lc.results.set(lc.mRecordNum - 1, result.payload);
                    lc.mCount++;
                    if (lc.mCount < lc.mCountLoadrecords) {
                        lc.mRecordNum = lc.mRecordNums.get(lc.mCount);
                        if (lc.mRecordNum <= lc.mCountRecords) {
                            if (path == null) {
                                path = getEFPath(lc.mEfid);
                            }
                            mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path, lc.mRecordNum, READ_RECORD_MODE_ABSOLUTE, lc.mRecordSize, null, null, mAid, obtainMessage(EVENT_READ_RECORD_DONE, lc));
                        } else {
                            sendResult(response, lc.results, null);
                        }
                    } else {
                        sendResult(response, lc.results, null);
                    }
                } else {
                    sendResult(response, result.payload, null);
                }
                break;
            case EVENT_READ_BINARY_DONE:
            case EVENT_READ_ICON_DONE:
                ar = (AsyncResult) msg.obj;
                response = (Message) ar.userObj;
                result = (IccIoResult) ar.result;
                if (processException(response, (AsyncResult) msg.obj)) {
                    break;
                }
                sendResult(response, result.payload, null);
                break;
        }
    } catch (Exception exc) {
        if (response != null) {
            sendResult(response, null, exc);
        } else {
            loge("uncaught exception" + exc);
        }
    }
}
#end_block

#method_before
public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus, Message result) {
    // Note: This RIL request is also valid for SIM and RUIM (ICC card)
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " slot: " + slotId + " appIndex: " + appIndex + " subId: " + subId + " subStatus: " + subStatus);
    rr.mParcel.writeInt(slotId);
    rr.mParcel.writeInt(appIndex);
    rr.mParcel.writeInt(subId);
    rr.mParcel.writeInt(subStatus);
    send(rr);
}
#method_after
public void setUiccSubscription(int appIndex, boolean activate, Message result) {
    // Note: This RIL request is also valid for SIM and RUIM (ICC card)
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " appIndex: " + appIndex + " activate: " + activate);
    rr.mParcel.writeInt(mInstanceId);
    rr.mParcel.writeInt(appIndex);
    rr.mParcel.writeInt(mInstanceId);
    rr.mParcel.writeInt(activate ? 1 : 0);
    send(rr);
}
#end_block

#method_before
@Override
public void getIMSIForApp(String aid, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> getIMSI: " + requestToString(rr.mRequest) + " aid: " + aid);
    send(rr);
}
#method_after
@Override
public void getIMSIForApp(String aid, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
    boolean writeAidOnly = needsOldRilFeature("writeaidonly");
    if (!writeAidOnly) {
        rr.mParcel.writeInt(1);
    }
    rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> getIMSI: " + requestToString(rr.mRequest) + " aid: " + aid);
    send(rr);
}
#end_block

#method_before
protected RadioState getRadioStateFromInt(int stateInt) {
    RadioState state;
    /* RIL_RadioState ril.h */
    switch(stateInt) {
        case 0:
            state = RadioState.RADIO_OFF;
            break;
        case 1:
            state = RadioState.RADIO_UNAVAILABLE;
            break;
        case 10:
            state = RadioState.RADIO_ON;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_RadioState: " + stateInt);
    }
    return state;
}
#method_after
protected RadioState getRadioStateFromInt(int stateInt) {
    RadioState state;
    /* RIL_RadioState ril.h */
    switch(stateInt) {
        case 0:
            state = RadioState.RADIO_OFF;
            break;
        case 1:
            state = RadioState.RADIO_UNAVAILABLE;
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
            state = RadioState.RADIO_ON;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_RadioState: " + stateInt);
    }
    return state;
}
#end_block

#method_before
/**
 * Holds a PARTIAL_WAKE_LOCK whenever
 * a) There is outstanding RIL request sent to RIL deamon and no replied
 * b) There is a request pending to be sent out.
 *
 * There is a WAKE_LOCK_TIMEOUT to release the lock, though it shouldn't
 * happen often.
 */
private void acquireWakeLock(RILRequest rr, int wakeLockType) {
    synchronized (rr) {
        if (rr.mWakeLockType != INVALID_WAKELOCK) {
            Rlog.d(RILJ_LOG_TAG, "Failed to aquire wakelock for " + rr.serialString());
            return;
        }
        switch(wakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mWakeLock.acquire();
                    mWakeLockCount++;
                    mWlSequenceNum++;
                    Message msg = mSender.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mWlSequenceNum;
                    mSender.sendMessageDelayed(msg, mWakeLockTimeout);
                }
                break;
            case FOR_ACK_WAKELOCK:
                synchronized (mAckWakeLock) {
                    mAckWakeLock.acquire();
                    mAckWlSequenceNum++;
                    Message msg = mSender.obtainMessage(EVENT_ACK_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mAckWlSequenceNum;
                    mSender.sendMessageDelayed(msg, mAckWakeLockTimeout);
                }
                break;
            default:
                // WTF
                Rlog.w(RILJ_LOG_TAG, "Acquiring Invalid Wakelock type " + wakeLockType);
                return;
        }
        rr.mWakeLockType = wakeLockType;
    }
}
#method_after
/**
 * Holds a PARTIAL_WAKE_LOCK whenever
 * a) There is outstanding RIL request sent to RIL deamon and no replied
 * b) There is a request pending to be sent out.
 *
 * There is a WAKE_LOCK_TIMEOUT to release the lock, though it shouldn't
 * happen often.
 */
protected void acquireWakeLock(RILRequest rr, int wakeLockType) {
    synchronized (rr) {
        if (rr.mWakeLockType != INVALID_WAKELOCK) {
            Rlog.d(RILJ_LOG_TAG, "Failed to aquire wakelock for " + rr.serialString());
            return;
        }
        switch(wakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mWakeLock.acquire();
                    mWakeLockCount++;
                    mWlSequenceNum++;
                    Message msg = mSender.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mWlSequenceNum;
                    mSender.sendMessageDelayed(msg, mWakeLockTimeout);
                }
                break;
            case FOR_ACK_WAKELOCK:
                synchronized (mAckWakeLock) {
                    mAckWakeLock.acquire();
                    mAckWlSequenceNum++;
                    Message msg = mSender.obtainMessage(EVENT_ACK_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mAckWlSequenceNum;
                    mSender.sendMessageDelayed(msg, mAckWakeLockTimeout);
                }
                break;
            default:
                // WTF
                Rlog.w(RILJ_LOG_TAG, "Acquiring Invalid Wakelock type " + wakeLockType);
                return;
        }
        rr.mWakeLockType = wakeLockType;
    }
}
#end_block

#method_before
protected void processUnsolicited(Parcel p, int type) {
    int response;
    Object ret;
    response = p.readInt();
    // Follow new symantics of sending an Ack starting from RIL version 13
    if (getRilVersion() >= 13 && type == RESPONSE_UNSOLICITED_ACK_EXP) {
        Message msg;
        RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, rr);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Unsol response received for " + responseToString(response) + " Sending ack to ril.cpp");
        }
    }
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_RECORDS:
                ret = responseAdnRecords(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
                ret = responseVoid(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                mEventLog.writeRilNewSms(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            mEventLog.writeRilNewSms(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                mEventLog.writeRilSrvcc(((int[]) ret)[0]);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnInitDoneRegistrants != null) {
                mAdnInitDoneRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_RECORDS:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnRecordsInfoRegistrants != null) {
                mAdnRecordsInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#method_after
protected void processUnsolicited(Parcel p, int type) {
    int response;
    Object ret;
    response = p.readInt();
    // Follow new symantics of sending an Ack starting from RIL version 13
    if (getRilVersion() >= 13 && type == RESPONSE_UNSOLICITED_ACK_EXP) {
        Message msg;
        RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, rr);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Unsol response received for " + responseToString(response) + " Sending ack to ril.cpp");
        }
    }
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_RECORDS:
                ret = responseAdnRecords(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
                ret = responseVoid(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                mEventLog.writeRilNewSms(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            mEventLog.writeRilNewSms(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                if (needsOldRilFeature("setPrefNwTypeOnUnsolConnected")) {
                    setPreferredNetworkType(mPreferredNetworkType, null);
                }
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                mEventLog.writeRilSrvcc(((int[]) ret)[0]);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnInitDoneRegistrants != null) {
                mAdnInitDoneRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_RECORDS:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnRecordsInfoRegistrants != null) {
                mAdnRecordsInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#end_block

#method_before
protected DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
    } else {
        dataCall.status = p.readInt();
        dataCall.suggestedRetryTime = p.readInt();
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#method_after
protected DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        // APN not used
        if (version < 4)
            p.readString();
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        // DataCallState needs an ifname. Since we don't have one,
        // use the name from the ThrottleService resource. (default = rmnet0)
        dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
    } else {
        dataCall.status = p.readInt();
        dataCall.suggestedRetryTime = p.readInt();
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#end_block

#method_before
protected Object responseOperatorInfos(Parcel p) {
    String[] strings = (String[]) responseStrings(p);
    ArrayList<OperatorInfo> ret;
    if (strings.length % 4 != 0) {
        throw new RuntimeException("RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got " + strings.length + " strings, expected multible of 4");
    }
    ret = new ArrayList<OperatorInfo>(strings.length / 4);
    for (int i = 0; i < strings.length; i += 4) {
        ret.add(new OperatorInfo(strings[i + 0], strings[i + 1], strings[i + 2], strings[i + 3]));
    }
    return ret;
}
#method_after
protected Object responseOperatorInfos(Parcel p) {
    String[] strings = (String[]) responseStrings(p);
    ArrayList<OperatorInfo> ret;
    if (strings.length % mQANElements != 0) {
        throw new RuntimeException("RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got " + strings.length + " strings, expected multiple of " + mQANElements);
    }
    ret = new ArrayList<OperatorInfo>(strings.length / mQANElements);
    for (int i = 0; i < strings.length; i += mQANElements) {
        ret.add(new OperatorInfo(strings[i + 0], strings[i + 1], strings[i + 2], strings[i + 3]));
    }
    return ret;
}
#end_block

#method_before
@Override
public void iccOpenLogicalChannel(String AID, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL, response);
    rr.mParcel.writeString(AID);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void iccOpenLogicalChannel(String AID, Message response) {
    if (mRilVersion < 10) {
        if (response != null) {
            CommandException ex = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response, null, ex);
            response.sendToTarget();
        }
        return;
    }
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL, response);
    rr.mParcel.writeString(AID);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

#method_before
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    iccTransmitApduHelper(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, channel, cla, instruction, p1, p2, p3, data, response);
}
#method_after
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    if (mRilVersion < 10) {
        if (response != null) {
            CommandException ex = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response, null, ex);
            response.sendToTarget();
        }
        return;
    }
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    iccTransmitApduHelper(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, channel, cla, instruction, p1, p2, p3, data, response);
}
#end_block

#method_before
private void iccTransmitApduHelper(int rilCommand, int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    RILRequest rr = RILRequest.obtain(rilCommand, response);
    rr.mParcel.writeInt(channel);
    rr.mParcel.writeInt(cla);
    rr.mParcel.writeInt(instruction);
    rr.mParcel.writeInt(p1);
    rr.mParcel.writeInt(p2);
    rr.mParcel.writeInt(p3);
    rr.mParcel.writeString(data);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
private void iccTransmitApduHelper(int rilCommand, int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    if (mRilVersion < 10) {
        if (response != null) {
            CommandException ex = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response, null, ex);
            response.sendToTarget();
        }
        return;
    }
    RILRequest rr = RILRequest.obtain(rilCommand, response);
    rr.mParcel.writeInt(channel);
    rr.mParcel.writeInt(cla);
    rr.mParcel.writeInt(instruction);
    rr.mParcel.writeInt(p1);
    rr.mParcel.writeInt(p2);
    rr.mParcel.writeInt(p3);
    rr.mParcel.writeString(data);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

#method_before
public static void makeDefaultPhone(Context context) {
    synchronized (sLockProxyPhones) {
        if (!sMadeDefaults) {
            sContext = context;
            // create the telephony device controller.
            TelephonyDevController.create();
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            TelephonyComponentFactory telephonyComponentFactory = TelephonyComponentFactory.getInstance();
            // Get preferred network mode
            int preferredNetworkMode = RILConstants.PREFERRED_NETWORK_MODE;
            if (preferredNetworkMode < RILConstants.NETWORK_MODE_TDSCDMA_ONLY) {
                if (TelephonyManager.getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                    preferredNetworkMode = Phone.NT_MODE_GLOBAL;
                }
                if (TelephonyManager.getLteOnGsmModeStatic() != 0) {
                    preferredNetworkMode = Phone.NT_MODE_LTE_GSM_WCDMA;
                }
            }
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            /* In case of multi SIM mode two instances of Phone, RIL are created,
                   where as in single SIM mode only instance. isMultiSimEnabled() function checks
                   whether it is single SIM or multi SIM mode */
            int numPhones = TelephonyManager.getDefault().getPhoneCount();
            int[] networkModes = new int[numPhones];
            sPhones = new Phone[numPhones];
            sCommandsInterfaces = new RIL[numPhones];
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
            Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
            for (int i = 0; i < numPhones; i++) {
                // reads the system properties and makes commandsinterface
                // Get preferred network type.
                networkModes[i] = preferredNetworkMode;
                Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
                // Use reflection to construct the RIL class (defaults to RIL)
                try {
                    sCommandsInterfaces[i] = instantiateCustomRIL(sRILClassname, context, networkModes[i], cdmaSubscription, i);
                } catch (Exception e) {
                    // The log message should make it clear why the radio is broken
                    while (true) {
                        Rlog.e(LOG_TAG, "Unable to construct custom RIL class", e);
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException ie) {
                        }
                    }
                }
            }
            Rlog.i(LOG_TAG, "Creating SubscriptionController");
            telephonyComponentFactory.initSubscriptionController(context, sCommandsInterfaces);
            // Instantiate UiccController so that all other classes can just
            // call getInstance()
            sUiccController = UiccController.make(context, sCommandsInterfaces);
            for (int i = 0; i < numPhones; i++) {
                Phone phone = null;
                int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                    phone = telephonyComponentFactory.makePhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_GSM, telephonyComponentFactory);
                } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                    phone = telephonyComponentFactory.makePhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_CDMA_LTE, telephonyComponentFactory);
                }
                Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
                sPhones[i] = phone;
            }
            // Set the default phone in base class.
            // FIXME: This is a first best guess at what the defaults will be. It
            // FIXME: needs to be done in a more controlled manner in the future.
            sPhone = sPhones[0];
            sCommandsInterface = sCommandsInterfaces[0];
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
            Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
            sSubInfoRecordUpdater = telephonyComponentFactory.makeSubscriptionInfoUpdater(context, sPhones, sCommandsInterfaces);
            SubscriptionController.getInstance().updatePhonesAvailability(sPhones);
            // because ImsService might need it when it is being opened.
            for (int i = 0; i < numPhones; i++) {
                sPhones[i].startMonitoringImsService();
            }
            ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
            SubscriptionController sc = SubscriptionController.getInstance();
            sSubscriptionMonitor = new SubscriptionMonitor(tr, sContext, sc, numPhones);
            sPhoneSwitcher = telephonyComponentFactory.makePhoneSwitcher(MAX_ACTIVE_PHONES, numPhones, sContext, sc, Looper.myLooper(), tr, sCommandsInterfaces, sPhones);
            sProxyController = ProxyController.getInstance(context, sPhones, sUiccController, sCommandsInterfaces, sPhoneSwitcher);
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            for (int i = 0; i < numPhones; i++) {
                sTelephonyNetworkFactories[i] = new TelephonyNetworkFactory(sPhoneSwitcher, sc, sSubscriptionMonitor, Looper.myLooper(), sContext, i, sPhones[i].mDcTracker);
            }
            telephonyComponentFactory.makeExtTelephonyClasses(context, sPhones, sCommandsInterfaces);
        }
    }
}
#method_after
public static void makeDefaultPhone(Context context) {
    synchronized (sLockProxyPhones) {
        if (!sMadeDefaults) {
            sContext = context;
            // create the telephony device controller.
            TelephonyDevController.create();
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            TelephonyComponentFactory telephonyComponentFactory = TelephonyComponentFactory.getInstance();
            // Get preferred network mode
            int preferredNetworkMode = RILConstants.PREFERRED_NETWORK_MODE;
            if (preferredNetworkMode < RILConstants.NETWORK_MODE_TDSCDMA_ONLY) {
                if (TelephonyManager.getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                    preferredNetworkMode = Phone.NT_MODE_GLOBAL;
                }
                if (TelephonyManager.getLteOnGsmModeStatic() != 0) {
                    preferredNetworkMode = Phone.NT_MODE_LTE_GSM_WCDMA;
                }
            }
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            /* In case of multi SIM mode two instances of Phone, RIL are created,
                   where as in single SIM mode only instance. isMultiSimEnabled() function checks
                   whether it is single SIM or multi SIM mode */
            int numPhones = TelephonyManager.getDefault().getPhoneCount();
            int[] networkModes = new int[numPhones];
            sPhones = new Phone[numPhones];
            sCommandsInterfaces = new RIL[numPhones];
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
            Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
            for (int i = 0; i < numPhones; i++) {
                // reads the system properties and makes commandsinterface
                // Get preferred network type.
                networkModes[i] = preferredNetworkMode;
                Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
                // Use reflection to construct the RIL class (defaults to RIL)
                try {
                    sCommandsInterfaces[i] = instantiateCustomRIL(sRILClassname, context, networkModes[i], cdmaSubscription, i);
                } catch (Exception e) {
                    // The log message should make it clear why the radio is broken
                    while (true) {
                        Rlog.e(LOG_TAG, "Unable to construct custom RIL class", e);
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException ie) {
                        }
                    }
                }
            }
            Rlog.i(LOG_TAG, "Creating SubscriptionController");
            telephonyComponentFactory.initSubscriptionController(context, sCommandsInterfaces);
            // Instantiate UiccController so that all other classes can just
            // call getInstance()
            sUiccController = UiccController.make(context, sCommandsInterfaces);
            for (int i = 0; i < numPhones; i++) {
                Phone phone = null;
                int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                    phone = telephonyComponentFactory.makePhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_GSM, telephonyComponentFactory);
                } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                    phone = telephonyComponentFactory.makePhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_CDMA, telephonyComponentFactory);
                }
                Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
                sPhones[i] = phone;
            }
            // Set the default phone in base class.
            // FIXME: This is a first best guess at what the defaults will be. It
            // FIXME: needs to be done in a more controlled manner in the future.
            sPhone = sPhones[0];
            sCommandsInterface = sCommandsInterfaces[0];
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
            Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
            sSubInfoRecordUpdater = telephonyComponentFactory.makeSubscriptionInfoUpdater(context, sPhones, sCommandsInterfaces);
            SubscriptionController.getInstance().updatePhonesAvailability(sPhones);
            // because ImsService might need it when it is being opened.
            for (int i = 0; i < numPhones; i++) {
                sPhones[i].startMonitoringImsService();
            }
            ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
            SubscriptionController sc = SubscriptionController.getInstance();
            sSubscriptionMonitor = new SubscriptionMonitor(tr, sContext, sc, numPhones);
            sPhoneSwitcher = telephonyComponentFactory.makePhoneSwitcher(MAX_ACTIVE_PHONES, numPhones, sContext, sc, Looper.myLooper(), tr, sCommandsInterfaces, sPhones);
            sProxyController = ProxyController.getInstance(context, sPhones, sUiccController, sCommandsInterfaces, sPhoneSwitcher);
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            for (int i = 0; i < numPhones; i++) {
                sTelephonyNetworkFactories[i] = new TelephonyNetworkFactory(sPhoneSwitcher, sc, sSubscriptionMonitor, Looper.myLooper(), sContext, i, sPhones[i].mDcTracker);
            }
            telephonyComponentFactory.makeExtTelephonyClasses(context, sPhones, sCommandsInterfaces);
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mInstanceId == null || mInstanceId == 0) {
                rilSocket = SOCKET_NAME_RIL[0];
            } else {
                rilSocket = SOCKET_NAME_RIL[mInstanceId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    Rlog.e(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '" + rilSocket + "' socket");
            // Compatibility with QCOM's DSDS (Dual SIM) stack
            if (needsOldRilFeature("qcomdsds")) {
                String str = "SUB1";
                byte[] data = str.getBytes();
                try {
                    mSocket.getOutputStream().write(data);
                    Rlog.i(RILJ_LOG_TAG, "Data sent!");
                } catch (IOException ex1) {
                    Rlog.e(RILJ_LOG_TAG, "IOException", ex1);
                } catch (RuntimeException ex2) {
                    Rlog.e(RILJ_LOG_TAG, "Uncaught exception", ex2);
                }
            }
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#method_after
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mInstanceId == null || mInstanceId == 0) {
                rilSocket = SOCKET_NAME_RIL[0];
            } else {
                rilSocket = SOCKET_NAME_RIL[mInstanceId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    Rlog.e(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#end_block

#method_before
public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus, Message result) {
    // Note: This RIL request is also valid for SIM and RUIM (ICC card)
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " slot: " + slotId + " appIndex: " + appIndex + " subId: " + subId + " subStatus: " + subStatus);
    rr.mParcel.writeInt(slotId);
    rr.mParcel.writeInt(appIndex);
    rr.mParcel.writeInt(subId);
    rr.mParcel.writeInt(subStatus);
    send(rr);
}
#method_after
public void setUiccSubscription(int appIndex, boolean activate, Message result) {
    // Note: This RIL request is also valid for SIM and RUIM (ICC card)
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " appIndex: " + appIndex + " activate: " + activate);
    rr.mParcel.writeInt(mInstanceId);
    rr.mParcel.writeInt(appIndex);
    rr.mParcel.writeInt(mInstanceId);
    rr.mParcel.writeInt(activate ? 1 : 0);
    send(rr);
}
#end_block

#method_before
@Override
public void supplyIccPinForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 1 : 2);
    rr.mParcel.writeString(pin);
    if (!oldRil) {
        rr.mParcel.writeString(aid);
    }
    send(rr);
}
#method_after
@Override
public void supplyIccPinForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(pin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin);
    if (!oldRil) {
        rr.mParcel.writeString(aid);
    }
    send(rr);
}
#method_after
@Override
public void supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void supplyIccPin2ForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 1 : 2);
    rr.mParcel.writeString(pin);
    if (!oldRil) {
        rr.mParcel.writeString(aid);
    }
    send(rr);
}
#method_after
@Override
public void supplyIccPin2ForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(pin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin2);
    if (!oldRil) {
        rr.mParcel.writeString(aid);
    }
    send(rr);
}
#method_after
@Override
public void supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin2);
    rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(oldPin);
    rr.mParcel.writeString(newPin);
    if (!oldRil) {
        rr.mParcel.writeString(aid);
    }
    send(rr);
}
#method_after
@Override
public void changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(oldPin);
    rr.mParcel.writeString(newPin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    rr.mParcel.writeInt(oldRil ? 2 : 3);
    rr.mParcel.writeString(oldPin2);
    rr.mParcel.writeString(newPin2);
    if (!oldRil) {
        rr.mParcel.writeString(aid);
    }
    send(rr);
}
#method_after
@Override
public void changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(oldPin2);
    rr.mParcel.writeString(newPin2);
    rr.mParcel.writeString(aid);
    send(rr);
}
#end_block

#method_before
@Override
public void getIMSIForApp(String aid, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
    boolean skipNullAid = needsOldRilFeature("skipnullaid");
    boolean writeAidOnly = needsOldRilFeature("writeaidonly");
    if (!writeAidOnly && (aid != null || !skipNullAid)) {
        rr.mParcel.writeInt(1);
        rr.mParcel.writeString(aid);
    }
    if (writeAidOnly) {
        rr.mParcel.writeString(aid);
    }
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> getIMSI: " + requestToString(rr.mRequest) + " aid: " + aid);
    send(rr);
}
#method_after
@Override
public void getIMSIForApp(String aid, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
    boolean writeAidOnly = needsOldRilFeature("writeaidonly");
    if (!writeAidOnly) {
        rr.mParcel.writeInt(1);
    }
    rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> getIMSI: " + requestToString(rr.mRequest) + " aid: " + aid);
    send(rr);
}
#end_block

#method_before
@Override
public void queryFacilityLockForApp(String facility, String password, int serviceClass, String appId, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    boolean oldRil = needsOldRilFeature("facilitylock");
    // count strings
    rr.mParcel.writeInt(oldRil ? 3 : 4);
    rr.mParcel.writeString(facility);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    if (!oldRil) {
        rr.mParcel.writeString(appId);
    }
    send(rr);
}
#method_after
@Override
public void queryFacilityLockForApp(String facility, String password, int serviceClass, String appId, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + serviceClass + " " + appId + "]");
    // count strings
    rr.mParcel.writeInt(4);
    rr.mParcel.writeString(facility);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    rr.mParcel.writeString(appId);
    send(rr);
}
#end_block

#method_before
@Override
public void setFacilityLockForApp(String facility, boolean lockState, String password, int serviceClass, String appId, Message response) {
    String lockString;
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + lockState + " " + serviceClass + " " + appId + "]");
    boolean oldRil = needsOldRilFeature("facilitylock");
    // count strings
    rr.mParcel.writeInt(oldRil ? 4 : 5);
    rr.mParcel.writeString(facility);
    lockString = (lockState) ? "1" : "0";
    rr.mParcel.writeString(lockString);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    if (!oldRil) {
        rr.mParcel.writeString(appId);
    }
    send(rr);
}
#method_after
@Override
public void setFacilityLockForApp(String facility, boolean lockState, String password, int serviceClass, String appId, Message response) {
    String lockString;
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + lockState + " " + serviceClass + " " + appId + "]");
    // count strings
    rr.mParcel.writeInt(5);
    rr.mParcel.writeString(facility);
    lockString = (lockState) ? "1" : "0";
    rr.mParcel.writeString(lockString);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    rr.mParcel.writeString(appId);
    send(rr);
}
#end_block

#method_before
protected void sendScreenState(boolean on) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(on ? 1 : 0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + on);
    send(rr);
}
#method_after
private void sendScreenState(boolean on) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(on ? 1 : 0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + on);
    send(rr);
}
#end_block

#method_before
protected RadioState getRadioStateFromInt(int stateInt) {
    RadioState state;
    /* RIL_RadioState ril.h */
    switch(stateInt) {
        case 0:
            state = RadioState.RADIO_OFF;
            break;
        case 1:
            state = RadioState.RADIO_UNAVAILABLE;
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
            state = RadioState.RADIO_ON;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_RadioState: " + stateInt);
    }
    return state;
}
#method_after
private RadioState getRadioStateFromInt(int stateInt) {
    RadioState state;
    /* RIL_RadioState ril.h */
    switch(stateInt) {
        case 0:
            state = RadioState.RADIO_OFF;
            break;
        case 1:
            state = RadioState.RADIO_UNAVAILABLE;
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
            state = RadioState.RADIO_ON;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_RadioState: " + stateInt);
    }
    return state;
}
#end_block

#method_before
protected void switchToRadioState(RadioState newState) {
    setRadioState(newState);
}
#method_after
private void switchToRadioState(RadioState newState) {
    setRadioState(newState);
}
#end_block

#method_before
protected void send(RILRequest rr) {
    Message msg;
    if (mSocket == null) {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
        return;
    }
    msg = mSender.obtainMessage(EVENT_SEND, rr);
    acquireWakeLock(rr, FOR_WAKELOCK);
    msg.sendToTarget();
}
#method_after
private void send(RILRequest rr) {
    Message msg;
    if (mSocket == null) {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
        return;
    }
    msg = mSender.obtainMessage(EVENT_SEND, rr);
    acquireWakeLock(rr, FOR_WAKELOCK);
    msg.sendToTarget();
}
#end_block

#method_before
protected void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED || type == RESPONSE_UNSOLICITED_ACK_EXP) {
        processUnsolicited(p, type);
    } else if (type == RESPONSE_SOLICITED || type == RESPONSE_SOLICITED_ACK_EXP) {
        RILRequest rr = processSolicited(p, type);
        if (rr != null) {
            if (type == RESPONSE_SOLICITED) {
                decrementWakeLock(rr);
            }
            rr.release();
            return;
        }
    } else if (type == RESPONSE_SOLICITED_ACK) {
        int serial;
        serial = p.readInt();
        RILRequest rr;
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + requestToString(rr.mRequest));
            }
        }
    }
}
#method_after
private void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED || type == RESPONSE_UNSOLICITED_ACK_EXP) {
        processUnsolicited(p, type);
    } else if (type == RESPONSE_SOLICITED || type == RESPONSE_SOLICITED_ACK_EXP) {
        RILRequest rr = processSolicited(p, type);
        if (rr != null) {
            if (type == RESPONSE_SOLICITED) {
                decrementWakeLock(rr);
            }
            rr.release();
            return;
        }
    } else if (type == RESPONSE_SOLICITED_ACK) {
        int serial;
        serial = p.readInt();
        RILRequest rr;
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + requestToString(rr.mRequest));
            }
        }
    }
}
#end_block

#method_before
protected void clearRequestList(int error, boolean loggable) {
    RILRequest rr;
    synchronized (mRequestList) {
        int count = mRequestList.size();
        if (RILJ_LOGD && loggable) {
            Rlog.d(RILJ_LOG_TAG, "clearRequestList " + " mWakeLockCount=" + mWakeLockCount + " mRequestList=" + count);
        }
        for (int i = 0; i < count; i++) {
            rr = mRequestList.valueAt(i);
            if (RILJ_LOGD && loggable) {
                Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
            }
            rr.onError(error, null);
            decrementWakeLock(rr);
            rr.release();
        }
        mRequestList.clear();
    }
}
#method_after
private void clearRequestList(int error, boolean loggable) {
    RILRequest rr;
    synchronized (mRequestList) {
        int count = mRequestList.size();
        if (RILJ_LOGD && loggable) {
            Rlog.d(RILJ_LOG_TAG, "clearRequestList " + " mWakeLockCount=" + mWakeLockCount + " mRequestList=" + count);
        }
        for (int i = 0; i < count; i++) {
            rr = mRequestList.valueAt(i);
            if (RILJ_LOGD && loggable) {
                Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
            }
            rr.onError(error, null);
            decrementWakeLock(rr);
            rr.release();
        }
        mRequestList.clear();
    }
}
#end_block

#method_before
protected RILRequest findAndRemoveRequestFromList(int serial) {
    RILRequest rr = null;
    synchronized (mRequestList) {
        rr = mRequestList.get(serial);
        if (rr != null) {
            mRequestList.remove(serial);
        }
    }
    return rr;
}
#method_after
private RILRequest findAndRemoveRequestFromList(int serial) {
    RILRequest rr = null;
    synchronized (mRequestList) {
        rr = mRequestList.get(serial);
        if (rr != null) {
            mRequestList.remove(serial);
        }
    }
    return rr;
}
#end_block

#method_before
protected RILRequest processSolicited(Parcel p, int type) {
    int serial, error;
    boolean found = false;
    serial = p.readInt();
    error = p.readInt();
    RILRequest rr;
    rr = findAndRemoveRequestFromList(serial);
    if (rr == null) {
        Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: " + serial + " error: " + error);
        return null;
    }
    if (getRilVersion() >= 13 && type == RESPONSE_SOLICITED_ACK_EXP) {
        Message msg;
        RILRequest response = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, response);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Response received for " + rr.serialString() + " " + requestToString(rr.mRequest) + " Sending ack to ril.cpp");
        }
    }
    Object ret = null;
    if (error == 0 || p.dataAvail() > 0) {
        // either command succeeds or command fails but with data payload
        try {
            switch(rr.mRequest) {
                /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
             */
                case RIL_REQUEST_GET_SIM_STATUS:
                    ret = responseIccCardStatus(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CURRENT_CALLS:
                    ret = responseCallList(p);
                    break;
                case RIL_REQUEST_DIAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMSI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_HANGUP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
                    {
                        if (mTestingEmergencyCall.getAndSet(false)) {
                            if (mEmergencyCallbackModeRegistrant != null) {
                                riljLog("testing emergency call, notify ECM Registrants");
                                mEmergencyCallbackModeRegistrant.notifyRegistrant();
                            }
                        }
                        ret = responseVoid(p);
                        break;
                    }
                case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CONFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_UDUB:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
                    ret = responseFailCause(p);
                    break;
                case RIL_REQUEST_SIGNAL_STRENGTH:
                    ret = responseSignalStrength(p);
                    break;
                case RIL_REQUEST_VOICE_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_DATA_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_OPERATOR:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_RADIO_POWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SETUP_DATA_CALL:
                    ret = responseSetupDataCall(p);
                    break;
                case RIL_REQUEST_SIM_IO:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SEND_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CANCEL_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_CLIR:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CLIR:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
                    ret = responseCallForward(p);
                    break;
                case RIL_REQUEST_SET_CALL_FORWARD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_WAITING:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CALL_WAITING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMEI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_GET_IMEISV:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ANSWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEACTIVATE_DATA_CALL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
                    ret = responseOperatorInfos(p);
                    break;
                case RIL_REQUEST_DTMF_START:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF_STOP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_BASEBAND_VERSION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SEPARATE_CONNECTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_MUTE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_MUTE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_QUERY_CLIP:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DATA_CALL_LIST:
                    ret = responseDataCallList(p);
                    break;
                case RIL_REQUEST_RESET_RADIO:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_RAW:
                    ret = responseRaw(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_STRINGS:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_SCREEN_STATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_WRITE_SMS_TO_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DELETE_SMS_ON_SIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_BAND_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_STK_GET_PROFILE:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SET_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
                    ret = responseGetPreferredNetworkType(p);
                    break;
                case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
                    ret = responseCellList(p);
                    break;
                case RIL_REQUEST_SET_LOCATION_UPDATES:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_TTY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_TTY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_FLASH:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BURST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
                    ret = responseGmsBroadcastConfig(p);
                    break;
                case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
                    ret = responseCdmaBroadcastConfig(p);
                    break;
                case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SUBSCRIPTION:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEVICE_IDENTITY:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_GET_SMSC_ADDRESS:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SET_SMSC_ADDRESS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ISIM_AUTHENTICATION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_VOICE_RADIO_TECH:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CELL_INFO_LIST:
                    ret = responseCellInfoList(p);
                    break;
                case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_DATA_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_IMS_REGISTRATION_STATE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_IMS_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_OPEN_CHANNEL:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SIM_CLOSE_CHANNEL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_GET_ATR:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_READ_ITEM:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_WRITE_ITEM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_WRITE_CDMA_PRL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_RESET_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_ALLOW_DATA:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_HARDWARE_CONFIG:
                    ret = responseHardwareConfig(p);
                    break;
                case RIL_REQUEST_SIM_AUTHENTICATION:
                    ret = responseICC_IOBase64(p);
                    break;
                case RIL_REQUEST_SHUTDOWN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_SET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_START_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_STOP_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_PULL_LCEDATA:
                    ret = responseLceData(p);
                    break;
                case RIL_REQUEST_GET_ACTIVITY_INFO:
                    ret = responseActivityData(p);
                    break;
                case RIL_REQUEST_GET_ADN_RECORD:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_UPDATE_ADN_RECORD:
                    ret = responseInts(p);
                    break;
                default:
                    throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
            }
        } catch (Throwable tr) {
            // Exceptions here usually mean invalid RIL responses
            Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< " + requestToString(rr.mRequest) + " exception, possible invalid RIL response", tr);
            if (rr.mResult != null) {
                AsyncResult.forMessage(rr.mResult, null, tr);
                rr.mResult.sendToTarget();
            }
            return rr;
        }
    }
    if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
        // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
        // regardless of error code to continue shutdown procedure.
        riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " + error + " Setting Radio State to Unavailable regardless of error.");
        setRadioState(RadioState.RADIO_UNAVAILABLE);
    }
    // screen when the pin or puk is entered incorrectly.
    switch(rr.mRequest) {
        case RIL_REQUEST_ENTER_SIM_PUK:
        case RIL_REQUEST_ENTER_SIM_PUK2:
            if (mIccStatusChangedRegistrants != null) {
                if (RILJ_LOGD) {
                    riljLog("ON enter sim puk fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                }
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
    }
    if (error != 0) {
        switch(rr.mRequest) {
            case RIL_REQUEST_ENTER_SIM_PIN:
            case RIL_REQUEST_ENTER_SIM_PIN2:
            case RIL_REQUEST_CHANGE_SIM_PIN:
            case RIL_REQUEST_CHANGE_SIM_PIN2:
            case RIL_REQUEST_SET_FACILITY_LOCK:
                if (mIccStatusChangedRegistrants != null) {
                    if (RILJ_LOGD) {
                        riljLog("ON some errors fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                    }
                    mIccStatusChangedRegistrants.notifyRegistrants();
                }
                break;
            case RIL_REQUEST_GET_RADIO_CAPABILITY:
                {
                    // TODO - remove GENERIC_FAILURE catching: b/21079604
                    if (REQUEST_NOT_SUPPORTED == error || GENERIC_FAILURE == error) {
                        // we should construct the RAF bitmask the radio
                        // supports based on preferred network bitmasks
                        ret = makeStaticRadioCapability();
                        error = 0;
                    }
                    break;
                }
            case RIL_REQUEST_GET_ACTIVITY_INFO:
                ret = new ModemActivityInfo(0, 0, 0, new int[ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
                error = 0;
                break;
        }
        if (error != 0)
            rr.onError(error, ret);
    }
    if (error == 0) {
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "< " + requestToString(rr.mRequest) + " " + retToString(rr.mRequest, ret));
        if (rr.mResult != null) {
            AsyncResult.forMessage(rr.mResult, ret, null);
            rr.mResult.sendToTarget();
        }
    }
    mEventLog.writeOnRilSolicitedResponse(rr.mSerial, error, rr.mRequest, ret);
    return rr;
}
#method_after
private RILRequest processSolicited(Parcel p, int type) {
    int serial, error;
    boolean found = false;
    serial = p.readInt();
    error = p.readInt();
    RILRequest rr;
    rr = findAndRemoveRequestFromList(serial);
    if (rr == null) {
        Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: " + serial + " error: " + error);
        return null;
    }
    if (getRilVersion() >= 13 && type == RESPONSE_SOLICITED_ACK_EXP) {
        Message msg;
        RILRequest response = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, response);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Response received for " + rr.serialString() + " " + requestToString(rr.mRequest) + " Sending ack to ril.cpp");
        }
    }
    Object ret = null;
    if (error == 0 || p.dataAvail() > 0) {
        // either command succeeds or command fails but with data payload
        try {
            switch(rr.mRequest) {
                /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
             */
                case RIL_REQUEST_GET_SIM_STATUS:
                    ret = responseIccCardStatus(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CURRENT_CALLS:
                    ret = responseCallList(p);
                    break;
                case RIL_REQUEST_DIAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMSI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_HANGUP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
                    {
                        if (mTestingEmergencyCall.getAndSet(false)) {
                            if (mEmergencyCallbackModeRegistrant != null) {
                                riljLog("testing emergency call, notify ECM Registrants");
                                mEmergencyCallbackModeRegistrant.notifyRegistrant();
                            }
                        }
                        ret = responseVoid(p);
                        break;
                    }
                case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CONFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_UDUB:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
                    ret = responseFailCause(p);
                    break;
                case RIL_REQUEST_SIGNAL_STRENGTH:
                    ret = responseSignalStrength(p);
                    break;
                case RIL_REQUEST_VOICE_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_DATA_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_OPERATOR:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_RADIO_POWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SETUP_DATA_CALL:
                    ret = responseSetupDataCall(p);
                    break;
                case RIL_REQUEST_SIM_IO:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SEND_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CANCEL_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_CLIR:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CLIR:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
                    ret = responseCallForward(p);
                    break;
                case RIL_REQUEST_SET_CALL_FORWARD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_WAITING:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CALL_WAITING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMEI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_GET_IMEISV:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ANSWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEACTIVATE_DATA_CALL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
                    ret = responseOperatorInfos(p);
                    break;
                case RIL_REQUEST_DTMF_START:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF_STOP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_BASEBAND_VERSION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SEPARATE_CONNECTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_MUTE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_MUTE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_QUERY_CLIP:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DATA_CALL_LIST:
                    ret = responseDataCallList(p);
                    break;
                case RIL_REQUEST_RESET_RADIO:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_RAW:
                    ret = responseRaw(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_STRINGS:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_SCREEN_STATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_WRITE_SMS_TO_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DELETE_SMS_ON_SIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_BAND_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_STK_GET_PROFILE:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SET_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
                    ret = responseGetPreferredNetworkType(p);
                    break;
                case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
                    ret = responseCellList(p);
                    break;
                case RIL_REQUEST_SET_LOCATION_UPDATES:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_TTY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_TTY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_FLASH:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BURST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
                    ret = responseGmsBroadcastConfig(p);
                    break;
                case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
                    ret = responseCdmaBroadcastConfig(p);
                    break;
                case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SUBSCRIPTION:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEVICE_IDENTITY:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_GET_SMSC_ADDRESS:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SET_SMSC_ADDRESS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ISIM_AUTHENTICATION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_VOICE_RADIO_TECH:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CELL_INFO_LIST:
                    ret = responseCellInfoList(p);
                    break;
                case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_DATA_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_IMS_REGISTRATION_STATE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_IMS_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_OPEN_CHANNEL:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SIM_CLOSE_CHANNEL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_GET_ATR:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_READ_ITEM:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_WRITE_ITEM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_WRITE_CDMA_PRL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_RESET_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_ALLOW_DATA:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_HARDWARE_CONFIG:
                    ret = responseHardwareConfig(p);
                    break;
                case RIL_REQUEST_SIM_AUTHENTICATION:
                    ret = responseICC_IOBase64(p);
                    break;
                case RIL_REQUEST_SHUTDOWN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_SET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_START_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_STOP_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_PULL_LCEDATA:
                    ret = responseLceData(p);
                    break;
                case RIL_REQUEST_GET_ACTIVITY_INFO:
                    ret = responseActivityData(p);
                    break;
                case RIL_REQUEST_GET_ADN_RECORD:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_UPDATE_ADN_RECORD:
                    ret = responseInts(p);
                    break;
                default:
                    throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
            }
        } catch (Throwable tr) {
            // Exceptions here usually mean invalid RIL responses
            Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< " + requestToString(rr.mRequest) + " exception, possible invalid RIL response", tr);
            if (rr.mResult != null) {
                AsyncResult.forMessage(rr.mResult, null, tr);
                rr.mResult.sendToTarget();
            }
            return rr;
        }
    }
    if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
        // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
        // regardless of error code to continue shutdown procedure.
        riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " + error + " Setting Radio State to Unavailable regardless of error.");
        setRadioState(RadioState.RADIO_UNAVAILABLE);
    }
    // screen when the pin or puk is entered incorrectly.
    switch(rr.mRequest) {
        case RIL_REQUEST_ENTER_SIM_PUK:
        case RIL_REQUEST_ENTER_SIM_PUK2:
            if (mIccStatusChangedRegistrants != null) {
                if (RILJ_LOGD) {
                    riljLog("ON enter sim puk fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                }
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
    }
    if (error != 0) {
        switch(rr.mRequest) {
            case RIL_REQUEST_ENTER_SIM_PIN:
            case RIL_REQUEST_ENTER_SIM_PIN2:
            case RIL_REQUEST_CHANGE_SIM_PIN:
            case RIL_REQUEST_CHANGE_SIM_PIN2:
            case RIL_REQUEST_SET_FACILITY_LOCK:
                if (mIccStatusChangedRegistrants != null) {
                    if (RILJ_LOGD) {
                        riljLog("ON some errors fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                    }
                    mIccStatusChangedRegistrants.notifyRegistrants();
                }
                break;
            case RIL_REQUEST_GET_RADIO_CAPABILITY:
                {
                    // TODO - remove GENERIC_FAILURE catching: b/21079604
                    if (REQUEST_NOT_SUPPORTED == error || GENERIC_FAILURE == error) {
                        // we should construct the RAF bitmask the radio
                        // supports based on preferred network bitmasks
                        ret = makeStaticRadioCapability();
                        error = 0;
                    }
                    break;
                }
            case RIL_REQUEST_GET_ACTIVITY_INFO:
                ret = new ModemActivityInfo(0, 0, 0, new int[ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
                error = 0;
                break;
        }
        if (error != 0)
            rr.onError(error, ret);
    }
    if (error == 0) {
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "< " + requestToString(rr.mRequest) + " " + retToString(rr.mRequest, ret));
        if (rr.mResult != null) {
            AsyncResult.forMessage(rr.mResult, ret, null);
            rr.mResult.sendToTarget();
        }
    }
    mEventLog.writeOnRilSolicitedResponse(rr.mSerial, error, rr.mRequest, ret);
    return rr;
}
#end_block

#method_before
protected RadioCapability makeStaticRadioCapability() {
    // default to UNKNOWN so we fail fast.
    int raf = RadioAccessFamily.RAF_UNKNOWN;
    String rafString = mContext.getResources().getString(com.android.internal.R.string.config_radio_access_family);
    if (TextUtils.isEmpty(rafString) == false) {
        raf = RadioAccessFamily.rafTypeFromString(rafString);
    }
    RadioCapability rc = new RadioCapability(mInstanceId.intValue(), 0, 0, raf, "", RadioCapability.RC_STATUS_SUCCESS);
    if (RILJ_LOGD)
        riljLog("Faking RIL_REQUEST_GET_RADIO_CAPABILITY response using " + raf);
    return rc;
}
#method_after
private RadioCapability makeStaticRadioCapability() {
    // default to UNKNOWN so we fail fast.
    int raf = RadioAccessFamily.RAF_UNKNOWN;
    String rafString = mContext.getResources().getString(com.android.internal.R.string.config_radio_access_family);
    if (TextUtils.isEmpty(rafString) == false) {
        raf = RadioAccessFamily.rafTypeFromString(rafString);
    }
    RadioCapability rc = new RadioCapability(mInstanceId.intValue(), 0, 0, raf, "", RadioCapability.RC_STATUS_SUCCESS);
    if (RILJ_LOGD)
        riljLog("Faking RIL_REQUEST_GET_RADIO_CAPABILITY response using " + raf);
    return rc;
}
#end_block

#method_before
protected void processUnsolicited(Parcel p, int type) {
    int response;
    Object ret;
    response = p.readInt();
    // Follow new symantics of sending an Ack starting from RIL version 13
    if (getRilVersion() >= 13 && type == RESPONSE_UNSOLICITED_ACK_EXP) {
        Message msg;
        RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, rr);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Unsol response received for " + responseToString(response) + " Sending ack to ril.cpp");
        }
    }
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_RECORDS:
                ret = responseAdnRecords(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
                ret = responseVoid(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                mEventLog.writeRilNewSms(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            boolean oldRil = needsOldRilFeature("skipbrokendatacall");
            if (oldRil && "IP".equals(((ArrayList<DataCallResponse>) ret).get(0).type)) {
                break;
            }
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            mEventLog.writeRilNewSms(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                if (needsOldRilFeature("setPrefNwTypeOnUnsolConnected")) {
                    setPreferredNetworkType(mPreferredNetworkType, null);
                }
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                mEventLog.writeRilSrvcc(((int[]) ret)[0]);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnInitDoneRegistrants != null) {
                mAdnInitDoneRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_RECORDS:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnRecordsInfoRegistrants != null) {
                mAdnRecordsInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#method_after
private void processUnsolicited(Parcel p, int type) {
    int response;
    Object ret;
    response = p.readInt();
    // Follow new symantics of sending an Ack starting from RIL version 13
    if (getRilVersion() >= 13 && type == RESPONSE_UNSOLICITED_ACK_EXP) {
        Message msg;
        RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, rr);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Unsol response received for " + responseToString(response) + " Sending ack to ril.cpp");
        }
    }
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_RECORDS:
                ret = responseAdnRecords(p);
                break;
            case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
                ret = responseVoid(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                mEventLog.writeRilNewSms(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            mEventLog.writeRilNewSms(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                if (needsOldRilFeature("setPrefNwTypeOnUnsolConnected")) {
                    setPreferredNetworkType(mPreferredNetworkType, null);
                }
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                mEventLog.writeRilSrvcc(((int[]) ret)[0]);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_INIT_DONE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnInitDoneRegistrants != null) {
                mAdnInitDoneRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_ADN_RECORDS:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mAdnRecordsInfoRegistrants != null) {
                mAdnRecordsInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#end_block

#method_before
protected void notifyRegistrantsRilConnectionChanged(int rilVer) {
    mRilVersion = rilVer;
    if (mRilConnectedRegistrants != null) {
        mRilConnectedRegistrants.notifyRegistrants(new AsyncResult(null, new Integer(rilVer), null));
    }
}
#method_after
private void notifyRegistrantsRilConnectionChanged(int rilVer) {
    mRilVersion = rilVer;
    if (mRilConnectedRegistrants != null) {
        mRilConnectedRegistrants.notifyRegistrants(new AsyncResult(null, new Integer(rilVer), null));
    }
}
#end_block

#method_before
protected Object responseInts(Parcel p) {
    int numInts;
    int[] response;
    numInts = p.readInt();
    response = new int[numInts];
    for (int i = 0; i < numInts; i++) {
        response[i] = p.readInt();
    }
    return response;
}
#method_after
private Object responseInts(Parcel p) {
    int numInts;
    int[] response;
    numInts = p.readInt();
    response = new int[numInts];
    for (int i = 0; i < numInts; i++) {
        response[i] = p.readInt();
    }
    return response;
}
#end_block

#method_before
protected Object responseFailCause(Parcel p) {
    LastCallFailCause failCause = new LastCallFailCause();
    failCause.causeCode = p.readInt();
    if (p.dataAvail() > 0) {
        failCause.vendorCause = p.readString();
    }
    return failCause;
}
#method_after
private Object responseFailCause(Parcel p) {
    LastCallFailCause failCause = new LastCallFailCause();
    failCause.causeCode = p.readInt();
    if (p.dataAvail() > 0) {
        failCause.vendorCause = p.readString();
    }
    return failCause;
}
#end_block

#method_before
protected Object responseVoid(Parcel p) {
    return null;
}
#method_after
private Object responseVoid(Parcel p) {
    return null;
}
#end_block

#method_before
protected Object responseCallForward(Parcel p) {
    int numInfos;
    CallForwardInfo[] infos;
    numInfos = p.readInt();
    infos = new CallForwardInfo[numInfos];
    for (int i = 0; i < numInfos; i++) {
        infos[i] = new CallForwardInfo();
        infos[i].status = p.readInt();
        infos[i].reason = p.readInt();
        infos[i].serviceClass = p.readInt();
        infos[i].toa = p.readInt();
        infos[i].number = p.readString();
        infos[i].timeSeconds = p.readInt();
    }
    return infos;
}
#method_after
private Object responseCallForward(Parcel p) {
    int numInfos;
    CallForwardInfo[] infos;
    numInfos = p.readInt();
    infos = new CallForwardInfo[numInfos];
    for (int i = 0; i < numInfos; i++) {
        infos[i] = new CallForwardInfo();
        infos[i].status = p.readInt();
        infos[i].reason = p.readInt();
        infos[i].serviceClass = p.readInt();
        infos[i].toa = p.readInt();
        infos[i].number = p.readString();
        infos[i].timeSeconds = p.readInt();
    }
    return infos;
}
#end_block

#method_before
protected Object responseSuppServiceNotification(Parcel p) {
    SuppServiceNotification notification = new SuppServiceNotification();
    notification.notificationType = p.readInt();
    notification.code = p.readInt();
    notification.index = p.readInt();
    notification.type = p.readInt();
    notification.number = p.readString();
    return notification;
}
#method_after
private Object responseSuppServiceNotification(Parcel p) {
    SuppServiceNotification notification = new SuppServiceNotification();
    notification.notificationType = p.readInt();
    notification.code = p.readInt();
    notification.index = p.readInt();
    notification.type = p.readInt();
    notification.number = p.readString();
    return notification;
}
#end_block

#method_before
protected Object responseCdmaSms(Parcel p) {
    SmsMessage sms;
    sms = SmsMessage.newFromParcel(p);
    return sms;
}
#method_after
private Object responseCdmaSms(Parcel p) {
    SmsMessage sms;
    sms = SmsMessage.newFromParcel(p);
    return sms;
}
#end_block

#method_before
protected Object responseString(Parcel p) {
    String response;
    response = p.readString();
    return response;
}
#method_after
private Object responseString(Parcel p) {
    String response;
    response = p.readString();
    return response;
}
#end_block

#method_before
protected Object responseStrings(Parcel p) {
    int num;
    String[] response;
    response = p.readStringArray();
    return response;
}
#method_after
private Object responseStrings(Parcel p) {
    int num;
    String[] response;
    response = p.readStringArray();
    return response;
}
#end_block

#method_before
protected Object responseRaw(Parcel p) {
    int num;
    byte[] response;
    response = p.createByteArray();
    return response;
}
#method_after
private Object responseRaw(Parcel p) {
    int num;
    byte[] response;
    response = p.createByteArray();
    return response;
}
#end_block

#method_before
protected Object responseSMS(Parcel p) {
    int messageRef, errorCode;
    String ackPDU;
    messageRef = p.readInt();
    ackPDU = p.readString();
    errorCode = p.readInt();
    SmsResponse response = new SmsResponse(messageRef, ackPDU, errorCode);
    return response;
}
#method_after
private Object responseSMS(Parcel p) {
    int messageRef, errorCode;
    String ackPDU;
    messageRef = p.readInt();
    ackPDU = p.readString();
    errorCode = p.readInt();
    SmsResponse response = new SmsResponse(messageRef, ackPDU, errorCode);
    return response;
}
#end_block

#method_before
protected Object responseICC_IO(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, s);
}
#method_after
private Object responseICC_IO(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, s);
}
#end_block

#method_before
protected Object responseICC_IOBase64(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, (s != null) ? android.util.Base64.decode(s, android.util.Base64.DEFAULT) : (byte[]) null);
}
#method_after
private Object responseICC_IOBase64(Parcel p) {
    int sw1, sw2;
    Message ret;
    sw1 = p.readInt();
    sw2 = p.readInt();
    String s = p.readString();
    if (RILJ_LOGV)
        riljLog("< iccIO: " + " 0x" + Integer.toHexString(sw1) + " 0x" + Integer.toHexString(sw2) + " " + s);
    return new IccIoResult(sw1, sw2, (s != null) ? android.util.Base64.decode(s, android.util.Base64.DEFAULT) : (byte[]) null);
}
#end_block

#method_before
protected Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus;
    boolean oldRil = needsOldRilFeature("icccardstatus");
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    if (!oldRil) {
        cardStatus.mImsSubscriptionAppIndex = p.readInt();
    }
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    for (int i = 0; i < numApplications; i++) {
        appStatus = new IccCardApplicationStatus();
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        cardStatus.mApplications[i] = appStatus;
    }
    return cardStatus;
}
#method_after
private Object responseIccCardStatus(Parcel p) {
    IccCardApplicationStatus appStatus;
    IccCardStatus cardStatus = new IccCardStatus();
    cardStatus.setCardState(p.readInt());
    cardStatus.setUniversalPinState(p.readInt());
    cardStatus.mGsmUmtsSubscriptionAppIndex = p.readInt();
    cardStatus.mCdmaSubscriptionAppIndex = p.readInt();
    cardStatus.mImsSubscriptionAppIndex = p.readInt();
    int numApplications = p.readInt();
    // limit to maximum allowed applications
    if (numApplications > IccCardStatus.CARD_MAX_APPS) {
        numApplications = IccCardStatus.CARD_MAX_APPS;
    }
    cardStatus.mApplications = new IccCardApplicationStatus[numApplications];
    for (int i = 0; i < numApplications; i++) {
        appStatus = new IccCardApplicationStatus();
        appStatus.app_type = appStatus.AppTypeFromRILInt(p.readInt());
        appStatus.app_state = appStatus.AppStateFromRILInt(p.readInt());
        appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(p.readInt());
        appStatus.aid = p.readString();
        appStatus.app_label = p.readString();
        appStatus.pin1_replaced = p.readInt();
        appStatus.pin1 = appStatus.PinStateFromRILInt(p.readInt());
        appStatus.pin2 = appStatus.PinStateFromRILInt(p.readInt());
        cardStatus.mApplications[i] = appStatus;
    }
    return cardStatus;
}
#end_block

#method_before
protected Object responseSimRefresh(Parcel p) {
    IccRefreshResponse response = new IccRefreshResponse();
    response.refreshResult = p.readInt();
    response.efId = p.readInt();
    response.aid = p.readString();
    return response;
}
#method_after
private Object responseSimRefresh(Parcel p) {
    IccRefreshResponse response = new IccRefreshResponse();
    response.refreshResult = p.readInt();
    response.efId = p.readInt();
    response.aid = p.readString();
    return response;
}
#end_block

#method_before
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt();
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 == voiceSettings) ? false : true;
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        // according to ril.h, namePresentation should be handled as numberPresentation;
        dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#method_after
private Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt();
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 == voiceSettings) ? false : true;
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        // according to ril.h, namePresentation should be handled as numberPresentation;
        dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#end_block

#method_before
protected DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        if (version < 4 || needsOldRilFeature("datacallapn")) {
            // APN not used
            p.readString();
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        // DataCallState needs an ifname. Since we don't have one,
        // use the name from the ThrottleService resource. (default = rmnet0)
        dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
    } else {
        dataCall.status = p.readInt();
        if (needsOldRilFeature("usehcradio")) {
            dataCall.suggestedRetryTime = -1;
        } else {
            dataCall.suggestedRetryTime = p.readInt();
        }
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#method_after
private DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        // APN not used
        if (version < 4)
            p.readString();
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        // DataCallState needs an ifname. Since we don't have one,
        // use the name from the ThrottleService resource. (default = rmnet0)
        dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
    } else {
        dataCall.status = p.readInt();
        dataCall.suggestedRetryTime = p.readInt();
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#end_block

#method_before
protected Object responseDataCallList(Parcel p) {
    ArrayList<DataCallResponse> response;
    boolean oldRil = needsOldRilFeature("datacall");
    int ver = (oldRil ? 3 : p.readInt());
    int num = p.readInt();
    riljLog("responseDataCallList ver=" + ver + " num=" + num);
    response = new ArrayList<DataCallResponse>(num);
    for (int i = 0; i < num; i++) {
        response.add(getDataCallResponse(p, ver));
    }
    mEventLog.writeRilDataCallList(response);
    return response;
}
#method_after
private Object responseDataCallList(Parcel p) {
    ArrayList<DataCallResponse> response;
    int ver = p.readInt();
    int num = p.readInt();
    riljLog("responseDataCallList ver=" + ver + " num=" + num);
    response = new ArrayList<DataCallResponse>(num);
    for (int i = 0; i < num; i++) {
        response.add(getDataCallResponse(p, ver));
    }
    mEventLog.writeRilDataCallList(response);
    return response;
}
#end_block

#method_before
protected Object responseSetupDataCall(Parcel p) {
    boolean oldRil = needsOldRilFeature("datacall");
    int ver = (oldRil ? 3 : p.readInt());
    int num = p.readInt();
    if (RILJ_LOGV)
        riljLog("responseSetupDataCall ver=" + ver + " num=" + num);
    DataCallResponse dataCall;
    if (ver < 5) {
        dataCall = new DataCallResponse();
        dataCall.version = ver;
        dataCall.cid = Integer.parseInt(p.readString());
        dataCall.ifname = p.readString();
        if (TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        if (num >= 4) {
            String dnses = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got dnses=" + dnses);
            if (!TextUtils.isEmpty(dnses)) {
                dataCall.dnses = dnses.split(" ");
            }
        }
        if (num >= 5) {
            String gateways = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got gateways=" + gateways);
            if (!TextUtils.isEmpty(gateways)) {
                dataCall.gateways = gateways.split(" ");
            }
        }
        if (num >= 6) {
            String pcscf = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got pcscf=" + pcscf);
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
    } else {
        if (num != 1) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response expecting 1 RIL_Data_Call_response_v5" + " got " + num);
        }
        dataCall = getDataCallResponse(p, ver);
    }
    return dataCall;
}
#method_after
private Object responseSetupDataCall(Parcel p) {
    int ver = p.readInt();
    int num = p.readInt();
    if (RILJ_LOGV)
        riljLog("responseSetupDataCall ver=" + ver + " num=" + num);
    DataCallResponse dataCall;
    if (ver < 5) {
        dataCall = new DataCallResponse();
        dataCall.version = ver;
        dataCall.cid = Integer.parseInt(p.readString());
        dataCall.ifname = p.readString();
        if (TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        if (num >= 4) {
            String dnses = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got dnses=" + dnses);
            if (!TextUtils.isEmpty(dnses)) {
                dataCall.dnses = dnses.split(" ");
            }
        }
        if (num >= 5) {
            String gateways = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got gateways=" + gateways);
            if (!TextUtils.isEmpty(gateways)) {
                dataCall.gateways = gateways.split(" ");
            }
        }
        if (num >= 6) {
            String pcscf = p.readString();
            if (RILJ_LOGD)
                riljLog("responseSetupDataCall got pcscf=" + pcscf);
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
    } else {
        if (num != 1) {
            throw new RuntimeException("RIL_REQUEST_SETUP_DATA_CALL response expecting 1 RIL_Data_Call_response_v5" + " got " + num);
        }
        dataCall = getDataCallResponse(p, ver);
    }
    return dataCall;
}
#end_block

#method_before
protected Object responseOperatorInfos(Parcel p) {
    String[] strings = (String[]) responseStrings(p);
    ArrayList<OperatorInfo> ret;
    if (strings.length % 4 != 0) {
        throw new RuntimeException("RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got " + strings.length + " strings, expected multible of 4");
    }
    ret = new ArrayList<OperatorInfo>(strings.length / 4);
    for (int i = 0; i < strings.length; i += 4) {
        ret.add(new OperatorInfo(strings[i + 0], strings[i + 1], strings[i + 2], strings[i + 3]));
    }
    return ret;
}
#method_after
private Object responseOperatorInfos(Parcel p) {
    String[] strings = (String[]) responseStrings(p);
    ArrayList<OperatorInfo> ret;
    if (strings.length % 4 != 0) {
        throw new RuntimeException("RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got " + strings.length + " strings, expected multible of 4");
    }
    ret = new ArrayList<OperatorInfo>(strings.length / 4);
    for (int i = 0; i < strings.length; i += 4) {
        ret.add(new OperatorInfo(strings[i + 0], strings[i + 1], strings[i + 2], strings[i + 3]));
    }
    return ret;
}
#end_block

#method_before
protected Object responseCellList(Parcel p) {
    int num, rssi;
    String location;
    ArrayList<NeighboringCellInfo> response;
    NeighboringCellInfo cell;
    num = p.readInt();
    response = new ArrayList<NeighboringCellInfo>();
    // Determine the radio access type
    int[] subId = SubscriptionManager.getSubId(mInstanceId);
    int radioType = ((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).getDataNetworkType(subId[0]);
    // Interpret the location based on radio access type
    if (radioType != NETWORK_TYPE_UNKNOWN) {
        for (int i = 0; i < num; i++) {
            rssi = p.readInt();
            location = p.readString();
            cell = new NeighboringCellInfo(rssi, location, radioType);
            response.add(cell);
        }
    }
    return response;
}
#method_after
private Object responseCellList(Parcel p) {
    int num, rssi;
    String location;
    ArrayList<NeighboringCellInfo> response;
    NeighboringCellInfo cell;
    num = p.readInt();
    response = new ArrayList<NeighboringCellInfo>();
    // Determine the radio access type
    int[] subId = SubscriptionManager.getSubId(mInstanceId);
    int radioType = ((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).getDataNetworkType(subId[0]);
    // Interpret the location based on radio access type
    if (radioType != NETWORK_TYPE_UNKNOWN) {
        for (int i = 0; i < num; i++) {
            rssi = p.readInt();
            location = p.readString();
            cell = new NeighboringCellInfo(rssi, location, radioType);
            response.add(cell);
        }
    }
    return response;
}
#end_block

#method_before
protected Object responseGetPreferredNetworkType(Parcel p) {
    int[] response = (int[]) responseInts(p);
    if (response.length >= 1) {
        // Since this is the response for getPreferredNetworkType
        // we'll assume that it should be the value we want the
        // vendor ril to take if we reestablish a connection to it.
        mPreferredNetworkType = response[0];
    }
    return response;
}
#method_after
private Object responseGetPreferredNetworkType(Parcel p) {
    int[] response = (int[]) responseInts(p);
    if (response.length >= 1) {
        // Since this is the response for getPreferredNetworkType
        // we'll assume that it should be the value we want the
        // vendor ril to take if we reestablish a connection to it.
        mPreferredNetworkType = response[0];
    }
    return response;
}
#end_block

#method_before
protected Object responseGmsBroadcastConfig(Parcel p) {
    int num;
    ArrayList<SmsBroadcastConfigInfo> response;
    SmsBroadcastConfigInfo info;
    num = p.readInt();
    response = new ArrayList<SmsBroadcastConfigInfo>(num);
    for (int i = 0; i < num; i++) {
        int fromId = p.readInt();
        int toId = p.readInt();
        int fromScheme = p.readInt();
        int toScheme = p.readInt();
        boolean selected = (p.readInt() == 1);
        info = new SmsBroadcastConfigInfo(fromId, toId, fromScheme, toScheme, selected);
        response.add(info);
    }
    return response;
}
#method_after
private Object responseGmsBroadcastConfig(Parcel p) {
    int num;
    ArrayList<SmsBroadcastConfigInfo> response;
    SmsBroadcastConfigInfo info;
    num = p.readInt();
    response = new ArrayList<SmsBroadcastConfigInfo>(num);
    for (int i = 0; i < num; i++) {
        int fromId = p.readInt();
        int toId = p.readInt();
        int fromScheme = p.readInt();
        int toScheme = p.readInt();
        boolean selected = (p.readInt() == 1);
        info = new SmsBroadcastConfigInfo(fromId, toId, fromScheme, toScheme, selected);
        response.add(info);
    }
    return response;
}
#end_block

#method_before
protected Object responseCdmaBroadcastConfig(Parcel p) {
    int numServiceCategories;
    int[] response;
    numServiceCategories = p.readInt();
    if (numServiceCategories == 0) {
        // TODO: The logic of providing default values should
        // not be done by this transport layer. And needs to
        // be done by the vendor ril or application logic.
        int numInts;
        numInts = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES * CDMA_BSI_NO_OF_INTS_STRUCT + 1;
        response = new int[numInts];
        // Faking a default record for all possible records.
        response[0] = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES;
        // default language and selection status to false for all.
        for (int i = 1; i < numInts; i += CDMA_BSI_NO_OF_INTS_STRUCT) {
            response[i + 0] = i / CDMA_BSI_NO_OF_INTS_STRUCT;
            response[i + 1] = 1;
            response[i + 2] = 0;
        }
    } else {
        int numInts;
        numInts = (numServiceCategories * CDMA_BSI_NO_OF_INTS_STRUCT) + 1;
        response = new int[numInts];
        response[0] = numServiceCategories;
        for (int i = 1; i < numInts; i++) {
            response[i] = p.readInt();
        }
    }
    return response;
}
#method_after
private Object responseCdmaBroadcastConfig(Parcel p) {
    int numServiceCategories;
    int[] response;
    numServiceCategories = p.readInt();
    if (numServiceCategories == 0) {
        // TODO: The logic of providing default values should
        // not be done by this transport layer. And needs to
        // be done by the vendor ril or application logic.
        int numInts;
        numInts = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES * CDMA_BSI_NO_OF_INTS_STRUCT + 1;
        response = new int[numInts];
        // Faking a default record for all possible records.
        response[0] = CDMA_BROADCAST_SMS_NO_OF_SERVICE_CATEGORIES;
        // default language and selection status to false for all.
        for (int i = 1; i < numInts; i += CDMA_BSI_NO_OF_INTS_STRUCT) {
            response[i + 0] = i / CDMA_BSI_NO_OF_INTS_STRUCT;
            response[i + 1] = 1;
            response[i + 2] = 0;
        }
    } else {
        int numInts;
        numInts = (numServiceCategories * CDMA_BSI_NO_OF_INTS_STRUCT) + 1;
        response = new int[numInts];
        response[0] = numServiceCategories;
        for (int i = 1; i < numInts; i++) {
            response[i] = p.readInt();
        }
    }
    return response;
}
#end_block

#method_before
protected Object responseSignalStrength(Parcel p) {
    // Assume this is gsm, but doesn't matter as ServiceStateTracker
    // sets the proper value.
    SignalStrength signalStrength = SignalStrength.makeSignalStrengthFromRilParcel(p);
    return signalStrength;
}
#method_after
private Object responseSignalStrength(Parcel p) {
    // Assume this is gsm, but doesn't matter as ServiceStateTracker
    // sets the proper value.
    SignalStrength signalStrength = SignalStrength.makeSignalStrengthFromRilParcel(p);
    return signalStrength;
}
#end_block

#method_before
protected ArrayList<CdmaInformationRecords> responseCdmaInformationRecord(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CdmaInformationRecords> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CdmaInformationRecords>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CdmaInformationRecords InfoRec = new CdmaInformationRecords(p);
        response.add(InfoRec);
    }
    return response;
}
#method_after
private ArrayList<CdmaInformationRecords> responseCdmaInformationRecord(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CdmaInformationRecords> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CdmaInformationRecords>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CdmaInformationRecords InfoRec = new CdmaInformationRecords(p);
        response.add(InfoRec);
    }
    return response;
}
#end_block

#method_before
protected Object responseCdmaCallWaiting(Parcel p) {
    CdmaCallWaitingNotification notification = new CdmaCallWaitingNotification();
    notification.number = p.readString();
    notification.numberPresentation = CdmaCallWaitingNotification.presentationFromCLIP(p.readInt());
    notification.name = p.readString();
    notification.namePresentation = notification.numberPresentation;
    notification.isPresent = p.readInt();
    notification.signalType = p.readInt();
    notification.alertPitch = p.readInt();
    notification.signal = p.readInt();
    notification.numberType = p.readInt();
    notification.numberPlan = p.readInt();
    return notification;
}
#method_after
private Object responseCdmaCallWaiting(Parcel p) {
    CdmaCallWaitingNotification notification = new CdmaCallWaitingNotification();
    notification.number = p.readString();
    notification.numberPresentation = CdmaCallWaitingNotification.presentationFromCLIP(p.readInt());
    notification.name = p.readString();
    notification.namePresentation = notification.numberPresentation;
    notification.isPresent = p.readInt();
    notification.signalType = p.readInt();
    notification.alertPitch = p.readInt();
    notification.signal = p.readInt();
    notification.numberType = p.readInt();
    notification.numberPlan = p.readInt();
    return notification;
}
#end_block

#method_before
protected Object responseCallRing(Parcel p) {
    char[] response = new char[4];
    // isPresent
    response[0] = (char) p.readInt();
    // signalType
    response[1] = (char) p.readInt();
    // alertPitch
    response[2] = (char) p.readInt();
    // signal
    response[3] = (char) p.readInt();
    mEventLog.writeRilCallRing(response);
    return response;
}
#method_after
private Object responseCallRing(Parcel p) {
    char[] response = new char[4];
    // isPresent
    response[0] = (char) p.readInt();
    // signalType
    response[1] = (char) p.readInt();
    // alertPitch
    response[2] = (char) p.readInt();
    // signal
    response[3] = (char) p.readInt();
    mEventLog.writeRilCallRing(response);
    return response;
}
#end_block

#method_before
protected void notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
    int response = RIL_UNSOL_CDMA_INFO_REC;
    if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
        if (mDisplayInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mDisplayInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaSignalInfoRec) {
        if (mSignalInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mSignalInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaNumberInfoRec) {
        if (mNumberInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mNumberInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaRedirectingNumberInfoRec) {
        if (mRedirNumInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mRedirNumInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaLineControlInfoRec) {
        if (mLineControlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mLineControlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53ClirInfoRec) {
        if (mT53ClirInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53ClirInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53AudioControlInfoRec) {
        if (mT53AudCntrlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53AudCntrlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    }
}
#method_after
private void notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
    int response = RIL_UNSOL_CDMA_INFO_REC;
    if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
        if (mDisplayInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mDisplayInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaSignalInfoRec) {
        if (mSignalInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mSignalInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaNumberInfoRec) {
        if (mNumberInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mNumberInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaRedirectingNumberInfoRec) {
        if (mRedirNumInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mRedirNumInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaLineControlInfoRec) {
        if (mLineControlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mLineControlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53ClirInfoRec) {
        if (mT53ClirInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53ClirInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53AudioControlInfoRec) {
        if (mT53AudCntrlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53AudCntrlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    }
}
#end_block

#method_before
protected ArrayList<CellInfo> responseCellInfoList(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CellInfo> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CellInfo>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        response.add(InfoRec);
    }
    return response;
}
#method_after
private ArrayList<CellInfo> responseCellInfoList(Parcel p) {
    int numberOfInfoRecs;
    ArrayList<CellInfo> response;
    /**
     * Loop through all of the information records unmarshalling them
     * and converting them to Java Objects.
     */
    numberOfInfoRecs = p.readInt();
    response = new ArrayList<CellInfo>(numberOfInfoRecs);
    for (int i = 0; i < numberOfInfoRecs; i++) {
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        response.add(InfoRec);
    }
    return response;
}
#end_block

#method_before
protected Object responseHardwareConfig(Parcel p) {
    int num;
    ArrayList<HardwareConfig> response;
    HardwareConfig hw;
    num = p.readInt();
    response = new ArrayList<HardwareConfig>(num);
    if (RILJ_LOGV) {
        riljLog("responseHardwareConfig: num=" + num);
    }
    for (int i = 0; i < num; i++) {
        int type = p.readInt();
        switch(type) {
            case HardwareConfig.DEV_HARDWARE_TYPE_MODEM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignModem(p.readString(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt());
                    break;
                }
            case HardwareConfig.DEV_HARDWARE_TYPE_SIM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignSim(p.readString(), p.readInt(), p.readString());
                    break;
                }
            default:
                {
                    throw new RuntimeException("RIL_REQUEST_GET_HARDWARE_CONFIG invalid hardward type:" + type);
                }
        }
        response.add(hw);
    }
    return response;
}
#method_after
private Object responseHardwareConfig(Parcel p) {
    int num;
    ArrayList<HardwareConfig> response;
    HardwareConfig hw;
    num = p.readInt();
    response = new ArrayList<HardwareConfig>(num);
    if (RILJ_LOGV) {
        riljLog("responseHardwareConfig: num=" + num);
    }
    for (int i = 0; i < num; i++) {
        int type = p.readInt();
        switch(type) {
            case HardwareConfig.DEV_HARDWARE_TYPE_MODEM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignModem(p.readString(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt(), p.readInt());
                    break;
                }
            case HardwareConfig.DEV_HARDWARE_TYPE_SIM:
                {
                    hw = new HardwareConfig(type);
                    hw.assignSim(p.readString(), p.readInt(), p.readString());
                    break;
                }
            default:
                {
                    throw new RuntimeException("RIL_REQUEST_GET_HARDWARE_CONFIG invalid hardward type:" + type);
                }
        }
        response.add(hw);
    }
    return response;
}
#end_block

#method_before
protected Object responseRadioCapability(Parcel p) {
    int version = p.readInt();
    int session = p.readInt();
    int phase = p.readInt();
    int rat = p.readInt();
    String logicModemUuid = p.readString();
    int status = p.readInt();
    riljLog("responseRadioCapability: version= " + version + ", session=" + session + ", phase=" + phase + ", rat=" + rat + ", logicModemUuid=" + logicModemUuid + ", status=" + status);
    RadioCapability rc = new RadioCapability(mInstanceId.intValue(), session, phase, rat, logicModemUuid, status);
    return rc;
}
#method_after
private Object responseRadioCapability(Parcel p) {
    int version = p.readInt();
    int session = p.readInt();
    int phase = p.readInt();
    int rat = p.readInt();
    String logicModemUuid = p.readString();
    int status = p.readInt();
    riljLog("responseRadioCapability: version= " + version + ", session=" + session + ", phase=" + phase + ", rat=" + rat + ", logicModemUuid=" + logicModemUuid + ", status=" + status);
    RadioCapability rc = new RadioCapability(mInstanceId.intValue(), session, phase, rat, logicModemUuid, status);
    return rc;
}
#end_block

#method_before
protected Object responseLceData(Parcel p) {
    final ArrayList<Integer> capacityResponse = new ArrayList<Integer>();
    final int capacityDownKbps = p.readInt();
    final int confidenceLevel = p.readByte();
    final int lceSuspended = p.readByte();
    riljLog("LCE capacity information received:" + " capacity=" + capacityDownKbps + " confidence=" + confidenceLevel + " lceSuspended=" + lceSuspended);
    capacityResponse.add(capacityDownKbps);
    capacityResponse.add(confidenceLevel);
    capacityResponse.add(lceSuspended);
    return capacityResponse;
}
#method_after
private Object responseLceData(Parcel p) {
    final ArrayList<Integer> capacityResponse = new ArrayList<Integer>();
    final int capacityDownKbps = p.readInt();
    final int confidenceLevel = p.readByte();
    final int lceSuspended = p.readByte();
    riljLog("LCE capacity information received:" + " capacity=" + capacityDownKbps + " confidence=" + confidenceLevel + " lceSuspended=" + lceSuspended);
    capacityResponse.add(capacityDownKbps);
    capacityResponse.add(confidenceLevel);
    capacityResponse.add(lceSuspended);
    return capacityResponse;
}
#end_block

#method_before
protected Object responseLceStatus(Parcel p) {
    final ArrayList<Integer> statusResponse = new ArrayList<Integer>();
    final int lceStatus = (int) p.readByte();
    final int actualInterval = p.readInt();
    riljLog("LCE status information received:" + " lceStatus=" + lceStatus + " actualInterval=" + actualInterval);
    statusResponse.add(lceStatus);
    statusResponse.add(actualInterval);
    return statusResponse;
}
#method_after
private Object responseLceStatus(Parcel p) {
    final ArrayList<Integer> statusResponse = new ArrayList<Integer>();
    final int lceStatus = (int) p.readByte();
    final int actualInterval = p.readInt();
    riljLog("LCE status information received:" + " lceStatus=" + lceStatus + " actualInterval=" + actualInterval);
    statusResponse.add(lceStatus);
    statusResponse.add(actualInterval);
    return statusResponse;
}
#end_block

#method_before
protected Object responseActivityData(Parcel p) {
    final int sleepModeTimeMs = p.readInt();
    final int idleModeTimeMs = p.readInt();
    int[] txModeTimeMs = new int[ModemActivityInfo.TX_POWER_LEVELS];
    for (int i = 0; i < ModemActivityInfo.TX_POWER_LEVELS; i++) {
        txModeTimeMs[i] = p.readInt();
    }
    final int rxModeTimeMs = p.readInt();
    riljLog("Modem activity info received:" + " sleepModeTimeMs=" + sleepModeTimeMs + " idleModeTimeMs=" + idleModeTimeMs + " txModeTimeMs[]=" + Arrays.toString(txModeTimeMs) + " rxModeTimeMs=" + rxModeTimeMs);
    return new ModemActivityInfo(SystemClock.elapsedRealtime(), sleepModeTimeMs, idleModeTimeMs, txModeTimeMs, rxModeTimeMs, 0);
}
#method_after
private Object responseActivityData(Parcel p) {
    final int sleepModeTimeMs = p.readInt();
    final int idleModeTimeMs = p.readInt();
    int[] txModeTimeMs = new int[ModemActivityInfo.TX_POWER_LEVELS];
    for (int i = 0; i < ModemActivityInfo.TX_POWER_LEVELS; i++) {
        txModeTimeMs[i] = p.readInt();
    }
    final int rxModeTimeMs = p.readInt();
    riljLog("Modem activity info received:" + " sleepModeTimeMs=" + sleepModeTimeMs + " idleModeTimeMs=" + idleModeTimeMs + " txModeTimeMs[]=" + Arrays.toString(txModeTimeMs) + " rxModeTimeMs=" + rxModeTimeMs);
    return new ModemActivityInfo(SystemClock.elapsedRealtime(), sleepModeTimeMs, idleModeTimeMs, txModeTimeMs, rxModeTimeMs, 0);
}
#end_block

#method_before
protected void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
private void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#end_block

#method_before
protected void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
private void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#end_block

#method_before
protected void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#method_after
private void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#end_block

#method_before
protected void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#method_after
private void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#end_block

#method_before
protected void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
private void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
protected void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
private void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
@Override
public boolean needsOldRilFeature(String feature) {
    String[] features = SystemProperties.get("ro.telephony.ril.config", "").split(",");
    for (String found : features) {
        if (found.equals(feature))
            return true;
    }
    return false;
}
#method_after
public boolean needsOldRilFeature(String feature) {
    return mOldRilFeatures.contains(feature);
}
#end_block

#method_before
public int dispatchWapPdu(byte[] pdu, BroadcastReceiver receiver, InboundSmsHandler handler) {
    if (DBG)
        Rlog.d(TAG, "Rx: " + IccUtils.bytesToHexString(pdu));
    try {
        int index = 0;
        int transactionId = pdu[index++] & 0xFF;
        int pduType = pdu[index++] & 0xFF;
        // Should we "abort" if no subId for now just no supplying extra param below
        int phoneId = handler.getPhone().getPhoneId();
        if ((pduType != WspTypeDecoder.PDU_TYPE_PUSH) && (pduType != WspTypeDecoder.PDU_TYPE_CONFIRMED_PUSH)) {
            index = mContext.getResources().getInteger(com.android.internal.R.integer.config_valid_wappush_index);
            if (index != -1) {
                transactionId = pdu[index++] & 0xff;
                pduType = pdu[index++] & 0xff;
                if (DBG)
                    Rlog.d(TAG, "index = " + index + " PDU Type = " + pduType + " transactionID = " + transactionId);
                // recheck wap push pduType
                if ((pduType != WspTypeDecoder.PDU_TYPE_PUSH) && (pduType != WspTypeDecoder.PDU_TYPE_CONFIRMED_PUSH)) {
                    if (DBG)
                        Rlog.w(TAG, "Received non-PUSH WAP PDU. Type = " + pduType);
                    return Intents.RESULT_SMS_HANDLED;
                }
            } else {
                if (DBG)
                    Rlog.w(TAG, "Received non-PUSH WAP PDU. Type = " + pduType);
                return Intents.RESULT_SMS_HANDLED;
            }
        }
        WspTypeDecoder pduDecoder = new WspTypeDecoder(pdu);
        /**
         * Parse HeaderLen(unsigned integer).
         * From wap-230-wsp-20010705-a section 8.1.2
         * The maximum size of a uintvar is 32 bits.
         * So it will be encoded in no more than 5 octets.
         */
        if (pduDecoder.decodeUintvarInteger(index) == false) {
            if (DBG)
                Rlog.w(TAG, "Received PDU. Header Length error.");
            return Intents.RESULT_SMS_GENERIC_ERROR;
        }
        int headerLength = (int) pduDecoder.getValue32();
        index += pduDecoder.getDecodedDataLength();
        int headerStartIndex = index;
        /**
         * Parse Content-Type.
         * From wap-230-wsp-20010705-a section 8.4.2.24
         *
         * Content-type-value = Constrained-media | Content-general-form
         * Content-general-form = Value-length Media-type
         * Media-type = (Well-known-media | Extension-Media) *(Parameter)
         * Value-length = Short-length | (Length-quote Length)
         * Short-length = <Any octet 0-30>   (octet <= WAP_PDU_SHORT_LENGTH_MAX)
         * Length-quote = <Octet 31>         (WAP_PDU_LENGTH_QUOTE)
         * Length = Uintvar-integer
         */
        if (pduDecoder.decodeContentType(index) == false) {
            if (DBG)
                Rlog.w(TAG, "Received PDU. Header Content-Type error.");
            return Intents.RESULT_SMS_GENERIC_ERROR;
        }
        String mimeType = pduDecoder.getValueString();
        long binaryContentType = pduDecoder.getValue32();
        index += pduDecoder.getDecodedDataLength();
        byte[] header = new byte[headerLength];
        System.arraycopy(pdu, headerStartIndex, header, 0, header.length);
        byte[] intentData;
        if (mimeType != null && mimeType.equals(WspTypeDecoder.CONTENT_TYPE_B_PUSH_CO)) {
            intentData = pdu;
        } else {
            int dataIndex = headerStartIndex + headerLength;
            intentData = new byte[pdu.length - dataIndex];
            System.arraycopy(pdu, dataIndex, intentData, 0, intentData.length);
        }
        if (SmsManager.getDefault().getAutoPersisting()) {
            // Store the wap push data in telephony
            int[] subIds = SubscriptionManager.getSubId(phoneId);
            // FIXME (tomtaylor) - when we've updated SubscriptionManager, change
            // SubscriptionManager.DEFAULT_SUB_ID to SubscriptionManager.getDefaultSmsSubId()
            int subId = (subIds != null) && (subIds.length > 0) ? subIds[0] : SmsManager.getDefaultSmsSubscriptionId();
            writeInboxMessage(subId, intentData);
        }
        /**
         * Seek for application ID field in WSP header.
         * If application ID is found, WapPushManager substitute the message
         * processing. Since WapPushManager is optional module, if WapPushManager
         * is not found, legacy message processing will be continued.
         */
        if (pduDecoder.seekXWapApplicationId(index, index + headerLength - 1)) {
            index = (int) pduDecoder.getValue32();
            pduDecoder.decodeXWapApplicationId(index);
            String wapAppId = pduDecoder.getValueString();
            if (wapAppId == null) {
                wapAppId = Integer.toString((int) pduDecoder.getValue32());
            }
            String contentType = ((mimeType == null) ? Long.toString(binaryContentType) : mimeType);
            if (DBG)
                Rlog.v(TAG, "appid found: " + wapAppId + ":" + contentType);
            try {
                boolean processFurther = true;
                IWapPushManager wapPushMan = mWapPushManager;
                if (wapPushMan == null) {
                    if (DBG)
                        Rlog.w(TAG, "wap push manager not found!");
                } else {
                    mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(mWapPushManagerPackage, 0, "mms-mgr");
                    Intent intent = new Intent();
                    intent.putExtra("transactionId", transactionId);
                    intent.putExtra("pduType", pduType);
                    intent.putExtra("header", header);
                    intent.putExtra("data", intentData);
                    intent.putExtra("contentTypeParameters", pduDecoder.getContentParameters());
                    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, phoneId);
                    int procRet = wapPushMan.processMessage(wapAppId, contentType, intent);
                    if (DBG)
                        Rlog.v(TAG, "procRet:" + procRet);
                    if ((procRet & WapPushManagerParams.MESSAGE_HANDLED) > 0 && (procRet & WapPushManagerParams.FURTHER_PROCESSING) == 0) {
                        processFurther = false;
                    }
                }
                if (!processFurther) {
                    return Intents.RESULT_SMS_HANDLED;
                }
            } catch (RemoteException e) {
                if (DBG)
                    Rlog.w(TAG, "remote func failed...");
            }
        }
        if (DBG)
            Rlog.v(TAG, "fall back to existing handler");
        if (mimeType == null) {
            if (DBG)
                Rlog.w(TAG, "Header Content-Type error.");
            return Intents.RESULT_SMS_GENERIC_ERROR;
        }
        String permission;
        int appOp;
        if (mimeType.equals(WspTypeDecoder.CONTENT_TYPE_B_MMS)) {
            permission = android.Manifest.permission.RECEIVE_MMS;
            appOp = AppOpsManager.OP_RECEIVE_MMS;
        } else {
            permission = android.Manifest.permission.RECEIVE_WAP_PUSH;
            appOp = AppOpsManager.OP_RECEIVE_WAP_PUSH;
        }
        Intent intent = new Intent(Intents.WAP_PUSH_DELIVER_ACTION);
        intent.setType(mimeType);
        intent.putExtra("transactionId", transactionId);
        intent.putExtra("pduType", pduType);
        intent.putExtra("header", header);
        intent.putExtra("data", intentData);
        intent.putExtra("contentTypeParameters", pduDecoder.getContentParameters());
        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, phoneId);
        // Direct the intent to only the default WAP Push app. If none declared:
        // Direct the intent to only the default MMS app. If we can't find a default MMS app
        // then sent it to all broadcast receivers.
        ComponentName componentName = null;
        String fqcn = new ConfigResourceUtil().getStringValue(mContext, "default_wap_push_handler");
        if (!TextUtils.isEmpty(fqcn)) {
            String[] parsed = fqcn.split("#");
            if (!(TextUtils.isEmpty(parsed[0]) || TextUtils.isEmpty(parsed[1])))
                componentName = new ComponentName(parsed[0], parsed[1]);
        }
        if (componentName == null)
            componentName = SmsApplication.getDefaultMmsApplication(mContext, true);
        Bundle options = null;
        if (componentName != null) {
            // Deliver MMS message only to this receiver
            intent.setComponent(componentName);
            if (DBG)
                Rlog.v(TAG, "Delivering MMS to: " + componentName.getPackageName() + " " + componentName.getClassName());
            try {
                long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(componentName.getPackageName(), 0, "mms-app");
                BroadcastOptions bopts = BroadcastOptions.makeBasic();
                bopts.setTemporaryAppWhitelistDuration(duration);
                options = bopts.toBundle();
            } catch (RemoteException e) {
            }
        }
        handler.dispatchIntent(intent, permission, appOp, options, receiver, UserHandle.OWNER);
        return Activity.RESULT_OK;
    } catch (ArrayIndexOutOfBoundsException aie) {
        // 0-byte WAP PDU or other unexpected WAP PDU contents can easily throw this;
        // log exception string without stack trace and return false.
        Rlog.e(TAG, "ignoring dispatchWapPdu() array index exception: " + aie);
        return Intents.RESULT_SMS_GENERIC_ERROR;
    }
}
#method_after
public int dispatchWapPdu(byte[] pdu, BroadcastReceiver receiver, InboundSmsHandler handler) {
    if (DBG)
        Rlog.d(TAG, "Rx: " + IccUtils.bytesToHexString(pdu));
    try {
        int index = 0;
        int transactionId = pdu[index++] & 0xFF;
        int pduType = pdu[index++] & 0xFF;
        // Should we "abort" if no subId for now just no supplying extra param below
        int phoneId = handler.getPhone().getPhoneId();
        if ((pduType != WspTypeDecoder.PDU_TYPE_PUSH) && (pduType != WspTypeDecoder.PDU_TYPE_CONFIRMED_PUSH)) {
            index = mContext.getResources().getInteger(com.android.internal.R.integer.config_valid_wappush_index);
            if (index != -1) {
                transactionId = pdu[index++] & 0xff;
                pduType = pdu[index++] & 0xff;
                if (DBG)
                    Rlog.d(TAG, "index = " + index + " PDU Type = " + pduType + " transactionID = " + transactionId);
                // recheck wap push pduType
                if ((pduType != WspTypeDecoder.PDU_TYPE_PUSH) && (pduType != WspTypeDecoder.PDU_TYPE_CONFIRMED_PUSH)) {
                    if (DBG)
                        Rlog.w(TAG, "Received non-PUSH WAP PDU. Type = " + pduType);
                    return Intents.RESULT_SMS_HANDLED;
                }
            } else {
                if (DBG)
                    Rlog.w(TAG, "Received non-PUSH WAP PDU. Type = " + pduType);
                return Intents.RESULT_SMS_HANDLED;
            }
        }
        WspTypeDecoder pduDecoder = new WspTypeDecoder(pdu);
        /**
         * Parse HeaderLen(unsigned integer).
         * From wap-230-wsp-20010705-a section 8.1.2
         * The maximum size of a uintvar is 32 bits.
         * So it will be encoded in no more than 5 octets.
         */
        if (pduDecoder.decodeUintvarInteger(index) == false) {
            if (DBG)
                Rlog.w(TAG, "Received PDU. Header Length error.");
            return Intents.RESULT_SMS_GENERIC_ERROR;
        }
        int headerLength = (int) pduDecoder.getValue32();
        index += pduDecoder.getDecodedDataLength();
        int headerStartIndex = index;
        /**
         * Parse Content-Type.
         * From wap-230-wsp-20010705-a section 8.4.2.24
         *
         * Content-type-value = Constrained-media | Content-general-form
         * Content-general-form = Value-length Media-type
         * Media-type = (Well-known-media | Extension-Media) *(Parameter)
         * Value-length = Short-length | (Length-quote Length)
         * Short-length = <Any octet 0-30>   (octet <= WAP_PDU_SHORT_LENGTH_MAX)
         * Length-quote = <Octet 31>         (WAP_PDU_LENGTH_QUOTE)
         * Length = Uintvar-integer
         */
        if (pduDecoder.decodeContentType(index) == false) {
            if (DBG)
                Rlog.w(TAG, "Received PDU. Header Content-Type error.");
            return Intents.RESULT_SMS_GENERIC_ERROR;
        }
        String mimeType = pduDecoder.getValueString();
        long binaryContentType = pduDecoder.getValue32();
        index += pduDecoder.getDecodedDataLength();
        byte[] header = new byte[headerLength];
        System.arraycopy(pdu, headerStartIndex, header, 0, header.length);
        byte[] intentData;
        if (mimeType != null && mimeType.equals(WspTypeDecoder.CONTENT_TYPE_B_PUSH_CO)) {
            intentData = pdu;
        } else {
            int dataIndex = headerStartIndex + headerLength;
            intentData = new byte[pdu.length - dataIndex];
            System.arraycopy(pdu, dataIndex, intentData, 0, intentData.length);
        }
        if (SmsManager.getDefault().getAutoPersisting()) {
            // Store the wap push data in telephony
            int[] subIds = SubscriptionManager.getSubId(phoneId);
            // FIXME (tomtaylor) - when we've updated SubscriptionManager, change
            // SubscriptionManager.DEFAULT_SUB_ID to SubscriptionManager.getDefaultSmsSubId()
            int subId = (subIds != null) && (subIds.length > 0) ? subIds[0] : SmsManager.getDefaultSmsSubscriptionId();
            writeInboxMessage(subId, intentData);
        }
        /**
         * Seek for application ID field in WSP header.
         * If application ID is found, WapPushManager substitute the message
         * processing. Since WapPushManager is optional module, if WapPushManager
         * is not found, legacy message processing will be continued.
         */
        if (pduDecoder.seekXWapApplicationId(index, index + headerLength - 1)) {
            index = (int) pduDecoder.getValue32();
            pduDecoder.decodeXWapApplicationId(index);
            String wapAppId = pduDecoder.getValueString();
            if (wapAppId == null) {
                wapAppId = Integer.toString((int) pduDecoder.getValue32());
            }
            String contentType = ((mimeType == null) ? Long.toString(binaryContentType) : mimeType);
            if (DBG)
                Rlog.v(TAG, "appid found: " + wapAppId + ":" + contentType);
            try {
                boolean processFurther = true;
                IWapPushManager wapPushMan = mWapPushManager;
                if (wapPushMan == null) {
                    if (DBG)
                        Rlog.w(TAG, "wap push manager not found!");
                } else {
                    mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(mWapPushManagerPackage, 0, "mms-mgr");
                    Intent intent = new Intent();
                    intent.putExtra("transactionId", transactionId);
                    intent.putExtra("pduType", pduType);
                    intent.putExtra("header", header);
                    intent.putExtra("data", intentData);
                    intent.putExtra("contentTypeParameters", pduDecoder.getContentParameters());
                    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, phoneId);
                    int procRet = wapPushMan.processMessage(wapAppId, contentType, intent);
                    if (DBG)
                        Rlog.v(TAG, "procRet:" + procRet);
                    if ((procRet & WapPushManagerParams.MESSAGE_HANDLED) > 0 && (procRet & WapPushManagerParams.FURTHER_PROCESSING) == 0) {
                        processFurther = false;
                    }
                }
                if (!processFurther) {
                    return Intents.RESULT_SMS_HANDLED;
                }
            } catch (RemoteException e) {
                if (DBG)
                    Rlog.w(TAG, "remote func failed...");
            }
        }
        if (DBG)
            Rlog.v(TAG, "fall back to existing handler");
        if (mimeType == null) {
            if (DBG)
                Rlog.w(TAG, "Header Content-Type error.");
            return Intents.RESULT_SMS_GENERIC_ERROR;
        }
        String permission;
        int appOp;
        if (mimeType.equals(WspTypeDecoder.CONTENT_TYPE_B_MMS)) {
            permission = android.Manifest.permission.RECEIVE_MMS;
            appOp = AppOpsManager.OP_RECEIVE_MMS;
        } else {
            permission = android.Manifest.permission.RECEIVE_WAP_PUSH;
            appOp = AppOpsManager.OP_RECEIVE_WAP_PUSH;
        }
        Intent intent = new Intent(Intents.WAP_PUSH_DELIVER_ACTION);
        intent.setType(mimeType);
        intent.putExtra("transactionId", transactionId);
        intent.putExtra("pduType", pduType);
        intent.putExtra("header", header);
        intent.putExtra("data", intentData);
        intent.putExtra("contentTypeParameters", pduDecoder.getContentParameters());
        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, phoneId);
        // Direct the intent to only the default WAP Push app. If none declared:
        // Direct the intent to only the default MMS app. If we can't find a default MMS app
        // then sent it to all broadcast receivers.
        ComponentName componentName = null;
        String fqcn = new ConfigResourceUtil().getStringValue(mContext, "default_wap_push_handler");
        if (!TextUtils.isEmpty(fqcn)) {
            componentName = ComponentName.unflattenFromString(fqcn);
        }
        if (componentName == null) {
            componentName = SmsApplication.getDefaultMmsApplication(mContext, true);
        }
        Bundle options = null;
        if (componentName != null) {
            // Deliver MMS message only to this receiver
            intent.setComponent(componentName);
            if (DBG)
                Rlog.v(TAG, "Delivering MMS to: " + componentName.getPackageName() + " " + componentName.getClassName());
            try {
                long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(componentName.getPackageName(), 0, "mms-app");
                BroadcastOptions bopts = BroadcastOptions.makeBasic();
                bopts.setTemporaryAppWhitelistDuration(duration);
                options = bopts.toBundle();
            } catch (RemoteException e) {
            }
        }
        handler.dispatchIntent(intent, permission, appOp, options, receiver, UserHandle.OWNER);
        return Activity.RESULT_OK;
    } catch (ArrayIndexOutOfBoundsException aie) {
        // 0-byte WAP PDU or other unexpected WAP PDU contents can easily throw this;
        // log exception string without stack trace and return false.
        Rlog.e(TAG, "ignoring dispatchWapPdu() array index exception: " + aie);
        return Intents.RESULT_SMS_GENERIC_ERROR;
    }
}
#end_block

#method_before
@Override
public void enter() {
    if (DBG)
        localLog("Entering IdleState");
}
#method_after
@Override
public void enter() {
    if (DBG)
        localLog("DefaultState");
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    if (DBG)
        localLog("DefaultState state got " + msg);
    switch(msg.what) {
        case WIFI_CHANGE_CMD_ENABLE:
            transitionTo(mMovingState);
            break;
        case WIFI_CHANGE_CMD_DISABLE:
            // nothing to do
            break;
        case WIFI_CHANGE_CMD_NEW_SCAN_RESULTS:
            // nothing to do
            break;
        case WIFI_CHANGE_CMD_CONFIGURE:
            /* save configuration till we transition to moving state */
            deferMessage(msg);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    if (DBG)
        localLog("DefaultState got" + msg);
    ClientInfo ci = mClients.get(msg.replyTo);
    switch(msg.what) {
        case CMD_DRIVER_LOADED:
            if (WifiNative.getInterfaces() != 0) {
                if (WifiNative.getScanCapabilities(mScanCapabilities)) {
                    transitionTo(mStartedState);
                } else {
                    loge("could not get scan capabilities");
                }
            } else {
                loge("could not start HAL");
            }
            break;
        case WifiScanner.CMD_SCAN:
        case WifiScanner.CMD_START_BACKGROUND_SCAN:
        case WifiScanner.CMD_STOP_BACKGROUND_SCAN:
        case WifiScanner.CMD_START_SINGLE_SCAN:
        case WifiScanner.CMD_STOP_SINGLE_SCAN:
        case WifiScanner.CMD_SET_HOTLIST:
        case WifiScanner.CMD_RESET_HOTLIST:
        case WifiScanner.CMD_CONFIGURE_WIFI_CHANGE:
        case WifiScanner.CMD_START_TRACKING_CHANGE:
        case WifiScanner.CMD_STOP_TRACKING_CHANGE:
        case WifiScanner.CMD_GET_SCAN_RESULTS:
            replyFailed(msg, WifiScanner.REASON_UNSPECIFIED, "not available");
            break;
        case CMD_SCAN_RESULTS_AVAILABLE:
            if (DBG)
                localLog("ignored scan results available event");
            break;
        case CMD_FULL_SCAN_RESULTS:
            if (DBG)
                localLog("ignored full scan result event");
            break;
        default:
            break;
    }
    return HANDLED;
}
#end_block

#method_before
private int getBestBucket(ScanSettings settings) {
    // check to see if any of the channels are being scanned already
    // and find the smallest bucket index (it represents the quickest
    // period of scan)
    ChannelSpec[] channels = settings.channels;
    if (channels == null) {
        // set channels based on band
        channels = getChannelsForBand(settings.band);
    }
    if (channels == null) {
        // still no channels; then there's nothing to scan
        loge("No channels to scan!!");
        return -1;
    }
    int mostFrequentBucketIndex = mTimeBuckets.length;
    for (ChannelSpec desiredChannelSpec : channels) {
        if (mChannelToBucketMap.containsKey(desiredChannelSpec.frequency)) {
            int bucket = mChannelToBucketMap.get(desiredChannelSpec.frequency);
            if (bucket < mostFrequentBucketIndex) {
                mostFrequentBucketIndex = bucket;
            }
        }
    }
    // best by period
    int bestBucketIndex = -1;
    for (int i = 0; i < mTimeBuckets.length; i++) {
        TimeBucket bucket = mTimeBuckets[i];
        if (bucket.periodMinInSecond * 1000 <= settings.periodInMs && settings.periodInMs < bucket.periodMaxInSecond * 1000) {
            // we set the time period to this
            bestBucketIndex = i;
            break;
        }
    }
    if (bestBucketIndex >= mSettings.buckets.length)
        bestBucketIndex = -1;
    if (mostFrequentBucketIndex < bestBucketIndex) {
        for (ChannelSpec desiredChannelSpec : channels) {
            mChannelToBucketMap.put(desiredChannelSpec.frequency, mostFrequentBucketIndex);
        }
        localLog("returning mf bucket number " + mostFrequentBucketIndex);
        return mostFrequentBucketIndex;
    } else if (bestBucketIndex != -1) {
        for (ChannelSpec desiredChannelSpec : channels) {
            mChannelToBucketMap.put(desiredChannelSpec.frequency, bestBucketIndex);
        }
        localLog("returning best bucket number " + bestBucketIndex);
        return bestBucketIndex;
    }
    loge("Could not find suitable bucket for period " + settings.periodInMs);
    return -1;
}
#method_after
private int getBestBucket(ScanSettings settings) {
    // check to see if any of the channels are being scanned already
    // and find the smallest bucket index (it represents the quickest
    // period of scan)
    ChannelSpec[] channels = settings.channels;
    if (channels == null) {
        // set channels based on band
        channels = getChannelsForBand(settings.band);
    }
    if (channels == null) {
        // still no channels; then there's nothing to scan
        loge("No channels to scan!!");
        return -1;
    }
    int mostFrequentBucketIndex = mTimeBuckets.length;
    for (ChannelSpec desiredChannelSpec : channels) {
        if (mChannelToBucketMap.containsKey(desiredChannelSpec.frequency)) {
            int bucket = mChannelToBucketMap.get(desiredChannelSpec.frequency);
            if (bucket < mostFrequentBucketIndex) {
                mostFrequentBucketIndex = bucket;
            }
        }
    }
    // best by period
    int bestBucketIndex = -1;
    for (int i = 0; i < mTimeBuckets.length && i < mSettings.buckets.length; i++) {
        TimeBucket bucket = mTimeBuckets[i];
        if (bucket.periodMinInSecond * 1000 <= settings.periodInMs && settings.periodInMs < bucket.periodMaxInSecond * 1000) {
            // we set the time period to this
            bestBucketIndex = i;
            break;
        }
    }
    if (mostFrequentBucketIndex < bestBucketIndex) {
        for (ChannelSpec desiredChannelSpec : channels) {
            mChannelToBucketMap.put(desiredChannelSpec.frequency, mostFrequentBucketIndex);
        }
        localLog("returning mf bucket number " + mostFrequentBucketIndex);
        return mostFrequentBucketIndex;
    } else if (bestBucketIndex != -1) {
        for (ChannelSpec desiredChannelSpec : channels) {
            mChannelToBucketMap.put(desiredChannelSpec.frequency, bestBucketIndex);
        }
        localLog("returning best bucket number " + bestBucketIndex);
        return bestBucketIndex;
    }
    loge("Could not find suitable bucket for period " + settings.periodInMs);
    return -1;
}
#end_block

#method_before
public int getMasterValue(int item) throws ImsException {
    int ret = 0;
    try {
        ret = miConfig.getMasterValue(item);
    } catch (RemoteException e) {
        throw new ImsException("getValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getMasterValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#method_after
public int getMasterValue(int item) throws ImsException {
    int ret = 0;
    try {
        Method m = miConfig.getClass().getDeclaredMethod("getMasterValue", int.class);
        if (m != null) {
            ret = (Integer) m.invoke(miConfig, item);
        }
    } catch (Exception e) {
        throw new ImsException("getValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getMasterValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#end_block

#method_before
public String getMasterStringValue(int item) throws ImsException {
    String ret = "Unknown";
    try {
        ret = miConfig.getMasterStringValue(item);
    } catch (RemoteException e) {
        throw new ImsException("getMasterStringValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getMasterStringValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#method_after
public String getMasterStringValue(int item) throws ImsException {
    String ret = "Unknown";
    try {
        Method m = miConfig.getClass().getDeclaredMethod("getMasterStringValue", int.class);
        if (m != null) {
            ret = (String) m.invoke(miConfig, item);
        }
    } catch (Exception e) {
        throw new ImsException("getMasterStringValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getMasterStringValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#end_block

#method_before
public int getProvisionedValue(int item) throws ImsException {
    int ret = 0;
    try {
        Method m = miConfig.getClass().getDeclaredMethod("getProvisionedValue", Integer.class);
        if (m != null) {
            ret = (Integer) m.invoke(miConfig, item);
        }
    } catch (Exception e) {
        throw new ImsException("getValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getProvisionedValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#method_after
public int getProvisionedValue(int item) throws ImsException {
    int ret = 0;
    try {
        Method m = miConfig.getClass().getDeclaredMethod("getProvisionedValue", int.class);
        if (m != null) {
            ret = (Integer) m.invoke(miConfig, item);
        }
    } catch (Exception e) {
        throw new ImsException("getValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getProvisionedValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#end_block

#method_before
public String getProvisionedStringValue(int item) throws ImsException {
    String ret = "Unknown";
    try {
        Method m = miConfig.getClass().getDeclaredMethod("getProvisionedStringValue");
        if (m != null) {
            ret = (String) m.invoke(miConfig, item);
        }
    } catch (Exception e) {
        throw new ImsException("getProvisionedStringValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getProvisionedStringValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#method_after
public String getProvisionedStringValue(int item) throws ImsException {
    String ret = "Unknown";
    try {
        Method m = miConfig.getClass().getDeclaredMethod("getProvisionedStringValue", int.class);
        if (m != null) {
            ret = (String) m.invoke(miConfig, item);
        }
    } catch (Exception e) {
        throw new ImsException("getProvisionedStringValue()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
    if (DBG)
        Rlog.d(TAG, "getProvisionedStringValue(): item = " + item + ", ret =" + ret);
    return ret;
}
#end_block

#method_before
public void getVideoQuality(ImsConfigListener listener) throws ImsException {
    try {
        miConfig.getVideoQuality(listener);
    } catch (RemoteException e) {
        throw new ImsException("getVideoQuality()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
}
#method_after
public void getVideoQuality(ImsConfigListener listener) throws ImsException {
    try {
        Method m = miConfig.getClass().getDeclaredMethod("getVideoQuality", ImsConfigListener.class);
        if (m != null) {
            m.invoke(miConfig, listener);
        }
    } catch (Exception e) {
        throw new ImsException("getVideoQuality()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
public void setVideoQuality(int quality, ImsConfigListener listener) throws ImsException {
    try {
        miConfig.setVideoQuality(quality, listener);
    } catch (RemoteException e) {
        throw new ImsException("setVideoQuality()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
}
#method_after
public void setVideoQuality(int quality, ImsConfigListener listener) throws ImsException {
    try {
        Method m = miConfig.getClass().getDeclaredMethod("setVideoQuality", int.class, ImsConfigListener.class);
        if (m != null) {
            m.invoke(miConfig, quality, listener);
        }
    } catch (Exception e) {
        throw new ImsException("setVideoQuality()", e, ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
public static void updateImsServiceConfig(Context context, int phoneId, boolean force) {
    final ImsManager imsManager = ImsManager.getInstance(context, phoneId);
    if (imsManager != null && (!imsManager.mConfigUpdated || force)) {
        try {
            boolean turnOn = imsManager.updateVolteFeatureValue();
            turnOn |= imsManager.updateVideoCallFeatureValue();
            turnOn |= imsManager.updateWfcFeatureAndProvisionedValues();
            if (turnOn) {
                imsManager.turnOnIms();
            } else if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL)) {
                imsManager.turnOffIms();
            }
            imsManager.mConfigUpdated = true;
        } catch (ImsException e) {
            loge("updateImsServiceConfig: " + e);
            imsManager.mConfigUpdated = false;
        }
    }
}
#method_after
public static void updateImsServiceConfig(Context context, int phoneId, boolean force) {
    final ImsManager imsManager = ImsManager.getInstance(context, phoneId);
    if (imsManager != null && (!imsManager.mConfigUpdated || force)) {
        try {
            boolean isImsUsed = imsManager.updateVolteFeatureValue();
            isImsUsed |= imsManager.updateVideoCallFeatureValue();
            isImsUsed |= imsManager.updateWfcFeatureAndProvisionedValues();
            if (isImsUsed || !getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL)) {
                // Turn on IMS if it is used.
                // Also, if turning off is not allowed for current carrier,
                // we need to turn IMS on because it might be turned off before
                // phone switched to current carrier.
                imsManager.turnOnIms();
            } else {
                // Turn off IMS if it is not used AND turning off is allowed for carrier.
                imsManager.turnOffIms();
            }
            imsManager.mConfigUpdated = true;
        } catch (ImsException e) {
            loge("updateImsServiceConfig: " + e);
            imsManager.mConfigUpdated = false;
        }
    }
}
#end_block

#method_before
private boolean updateVolteFeatureValue() throws ImsException {
    boolean available = isVolteEnabledByPlatform(mContext);
    boolean enabled = isEnhanced4gLteModeSettingEnabledByUser(mContext);
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabled(mContext);
    boolean turnOn = available && enabled && isNonTty;
    log("updateVolteFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, turnOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, null);
    return turnOn;
}
#method_after
private boolean updateVolteFeatureValue() throws ImsException {
    boolean available = isVolteEnabledByPlatform(mContext);
    boolean enabled = isEnhanced4gLteModeSettingEnabledByUser(mContext);
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabled(mContext);
    boolean isFeatureOn = available && enabled && isNonTty;
    log("updateVolteFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, null);
    return isFeatureOn;
}
#end_block

#method_before
private boolean updateVideoCallFeatureValue() throws ImsException {
    boolean available = isVtEnabledByPlatform(mContext);
    SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(mContext);
    boolean enabled = isEnhanced4gLteModeSettingEnabledByUser(mContext) && sharedPrefs.getBoolean(PREF_ENABLE_VIDEO_CALLING_KEY, true);
    boolean isNonTty = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, TelecomManager.TTY_MODE_OFF) == TelecomManager.TTY_MODE_OFF;
    boolean turnOn = available && enabled && isNonTty;
    log("updateVideoCallFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, turnOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, null);
    return turnOn;
}
#method_after
private boolean updateVideoCallFeatureValue() throws ImsException {
    boolean available = isVtEnabledByPlatform(mContext);
    SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(mContext);
    boolean enabled = isEnhanced4gLteModeSettingEnabledByUser(mContext) && sharedPrefs.getBoolean(PREF_ENABLE_VIDEO_CALLING_KEY, true);
    boolean isNonTty = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, TelecomManager.TTY_MODE_OFF) == TelecomManager.TTY_MODE_OFF;
    boolean isFeatureOn = available && enabled && isNonTty;
    log("updateVideoCallFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, null);
    return isFeatureOn;
}
#end_block

#method_before
private boolean updateWfcFeatureAndProvisionedValues() throws ImsException {
    boolean available = isWfcEnabledByPlatform(mContext);
    boolean enabled = isWfcEnabledByUser(mContext);
    int mode = getWfcMode(mContext);
    boolean roaming = isWfcRoamingEnabledByUser(mContext);
    boolean turnOn = available && enabled;
    log("updateWfcFeatureAndProvisionedValues: available = " + available + ", enabled = " + enabled + ", mode = " + mode + ", roaming = " + roaming);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, turnOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, null);
    if (!turnOn) {
        mode = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
        roaming = false;
    }
    setWfcModeInternal(mContext, mode);
    setWfcRoamingSettingInternal(mContext, roaming);
    return turnOn;
}
#method_after
private boolean updateWfcFeatureAndProvisionedValues() throws ImsException {
    boolean available = isWfcEnabledByPlatform(mContext);
    boolean enabled = isWfcEnabledByUser(mContext);
    int mode = getWfcMode(mContext);
    boolean roaming = isWfcRoamingEnabledByUser(mContext);
    boolean isFeatureOn = available && enabled;
    log("updateWfcFeatureAndProvisionedValues: available = " + available + ", enabled = " + enabled + ", mode = " + mode + ", roaming = " + roaming);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, null);
    if (!isFeatureOn) {
        mode = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
        roaming = false;
    }
    setWfcModeInternal(mContext, mode);
    setWfcRoamingSettingInternal(mContext, roaming);
    return isFeatureOn;
}
#end_block

