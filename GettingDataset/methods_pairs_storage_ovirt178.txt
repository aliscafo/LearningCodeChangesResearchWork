156
#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    ActionReturnValue actionReturnValue = null;
    if (currentChildId != null) {
        actionReturnValue = commandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<ActionType, ? extends ActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(ActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(ActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(ActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (actionReturnValue != null) {
                getParameters().setMergeStatusReturnValue(actionReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = buildDestroyCommand(ActionType.DestroyImage, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.REDUCE_IMAGE);
            break;
        case REDUCE_IMAGE:
            nextCommand = buildReduceImageCommand();
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        commandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    ActionReturnValue actionReturnValue = null;
    if (currentChildId != null) {
        actionReturnValue = commandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<ActionType, ? extends ActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(ActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(ActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(ActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (actionReturnValue != null) {
                getParameters().setMergeStatusReturnValue(actionReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = buildDestroyCommand(ActionType.DestroyImage, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.REDUCE_IMAGE);
            break;
        case REDUCE_IMAGE:
            nextCommand = buildReduceImageCommand();
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        commandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private boolean completedMerge() {
    return getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.DESTROY_IMAGE || getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.COMPLETE;
}
#method_after
private boolean completedMerge() {
    return getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.DESTROY_IMAGE;
}
#end_block

#method_before
@Override
public void init() {
    super.init();
    setStoragePoolId(getVm().getStoragePoolId());
    getParameters().setStoragePoolId(getStoragePoolId());
    getParameters().setVdsId(getVdsId());
    getParameters().setDiskAlias(getDiskAlias());
    getParameters().setImageGroupID(getImageGroupId());
    getParameters().setCommandType(getActionType());
}
#method_after
@Override
public void init() {
    super.init();
    setStoragePoolId(getVm().getStoragePoolId());
    getParameters().setStoragePoolId(getStoragePoolId());
    getParameters().setVdsId(getVdsId());
    getParameters().setDiskAlias(getDiskAlias());
    getParameters().setImageGroupID(getImageGroupId());
    getParameters().setCommandType(getActionType());
    getParameters().setDestinationImageId(((DiskImage) getDiskImageByDiskId(getParameters().getImageGroupID())).getImageId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    runInternalAction(ActionType.CreateImagePlaceholder, buildCreateImagePlacerholderParams(), createStepsContext(StepEnum.CLONE_IMAGE_STRUCTURE));
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    imagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getImageGroupIds(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
    ActionReturnValue actionReturnValueurnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createInternalJobContext(getContext(), getLock()));
    getParameters().setAutoGeneratedSnapshotId(actionReturnValueurnValue.getActionReturnValue());
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_PLACEHOLDER_CREATION) {
        updateStage(LiveDiskMigrateStage.VM_REPLICATE_DISK_START);
        replicateDiskStart();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_START);
        syncImageData();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END);
        return true;
    }
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END) {
        updateStage(LiveDiskMigrateStage.VM_REPLICATE_DISK_FINISH);
        completeLiveMigration();
        updateStage(LiveDiskMigrateStage.SOURCE_IMAGE_DELETION);
        liveStorageMigrationHelper.removeImage(this, getParameters().getSourceStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE);
        return false;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveDiskMigrateStage.IMAGE_PLACEHOLDER_CREATION);
        runInternalAction(ActionType.CreateImagePlaceholder, buildCreateImagePlacerholderParams(), createStepsContext(StepEnum.CLONE_IMAGE_STRUCTURE));
        return true;
    }
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_PLACEHOLDER_CREATION) {
        updateStage(LiveDiskMigrateStage.VM_REPLICATE_DISK_START);
        replicateDiskStart();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_START);
        syncImageData();
        updateStage(LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END);
        return true;
    }
    if (getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.IMAGE_DATA_SYNC_EXEC_END) {
        updateStage(LiveDiskMigrateStage.VM_REPLICATE_DISK_FINISH);
        completeLiveMigration();
        updateStage(LiveDiskMigrateStage.SOURCE_IMAGE_DELETION);
        liveStorageMigrationHelper.removeImage(this, getParameters().getSourceStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE);
        updateStage(LiveDiskMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    if (isRemoveAutoGeneratedSnapshotRequired()) {
        // running at the same time as RemoveSnapshotCommand
        if (!lockVm(getVmId())) {
            log.info("Failed to acquire VM lock, will retry on the next polling cycle");
            return true;
        }
        updateStage(LiveDiskMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_START);
        removeAutogeneratedSnapshot();
        updateStage(LiveDiskMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END);
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean isConsiderSuccessful() {
    return getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.SOURCE_IMAGE_DELETION;
}
#method_after
private boolean isConsiderSuccessful() {
    return getParameters().getLiveDiskMigrateStage() == LiveDiskMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END;
}
#end_block

#method_before
private void replicateDiskStart() {
    if (Guid.Empty.equals(getParameters().getVdsId())) {
        throw new EngineException(EngineError.down, "VM " + getParameters().getVmId() + " is not running on any VDS");
    }
    StorageType targetType = storageDomainDao.get(getParameters().getStorageDomainId()).getStorageStaticData().getStorageType();
    Optional<String> diskType = vmInfoBuildUtils.getNetworkDiskType(getVm(), targetType);
    // Start disk migration
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), diskType.orElse(null));
    VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.VmReplicateDiskStart, migrationStartParams);
    if (!ret.getSucceeded()) {
        log.error("Failed VmReplicateDiskStart (Disk '{}' , VM '{}')", getParameters().getImageGroupID(), getParameters().getVmId());
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#method_after
private void replicateDiskStart() {
    if (Guid.Empty.equals(getParameters().getVdsId())) {
        throw new EngineException(EngineError.down, "VM " + getParameters().getVmId() + " is not running on any VDS");
    }
    StorageType targetType = this.getStorageDomainById(getParameters().getTargetStorageDomainId(), getParameters().getStoragePoolId()).getStorageStaticData().getStorageType();
    Optional<String> diskType = vmInfoBuildUtils.getNetworkDiskType(getVm(), targetType);
    // Start disk migration
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), diskType.orElse(null));
    VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.VmReplicateDiskStart, migrationStartParams);
    if (!ret.getSucceeded()) {
        log.error("Failed VmReplicateDiskStart (Disk '{}' , VM '{}')", getParameters().getImageGroupID(), getParameters().getVmId());
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean validate = super.validate();
    if (!validate) {
        auditLogDirector.log(this, AuditLogType.USER_MOVED_DISK_FINISHED_FAILURE);
    }
    return validate;
}
#method_after
@Override
protected boolean validate() {
    boolean validate = super.validate();
    if (!validate) {
        auditLogDirector.log(this, AuditLogType.USER_MOVED_DISK_FINISHED_FAILURE);
    }
    if (!getVm().isRunningAndQualifyForDisksMigration()) {
        return false;
    }
    setStoragePoolId(getVm().getStoragePoolId());
    if (!validateDestDomainsSpaceRequirements()) {
        return false;
    }
    getReturnValue().setValid(isDiskNotShareable(getParameters().getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(getParameters().getImageId()));
    if (!getReturnValue().isValid()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return validateCreateAllSnapshotsFromVmCommand() && validate;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getImageGroupID().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, getDiskIsBeingMigratedMessage(getDiskImageByDiskId(getParameters().getImageGroupID()))));
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#end_block

#method_before
Map<String, Object> buildCdDetails(VmDevice vmDevice, VM vm) {
    Map<String, Object> struct = new HashMap<>();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = getOsRepository().getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    struct.put(VdsProperties.INTERFACE, cdInterface);
    int index = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
    struct.put(VdsProperties.Index, Integer.toString(index));
    if ("scsi".equals(cdInterface)) {
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, index));
    }
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
    return struct;
}
#method_after
Map<String, Object> buildCdDetails(VmDevice vmDevice, VM vm) {
    Map<String, Object> struct = new HashMap<>();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    struct.put(VdsProperties.INTERFACE, cdInterface);
    int index = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
    struct.put(VdsProperties.Index, Integer.toString(index));
    if ("scsi".equals(cdInterface)) {
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, index));
    }
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
    return struct;
}
#end_block

#method_before
public VmDevice createSysprepPayloadDevice(String sysPrepContent, VM vm) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    return new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
}
#method_after
public VmDevice createSysprepPayloadDevice(String sysPrepContent, VM vm) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(osRepository.getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    return new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
}
#end_block

#method_before
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        if (vm.getDynamicData() != null) {
            tempVM.setDynamicData(vm.getDynamicData());
        }
        FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(tempVM);
        ovfManager.importVm(configuration, tempVM, fullEntityOvfData);
        for (DiskImage diskImage : fullEntityOvfData.getDiskImages()) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages((ArrayList) fullEntityOvfData.getDiskImages());
        vm.setInterfaces(fullEntityOvfData.getInterfaces());
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData()).isValid()) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        vmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        if (vm.getDynamicData() != null) {
            tempVM.setDynamicData(vm.getDynamicData());
        }
        FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(tempVM);
        ovfManager.importVm(configuration, tempVM, fullEntityOvfData);
        for (DiskImage diskImage : fullEntityOvfData.getDiskImages()) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages((ArrayList<DiskImage>) fullEntityOvfData.getDiskImages());
        vm.setInterfaces(fullEntityOvfData.getInterfaces());
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData()).isValid()) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        vmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    validateVnicMappings(action);
    validateClusterMappings(action);
    validateRoleMappings(action);
    validateDomainMappings(action);
    validateAffinityGroupMappings(action);
    validateAffinityLabelMappings(action);
    validateLunMappings(action);
    ImportVmFromConfParameters params = new ImportVmFromConfParameters(getVnicProfileMappings(action), getReassignBadMacs(action));
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setClusterId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    if (action.isSetRegistrationConfiguration()) {
        validateVnicMappings(action);
        validateClusterMappings(action);
        validateRoleMappings(action);
        validateDomainMappings(action);
        validateAffinityGroupMappings(action);
        validateAffinityLabelMappings(action);
        validateLunMappings(action);
    }
    ImportVmFromConfParameters params = new ImportVmFromConfParameters(getVnicProfileMappings(action), getReassignBadMacs(action));
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setClusterId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmFromConfiguration, params, action);
}
#end_block

#method_before
private void validateClusterMappings(Action action) {
    if (action.isSetRegistrationConfiguration() && action.getRegistrationConfiguration().isSetClusterMappings() && action.getRegistrationConfiguration().getClusterMappings().isSetRegistrationClusterMappings()) {
        action.getRegistrationConfiguration().getClusterMappings().getRegistrationClusterMappings().forEach(this::validateClusterMapping);
    }
}
#method_after
private void validateClusterMappings(Action action) {
    if (action.getRegistrationConfiguration().isSetClusterMappings() && action.getRegistrationConfiguration().getClusterMappings().isSetRegistrationClusterMappings()) {
        action.getRegistrationConfiguration().getClusterMappings().getRegistrationClusterMappings().forEach(this::validateClusterMapping);
    }
}
#end_block

#method_before
private void validateRoleMappings(Action action) {
    if (action.isSetRegistrationConfiguration() && action.getRegistrationConfiguration().isSetRoleMappings() && action.getRegistrationConfiguration().getRoleMappings().isSetRegistrationRoleMappings()) {
        action.getRegistrationConfiguration().getRoleMappings().getRegistrationRoleMappings().forEach(this::validateRoleMapping);
    }
}
#method_after
private void validateRoleMappings(Action action) {
    if (action.getRegistrationConfiguration().isSetRoleMappings() && action.getRegistrationConfiguration().getRoleMappings().isSetRegistrationRoleMappings()) {
        action.getRegistrationConfiguration().getRoleMappings().getRegistrationRoleMappings().forEach(this::validateRoleMapping);
    }
}
#end_block

#method_before
private void validateRoleMapping(RegistrationRoleMapping mapping) {
    if (!mapping.isSetFrom()) {
        badRequest("Role name is missing from source.");
    }
    if (!mapping.isSetTo()) {
        badRequest("Role name is missing from destination.");
    }
}
#method_after
private void validateRoleMapping(RegistrationRoleMapping mapping) {
    if (!mapping.isSetFrom()) {
        badRequest("Role name is missing from source.");
    }
    if (!mapping.isSetTo()) {
        badRequest("Role is missing from destination.");
    }
}
#end_block

#method_before
private void validateAffinityGroupMappings(Action action) {
    if (action.isSetRegistrationConfiguration() && action.getRegistrationConfiguration().isSetAffinityGroupMappings() && action.getRegistrationConfiguration().getAffinityGroupMappings().isSetRegistrationAffinityGroupMappings()) {
        action.getRegistrationConfiguration().getAffinityGroupMappings().getRegistrationAffinityGroupMappings().forEach(this::validateAffinityGroupMapping);
    }
}
#method_after
private void validateAffinityGroupMappings(Action action) {
    if (action.getRegistrationConfiguration().isSetAffinityGroupMappings() && action.getRegistrationConfiguration().getAffinityGroupMappings().isSetRegistrationAffinityGroupMappings()) {
        action.getRegistrationConfiguration().getAffinityGroupMappings().getRegistrationAffinityGroupMappings().forEach(this::validateAffinityGroupMapping);
    }
}
#end_block

#method_before
private void validateAffinityLabelMappings(Action action) {
    if (action.isSetRegistrationConfiguration() && action.getRegistrationConfiguration().isSetAffinityLabelMappings() && action.getRegistrationConfiguration().getAffinityLabelMappings().isSetRegistrationAffinityLabelMappings()) {
        action.getRegistrationConfiguration().getAffinityLabelMappings().getRegistrationAffinityLabelMappings().forEach(this::validateAffinityLabelMapping);
    }
}
#method_after
private void validateAffinityLabelMappings(Action action) {
    if (action.getRegistrationConfiguration().isSetAffinityLabelMappings() && action.getRegistrationConfiguration().getAffinityLabelMappings().isSetRegistrationAffinityLabelMappings()) {
        action.getRegistrationConfiguration().getAffinityLabelMappings().getRegistrationAffinityLabelMappings().forEach(this::validateAffinityLabelMapping);
    }
}
#end_block

#method_before
private void validateDomainMappings(Action action) {
    if (action.isSetRegistrationConfiguration() && action.getRegistrationConfiguration().isSetDomainMappings() && action.getRegistrationConfiguration().getDomainMappings().isSetRegistrationDomainMappings()) {
        action.getRegistrationConfiguration().getDomainMappings().getRegistrationDomainMappings().forEach(this::validateDomainMapping);
    }
}
#method_after
private void validateDomainMappings(Action action) {
    if (action.getRegistrationConfiguration().isSetDomainMappings() && action.getRegistrationConfiguration().getDomainMappings().isSetRegistrationDomainMappings()) {
        action.getRegistrationConfiguration().getDomainMappings().getRegistrationDomainMappings().forEach(this::validateDomainMapping);
    }
}
#end_block

#method_before
private void validateLunMappings(Action action) {
    if (action.isSetRegistrationConfiguration() && action.getRegistrationConfiguration().isSetLunMappings() && action.getRegistrationConfiguration().getLunMappings().isSetRegistrationLunMappings()) {
        action.getRegistrationConfiguration().getLunMappings().getRegistrationLunMappings().forEach(this::validateLunMapping);
    }
}
#method_after
private void validateLunMappings(Action action) {
    if (action.getRegistrationConfiguration().isSetLunMappings() && action.getRegistrationConfiguration().getLunMappings().isSetRegistrationLunMappings()) {
        action.getRegistrationConfiguration().getLunMappings().getRegistrationLunMappings().forEach(this::validateLunMapping);
    }
}
#end_block

#method_before
private void validateLunMapping(RegistrationLunMapping mapping) {
    if (!mapping.isSetFrom()) {
        badRequest("Lun name is missing from source.");
    }
    if (!mapping.isSetTo()) {
        badRequest("Lun name is missing from destination.");
    }
}
#method_after
private void validateLunMapping(RegistrationLunMapping mapping) {
    if (!mapping.isSetFrom()) {
        badRequest("Lun id is missing from source.");
    }
    if (!mapping.isSetTo()) {
        badRequest("Lun is missing from destination.");
    }
}
#end_block

#method_before
public static Map<String, Map> mapFromModel(RegistrationConfiguration registrationConfiguration) {
    Map extraMappingsForRegister = new HashMap<>();
    if (registrationConfiguration.getAffinityGroupMappings() != null && registrationConfiguration.isSetAffinityGroupMappings()) {
        extraMappingsForRegister.put(AFFINITY_GROUP_KEY, mapAffinityGroupMapping(registrationConfiguration.getAffinityGroupMappings()));
    }
    if (registrationConfiguration.getAffinityLabelMappings() != null && registrationConfiguration.isSetAffinityLabelMappings()) {
        extraMappingsForRegister.put(AFFINITY_LABEL_KEY, mapAffinityLabelMapping(registrationConfiguration.getAffinityLabelMappings()));
    }
    if (registrationConfiguration.getClusterMappings() != null && registrationConfiguration.isSetClusterMappings()) {
        extraMappingsForRegister.put(CLUSTER_KEY, mapClusterMapping(registrationConfiguration.getClusterMappings()));
    }
    if (registrationConfiguration.getLunMapping() != null && registrationConfiguration.isSetLunMapping()) {
        extraMappingsForRegister.put(EXTERNAL_LUN_KEY, mapExternalLunMapping(registrationConfiguration.getLunMapping()));
    }
    if (registrationConfiguration.getRoleMappings() != null && registrationConfiguration.isSetRoleMappings()) {
        extraMappingsForRegister.put(ROLE_KEY, mapExternalRoleMapping(registrationConfiguration.getRoleMappings()));
    }
    if (registrationConfiguration.getDomainMappings() != null && registrationConfiguration.isSetDomainMappings()) {
        extraMappingsForRegister.put(DOMAIN_KEY, mapExternalDomainMapping(registrationConfiguration.getDomainMappings()));
    }
    return extraMappingsForRegister;
}
#method_after
public static void mapFromModel(RegistrationConfiguration registrationConfiguration, ImportFromConfParameters params) {
    if (registrationConfiguration != null) {
        setParamsWithRegistrationConfigurationMappings(registrationConfiguration, params);
    }
}
#end_block

#method_before
private static Map<String, AffinityGroup> mapAffinityGroupMapping(RegistrationAffinityGroupMappings model) {
    return model.getRegistrationAffinityGroupMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? AffinityGroupMapper.map(registrationMap.getTo(), null) : null));
}
#method_after
private static Map<String, String> mapAffinityGroupMapping(RegistrationAffinityGroupMappings model) {
    return model.getRegistrationAffinityGroupMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? AffinityGroupMapper.map(registrationMap.getTo(), null).getName() : null));
}
#end_block

#method_before
private static Map<String, Label> mapAffinityLabelMapping(RegistrationAffinityLabelMappings model) {
    return model.getRegistrationAffinityLabelMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? AffinityLabelMapper.map(registrationMap.getTo(), null) : null));
}
#method_after
private static Map<String, String> mapAffinityLabelMapping(RegistrationAffinityLabelMappings model) {
    return model.getRegistrationAffinityLabelMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? AffinityLabelMapper.map(registrationMap.getTo(), null).getName() : null));
}
#end_block

#method_before
private static Map<String, Cluster> mapClusterMapping(RegistrationClusterMappings model) {
    return model.getRegistrationClusterMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? ClusterMapper.map(registrationMap.getTo(), null) : null));
}
#method_after
private static Map<String, String> mapClusterMapping(RegistrationClusterMappings model) {
    return model.getRegistrationClusterMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? ClusterMapper.map(registrationMap.getTo(), null).getName() : null));
}
#end_block

#method_before
private static Map<String, Disk> mapExternalLunMapping(RegistrationLunMappings model) {
    return model.getRegistrationLunMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getId() : null, registrationMap -> registrationMap.isSetTo() ? DiskMapper.map(registrationMap.getTo(), null) : null));
}
#method_after
private static Map<String, Object> mapExternalLunMapping(RegistrationLunMappings model) {
    return model.getRegistrationLunMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getId() : null, registrationMap -> registrationMap.isSetTo() ? DiskMapper.map(registrationMap.getTo(), null) : null));
}
#end_block

#method_before
private static Map<String, Role> mapExternalRoleMapping(RegistrationRoleMappings model) {
    return model.getRegistrationRoleMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getId() : null, registrationMap -> registrationMap.isSetTo() ? RoleMapper.map(registrationMap.getTo(), null) : null));
}
#method_after
private static Map<String, Object> mapExternalRoleMapping(RegistrationRoleMappings model) {
    return model.getRegistrationRoleMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? RoleMapper.map(registrationMap.getTo(), null) : null));
}
#end_block

#method_before
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
    Map<String, Map> registrationMap = getRegistrationMappings(action);
    params.setClusterMap(registrationMap.get(ExternalRegistrationConfigurationMapper.CLUSTER_KEY));
    params.setDomainMap(registrationMap.get(ExternalRegistrationConfigurationMapper.DOMAIN_KEY));
    params.setRoleMap(registrationMap.get(ExternalRegistrationConfigurationMapper.ROLE_KEY));
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setClusterId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmTemplateFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setClusterId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmTemplateFromConfiguration, params, action);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    FullEntityOvfData that = (FullEntityOvfData) o;
    if (diskImages != null ? !diskImages.equals(that.diskImages) : that.diskImages != null) {
        return false;
    }
    if (lunDisks != null ? !lunDisks.equals(that.lunDisks) : that.lunDisks != null) {
        return false;
    }
    if (interfaces != null ? !interfaces.equals(that.interfaces) : that.interfaces != null) {
        return false;
    }
    return vmBase != null ? vmBase.equals(that.vmBase) : that.vmBase == null;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof FullEntityOvfData)) {
        return false;
    }
    FullEntityOvfData other = (FullEntityOvfData) obj;
    return super.equals(obj) && Objects.equals(diskImages, other.diskImages) && Objects.equals(lunDisks, other.lunDisks) && Objects.equals(interfaces, other.interfaces) && Objects.equals(vmBase, other.vmBase);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = diskImages != null ? diskImages.hashCode() : 0;
    result = 31 * result + (lunDisks != null ? lunDisks.hashCode() : 0);
    result = 31 * result + (interfaces != null ? interfaces.hashCode() : 0);
    result = 31 * result + (vmBase != null ? vmBase.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(super.hashCode(), diskImages, lunDisks, interfaces, vmBase);
}
#end_block

#method_before
@Override
public Response upgrade(Action action) {
    UpgradeHostParameters params = new UpgradeHostParameters(guid);
    if (action.isSetImage()) {
        params.setoVirtIsoFile(action.getImage());
    }
    if (action.isReboot() != null) {
        params.setReboot(action.isReboot());
    }
    return doAction(ActionType.UpgradeHost, params, action);
}
#method_after
@Override
public Response upgrade(Action action) {
    UpgradeHostParameters params = new UpgradeHostParameters(guid);
    if (action.isSetImage()) {
        params.setoVirtIsoFile(action.getImage());
    }
    if (action.isSetReboot()) {
        params.setReboot(action.isReboot());
    }
    return doAction(ActionType.UpgradeHost, params, action);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch();
    IdQueryParameters tempVar = new IdQueryParameters(getEntity().getId());
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(QueryType.GetAllNetworksByClusterId, tempVar, new AsyncQuery<>((AsyncCallback<QueryReturnValue>) returnValue -> {
        final List<Network> newItems = returnValue.getReturnValue();
        Collections.sort(newItems, Comparator.comparing((Network n) -> n.getCluster().isManagement()).reversed().thenComparing(Network::getName, new LexoNumericComparator()));
        for (Network network : newItems) {
            network.getCluster().setId(new NetworkClusterId(tempVar.getId(), network.getId()));
        }
        setItems(newItems);
    }));
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch();
    Guid clusterId = getEntity().getId();
    IdQueryParameters tempVar = new IdQueryParameters(clusterId);
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(QueryType.GetAllNetworksByClusterId, tempVar, new AsyncQuery<>((AsyncCallback<QueryReturnValue>) returnValue -> {
        final List<Network> newItems = returnValue.getReturnValue();
        Collections.sort(newItems, Comparator.comparing((Network n) -> n.getCluster().isManagement()).reversed().thenComparing(Network::getName, new LexoNumericComparator()));
        for (Network network : newItems) {
            network.getCluster().setId(new NetworkClusterId(clusterId, network.getId()));
        }
        setItems(newItems);
    }));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getCompensationContext().snapshotEntityStatus(getVds().getDynamicData(), getParameters().getInitialStatus());
    getCompensationContext().stateChanged();
    VDSType vdsType = getVds().getVdsType();
    if (vdsType == VDSType.VDS || vdsType == VDSType.oVirtNode) {
        try {
            setVdsStatus(VDSStatus.Installing);
            Updateable upgradeManager = new HostUpgradeManager();
            upgradeManager.update(getVds());
            if (vdsType == VDSType.oVirtNode || getParameters().isReboot()) {
                VdsActionParameters params = new VdsActionParameters(getVds().getId());
                params.setPrevVdsStatus(getParameters().getInitialStatus());
                ActionReturnValue returnValue = runInternalAction(ActionType.SshHostReboot, params, ExecutionHandler.createInternalJobContext());
                if (!returnValue.getSucceeded()) {
                    setVdsStatus(VDSStatus.InstallFailed);
                    log.error("Engine failed to restart via ssh host '{}' ('{}') after upgrade", getVds().getName(), getVds().getId());
                    return;
                }
            } else {
                // letting the host a chance to recover from restarting the VDSM service after the upgrade
                if (!new HostConnectivityChecker().check(getVds())) {
                    log.warn("Engine failed to communicate with VDSM agent on host '{}' with address '{}' ('{}') " + "after upgrade", getVds().getName(), getVds().getHostName(), getVds().getId());
                }
            }
        } catch (Exception e) {
            setVdsStatus(VDSStatus.InstallFailed);
            return;
        }
    } else if (getVds().isOvirtVintageNode()) {
        InstallVdsParameters parameters = new InstallVdsParameters(getVdsId());
        parameters.setIsReinstallOrUpgrade(true);
        parameters.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        parameters.setActivateHost(getParameters().getInitialStatus() == VDSStatus.Up);
        ActionReturnValue result = runInternalAction(ActionType.UpgradeOvirtNodeInternal, parameters);
        if (!result.getSucceeded()) {
            setVdsStatus(VDSStatus.InstallFailed);
            propagateFailure(result);
            return;
        }
    }
    try {
        updateHostStatusAfterSuccessfulUpgrade();
        setSucceeded(true);
    } catch (Exception e) {
        log.error("Failed to set new status for host '{}' after upgrade has ended.", getVdsName());
        log.error("Exception", e);
        setVdsStatus(VDSStatus.InstallFailed);
    }
}
#method_after
@Override
protected void executeCommand() {
    getCompensationContext().snapshotEntityStatus(getVds().getDynamicData(), getParameters().getInitialStatus());
    getCompensationContext().stateChanged();
    VDSType vdsType = getVds().getVdsType();
    if (vdsType == VDSType.VDS || vdsType == VDSType.oVirtNode) {
        try {
            setVdsStatus(VDSStatus.Installing);
            upgradeManager.update(getVds());
            if (vdsType == VDSType.oVirtNode || getParameters().isReboot()) {
                VdsActionParameters params = new VdsActionParameters(getVds().getId());
                params.setPrevVdsStatus(getParameters().getInitialStatus());
                ActionReturnValue returnValue = runInternalAction(ActionType.SshHostReboot, params, ExecutionHandler.createInternalJobContext());
                if (!returnValue.getSucceeded()) {
                    setVdsStatus(VDSStatus.InstallFailed);
                    log.error("Engine failed to restart via ssh host '{}' ('{}') after upgrade", getVds().getName(), getVds().getId());
                    return;
                }
            } else {
                // letting the host a chance to recover from restarting the VDSM service after the upgrade
                if (!new HostConnectivityChecker().check(getVds())) {
                    log.warn("Engine failed to communicate with VDSM agent on host '{}' with address '{}' ('{}') " + "after upgrade", getVds().getName(), getVds().getHostName(), getVds().getId());
                }
            }
        } catch (Exception e) {
            setVdsStatus(VDSStatus.InstallFailed);
            return;
        }
    } else if (getVds().isOvirtVintageNode()) {
        InstallVdsParameters parameters = new InstallVdsParameters(getVdsId());
        parameters.setIsReinstallOrUpgrade(true);
        parameters.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        parameters.setActivateHost(getParameters().getInitialStatus() == VDSStatus.Up);
        ActionReturnValue result = runInternalAction(ActionType.UpgradeOvirtNodeInternal, parameters);
        if (!result.getSucceeded()) {
            setVdsStatus(VDSStatus.InstallFailed);
            propagateFailure(result);
            return;
        }
    }
    try {
        updateHostStatusAfterSuccessfulUpgrade();
        setSucceeded(true);
    } catch (Exception e) {
        log.error("Failed to set new status for host '{}' after upgrade has ended.", getVdsName());
        log.error("Exception", e);
        setVdsStatus(VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit(), new VdsDeployKernelUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = providerDao.get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        FirewallType hostFirewallType = clusterDao.get(getClusterId()).getFirewallType();
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                case oVirtNode:
                    deploy.addUnit(new VdsDeployIptablesUnit(hostFirewallType.equals(FirewallType.IPTABLES)));
                    break;
                case oVirtVintageNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            deploy.addUnit(new VdsDeployVmconsoleUnit());
        }
        if (MapUtils.isNotEmpty(parameters.getHostedEngineConfiguration())) {
            deploy.addUnit(new VdsDeployHostedEngineUnit(parameters.getHostedEngineConfiguration()));
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                markCurrentCmdlineAsStored();
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                markCurrentCmdlineAsStored();
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                markCurrentCmdlineAsStored();
                // TODO: When more logic goes to ovirt-host-deploy role,
                // this code should be moved to appropriate place, currently
                // we run this playbook only after successful run of otopi host-deploy
                runAnsibleHostDeployPlaybook(hostFirewallType);
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#method_after
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit(), new VdsDeployKernelUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = providerDao.get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        FirewallType hostFirewallType = clusterDao.get(getClusterId()).getFirewallType();
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                case oVirtNode:
                    deploy.addUnit(new VdsDeployIptablesUnit(hostFirewallType.equals(FirewallType.IPTABLES)));
                    break;
                case oVirtVintageNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            deploy.addUnit(new VdsDeployVmconsoleUnit());
        }
        if (MapUtils.isNotEmpty(parameters.getHostedEngineConfiguration())) {
            deploy.addUnit(new VdsDeployHostedEngineUnit(parameters.getHostedEngineConfiguration()));
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                markCurrentCmdlineAsStored();
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                markCurrentCmdlineAsStored();
                markVdsReinstalled();
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                markCurrentCmdlineAsStored();
                markVdsReinstalled();
                // TODO: When more logic goes to ovirt-host-deploy role,
                // this code should be moved to appropriate place, currently
                // we run this playbook only after successful run of otopi host-deploy
                runAnsibleHostDeployPlaybook(hostFirewallType);
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
@Override
public HostUpgradeManagerResult checkForUpdates(final VDS host) {
    try {
        AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(host.getHostName()).checkMode(true).enableLogging(false).playbook(AnsibleConstants.HOST_UPGRADE_PLAYBOOK);
        AnsibleReturnValue ansibleReturnValue = new AnsibleExecutor().runCommand(command, new Pair<>("ANSIBLE_STDOUT_CALLBACK", "hostupgradeplugin"));
        if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
            log.error("Failed to run check-update of host '{}'.", host.getName());
            throw new RuntimeException("Failed to run check-update of host '{}'.");
        }
        boolean updatesAvailable = Boolean.valueOf(ansibleReturnValue.getStdout());
        HostUpgradeManagerResult hostUpgradeManagerResult = new HostUpgradeManagerResult();
        hostUpgradeManagerResult.setUpdatesAvailable(updatesAvailable);
        if (updatesAvailable) {
            AuditLogable auditLog = new AuditLogableImpl();
            auditLog.setVdsId(host.getId());
            auditLog.setVdsName(host.getName());
            auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
        }
        return hostUpgradeManagerResult;
    } catch (final Exception e) {
        throw new RuntimeException(e.getMessage(), e);
    }
}
#method_after
@Override
public HostUpgradeManagerResult checkForUpdates(final VDS host) {
    try {
        AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(host.getHostName()).checkMode(true).enableLogging(false).playbook(AnsibleConstants.HOST_UPGRADE_PLAYBOOK);
        AnsibleReturnValue ansibleReturnValue = ansibleExecutor.runCommand(command, new Pair<>("ANSIBLE_STDOUT_CALLBACK", AnsibleConstants.HOST_UPGRADE_CALLBACK_PLUGIN));
        if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
            String error = String.format("Failed to run check-update of host '%1$s'.", host.getHostName());
            log.error(error);
            throw new RuntimeException(error);
        }
        List<String> availablePackages = JsonHelper.jsonToList(ansibleReturnValue.getStdout());
        boolean updatesAvailable = !availablePackages.isEmpty();
        HostUpgradeManagerResult hostUpgradeManagerResult = new HostUpgradeManagerResult();
        hostUpgradeManagerResult.setUpdatesAvailable(updatesAvailable);
        if (updatesAvailable) {
            hostUpgradeManagerResult.setAvailablePackages(availablePackages);
            log.info("There are available package updates ({}) for host '{}'", StringUtils.join(availablePackages, ", "), host.getHostName());
            AuditLogable auditLog = new AuditLogableImpl();
            auditLog.setVdsId(host.getId());
            auditLog.setVdsName(host.getName());
            if (availablePackages.isEmpty()) {
                auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
            } else {
                if (availablePackages.size() > MAX_NUM_OF_DISPLAYED_UPDATES) {
                    auditLog.addCustomValue("Packages", String.format("%1$s and %2$s others. To see all packages check engine.log.", StringUtils.join(availablePackages.subList(0, MAX_NUM_OF_DISPLAYED_UPDATES), ", "), availablePackages.size() - MAX_NUM_OF_DISPLAYED_UPDATES));
                } else {
                    auditLog.addCustomValue("Packages", StringUtils.join(availablePackages, ", "));
                }
                auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE_WITH_PACKAGES);
            }
        }
        return hostUpgradeManagerResult;
    } catch (final Exception e) {
        throw new RuntimeException(e.getMessage(), e);
    }
}
#end_block

#method_before
@Override
public void update(final VDS host) {
    try {
        AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(host.getHostName()).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-mgmt-ansible").logFileName(host.getHostName()).logFileSuffix(CorrelationIdTracker.getCorrelationId()).playbook(AnsibleConstants.HOST_UPGRADE_PLAYBOOK);
        if (new AnsibleExecutor().runCommand(command).getAnsibleReturnCode() != AnsibleReturnCode.OK) {
            log.error("Failed to update host '{}'.", host.getName());
            throw new RuntimeException("Failed to update host '{}'.");
        }
    } catch (InterruptedException | IOException ex) {
        throw new RuntimeException(ex);
    }
}
#method_after
@Override
public void update(final VDS host) {
    try {
        AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(host.getHostName()).verboseLevel(AnsibleVerbosity.LEVEL1).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-mgmt-ansible").logFileName(host.getHostName()).logFileSuffix(CorrelationIdTracker.getCorrelationId()).playbook(AnsibleConstants.HOST_UPGRADE_PLAYBOOK);
        if (ansibleExecutor.runCommand(command).getAnsibleReturnCode() != AnsibleReturnCode.OK) {
            String error = String.format("Failed to update host '%1$s'.", host.getHostName());
            log.error(error);
            throw new RuntimeException(error);
        }
    } catch (InterruptedException | IOException ex) {
        throw new RuntimeException(ex);
    }
}
#end_block

#method_before
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    commandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
}
#method_after
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    auditLogDirector.log(commandCoordinatorUtil.retrieveCommand(cmdId), AuditLogType.HOST_UPGRADE_FAILED);
    commandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
}
#end_block

#method_before
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = DbFacade.getInstance().getVdsDynamicDao().get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
            invokeHostUpgrade(rootCommand, parameters);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds)) {
                log.error("Host '{}' failed to move to maintenance mode. Upgrade process is terminated.", getHostName(parameters.getVdsId()));
                rootCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#method_after
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = DbFacade.getInstance().getVdsDynamicDao().get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
            invokeHostUpgrade(rootCommand, parameters);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds)) {
                log.error("Host '{}' failed to move to maintenance mode. Upgrade process is terminated.", getHostName(parameters.getVdsId()));
                auditLogDirector.log(rootCommand, AuditLogType.VDS_MAINTENANCE_FAILED);
                rootCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#end_block

#method_before
private void initLabelsToNetworks() {
    for (Network network : clusterNetworks) {
        if (network != null) {
            labelToNetworks.computeIfAbsent(network.getLabel(), k -> new ArrayList<>()).add(network);
        }
    }
}
#method_after
private void initLabelsToNetworks() {
    for (Network network : clusterNetworks) {
        labelToNetworks.computeIfAbsent(network.getLabel(), k -> new ArrayList<>()).add(network);
    }
}
#end_block

#method_before
private boolean validateLunDisksForVm(VM vmFromParams) {
    if (vmFromParams.getDiskMap() != null) {
        List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vmFromParams.getDiskMap().values());
        for (LunDisk lunDisk : lunDisks) {
            List<EngineMessage> lunValidationMessages = validateLunDisk(lunDisk);
            if (lunValidationMessages.isEmpty()) {
                getVm().getDiskMap().put(lunDisk.getId(), lunDisk);
            } else if (!getParameters().isAllowPartialImport()) {
                addValidationMessages(lunValidationMessages);
                return false;
            } else {
                log.warn("Skipping validation for external LUN disk '{}' since partialImport flag is true." + " Invalid external LUN disk might reflect on the run VM process", lunDisk.getId());
                vmFromParams.getDiskMap().remove(lunDisk.getId());
                failedDisksToImportForAuditLog.putIfAbsent(lunDisk.getId(), lunDisk.getDiskAlias());
            }
        }
    }
    return true;
}
#method_after
private boolean validateLunDisksForVm(VM vmFromParams) {
    if (vmFromParams.getDiskMap() != null) {
        List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vmFromParams.getDiskMap().values());
        for (LunDisk lunDisk : lunDisks) {
            List<EngineMessage> lunValidationMessages = validateLunDisk(lunDisk);
            if (lunValidationMessages.isEmpty()) {
                getVm().getDiskMap().put(lunDisk.getId(), lunDisk);
            } else if (!getParameters().isAllowPartialImport()) {
                return failValidation(lunValidationMessages);
            } else {
                log.warn("Skipping validation for external LUN disk '{}' since partialImport flag is true." + " Invalid external LUN disk might reflect on the run VM process", lunDisk.getId());
                vmFromParams.getDiskMap().remove(lunDisk.getId());
                failedDisksToImportForAuditLog.putIfAbsent(lunDisk.getId(), lunDisk.getDiskAlias());
            }
        }
    }
    return true;
}
#end_block

#method_before
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = validateStorageDomainExistsInDb(snapshot, guids.get(0), guids.get(2), guids.get(3));
    DiskImage disk = isMemoryDiskAlreadyExistsInDb(snapshot, guids.get(2), guids.get(3));
    if (sd == null || disk != null) {
        return null;
    }
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, sd.getStorageType(), vmOverheadCalculator, MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    memoryDisk.setActive(true);
    return memoryDisk;
}
#method_after
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = validateStorageDomainExistsInDb(snapshot, guids.get(0), guids.get(2), guids.get(3));
    DiskImage disk = isMemoryDiskAlreadyExistsInDb(snapshot, guids.get(2), guids.get(3));
    if (sd == null || disk != null) {
        return null;
    }
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createSnapshotMemoryDisk(vm, sd.getStorageType(), vmOverheadCalculator, MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    memoryDisk.setActive(true);
    return memoryDisk;
}
#end_block

#method_before
private DiskImage createMetadataDisk(VM vm, Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = validateStorageDomainExistsInDb(snapshot, guids.get(0), guids.get(4), guids.get(5));
    DiskImage disk = isMemoryDiskAlreadyExistsInDb(snapshot, guids.get(4), guids.get(5));
    if (sd == null || disk != null) {
        return null;
    }
    DiskImage memoryDisk = MemoryUtils.createMetadataDisk(MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(4));
    memoryDisk.setImageId(guids.get(5));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    memoryDisk.setActive(true);
    return memoryDisk;
}
#method_after
private DiskImage createMetadataDisk(VM vm, Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = validateStorageDomainExistsInDb(snapshot, guids.get(0), guids.get(4), guids.get(5));
    DiskImage disk = isMemoryDiskAlreadyExistsInDb(snapshot, guids.get(4), guids.get(5));
    if (sd == null || disk != null) {
        return null;
    }
    DiskImage memoryDisk = MemoryUtils.createSnapshotMetadataDisk(MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(4));
    memoryDisk.setImageId(guids.get(5));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    memoryDisk.setActive(true);
    return memoryDisk;
}
#end_block

#method_before
private DiskImage isMemoryDiskAlreadyExistsInDb(Snapshot snapshot, Guid diskId, Guid imageId) {
    DiskImage disk = diskImageDao.get(imageId);
    if (disk != null) {
        log.warn("Memory disk '{}'/'{}' of snapshot '{}'(id: '{}') already exists on storage domain '{}'", diskId, imageId, snapshot.getDescription(), snapshot.getId(), disk.getStoragesNames().get(0));
    }
    return disk;
}
#method_after
private DiskImage isMemoryDiskAlreadyExistsInDb(Snapshot snapshot, Guid diskId, Guid imageId) {
    DiskImage disk = diskImageDao.get(imageId);
    if (disk != null) {
        log.info("Memory disk '{}'/'{}' of snapshot '{}'(id: '{}') already exists on storage domain '{}'", diskId, imageId, snapshot.getDescription(), snapshot.getId(), disk.getStoragesNames().get(0));
    }
    return disk;
}
#end_block

#method_before
public void registerTrackingRequest(JsonRpcRequest req, ResponseTracking tracking) {
    JsonNode id = req.getId();
    List<JsonNode> nodes = new CopyOnWriteArrayList<>();
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        this.map.put(id, tracking);
        this.queue.add(id);
        nodes.add(id);
        nodes = this.hostToId.putIfAbsent(tracking.getClient().getClientId(), nodes);
        if (nodes != null) {
            nodes.add(id);
        }
    }
}
#method_after
public void registerTrackingRequest(JsonRpcRequest req, ResponseTracking tracking) {
    JsonNode id = req.getId();
    List<JsonNode> nodes = new CopyOnWriteArrayList<>();
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (!tracking.getClient().isOpen()) {
            return;
        }
        this.map.put(id, tracking);
        this.queue.add(id);
        nodes.add(id);
        nodes = this.hostToId.putIfAbsent(tracking.getClient().getClientId(), nodes);
        if (nodes != null && !nodes.contains(id)) {
            nodes.add(id);
        }
    }
}
#end_block

#method_before
@Before
public void setup() throws ClientConnectionException {
    request = mock(JsonRpcRequest.class);
    tracking = mock(ResponseTracking.class);
    client = spy(new StompClient(mock(Reactor.class), mock(Selector.class), "127.0.0.1", 54321));
    when(request.getId()).thenReturn(idNode);
    when(client.getClientId()).thenReturn("127.0.0.1:" + client.hashCode());
    when(tracking.getClient()).thenReturn(client);
}
#method_after
@Before
public void setup() throws ClientConnectionException {
    request = mock(JsonRpcRequest.class);
    tracking = mock(ResponseTracking.class);
    client = spy(new StompClient(mock(Reactor.class), mock(Selector.class), "127.0.0.1", 54321));
    when(request.getId()).thenReturn(idNode);
}
#end_block

#method_before
@Test
public void testRegisterTrackingRequest() {
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    assertEquals(1, tracker.getHostMap().size());
}
#method_after
@Test
public void testRegisterTrackingRequest() {
    when(client.getClientId()).thenReturn("127.0.0.1:" + client.hashCode());
    when(client.isOpen()).thenReturn(true);
    when(tracking.getClient()).thenReturn(client);
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    assertEquals(1, tracker.getHostMap().size());
}
#end_block

#method_before
@Test
public void testDoubleTrackingRequestRegistration() {
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    tracker.registerTrackingRequest(request, tracking);
    assertEquals(1, tracker.getHostMap().size());
}
#method_after
@Test
public void testDoubleTrackingRequestRegistration() {
    when(client.getClientId()).thenReturn("127.0.0.1:" + client.hashCode());
    when(client.isOpen()).thenReturn(true);
    when(tracking.getClient()).thenReturn(client);
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    tracker.registerTrackingRequest(request, tracking);
    assertEquals(1, tracker.getHostMap().size());
}
#end_block

#method_before
@Test
public void testRegisterAndRemove() {
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    tracker.removeCall(idNode);
    Map<String, List<JsonNode>> map = tracker.getHostMap();
    assertEquals(0, map.get(client.getClientId()).size());
    assertEquals(1, map.keySet().size());
}
#method_after
@Test
public void testRegisterAndRemove() {
    when(client.getClientId()).thenReturn("127.0.0.1:" + client.hashCode());
    when(client.isOpen()).thenReturn(true);
    when(tracking.getClient()).thenReturn(client);
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    tracker.removeCall(idNode);
    Map<String, List<JsonNode>> map = tracker.getHostMap();
    assertEquals(1, map.keySet().size());
    assertEquals(0, map.get(client.getClientId()).size());
}
#end_block

#method_before
@Test
public void testRegisterAndProcessIssue() {
    when(tracking.getCall()).thenReturn(mock(JsonRpcCall.class));
    Map<String, Object> error = new HashMap<>();
    error.put("message", "message");
    error.put("code", "127.0.0.1:" + client.hashCode());
    JsonRpcResponse response = new ResponseBuilder(idNode).withError(error).build();
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    tracker.processIssue(response);
    Map<String, List<JsonNode>> map = tracker.getHostMap();
    assertEquals(0, map.keySet().size());
}
#method_after
@Test
public void testRegisterAndProcessIssue() {
    when(client.getClientId()).thenReturn("127.0.0.1:" + client.hashCode());
    when(client.isOpen()).thenReturn(true);
    when(tracking.getClient()).thenReturn(client);
    when(tracking.getCall()).thenReturn(mock(JsonRpcCall.class));
    Map<String, Object> error = new HashMap<>();
    error.put("message", "message");
    error.put("code", "127.0.0.1:" + client.hashCode());
    JsonRpcResponse response = new ResponseBuilder(idNode).withError(error).build();
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerTrackingRequest(request, tracking);
    tracker.processIssue(response);
    Map<String, List<JsonNode>> map = tracker.getHostMap();
    assertEquals(0, map.keySet().size());
}
#end_block

#method_before
@Test
public void testRegisterAndHandleFailure() {
    when(tracking.getCall()).thenReturn(mock(JsonRpcCall.class));
    when(tracking.getTimeout()).thenReturn(0l);
    RetryContext context = mock(RetryContext.class);
    when(context.getNumberOfAttempts()).thenReturn(0);
    when(tracking.getContext()).thenReturn(context);
    when(tracking.getRequest()).thenReturn(request);
    when(tracking.isResetConnection()).thenReturn(true);
    doNothing().when(client).disconnect("Vds timeout occured");
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerCall(request, new Call(request));
    tracker.registerTrackingRequest(request, tracking);
    tracker.loop();
    Map<String, List<JsonNode>> map = tracker.getHostMap();
    assertEquals(0, map.keySet().size());
}
#method_after
@Test
public void testRegisterAndHandleFailure() {
    when(client.getClientId()).thenReturn("127.0.0.1:" + client.hashCode());
    when(client.isOpen()).thenReturn(true);
    when(tracking.getClient()).thenReturn(client);
    when(tracking.getCall()).thenReturn(mock(JsonRpcCall.class));
    when(tracking.getTimeout()).thenReturn(0l);
    RetryContext context = mock(RetryContext.class);
    when(context.getNumberOfAttempts()).thenReturn(0);
    when(tracking.getContext()).thenReturn(context);
    when(tracking.getRequest()).thenReturn(request);
    when(tracking.isResetConnection()).thenReturn(true);
    doNothing().when(client).disconnect("Vds timeout occured");
    ResponseTracker tracker = new ResponseTracker();
    tracker.registerCall(request, new Call(request));
    tracker.registerTrackingRequest(request, tracking);
    tracker.loop();
    Map<String, List<JsonNode>> map = tracker.getHostMap();
    assertEquals(0, map.keySet().size());
}
#end_block

#method_before
private String maskPassword(String queryString) {
    return queryString.replaceAll("password=[^&]+", "password=****");
}
#method_after
private String maskPassword(String queryString) {
    return StringUtils.isNotEmpty(queryString) ? queryString.replaceAll("password=[^&]+", "password=***") : queryString;
}
#end_block

#method_before
private Map<Guid, Guid> mapDisks(DiskAttachments diskAttachments) {
    Map<Guid, Guid> diskToImageIds = null;
    if (diskAttachments.isSetDiskAttachments()) {
        diskToImageIds = diskAttachments.getDiskAttachments().stream().map(DiskAttachment::getDisk).filter(Objects::nonNull).map(d -> (DiskImage) DiskMapper.map(d, null)).collect(Collectors.toMap(BaseDisk::getId, DiskImage::getImageId));
    }
    return diskToImageIds;
}
#method_after
private Map<Guid, Guid> mapDisks(DiskAttachments diskAttachments) {
    Map<Guid, Guid> diskToImageIds = null;
    if (diskAttachments.isSetDiskAttachments()) {
        diskToImageIds = diskAttachments.getDiskAttachments().stream().map(DiskAttachment::getDisk).filter(Objects::nonNull).map(disk -> (DiskImage) DiskMapper.map(disk, null)).collect(Collectors.toMap(BaseDisk::getId, DiskImage::getImageId));
    }
    return diskToImageIds;
}
#end_block

#method_before
public ArrayList<DiskImage> mapDisks(Disks disks) {
    ArrayList<DiskImage> diskImages = null;
    if (disks != null && disks.isSetDisks()) {
        diskImages = new ArrayList<>();
        for (Disk disk : disks.getDisks()) {
            if (disk != null) {
                DiskImage diskImage = (DiskImage) DiskMapper.map(disk, null);
                diskImages.add(diskImage);
            }
        }
    }
    return diskImages;
}
#method_after
List<DiskImage> mapDisks(Disks disks) {
    List<DiskImage> diskImages = null;
    if (disks != null && disks.isSetDisks()) {
        diskImages = disks.getDisks().stream().filter(Objects::nonNull).map(disk -> (DiskImage) DiskMapper.map(disk, null)).collect(Collectors.toList());
    }
    return diskImages;
}
#end_block

#method_before
@Override
protected void createImage() {
    CommandCoordinatorUtil.executeAsyncCommand(ActionType.AddDisk, getAddDiskParameters(), cloneContextAndDetachFromParent());
}
#method_after
@Override
protected void createImage() {
    runInternalAction(ActionType.AddDisk, getAddDiskParameters(), cloneContextAndDetachFromParent());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData))) {
            return false;
        }
        if (!validateMacs(vmFromConfiguration)) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.validate();
}
#end_block

#method_before
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElements().iterator().next();
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(dve, disk.getPlugged());
        ActionReturnValue returnVal = runInternalAction(ActionType.AttachDiskToVm, params, cloneContextAndDetachFromParent());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#method_after
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElements().iterator().next();
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(dve, dve.isPlugged());
        ActionReturnValue returnVal = runInternalAction(ActionType.AttachDiskToVm, params, cloneContextAndDetachFromParent());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#end_block

#method_before
@Override
protected boolean performImageVdsmOperation() {
    setDestinationImageId(Guid.isNullOrEmpty(getParameters().getDestinationImageId()) ? Guid.newGuid() : getParameters().getDestinationImageId());
    persistCommandIfNeeded();
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setVolumeFormat(VolumeFormat.COW);
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), ""));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
            return true;
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        CommandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return false;
}
#method_after
@Override
protected boolean performImageVdsmOperation() {
    setDestinationImageId(Guid.isNullOrEmpty(getParameters().getDestinationImageId()) ? Guid.newGuid() : getParameters().getDestinationImageId());
    persistCommandIfNeeded();
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setVolumeFormat(VolumeFormat.COW);
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), ""));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
            return true;
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        commandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return false;
}
#end_block

#method_before
private void handleInitializing(final StateContext context) {
    if (context.childCmdId == null) {
        // Guard against callback invocation before executeCommand() is complete
        return;
    }
    switch(CommandCoordinatorUtil.getCommandStatus(context.childCmdId)) {
        case NOT_STARTED:
        case ACTIVE:
            log.info("Waiting for {} to be added for image transfer command '{}'", getImageType(), getCommandId());
            return;
        case SUCCEEDED:
            break;
        default:
            log.error("Failed to add {} for image transfer command '{}'", getImageType(), getCommandId());
            setCommandStatus(CommandStatus.FAILED);
            return;
    }
    ActionReturnValue addDiskRetVal = CommandCoordinatorUtil.getCommandReturnValue(context.childCmdId);
    if (addDiskRetVal == null || !addDiskRetVal.getSucceeded()) {
        log.error("Failed to add {} (command status was success, but return value was failed)" + " for image transfer command '{}'", getImageType(), getCommandId());
        setReturnValue(addDiskRetVal);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Guid createdId = addDiskRetVal.getActionReturnValue();
    // Saving disk id in the parameters in order to persist it in command_entities table
    getParameters().setImageGroupID(createdId);
    handleImageIsReadyForTransfer();
}
#method_after
private void handleInitializing(final StateContext context) {
    if (context.childCmdId == null) {
        // Guard against callback invocation before executeCommand() is complete
        return;
    }
    switch(commandCoordinatorUtil.getCommandStatus(context.childCmdId)) {
        case NOT_STARTED:
        case ACTIVE:
            log.info("Waiting for {} to be added for image transfer command '{}'", getImageType(), getCommandId());
            return;
        case SUCCEEDED:
            break;
        default:
            log.error("Failed to add {} for image transfer command '{}'", getImageType(), getCommandId());
            setCommandStatus(CommandStatus.FAILED);
            return;
    }
    ActionReturnValue addDiskRetVal = commandCoordinatorUtil.getCommandReturnValue(context.childCmdId);
    if (addDiskRetVal == null || !addDiskRetVal.getSucceeded()) {
        log.error("Failed to add {} (command status was success, but return value was failed)" + " for image transfer command '{}'", getImageType(), getCommandId());
        setReturnValue(addDiskRetVal);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Guid createdId = addDiskRetVal.getActionReturnValue();
    // Saving disk id in the parameters in order to persist it in command_entities table
    getParameters().setImageGroupID(createdId);
    handleImageIsReadyForTransfer();
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        Guid transferingVdsId = context.entity.getVdsId();
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else // We want to use the transferring vds for image actions for having a coherent log when transferring.
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getDiskImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getImage().getImage(), getStoragePool().getId(), getDiskImage().getId(), getDiskImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        Guid transferingVdsId = context.entity.getVdsId();
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else // We want to use the transferring vds for image actions for having a coherent log when transferring.
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getDiskImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getDiskImage().getImage(), getStoragePool().getId(), getDiskImage().getId(), getDiskImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getDiskImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#end_block

#method_before
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (getParameters().getTransferType() == TransferType.Upload && !setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getOp() };
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename());
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (getParameters().getTransferType() == TransferType.Upload && !setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getAllowedOperation() };
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename());
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new TransferImageCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return callbackProvider.get();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    memoryImageBuilder.build();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    getParameters().setCreatedSnapshotId(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    memoryImageBuilder.build();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    setSucceeded(true);
}
#end_block

#method_before
private void createSnapshotsForDisks() {
    for (DiskImage disk : getDisksList()) {
        if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
            CreateCinderSnapshotParameters params = buildChildCommandParameters(disk);
            params.setQuotaId(disk.getQuotaId());
            Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.CreateCinderSnapshot, params, cloneContext().withoutCompensationContext().withoutLock());
            try {
                ActionReturnValue actionReturnValue = future.get();
                if (!actionReturnValue.getSucceeded()) {
                    log.error("Error creating snapshot for Cinder disk '{}'", disk.getDiskAlias());
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error creating snapshot for Cinder disk '{}': {}", disk.getDiskAlias(), e.getMessage());
                throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
            }
            continue;
        }
        ActionReturnValue actionReturnValue = Backend.getInstance().runInternalAction(ActionType.CreateSnapshot, buildCreateSnapshotParameters(disk), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (actionReturnValue.getSucceeded()) {
            getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
        } else {
            throw new EngineException(actionReturnValue.getFault().getError(), "Failed to create snapshot!");
        }
    }
}
#method_after
private void createSnapshotsForDisks() {
    for (DiskImage disk : getDisksList()) {
        if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
            CreateCinderSnapshotParameters params = buildChildCommandParameters(disk);
            params.setQuotaId(disk.getQuotaId());
            Future<ActionReturnValue> future = commandCoordinatorUtil.executeAsyncCommand(ActionType.CreateCinderSnapshot, params, cloneContext().withoutCompensationContext().withoutLock());
            try {
                ActionReturnValue actionReturnValue = future.get();
                if (!actionReturnValue.getSucceeded()) {
                    log.error("Error creating snapshot for Cinder disk '{}'", disk.getDiskAlias());
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error creating snapshot for Cinder disk '{}': {}", disk.getDiskAlias(), e.getMessage());
                throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
            }
            continue;
        }
        ActionReturnValue actionReturnValue = Backend.getInstance().runInternalAction(ActionType.CreateSnapshot, buildCreateSnapshotParameters(disk), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (actionReturnValue.getSucceeded()) {
            getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
        } else {
            throw new EngineException(actionReturnValue.getFault().getError(), "Failed to create snapshot!");
        }
    }
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = snapshotDao.get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = shouldPerformLiveSnapshot(createdSnapshot);
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        snapshotDao.updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (snapshotWithMemory(createdSnapshot)) {
                logMemorySavingFailed();
                snapshotDao.removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (snapshotWithMemory(createdSnapshot)) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = snapshotDao.get(getParameters().getCreatedSnapshotId());
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = shouldPerformLiveSnapshot(createdSnapshot);
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        snapshotDao.updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (snapshotWithMemory(createdSnapshot)) {
                logMemorySavingFailed();
                snapshotDao.removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (snapshotWithMemory(createdSnapshot)) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new ConcurrentChildCommandsExecutionCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return callbackProvider.get();
}
#end_block

#method_before
@Override
public Map<Boolean, List<VM>> getForDisk(Guid id, boolean includeVmsSnapshotAttachedTo) {
    Map<Boolean, List<VM>> result = new HashMap<>();
    List<Pair<VM, VmDevice>> vms = getVmsWithPlugInfo(id);
    for (Pair<VM, VmDevice> pair : vms) {
        VmDevice device = pair.getSecond();
        if (includeVmsSnapshotAttachedTo || device.getSnapshotId() == null) {
            MultiValueMapUtils.addToMap(device.isPlugged(), pair.getFirst(), result);
        }
    }
    return result;
}
#method_after
@Override
public Map<Boolean, List<VM>> getForDisk(Guid id, boolean includeVmsSnapshotAttachedTo) {
    List<Pair<VM, VmDevice>> vms = getVmsWithPlugInfo(id);
    return vms.stream().filter(p -> includeVmsSnapshotAttachedTo || p.getSecond().getSnapshotId() == null).collect(Collectors.groupingBy(p -> p.getSecond().isPlugged(), Collectors.mapping(Pair::getFirst, Collectors.toList())));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VM> vms = vmDao.getAllPinnedToHost(getParameters().getId());
    setReturnValue(vms);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VM> vms = vmDao.getAllPinnedToHost(getParameters().getId());
    if (vms != null) {
        vms.forEach(vmHandler::updateVmStatistics);
    }
    setReturnValue(vms);
}
#end_block

#method_before
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return !activeSnapshot.getMemoryVolume().isEmpty() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        return snapshotDao.getAll(getVmId()).stream().filter(s -> !StringUtils.EMPTY.equals(s.getMemoryVolume())).map(Function.identity()).collect(Collectors.toList());
    }
}
#method_after
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return !activeSnapshot.getMemoryVolume().isEmpty() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        return snapshotDao.getAll(getVmId()).stream().filter(s -> !StringUtils.EMPTY.equals(s.getMemoryVolume())).collect(Collectors.toList());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    vmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            moveOrCopyAllImageGroups();
            return null;
        });
        if (!getReturnValue().getVdsmTaskIdList().isEmpty()) {
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    vmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            moveOrCopyAllImageGroups();
            return null;
        });
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    ArrayList<DiskImage> AllVmImages = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        AllVmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.exportVm(vm, AllVmImages, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
private void updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    List<DiskImage> vmImages = new ArrayList<>();
    List<LunDisk> lunDisks = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        vmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    // TODO: Validate export
    lunDisks.addAll(DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE));
    for (LunDisk lun : lunDisks) {
        lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId())));
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.exportVm(vm, vmImages, lunDisks, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    runVdsCommand(VDSCommandType.UpdateVM, tempVar);
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
protected void updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, ovfUpdateProcessHelper.getVmImagesFromDb(getVm()));
    ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#method_after
protected void updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, ovfUpdateProcessHelper.getVmImagesFromDb(getVm()), new ArrayList<>());
    ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    setVmId(getParameters().getContainerId());
    setStoragePoolId(getParameters().getStoragePoolId());
    imageToDestinationDomainMap = getParameters().getImageToDestinationDomainMap();
    if (getParameters().getVm() != null && getVm().getDiskMap() != null) {
        getVm().getDiskMap().values().stream().filter(DisksFilter.ONLY_IMAGES).map(DiskImage.class::cast).collect(Collectors.toList());
    }
    ensureDomainMap(imageList, getParameters().getDestDomainId());
}
#method_after
@Override
protected void init() {
    super.init();
    setVmId(getParameters().getContainerId());
    setStoragePoolId(getParameters().getStoragePoolId());
    imageToDestinationDomainMap = getParameters().getImageToDestinationDomainMap();
    if (getParameters().getVm() != null && getVm().getDiskMap() != null) {
        imageList = getVm().getDiskMap().values().stream().filter(DisksFilter.ONLY_IMAGES).map(DiskImage.class::cast).collect(Collectors.toList());
    }
    ensureDomainMap(imageList, getParameters().getDestDomainId());
}
#end_block

#method_before
protected boolean validateAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !validateUniqueVmName()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getValidationMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", storageDomainStaticDao.get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        if (!handleDestStorageDomains()) {
            return false;
        }
    }
    if (!validateGraphicsAndDisplay()) {
        return false;
    }
    if (!getParameters().isImportAsNewEntity()) {
        List<VmNetworkInterface> vmNetworkInterfaces = getVm().getInterfaces();
        if (!validate(vmNicMacsUtils.validateThereIsEnoughOfFreeMacs(vmNetworkInterfaces, getMacPool(), getVnicRequiresNewMacPredicate()))) {
            return false;
        }
        if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
protected boolean validateAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !validateUniqueVmName()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (!validateLunDisksForVm(vmFromParams)) {
        return false;
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getValidationMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", storageDomainStaticDao.get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        if (!handleDestStorageDomains()) {
            return false;
        }
    }
    if (!validateGraphicsAndDisplay()) {
        return false;
    }
    if (!getParameters().isImportAsNewEntity()) {
        List<VmNetworkInterface> vmNetworkInterfaces = getVm().getInterfaces();
        if (!validate(vmNicMacsUtils.validateThereIsEnoughOfFreeMacs(vmNetworkInterfaces, getMacPool(), getVnicRequiresNewMacPredicate()))) {
            return false;
        }
        if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmImagesAndSnapshots();
        addMemoryImages();
        updateSnapshotsFromExport();
        if (useCopyImages) {
            moveOrCopyAllImageGroups();
        }
        getVmDeviceUtils().addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity(), false);
        if (getParameters().isImportAsNewEntity()) {
            getParameters().setVm(getVm());
            setVmId(getVm().getId());
        }
        return null;
    });
}
#method_after
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmImagesAndSnapshots();
        addVmExternalLuns();
        addMemoryImages();
        updateSnapshotsFromExport();
        if (useCopyImages) {
            moveOrCopyAllImageGroups();
        }
        getVmDeviceUtils().addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity(), false);
        if (getParameters().isImportAsNewEntity()) {
            getParameters().setVm(getVm());
            setVmId(getVm().getId());
        }
        return null;
    });
}
#end_block

#method_before
@Override
protected void logTimeoutException(TimeoutException e, VDSNetworkException ex) {
// don't do that.
}
#method_after
@Override
protected void logTimeoutException(TimeoutException e, VDSNetworkException ex) {
// don't do that.
// PollingVds is usually done to wait until connectivity to host is recovered.
// Any timeouts during process are expected and we don't want to log such 'failures'.
}
#end_block

#method_before
protected void logTimeoutException(TimeoutException e, VDSNetworkException ex) {
    logException(ex);
    log.error("Timeout waiting for VDSM response: {}", e.getMessage());
    log.debug("Exception", e);
}
#method_after
protected void logTimeoutException(TimeoutException e, VDSNetworkException ex) {
    log.error("Timeout waiting for VDSM response: {}", e.getMessage());
    log.debug("Exception", e);
}
#end_block

#method_before
public void attemptResolution() {
    Set<Guid> images;
    if (vmDao.get(getParameters().getVmId()).isDown()) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        MergeHelper.setLiveMergeNextCommandStep((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters(), RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
public void attemptResolution() {
    Set<Guid> images;
    if (vmDao.get(getParameters().getVmId()).isDown()) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        // As this command is executed only during live merge flow, the following casting is safe.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    } catch (EngineException e) {
        log.error("Failed to delete image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get(), e);
        if (!MergeHelper.isLiveMerge(getParameters().getParentParameters())) {
            throw e;
        }
    }
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getTaskIdList().add(result);
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        log.info("Retrying deleting image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get());
        MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, new HashSet<>(getParameters().getImageList()));
        getReturnValue().setActionReturnValue(returnValue);
        // At this point, we know that this command was executed during live merge and it is safe to do
        // the casting in the next line.
        MergeHelper.setLiveMergeNextCommandStep((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters(), RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
    }
    setSucceeded(true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    } catch (EngineException e) {
        log.error("Failed to delete image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get(), e);
        if (!getParameters().isLiveMerge()) {
            throw e;
        }
    }
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getTaskIdList().add(result);
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        log.info("Retrying deleting image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get());
        MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, new HashSet<>(getParameters().getImageList()));
        getReturnValue().setActionReturnValue(returnValue);
        // At this point, we know that this command was executed during live merge and it is safe to do
        // the casting in the next line.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
    }
    setSucceeded(true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    List<Guid> failedGuids = getFailedVolumeIds();
    if (failedGuids.isEmpty()) {
        log.info("Requested images were successfully removed");
        persistCommand(getParameters().getParentCommand());
    } else {
        log.error("The following images were not removed: {}", failedGuids);
        // in order to retry executing it.
        if (MergeHelper.isLiveMerge(getParameters().getParentParameters())) {
            MergeHelper.setLiveMergeNextCommandStep((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters(), RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
        }
    }
    setCommandStatus(CommandStatus.SUCCEEDED);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    List<Guid> failedGuids = getFailedVolumeIds();
    if (failedGuids.isEmpty()) {
        log.info("Requested images were successfully removed");
        persistCommand(getParameters().getParentCommand());
    } else {
        log.error("The following images were not removed: {}", failedGuids);
        // in order to retry executing it.
        if (getParameters().isLiveMerge()) {
            // As this command is executed only during live merge flow, the following casting is safe.
            ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
        }
    }
    setCommandStatus(CommandStatus.SUCCEEDED);
    setSucceeded(true);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    VDS host = getSelectedItem();
    EditHostModel hostModel = new EditHostModel();
    AsyncDataProvider.getInstance().getAllFenceAgentsByHostId(new AsyncQuery<>(retValue -> {
        ArrayList<FenceAgent> fenceAgents = new ArrayList<>();
        for (FenceAgent fenceAgent : retValue) {
            fenceAgents.add(fenceAgent);
        }
        host.setFenceAgents(fenceAgents);
        hostModel.setSelectedCluster(host);
        hostModel.getFenceAgentListModel().setItems(hostModel.getFenceAgentModelList(host));
    }), getSelectedItem().getId());
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis);
        hostModel.onDataInitialized();
        hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
        hostModel.setHelpTag(HelpTag.edit_host);
        // $NON-NLS-1$
        hostModel.setHashName("edit_host");
        hostModel.setIsHeSystem(isHeSystem());
        hostModel.setHostsWithHeDeployed(getHostsWithHeDeployed());
        hostModel.setHostedEngineHostModel(new HostedEngineHostModel());
        setWindow(hostModel);
        if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
            hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
        } else {
            AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
        }
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        hostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        hostModel.getCommands().add(cancelCommand);
    }));
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    VDS host = getSelectedItem();
    EditHostModel hostModel = new EditHostModel();
    hostModel.setSelectedCluster(host);
    AsyncDataProvider.getInstance().getAllFenceAgentsByHostId(new AsyncQuery<>(retValue -> {
        ArrayList<FenceAgent> fenceAgents = new ArrayList<>();
        for (FenceAgent fenceAgent : retValue) {
            fenceAgents.add(fenceAgent);
        }
        host.setFenceAgents(fenceAgents);
        hostModel.getFenceAgentListModel().setItems(hostModel.getFenceAgentModelList(host));
    }), getSelectedItem().getId());
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis);
        hostModel.onDataInitialized();
        hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
        hostModel.setHelpTag(HelpTag.edit_host);
        // $NON-NLS-1$
        hostModel.setHashName("edit_host");
        hostModel.setIsHeSystem(isHeSystem());
        hostModel.setHostsWithHeDeployed(getHostsWithHeDeployed());
        hostModel.setHostedEngineHostModel(new HostedEngineHostModel());
        setWindow(hostModel);
        if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
            hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
        } else {
            AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
        }
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        hostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        hostModel.getCommands().add(cancelCommand);
    }));
}
#end_block

#method_before
@Override
public List<UnregisteredDisk> getByDiskIdAndStorageDomainId(Guid diskId, Guid storageDomainId) {
    List<UnregisteredDisk> unregisteredDisks = getCallsHandler().executeReadList("GetDiskByDiskIdAndStorageDomainId", unregisteredDiskRowMapper, getCustomMapSqlParameterSource().addValue("disk_id", diskId).addValue("storage_domain_id", storageDomainId));
    for (UnregisteredDisk unregDisk : unregisteredDisks) {
        List<VmBase> vms = getCallsHandler().executeReadList("GetEntitiesByDiskId", vmsForUnregisteredDiskRowMapper, getCustomMapSqlParameterSource().addValue("disk_id", unregDisk.getId().getDiskId()));
        unregDisk.getVms().addAll(vms);
    }
    return unregisteredDisks;
}
#method_after
@Override
public List<UnregisteredDisk> getByDiskIdAndStorageDomainId(Guid diskId, Guid storageDomainId) {
    List<UnregisteredDisk> unregisteredDisks = getCallsHandler().executeReadList("GetDiskByDiskIdAndStorageDomainId", unregisteredDiskRowMapper, createIdParameterMapper(new UnregisteredDiskId(diskId, storageDomainId)));
    for (UnregisteredDisk unregDisk : unregisteredDisks) {
        List<VmBase> vms = getCallsHandler().executeReadList("GetEntitiesByDiskId", vmsForUnregisteredDiskRowMapper, getCustomMapSqlParameterSource().addValue("disk_id", unregDisk.getDiskId()));
        unregDisk.getVms().addAll(vms);
    }
    return unregisteredDisks;
}
#end_block

#method_before
@Override
public void removeUnregisteredDisk(Guid diskId, Guid storageDomainId) {
    getCallsHandler().executeModification("RemoveDiskFromUnregistered", getCustomMapSqlParameterSource().addValue("disk_id", diskId).addValue("storage_domain_id", storageDomainId));
}
#method_after
@Override
public void removeUnregisteredDisk(Guid diskId, Guid storageDomainId) {
    getCallsHandler().executeModification("RemoveDiskFromUnregistered", createIdParameterMapper(new UnregisteredDiskId(diskId, storageDomainId)));
}
#end_block

#method_before
@Override
public void saveUnregisteredDisk(UnregisteredDisk disk) {
    // OVF data is not included since it is being updated in the stored procedure.
    getCallsHandler().executeModification("InsertUnregisteredDisk", getCustomMapSqlParameterSource().addValue("disk_id", disk.getDiskImage().getId()).addValue("image_id", disk.getDiskImage().getImageId()).addValue("disk_alias", disk.getDiskImage().getDiskAlias()).addValue("disk_description", disk.getDiskImage().getDiskDescription()).addValue("creation_date", disk.getDiskImage().getCreationDate()).addValue("last_modified", disk.getDiskImage().getLastModified()).addValue("volume_type", disk.getDiskImage().getVolumeType()).addValue("volume_format", disk.getDiskImage().getVolumeFormat()).addValue("actual_size", disk.getDiskImage().getActualSize()).addValue("size", disk.getDiskImage().getSize()).addValue("storage_domain_id", disk.getDiskImage().getStorageIds().get(0)));
    for (VmBase vmBase : disk.getVms()) {
        getCallsHandler().executeModification("InsertUnregisteredDisksToVms", getCustomMapSqlParameterSource().addValue("disk_id", disk.getDiskImage().getId()).addValue("entity_id", vmBase.getId()).addValue("entity_name", vmBase.getName()).addValue("storage_domain_id", disk.getDiskImage().getStorageIds().get(0)));
    }
}
#method_after
@Override
public void saveUnregisteredDisk(UnregisteredDisk disk) {
    // OVF data is not included since it is being updated in the stored procedure.
    getCallsHandler().executeModification("InsertUnregisteredDisk", createFullParametersMapper(disk));
    for (VmBase vmBase : disk.getVms()) {
        getCallsHandler().executeModification("InsertUnregisteredDisksToVms", createIdParameterMapper(disk.getId()).addValue("entity_id", vmBase.getId()).addValue("entity_name", vmBase.getName()));
    }
}
#end_block

#method_before
private void completeOpenstackNetworkProviderId() {
    if (getParameters().getVdsStaticData().getOpenstackNetworkProviderId() == null) {
        Cluster cluster = clusterDao.get(getParameters().getVdsStaticData().getClusterId());
        getParameters().getVdsStaticData().setOpenstackNetworkProviderId(cluster.getDefaultNetworkProviderId());
    }
}
#method_after
private void completeOpenstackNetworkProviderId() {
    if (getParameters().getVdsStaticData().getOpenstackNetworkProviderId() == null) {
        getParameters().getVdsStaticData().setOpenstackNetworkProviderId(getCluster().getDefaultNetworkProviderId());
    }
}
#end_block

#method_before
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writeNetworkInterfaceMetadata();
    writeRunAndPauseMetadata();
    writer.writeEndElement();
}
#method_after
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writeNetworkInterfaceMetadata();
    writeDiskMetadata();
    writeRunAndPauseMetadata();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean refreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    refreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (refreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeManagedDisk(VmDevice device, Disk disk, DiskVmElement dve, int index) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    StorageType storageDomainType = disk.getDiskStorageType() == DiskStorageType.IMAGE ? storageDomainStaticDao.get(((DiskImage) disk).getStorageIds().get(0)).getStorageType() : null;
    writeGeneralDiskAttributes(device, disk, dve, storageDomainType);
    writeDiskTarget(dve, index);
    writeDiskSource(disk, storageDomainType);
    writeDiskDriver(device, disk, dve, storageDomainType);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#method_after
private void writeManagedDisk(VmDevice device, Disk disk, DiskVmElement dve, int index) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    StorageType storageDomainType = disk.getDiskStorageType() == DiskStorageType.IMAGE ? storageDomainStaticDao.get(((DiskImage) disk).getStorageIds().get(0)).getStorageType() : null;
    writeGeneralDiskAttributes(device, disk, dve, storageDomainType);
    String dev = writeDiskTarget(dve, index);
    writeDiskSource(disk, storageDomainType, dev);
    writeDiskDriver(device, disk, dve, storageDomainType);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(Disk disk, StorageType storageDomainType) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            if (storageDomainType.isBlockDomain()) {
                writer.writeAttributeString("dev", String.format("/rhev/data-center/mnt/blockSD/%s/images/%s/%s", diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
            } else {
                // file
                writer.writeAttributeString("file", String.format("/rhev/data-center/%s/%s/images/%s/%s", diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, StorageType storageDomainType, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            if (storageDomainType.isBlockDomain()) {
                writer.writeAttributeString("dev", String.format("/rhev/data-center/mnt/blockSD/%s/images/%s/%s", diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
            } else {
                // file
                writer.writeAttributeString("file", String.format("/rhev/data-center/%s/%s/images/%s/%s", diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
            }
            Map<String, Object> diskUuids = new HashMap<>();
            diskUuids.put("poolID", diskImage.getStoragePoolId());
            diskUuids.put("domainID", diskImage.getStorageIds().get(0));
            diskUuids.put("imageID", diskImage.getId());
            diskUuids.put("volumeID", diskImage.getImageId());
            diskMetadata.put(dev, diskUuids);
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskTarget(DiskVmElement dve, int index) {
    writer.writeStartElement("target");
    switch(dve.getDiskInterface()) {
        case IDE:
            writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName("ide", index));
            writer.writeAttributeString("bus", "ide");
            break;
        case VirtIO:
            writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName("virtio", index));
            writer.writeAttributeString("bus", "virtio");
            // TODO: index
            break;
        case VirtIO_SCSI:
            writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName("scsi", index));
            writer.writeAttributeString("bus", "scsi");
            // TODO address
            break;
        case SPAPR_VSCSI:
            // TODO address, name
            break;
        default:
            log.error("Unsupported interface type, ISCSI interface type is not supported.");
    }
    writer.writeEndElement();
}
#method_after
private String writeDiskTarget(DiskVmElement dve, int index) {
    String dev = null;
    writer.writeStartElement("target");
    switch(dve.getDiskInterface()) {
        case IDE:
            dev = vmInfoBuildUtils.makeDiskName("ide", index);
            writer.writeAttributeString("dev", dev);
            writer.writeAttributeString("bus", "ide");
            break;
        case VirtIO:
            dev = vmInfoBuildUtils.makeDiskName("virtio", index);
            writer.writeAttributeString("dev", dev);
            writer.writeAttributeString("bus", "virtio");
            // TODO: index
            break;
        case VirtIO_SCSI:
            dev = vmInfoBuildUtils.makeDiskName("scsi", index);
            writer.writeAttributeString("dev", dev);
            writer.writeAttributeString("bus", "scsi");
            // TODO address
            break;
        case SPAPR_VSCSI:
            // TODO address, name
            break;
        default:
            log.error("Unsupported interface type, ISCSI interface type is not supported.");
    }
    writer.writeEndElement();
    return dev;
}
#end_block

#method_before
private boolean isReduceVolumeSupported() {
    return FeatureSupported.isReduceVolumeSupported(getStoragePool().getCompatibilityVersion());
}
#method_after
private boolean isReduceVolumeSupported() {
    setStoragePoolId(getParameters().getStoragePoolId());
    return FeatureSupported.isReduceVolumeSupported(getStoragePool().getCompatibilityVersion());
}
#end_block

#method_before
@Override
public ImageTicketInformationReturn getImageTicket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("ticketInfo");
    return new ImageTicketInformationReturn(response);
}
#method_after
@Override
public ImageTicketInformationReturn getImageTicket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("result");
    return new ImageTicketInformationReturn(response);
}
#end_block

#method_before
private ImageTicketInformation parseImageTicketInformationReturn() {
    ImageTicketInformation ticketInfo = new ImageTicketInformation();
    Map<String, Object> ticketInfoMap = imageTicketInformationReturn.getImageTicketInformation();
    if (ticketInfoMap.containsKey(UUID)) {
        ticketInfo.setId(Guid.createGuidFromString((String) ticketInfoMap.get(UUID)));
    }
    if (ticketInfoMap.containsKey(SIZE)) {
        ticketInfo.setSize(((Number) ticketInfoMap.get(SIZE)).longValue());
    }
    if (ticketInfoMap.containsKey(URL)) {
        ticketInfo.setUrl((String) ticketInfoMap.get(URL));
    }
    if (ticketInfoMap.containsKey(TIMEOUT)) {
        ticketInfo.setTimeout((Integer) ticketInfoMap.get(TIMEOUT));
    }
    if (ticketInfoMap.containsKey(EXPIRES)) {
        ticketInfo.setExpires(((Number) ticketInfoMap.get(EXPIRES)).longValue());
    }
    if (ticketInfoMap.containsKey(OPS)) {
        List<TransferType> transferTypes = Stream.of((Object[]) ticketInfoMap.get(OPS)).map(String.class::cast).map(TransferType::getTransferType).collect(Collectors.toList());
        ticketInfo.setTransferTypes(transferTypes);
    }
    return ticketInfo;
}
#method_after
private ImageTicketInformation parseImageTicketInformationReturn() {
    ImageTicketInformation ticketInfo = new ImageTicketInformation();
    Map<String, Object> ticketInfoMap = imageTicketInformationReturn.getImageTicketInformation();
    if (ticketInfoMap.containsKey(UUID)) {
        ticketInfo.setId(Guid.createGuidFromString((String) ticketInfoMap.get(UUID)));
    }
    if (ticketInfoMap.containsKey(SIZE)) {
        ticketInfo.setSize(((Number) ticketInfoMap.get(SIZE)).longValue());
    }
    if (ticketInfoMap.containsKey(URL)) {
        ticketInfo.setUrl((String) ticketInfoMap.get(URL));
    }
    if (ticketInfoMap.containsKey(TIMEOUT)) {
        ticketInfo.setTimeout((Integer) ticketInfoMap.get(TIMEOUT));
    }
    if (ticketInfoMap.containsKey(OPS)) {
        List<TransferType> transferTypes = Stream.of((Object[]) ticketInfoMap.get(OPS)).map(String.class::cast).map(TransferType::getTransferType).collect(Collectors.toList());
        ticketInfo.setTransferTypes(transferTypes);
    }
    if (ticketInfoMap.containsKey(FILENAME)) {
        ticketInfo.setFileName((String) ticketInfoMap.get(FILENAME));
    }
    return ticketInfo;
}
#end_block

#method_before
public static boolean isHighPerformanceTypeSupported(Version version) {
    return Boolean.parseBoolean(Config.getValue(ConfigValues.isHighPerformanceTypeSupported, version.getValue()));
}
#method_after
public static boolean isHighPerformanceTypeSupported(Version version) {
    return supportedInConfig(ConfigValues.IsHighPerformanceTypeSupported, version);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isDedicatedVdsExistOnSameCluster(VmBase vm, ArrayList<String> validationMessages) {
    return vmHandler.validateDedicatedVdsExistOnSameCluster(vm, validationMessages);
}
#method_after
protected boolean isDedicatedVdsExistOnSameCluster(VmBase vm) {
    return validate(vmHandler.validateDedicatedVdsExistOnSameCluster(vm));
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return vmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getValidationMessages());
}
#method_after
protected boolean canAddVm(List<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return validate(vmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams));
}
#end_block

#method_before
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci() || getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none) {
        return true;
    }
    return vmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages());
}
#method_after
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci() || getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none) {
        return true;
    }
    return validate(vmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs()));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name, storagePoolId)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#method_after
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name, storagePoolId)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!validate(vmHandler.verifyMacPool(getVmInterfaces().size(), getMacPool()))) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmPriority))) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#method_after
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = getReturnValue().getValidationMessages();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#end_block

#method_before
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : isOsSupportedForVirtIoScsi;
}
#method_after
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = vmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : isOsSupportedForVirtIoScsi;
}
#end_block

#method_before
protected boolean checkNumberOfMonitors() {
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none) {
        return true;
    }
    Collection<GraphicsType> graphicsTypes = vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return vmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getValidationMessages());
}
#method_after
protected boolean checkNumberOfMonitors() {
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none) {
        return true;
    }
    Collection<GraphicsType> graphicsTypes = vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return validate(vmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors));
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemplateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    Version effectiveCompatibilityVersion = CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster);
    if (getParameters().getVmTemplateData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(effectiveCompatibilityVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", effectiveCompatibilityVersion));
    }
    if (VmHandler.isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getValidationMessages()) && checkDomain()) {
        returnValue = vmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmTemplateData()))) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmTemplateData(), CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster)))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemplateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    Version effectiveCompatibilityVersion = CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster);
    if (getParameters().getVmTemplateData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(effectiveCompatibilityVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", effectiveCompatibilityVersion));
    }
    if (vmHandler.isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority()).isValid() && checkDomain()) {
        returnValue = vmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmTemplateData()))) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmTemplateData(), CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster)))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check if the OS type is supported
    boolean returnValue = vmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages());
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion()).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = validate(VmValidator.validateCpuSockets(getParameters().getVmTemplateData(), getVmTemplate().getCompatibilityVersion()));
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && getParameters().getVmTemplateData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = vmNicDao.getAllForTemplate(getParameters().getVmTemplateData().getId());
        List<DiskVmElement> diskVmElements = diskVmElementDao.getAllForVm(getVmTemplateId());
        if (!validate(VmValidator.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, diskVmElements, getVmDeviceUtils().hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), getVmDeviceUtils().hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled()))) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check if the OS type is supported
    boolean returnValue = validate(vmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture()));
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion()).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getVmTemplate().getCompatibilityVersion()));
    }
    if (returnValue) {
        returnValue = validate(VmValidator.validateCpuSockets(getParameters().getVmTemplateData(), getVmTemplate().getCompatibilityVersion()));
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && getParameters().getVmTemplateData().getDefaultDisplayType() != DisplayType.none && !validate(vmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId()))) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = vmNicDao.getAllForTemplate(getParameters().getVmTemplateData().getId());
        List<DiskVmElement> diskVmElements = diskVmElementDao.getAllForVm(getVmTemplateId());
        if (!validate(VmValidator.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, diskVmElements, getVmDeviceUtils().hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), getVmDeviceUtils().hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled()))) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#end_block

#method_before
private void initTable(ImportExportRepoImageBaseModel model) {
    imageList = new EntityModelCellTable<>(SelectionMode.NONE, true);
    imageList.enableColumnResizing();
    if (model.isImportModel()) {
        imageList.addColumn(new AbstractEntityModelTextColumn<RepoImage>() {

            @Override
            public String getText(RepoImage image) {
                return image.getRepoImageTitle();
            }
        }, constants.fileNameIso(), // $NON-NLS-1$
        "100%");
        imageList.addColumn(new DiskAliasTextColumn(new DiskAliasFieldUpdater()), templates.sub(constants.diskSnapshotAlias(), constants.clickToEdit()), // $NON-NLS-1$
        "150px");
        imageList.addColumn(new AbstractEntityModelTextColumn<RepoImage>() {

            @Override
            public String getText(RepoImage image) {
                return image.getFileType().toString();
            }
        }, constants.typeIso(), // $NON-NLS-1$
        "75px");
        imageList.addColumn(new AbstractDiskSizeColumn<EntityModel<RepoImage>>(SizeConverter.SizeUnit.BYTES) {

            @Override
            protected Long getRawValue(EntityModel<RepoImage> image) {
                return image.getEntity().getSize();
            }
        }, constants.actualSizeTemplate(), // $NON-NLS-1$
        "75px");
    } else {
        imageList.addColumn(new AbstractEntityModelTextColumn<DiskImage>() {

            @Override
            public String getText(DiskImage image) {
                return image.getDiskAlias();
            }
        }, constants.fileNameIso(), // $NON-NLS-1$
        "100%");
        imageList.addColumn(new AbstractEntityModelTextColumn<DiskImage>() {

            @Override
            public String getText(DiskImage image) {
                return ImageFileType.Disk.toString();
            }
        }, constants.typeIso(), // $NON-NLS-1$
        "75px");
        imageList.addColumn(new AbstractDiskSizeColumn<EntityModel<DiskImage>>(SizeConverter.SizeUnit.BYTES) {

            @Override
            protected Long getRawValue(EntityModel<DiskImage> image) {
                return image.getEntity().getSize();
            }
        }, constants.actualSizeTemplate(), // $NON-NLS-1$
        "75px");
    }
    // $NON-NLS-1$
    imageList.setWidth("100%", true);
    imageListPanel.setWidget(imageList);
}
#method_after
private void initTable(ImportExportRepoImageBaseModel model) {
    imageList = new EntityModelCellTable<>(SelectionMode.NONE, true);
    imageList.enableColumnResizing();
    if (model.isImportModel()) {
        imageList.addColumn(new AbstractEntityModelTextColumn<RepoImage>() {

            @Override
            public String getText(RepoImage image) {
                return image.getRepoImageTitle();
            }
        }, constants.fileNameIso(), // $NON-NLS-1$
        "100%");
        imageList.addColumn(new DiskAliasTextColumn(new DiskAliasFieldUpdater()), templates.sub(constants.diskSnapshotAlias(), constants.clickToEdit()), // $NON-NLS-1$
        "150px");
        imageList.addColumn(new AbstractEntityModelTextColumn<RepoImage>() {

            @Override
            public String getText(RepoImage image) {
                return image.getFileType().toString();
            }
        }, constants.typeIso(), // $NON-NLS-1$
        "75px");
        imageList.addColumn(new AbstractDiskSizeColumn<EntityModel<RepoImage>>(SizeConverter.SizeUnit.BYTES) {

            @Override
            protected Long getRawValue(EntityModel<RepoImage> image) {
                return image.getEntity().getSize();
            }
        }, constants.actualSizeTemplate(), // $NON-NLS-1$
        "75px");
    } else {
        imageList.addColumn(new AbstractEntityModelTextColumn<DiskImage>() {

            @Override
            public String getText(DiskImage image) {
                return image.getDiskAlias();
            }
        }, constants.fileNameIso(), // $NON-NLS-1$
        "100%");
        imageList.addColumn(new AbstractEntityModelTextColumn<DiskImage>() {

            @Override
            public String getText(DiskImage image) {
                return ImageFileType.Disk.toString();
            }
        }, constants.typeIso(), // $NON-NLS-1$
        "75px");
        imageList.addColumn(new AbstractDiskSizeColumn<EntityModel<DiskImage>>(SizeConverter.SizeUnit.BYTES) {

            @Override
            protected Long getRawValue(EntityModel<DiskImage> image) {
                return image.getEntity().getSize();
            }
        }, constants.actualSizeTemplate(), // $NON-NLS-1$
        "75px");
    }
    // $NON-NLS-1$
    imageList.setWidth("100%");
    imageList.setEmptyTableWidget(new NoItemsLabel());
    imageListPanel.setWidget(imageList);
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    pollingRate = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingLoopInSeconds);
    repeatEndMethodsOnFailMaxRetries = Config.<Integer>getValue(ConfigValues.RepeatEndMethodsOnFailMaxRetries);
    initCommandExecutor();
    schedulerUtil.scheduleAFixedDelayJob(this, "invokeCallbackMethods", new Class[] {}, new Object[] {}, pollingRate, pollingRate, TimeUnit.SECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    pollingRate = Config.<Long>getValue(ConfigValues.AsyncCommandPollingLoopInSeconds);
    repeatEndMethodsOnFailMaxRetries = Config.<Integer>getValue(ConfigValues.RepeatEndMethodsOnFailMaxRetries);
    initCommandExecutor();
    executor.scheduleWithFixedDelay(this::invokeCallbackMethods, pollingRate, pollingRate, TimeUnit.SECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    Iterator<Entry<Guid, CallbackTiming>> iterator = commandsRepository.getCallbacksTiming().entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CallbackTiming> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CallbackTiming callbackTiming = entry.getValue();
        CommandEntity commandEntity = commandsRepository.getCommandEntity(cmdId);
        CorrelationIdTracker.setCorrelationId(commandEntity != null ? commandEntity.getCommandParameters().getCorrelationId() : null);
        if (commandEntity != null && updateCommandWaitingForEvent(commandEntity, callbackTiming)) {
            continue;
        }
        // Decrement counter; execute if it reaches 0
        callbackTiming.setRemainingDelay(callbackTiming.getRemainingDelay() - pollingRate);
        if (callbackTiming.getRemainingDelay() > 0) {
            continue;
        }
        CommandCallback callback = callbackTiming.getCallback();
        CommandStatus status = commandsRepository.getCommandStatus(cmdId);
        boolean runCallbackAgain = false;
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                case SUCCEEDED:
                    runCallbackAgain = endCallback(cmdId, callback, status);
                    break;
                case ACTIVE:
                    if (commandEntity != null && commandEntity.isExecuted()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                case EXECUTION_FAILED:
                    if (callback.pollOnExecutionFailed()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if ((CommandStatus.FAILED == status || (CommandStatus.SUCCEEDED == status && !errorInCallback)) && !runCallbackAgain) {
                commandsRepository.updateCallbackNotified(cmdId);
                iterator.remove();
                CommandEntity cmdEntity = commandsRepository.getCommandEntity(entry.getKey());
                if (cmdEntity != null) {
                    // When a child finishes, its parent's callback should execute shortly thereafter
                    CallbackTiming rootCmdContainer = commandsRepository.getCallbackTiming(cmdEntity.getRootCommandId());
                    if (rootCmdContainer != null) {
                        rootCmdContainer.setInitialDelay(pollingRate);
                        rootCmdContainer.setRemainingDelay(pollingRate);
                    }
                }
            } else if (status != commandsRepository.getCommandStatus(cmdId)) {
                callbackTiming.setInitialDelay(pollingRate);
                callbackTiming.setRemainingDelay(pollingRate);
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                callbackTiming.setInitialDelay(Math.min(maxDelay, callbackTiming.getInitialDelay() * 2));
                callbackTiming.setRemainingDelay(callbackTiming.getInitialDelay());
            }
        }
    }
    CorrelationIdTracker.setCorrelationId(null);
    commandsRepository.markExpiredCommandsAsFailure();
}
#method_after
private void invokeCallbackMethods() {
    try {
        invokeCallbackMethodsImpl();
    } catch (Throwable t) {
        log.error("Exception in invokeCallbackMethods: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (isInServerRebootTimeout()) {
        return;
    }
    if (cachedVds.getStatus() != VDSStatus.Down) {
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting();
            } else {
                saveToDb = false;
            }
            unrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                List<VmDynamic> vmsRunningOnVds = vmDynamicDao.getAllRunningForVds(getVdsId());
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVmsToUnknown(vmsRunningOnVds);
                    // we want to try to restart VMs with lease ~20 sec after they switch to unknown
                    int skippedIterationsBeforeFirstTry = Config.<Integer>getValue(ConfigValues.NumberVdsRefreshesBeforeTryToStartUnknownVms);
                    autoRestartUnknownVmsIteration = 0 - skippedIterationsBeforeFirstTry;
                    logHostFailToRespond(ex);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    saveToDb = false;
                }
                restartVmsWithLeaseIfNeeded(vmsRunningOnVds);
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#method_after
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (isInServerRebootTimeout()) {
        log.warn("Ignoring communication error for host '{}', because reboot timeout hasn't passed: {}", cachedVds.getHostName(), ex.getMessage());
        log.debug("Exception", ex);
        return;
    }
    if (cachedVds.getStatus() != VDSStatus.Down) {
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting();
            } else {
                saveToDb = false;
            }
            unrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                List<VmDynamic> vmsRunningOnVds = vmDynamicDao.getAllRunningForVds(getVdsId());
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVmsToUnknown(vmsRunningOnVds);
                    // we want to try to restart VMs with lease ~20 sec after they switch to unknown
                    int skippedIterationsBeforeFirstTry = Config.<Integer>getValue(ConfigValues.NumberVdsRefreshesBeforeTryToStartUnknownVms);
                    autoRestartUnknownVmsIteration = 0 - skippedIterationsBeforeFirstTry;
                    logHostFailToRespond(ex);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    saveToDb = false;
                }
                restartVmsWithLeaseIfNeeded(vmsRunningOnVds);
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("SourceIP", StringUtils.isEmpty(sourceIp) ? UNKNOWN : sourceIp);
    return getSucceeded() ? AuditLogType.USER_VDC_LOGOUT : AuditLogType.USER_VDC_LOGOUT_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("SessionID", StringUtils.isEmpty(sessionId) ? UNKNOWN : sessionId);
    addCustomValue("SourceIP", StringUtils.isEmpty(sourceIp) ? UNKNOWN : sourceIp);
    return getSucceeded() ? AuditLogType.USER_VDC_LOGOUT : AuditLogType.USER_VDC_LOGOUT_FAILED;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId());
    if (profile == null) {
        setSucceeded(false);
    } else {
        sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId());
        sessionDataContainer.setSessionValid(getParameters().getSessionId(), false);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId());
    sessionId = getParameters().getSessionId();
    sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId());
    if (profile == null) {
        setSucceeded(false);
    } else {
        sessionDataContainer.setSessionValid(getParameters().getSessionId(), false);
        setSucceeded(true);
    }
}
#end_block

#method_before
public void refresh() {
    _vdcOptionCache.clear();
    List<VdcOption> list = getVdcOptionDao().getAll();
    list = moveDependentToEnd(list);
    for (VdcOption option : list) {
        try {
            if (!_vdcOptionCache.containsKey(option.getOptionName()) || !_vdcOptionCache.get(option.getOptionName()).containsKey(option.getVersion()) || isReloadable(option.getOptionName())) {
                updateOption(option);
            }
        } catch (NoSuchFieldException e) {
            log.error("Not refreshing field '{}': does not exist in class {}.", option.getOptionName(), ConfigValues.class.getSimpleName());
        }
    }
}
#method_after
public void refresh() {
    _vdcOptionCache.clear();
    List<VdcOption> list = moveDependentToEnd(getVdcOptionDao().getAll());
    for (VdcOption option : list) {
        try {
            if (!_vdcOptionCache.containsKey(option.getOptionName()) || !_vdcOptionCache.get(option.getOptionName()).containsKey(option.getVersion()) || isReloadable(option.getOptionName())) {
                updateOption(option);
            }
        } catch (NoSuchFieldException e) {
            log.error("Not refreshing field '{}': does not exist in class {}.", option.getOptionName(), ConfigValues.class.getSimpleName());
        }
    }
}
#end_block

#method_before
private List<VdcOption> moveDependentToEnd(List<VdcOption> list) {
    Predicate<VdcOption> isDependent = o -> {
        EnumValue parsed = parseEnumValue(o.getOptionName());
        if (parsed != null) {
            OptionBehaviourAttribute behaviour = parsed.getOptionBehaviour();
            if (behaviour == null) {
                return false;
            }
            return behaviour.behaviour() == ValueDependent;
        }
        return false;
    };
    List<VdcOption> optionsList = list.stream().filter(isDependent.negate()).collect(Collectors.toList());
    optionsList.addAll(list.stream().filter(isDependent).collect(Collectors.toList()));
    return optionsList;
}
#method_after
private List<VdcOption> moveDependentToEnd(List<VdcOption> list) {
    Predicate<VdcOption> isDependent = o -> {
        EnumValue parsed = parseEnumValue(o.getOptionName());
        if (parsed != null) {
            OptionBehaviourAttribute behaviour = parsed.getOptionBehaviour();
            return behaviour != null && behaviour.behaviour() == ValueDependent;
        }
        return false;
    };
    List<VdcOption> optionsList = list.stream().filter(isDependent.negate()).collect(Collectors.toList());
    optionsList.addAll(list.stream().filter(isDependent).collect(Collectors.toList()));
    return optionsList;
}
#end_block

#method_before
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getCreateOrUpdateBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    ipConfigurationCompleter.fillInUnsetIpConfigs(getParameters().getNetworkAttachments());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
}
#method_after
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getCreateOrUpdateBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    ipConfigurationCompleter.fillInUnsetIpConfigs(getParameters().getNetworkAttachments());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap(), getStoragePoolId());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap(), getStoragePoolId());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
}
#end_block

#method_before
private NetworkCluster findCurrentDefaultRouteNetworkForCluster() {
    List<NetworkCluster> allForCluster = networkClusterDao.getAllForCluster(getClusterId());
    return allForCluster.stream().filter(NetworkCluster::isDefaultRoute).findFirst().get();
}
#method_after
private NetworkCluster findCurrentDefaultRouteNetworkForCluster() {
    List<NetworkCluster> allForCluster = networkClusterDao.getAllForCluster(getClusterId());
    return allForCluster.stream().filter(NetworkCluster::isDefaultRoute).findFirst().orElse(null);
}
#end_block

#method_before
@Override
public void onBind() {
    super.onBind();
    registerHandler(((ViewDef) getView()).getCloseButton().addClickHandler(e -> RevealOverlayContentEvent.fire(this, new RevealOverlayContentEvent(null))));
}
#method_after
@Override
public void onBind() {
    super.onBind();
    registerHandler(getView().getCloseButton().addClickHandler(e -> RevealOverlayContentEvent.fire(this, new RevealOverlayContentEvent(null))));
}
#end_block

#method_before
public void init(VDS vds) {
    currentVdsId = vds.getId();
    setmIrsPort(vds.getPort());
    privatemCurrentIrsHost = vds.getHostName();
}
#method_after
@PostConstruct
public void init() {
    int storagePoolRefreshTime = Config.<Integer>getValue(ConfigValues.StoragePoolRefreshTimeInSeconds);
    storagePoolRefreshJob = schedulerService.scheduleWithFixedDelay(this::updatingTimerElapsed, storagePoolRefreshTime, storagePoolRefreshTime, TimeUnit.SECONDS);
    domainRecoverOnHostJob = schedulerService.scheduleWithFixedDelay(this::hostsStorageConnectionsAndPoolMetadataRefresh, Config.<Integer>getValue(ConfigValues.HostStorageConnectionAndPoolRefreshTimeInSeconds), storagePoolRefreshTime, TimeUnit.SECONDS);
}
#end_block

#method_before
@OnTimerMethodAnnotation("updatingTimerElapsed")
public void updatingTimerElapsed() {
    runInControlledConcurrency(() -> {
        try {
            if (!_disposed) {
                StoragePool storagePool = storagePoolDao.get(_storagePoolId);
                if (storagePool != null) {
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (vdsDao.getAllForStoragePoolAndStatuses(_storagePoolId, StoragePoolDomainHelper.vdsDomainsActiveMonitoringStatus).isEmpty()) {
                        storagePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StorageConstants.monitoredDomainStatuses, StorageDomainStatus.Unknown, "no reporting hosts");
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        proceedStoragePoolStats(storagePool);
                    }
                }
            }
        } catch (Exception ignore) {
        }
    });
}
#method_after
public void updatingTimerElapsed() {
    runInControlledConcurrency(() -> {
        try {
            if (!_disposed) {
                StoragePool storagePool = storagePoolDao.get(storagePoolId);
                if (storagePool != null) {
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (vdsDao.getAllForStoragePoolAndStatuses(storagePoolId, StoragePoolDomainHelper.vdsDomainsActiveMonitoringStatus).isEmpty()) {
                        storagePoolDomainHelper.updateApplicablePoolDomainsStatuses(storagePoolId, StorageConstants.monitoredDomainStatuses, StorageDomainStatus.Unknown, "no reporting hosts");
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        proceedStoragePoolStats(storagePool);
                    }
                }
            }
        } catch (Exception ignore) {
        }
    });
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = currentVdsId;
    if (curVdsId != null) {
        result = resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) resourceManager.runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        storagePoolDao.updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = storageDomainDao.getAllForStoragePool(_storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = resourceManager.runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<>();
        List<StorageDomain> storageDomainsToSync = data.getValue().stream().peek(storageDomain -> domainsInVds.add(storageDomain.getId())).filter(storageDomain -> proceedStorageDomain(storageDomain, masterVersion, storagePool)).collect(Collectors.toList());
        if (!storageDomainsToSync.isEmpty()) {
            getEventListener().syncStorageDomainsLuns(getCurrentVdsId(), storageDomainsToSync.stream().map(StorageDomain::getId).collect(Collectors.toList()));
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                storagePoolIsoMapDao.remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
    domainsInMaintenanceCheck(domainsInDb, storagePool);
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = currentVdsId;
    if (curVdsId != null) {
        result = resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                updateStoragePoolStatus(storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                updateStoragePoolStatus(storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) resourceManager.runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        storagePoolDao.updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = storageDomainDao.getAllForStoragePool(storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = resourceManager.runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<>();
        List<StorageDomain> storageDomainsToSync = data.getValue().stream().peek(storageDomain -> domainsInVds.add(storageDomain.getId())).filter(storageDomain -> proceedStorageDomain(storageDomain, masterVersion, storagePool)).collect(Collectors.toList());
        if (!storageDomainsToSync.isEmpty()) {
            getEventListener().syncStorageDomainsLuns(getCurrentVdsId(), storageDomainsToSync.stream().map(StorageDomain::getId).collect(Collectors.toList()));
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                storagePoolIsoMapDao.remove(new StoragePoolIsoMapId(domainInDb.getId(), storagePoolId));
            }
        }
    }
    domainsInMaintenanceCheck(domainsInDb, storagePool);
}
#end_block

#method_before
public void queueDomainMaintenanceCheck(final StorageDomain domain, final StoragePool pool) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domain.getId(), null, EventType.DOMAINFAILOVER, ""), () -> {
        Collection<Guid> vdsConnectedToPool = getVdsConnectedToPool(_storagePoolId);
        Set<Guid> vdsDomInMaintenance = _domainsInMaintenance.get(domain.getId());
        if (vdsConnectedToPool.isEmpty() || (vdsDomInMaintenance != null && vdsDomInMaintenance.containsAll(vdsConnectedToPool))) {
            log.info("Moving domain '{}' to maintenance", domain.getId());
            storagePoolIsoMapDao.updateStatus(domain.getStoragePoolIsoMapData().getId(), StorageDomainStatus.Maintenance);
            AuditLogable logable = new AuditLogableImpl();
            logable.setStorageDomainId(domain.getId());
            logable.setStorageDomainName(domain.getName());
            logable.setStoragePoolId(pool.getId());
            logable.setStoragePoolName(pool.getName());
            auditLogDirector.log(logable, AuditLogType.STORAGE_DOMAIN_MOVED_TO_MAINTENANCE);
        }
        return null;
    });
}
#method_after
public void queueDomainMaintenanceCheck(final StorageDomain domain, final StoragePool pool) {
    getEventQueue().submitEventAsync(new Event(storagePoolId, domain.getId(), null, EventType.DOMAINFAILOVER, ""), () -> {
        Collection<Guid> vdsConnectedToPool = getVdsConnectedToPool(storagePoolId);
        Set<Guid> vdsDomInMaintenance = _domainsInMaintenance.get(domain.getId());
        if (vdsConnectedToPool.isEmpty() || (vdsDomInMaintenance != null && vdsDomInMaintenance.containsAll(vdsConnectedToPool))) {
            log.info("Moving domain '{}' to maintenance", domain.getId());
            storagePoolIsoMapDao.updateStatus(domain.getStoragePoolIsoMapData().getId(), StorageDomainStatus.Maintenance);
            AuditLogable logable = new AuditLogableImpl();
            logable.setStorageDomainId(domain.getId());
            logable.setStorageDomainName(domain.getName());
            logable.setStoragePoolId(pool.getId());
            logable.setStoragePoolName(pool.getName());
            auditLogDirector.log(logable, AuditLogType.STORAGE_DOMAIN_MOVED_TO_MAINTENANCE);
        }
        return null;
    });
}
#end_block

#method_before
private boolean proceedStorageDomain(StorageDomain domainFromVdsm, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = storageDomainDao.getForStoragePool(domainFromVdsm.getId(), _storagePoolId);
    if (storage_domain != null) {
        StorageDomainStatic domainFromDb = storage_domain.getStorageStaticData();
        StoragePoolIsoMap domainPoolMapFromDb = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMapFromDb != null && domainPoolMapFromDb.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((domainFromVdsm.getStorageDomainType() == StorageDomainType.Master) || (domainFromVdsm.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(domainFromVdsm.getStoragePoolId(), domainFromDb, "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getMasterDomainVersion()) {
                reconstructMasterDomainNotInSync(domainFromVdsm.getStoragePoolId(), domainFromDb, "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getMasterDomainVersion(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMapFromDb == null) {
            domainFromVdsm.setStoragePoolId(_storagePoolId);
            storagePoolIsoMapDao.save(domainFromVdsm.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (!domainPoolMapFromDb.getStatus().isStorageDomainInProcess() && domainPoolMapFromDb.getStatus() != domainFromVdsm.getStatus()) {
            if (domainPoolMapFromDb.getStatus() != StorageDomainStatus.Inactive && domainFromVdsm.getStatus() != StorageDomainStatus.Inactive) {
                storagePoolIsoMapDao.update(domainFromVdsm.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (domainFromVdsm.getStatus() != null && domainFromVdsm.getStatus() == StorageDomainStatus.Inactive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = storagePoolDao.get(domainPoolMapFromDb.getStoragePoolId());
                if (pool != null) {
                    storagePoolDao.updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMapFromDb.getStatus() != StorageDomainStatus.Inactive && domainFromVdsm.getStatus() == StorageDomainStatus.Active)) {
            storageDomainDynamicDao.update(domainFromVdsm.getStorageDynamicData());
            if (domainFromVdsm.getAvailableDiskSize() != null && domainFromVdsm.getUsedDiskSize() != null) {
                double freePercent = domainFromVdsm.getStorageDynamicData().getfreeDiskPercent();
                AuditLogType type = AuditLogType.UNASSIGNED;
                Integer freeDiskInGB = domainFromVdsm.getStorageDynamicData().getAvailableDiskSize();
                if (freeDiskInGB != null) {
                    if (freePercent < domainFromDb.getWarningLowSpaceIndicator()) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                    if (freeDiskInGB < domainFromDb.getCriticalSpaceActionBlocker()) {
                        // Note, if both conditions are met, only IRS_DISK_SPACE_LOW_ERROR will be shown
                        type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogable logable = new AuditLogableImpl();
                    logable.setStorageDomainName(domainFromDb.getStorageName());
                    logable.addCustomValue("DiskSpace", domainFromVdsm.getAvailableDiskSize().toString());
                    domainFromVdsm.setStorageName(domainFromDb.getStorageName());
                    auditLogDirector.log(logable, type);
                }
            }
            Set<EngineError> alerts = domainFromVdsm.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogable logable = new AuditLogableImpl();
                logable.setStorageDomainName(domainFromDb.getStorageName());
                domainFromVdsm.setStorageName(domainFromDb.getStorageName());
                for (EngineError alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            auditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            auditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.error("Unrecognized alert for domain {}(id = {}): {}", domainFromVdsm.getStorageName(), domainFromVdsm.getId(), alert);
                            break;
                    }
                }
            }
        }
        // Block domains should have their LUNs synchronized and updated in the DB.
        if (statusChanged && domainFromVdsm.getStatus() == StorageDomainStatus.Active && storage_domain.getStorageType().isBlockDomain()) {
            return true;
        }
    } else {
        log.debug("The domain with id '{}' was not found in DB", domainFromVdsm.getId());
    }
    return false;
}
#method_after
private boolean proceedStorageDomain(StorageDomain domainFromVdsm, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = storageDomainDao.getForStoragePool(domainFromVdsm.getId(), storagePoolId);
    if (storage_domain != null) {
        StorageDomainStatic domainFromDb = storage_domain.getStorageStaticData();
        StoragePoolIsoMap domainPoolMapFromDb = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMapFromDb != null && domainPoolMapFromDb.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((domainFromVdsm.getStorageDomainType() == StorageDomainType.Master) || (domainFromVdsm.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(domainFromVdsm.getStoragePoolId(), domainFromDb, "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getMasterDomainVersion()) {
                reconstructMasterDomainNotInSync(domainFromVdsm.getStoragePoolId(), domainFromDb, "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getMasterDomainVersion(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMapFromDb == null) {
            domainFromVdsm.setStoragePoolId(storagePoolId);
            storagePoolIsoMapDao.save(domainFromVdsm.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (!domainPoolMapFromDb.getStatus().isStorageDomainInProcess() && domainPoolMapFromDb.getStatus() != domainFromVdsm.getStatus()) {
            if (domainPoolMapFromDb.getStatus() != StorageDomainStatus.Inactive && domainFromVdsm.getStatus() != StorageDomainStatus.Inactive) {
                storagePoolIsoMapDao.update(domainFromVdsm.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (domainFromVdsm.getStatus() != null && domainFromVdsm.getStatus() == StorageDomainStatus.Inactive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = storagePoolDao.get(domainPoolMapFromDb.getStoragePoolId());
                if (pool != null) {
                    storagePoolDao.updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMapFromDb.getStatus() != StorageDomainStatus.Inactive && domainFromVdsm.getStatus() == StorageDomainStatus.Active)) {
            storageDomainDynamicDao.update(domainFromVdsm.getStorageDynamicData());
            if (domainFromVdsm.getAvailableDiskSize() != null && domainFromVdsm.getUsedDiskSize() != null) {
                double freePercent = domainFromVdsm.getStorageDynamicData().getfreeDiskPercent();
                AuditLogType type = AuditLogType.UNASSIGNED;
                Integer freeDiskInGB = domainFromVdsm.getStorageDynamicData().getAvailableDiskSize();
                if (freeDiskInGB != null) {
                    if (freePercent < domainFromDb.getWarningLowSpaceIndicator()) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                    if (freeDiskInGB < domainFromDb.getCriticalSpaceActionBlocker()) {
                        // Note, if both conditions are met, only IRS_DISK_SPACE_LOW_ERROR will be shown
                        type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogable logable = new AuditLogableImpl();
                    logable.setStorageDomainName(domainFromDb.getStorageName());
                    logable.addCustomValue("DiskSpace", domainFromVdsm.getAvailableDiskSize().toString());
                    domainFromVdsm.setStorageName(domainFromDb.getStorageName());
                    auditLogDirector.log(logable, type);
                }
            }
            Set<EngineError> alerts = domainFromVdsm.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogable logable = new AuditLogableImpl();
                logable.setStorageDomainName(domainFromDb.getStorageName());
                domainFromVdsm.setStorageName(domainFromDb.getStorageName());
                for (EngineError alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            auditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            auditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.error("Unrecognized alert for domain {}(id = {}): {}", domainFromVdsm.getStorageName(), domainFromVdsm.getId(), alert);
                            break;
                    }
                }
            }
        }
        // Block domains should have their LUNs synchronized and updated in the DB.
        if (statusChanged && domainFromVdsm.getStatus() == StorageDomainStatus.Active && storage_domain.getStorageType().isBlockDomain()) {
            return true;
        }
    } else {
        log.debug("The domain with id '{}' was not found in DB", domainFromVdsm.getId());
    }
    return false;
}
#end_block

#method_before
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final StorageDomainStatic masterDomain, final String exceptionMessage, final String logMessage) {
    getEventQueue().submitEventSync(new Event(_storagePoolId, masterDomain.getId(), null, EventType.RECONSTRUCT, "Reconstruct caused by failure to execute spm command"), () -> {
        log.warn(logMessage);
        AuditLogable logable = new AuditLogableImpl();
        logable.setVdsId(currentVdsId);
        logable.setVdsName(vdsStaticDao.get(currentVdsId).getName());
        logable.setStorageDomainId(masterDomain.getId());
        logable.setStorageDomainName(masterDomain.getName());
        auditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
        return getEventListener().masterDomainNotOperational(masterDomain.getId(), storagePoolId, false, true);
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#method_after
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final StorageDomainStatic masterDomain, final String exceptionMessage, final String logMessage) {
    getEventQueue().submitEventSync(new Event(this.storagePoolId, masterDomain.getId(), null, EventType.RECONSTRUCT, "Reconstruct caused by failure to execute spm command"), () -> {
        log.warn(logMessage);
        AuditLogable logable = new AuditLogableImpl();
        logable.setVdsId(currentVdsId);
        logable.setVdsName(vdsStaticDao.get(currentVdsId).getName());
        logable.setStorageDomainId(masterDomain.getId());
        logable.setStorageDomainName(masterDomain.getName());
        auditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
        return getEventListener().masterDomainNotOperational(masterDomain.getId(), storagePoolId, false, true);
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#end_block

#method_before
public boolean failover() {
    Guid vdsId = currentVdsId;
    nullifyInternalProxies();
    boolean performFailover = false;
    if (vdsId != null) {
        try {
            VDSReturnValue statusResult = resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vdsId, _storagePoolId));
            if (statusResult != null && statusResult.getSucceeded() && (((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.SPM || ((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.Contend)) {
                performFailover = resourceManager.runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsId, _storagePoolId)).getSucceeded();
            } else {
                performFailover = true;
            }
        } catch (Exception ex) {
            // try to failover to another host if failed to get spm
            // status or stop spm
            // (in case currentVdsId has wrong id for some reason)
            log.error("Could not get spm status on host '{}' for spmStop: {}", vdsId, ex.getMessage());
            log.debug("Exception", ex);
            performFailover = true;
        }
    }
    if (performFailover) {
        log.info("Irs placed on server '{}' failed. Proceed Failover", vdsId);
        triedVdssList.add(vdsId);
        return true;
    } else {
        log.error("IRS failover failed - can't allocate vds server");
        return false;
    }
}
#method_after
public boolean failover() {
    Guid vdsId = currentVdsId;
    nullifyInternalProxies();
    boolean performFailover = false;
    if (vdsId != null) {
        try {
            VDSReturnValue statusResult = resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vdsId, storagePoolId));
            if (statusResult != null && statusResult.getSucceeded() && (((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.SPM || ((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.Contend)) {
                performFailover = resourceManager.runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsId, storagePoolId)).getSucceeded();
            } else {
                performFailover = true;
            }
        } catch (Exception ex) {
            // try to failover to another host if failed to get spm
            // status or stop spm
            // (in case currentVdsId has wrong id for some reason)
            log.error("Could not get spm status on host '{}' for spmStop: {}", vdsId, ex.getMessage());
            log.debug("Exception", ex);
            performFailover = true;
        }
    }
    if (performFailover) {
        log.info("Irs placed on server '{}' failed. Proceed Failover", vdsId);
        triedVdssList.add(vdsId);
        return true;
    } else {
        log.error("IRS failover failed - can't allocate vds server");
        return false;
    }
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = storagePoolDao.get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, () -> getHostFromVds());
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = storagePoolDao.get(storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, () -> getHostFromVds());
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (isMasterDomainUp()) {
                    getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent: {}", exp.getMessage());
                log.debug("Exception", exp);
            }
        }

        private boolean isMasterDomainUp() {
            return storageDomainDao.getStorageDomains(_storagePoolId, StorageDomainType.Master).stream().anyMatch(d -> d.getStatus() == StorageDomainStatus.Active || d.getStatus() == StorageDomainStatus.Unknown);
        }
    });
}
#method_after
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (isMasterDomainUp()) {
                    getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent: {}", exp.getMessage());
                log.debug("Exception", exp);
            }
        }

        private boolean isMasterDomainUp() {
            return storageDomainDao.getStorageDomains(storagePoolId, StorageDomainType.Master).stream().anyMatch(d -> d.getStatus() == StorageDomainStatus.Active || d.getStatus() == StorageDomainStatus.Unknown);
        }
    });
}
#end_block

#method_before
private void connectStoragePool(VDS vds, StoragePool storagePool) {
    Guid masterDomainId = storageDomainDao.getMasterStorageDomainIdForPool(_storagePoolId);
    List<StoragePoolIsoMap> storagePoolIsoMap = storagePoolIsoMapDao.getAllForStoragePool(_storagePoolId);
    VDSReturnValue connectResult = resourceManager.runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomainId, storagePoolIsoMap));
    if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
        throw connectResult.getExceptionObject();
    } else if (!connectResult.getSucceeded()) {
        // failover
        throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
    }
}
#method_after
private void connectStoragePool(VDS vds, StoragePool storagePool) {
    Guid masterDomainId = storageDomainDao.getMasterStorageDomainIdForPool(storagePoolId);
    List<StoragePoolIsoMap> storagePoolIsoMap = storagePoolIsoMapDao.getAllForStoragePool(storagePoolId);
    VDSReturnValue connectResult = resourceManager.runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomainId, storagePoolIsoMap));
    if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
        throw connectResult.getExceptionObject();
    } else if (!connectResult.getSucceeded()) {
        // failover
        throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
    }
}
#end_block

#method_before
private String getHostFromVds() {
    String returnValue = null;
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    StoragePool storagePool = storagePoolDao.get(_storagePoolId);
    if (storagePool == null) {
        log.info("hostFromVds::Finished elect spm, storage pool '{}' was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    currentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = vdsDao.get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        triedVdssList.add(selectedVdsId);
        currentVdsId = selectedVds.getId();
        connectStoragePool(selectedVds, storagePool);
        VDSReturnValue returnValueFromVds = resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        boolean ignoreSpmStatusResult = returnValueFromVds.getVdsError() != null && returnValueFromVds.getVdsError().getCode() == EngineError.InquireNotSupportedError;
        if (spmStatus != null || ignoreSpmStatusResult) {
            boolean performedPoolConnect = false;
            log.info("hostFromVds::selectedVds - '{}', spmStatus '{}', storage pool '{}', storage pool version '{}'", selectedVds.getName(), spmStatus != null ? spmStatus.getSpmStatus() : "unknown", storagePool.getName(), storagePool.getCompatibilityVersion());
            if (ignoreSpmStatusResult) {
                spmStatus = startSpm(storagePool, selectedVds, DEFAULT_PREV_ID, DEFAULT_LVER, DEFAULT_PREV_ID);
            } else {
                if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                    connectStoragePool(selectedVds, storagePool);
                    performedPoolConnect = true;
                    // refresh spmStatus result
                    spmStatus = (SpmStatusResult) resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                    log.info("hostFromVds::Connected host to pool - selectedVds - {}, spmStatus {}, storage pool {}", selectedVds.getName(), spmStatus.getSpmStatus(), storagePool.getName());
                }
                RefObject<VDS> tempRefObject = new RefObject<>(selectedVds);
                spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
                selectedVds = tempRefObject.argvalue;
            }
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                currentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                resourceManager.runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.info("hostFromVds::selectedVds - '{}', spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String getHostFromVds() {
    String returnValue = null;
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    StoragePool storagePool = storagePoolDao.get(storagePoolId);
    if (storagePool == null) {
        log.info("hostFromVds::Finished elect spm, storage pool '{}' was removed", storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    currentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            getEventListener().storagePoolStatusChange(storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = vdsDao.get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        triedVdssList.add(selectedVdsId);
        currentVdsId = selectedVds.getId();
        connectStoragePool(selectedVds, storagePool);
        VDSReturnValue returnValueFromVds = resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        boolean ignoreSpmStatusResult = returnValueFromVds.getVdsError() != null && returnValueFromVds.getVdsError().getCode() == EngineError.InquireNotSupportedError;
        if (spmStatus != null || ignoreSpmStatusResult) {
            boolean performedPoolConnect = false;
            log.info("hostFromVds::selectedVds - '{}', spmStatus '{}', storage pool '{}', storage pool version '{}'", selectedVds.getName(), spmStatus != null ? spmStatus.getSpmStatus() : "unknown", storagePool.getName(), storagePool.getCompatibilityVersion());
            if (ignoreSpmStatusResult) {
                spmStatus = startSpm(storagePool, selectedVds, DEFAULT_PREV_ID, DEFAULT_LVER, DEFAULT_PREV_ID);
            } else {
                if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                    connectStoragePool(selectedVds, storagePool);
                    performedPoolConnect = true;
                    // refresh spmStatus result
                    spmStatus = (SpmStatusResult) resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), storagePoolId)).getReturnValue();
                    log.info("hostFromVds::Connected host to pool - selectedVds - {}, spmStatus {}, storage pool {}", selectedVds.getName(), spmStatus.getSpmStatus(), storagePool.getName());
                }
                RefObject<VDS> tempRefObject = new RefObject<>(selectedVds);
                spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
                selectedVds = tempRefObject.argvalue;
            }
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                currentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                resourceManager.runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.info("hostFromVds::selectedVds - '{}', spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private List<VDS> getPrioritizedVdsInPool() {
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = vdsDao.getListForSpmSelection(_storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<>();
    Guid preferredHost = getIrsProxyManager().getProxy(_storagePoolId).getPreferredHostId();
    getIrsProxyManager().getProxy(_storagePoolId).setPreferredHostId(null);
    for (VDS vds : allVds) {
        if (!triedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            if (vds.getId().equals(preferredHost)) {
                vdsRelevantForSpmSelection.add(0, vds);
            } else {
                vdsRelevantForSpmSelection.add(vds);
            }
        }
    }
    return vdsRelevantForSpmSelection;
}
#method_after
private List<VDS> getPrioritizedVdsInPool() {
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = vdsDao.getListForSpmSelection(storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<>();
    Guid preferredHost = getIrsProxyManager().getProxy(storagePoolId).getPreferredHostId();
    getIrsProxyManager().getProxy(storagePoolId).setPreferredHostId(null);
    for (VDS vds : allVds) {
        if (!triedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            if (vds.getId().equals(preferredHost)) {
                vdsRelevantForSpmSelection.add(0, vds);
            } else {
                vdsRelevantForSpmSelection.add(vds);
            }
        }
    }
    return vdsRelevantForSpmSelection;
}
#end_block

#method_before
private boolean wasVdsManuallyFenced(int spmId) {
    VdsSpmIdMap map = vdsSpmIdMapDao.get(_storagePoolId, spmId);
    return map != null && map.getId().equals(getFencedIrs());
}
#method_after
private boolean wasVdsManuallyFenced(int spmId) {
    VdsSpmIdMap map = vdsSpmIdMapDao.get(storagePoolId, spmId);
    return map != null && map.getId().equals(getFencedIrs());
}
#end_block

#method_before
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1 && !wasVdsManuallyFenced(spmStatus.getSpmId())) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.info("Found spm host '{}', host name: '{}', according to spmId: '{}'.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = vdsDao.getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = vdsDao.get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.info("SpmStatus on vds '{}': '{}'", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus());
                    // intentionally unreachable code
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (!spmVdsId.equals(selectedVds.argvalue.getId()) && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.info("Using old spm server: '{}', no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM '{}', but is not up.", spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.error("SPM Init: could not find reported vds or not up - pool: '{}' vds_spm_id: '{}'", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            VdsSpmIdMap map = vdsSpmIdMapDao.get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = vdsDao.get(map.getId());
                if (vdsToFenceObject != null) {
                    log.info("SPM selection - vds seems as spm '{}'", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = resourceManager.runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            spmStatus = startSpm(storagePool, selectedVds.argvalue, spmStatus.getSpmId(), spmStatus.getSpmLVER(), vdsSpmIdToFence);
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1 && !wasVdsManuallyFenced(spmStatus.getSpmId())) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.info("Found spm host '{}', host name: '{}', according to spmId: '{}'.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = vdsDao.getAllForStoragePoolAndStatus(storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = vdsDao.get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) resourceManager.runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, storagePoolId)).getReturnValue();
                    log.info("SpmStatus on vds '{}': '{}'", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus());
                    // intentionally unreachable code
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (!spmVdsId.equals(selectedVds.argvalue.getId()) && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.info("Using old spm server: '{}', no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM '{}', but is not up.", spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.error("SPM Init: could not find reported vds or not up - pool: '{}' vds_spm_id: '{}'", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            VdsSpmIdMap map = vdsSpmIdMapDao.get(storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = vdsDao.get(map.getId());
                if (vdsToFenceObject != null) {
                    log.info("SPM selection - vds seems as spm '{}'", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = resourceManager.runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            spmStatus = startSpm(storagePool, selectedVds.argvalue, spmStatus.getSpmId(), spmStatus.getSpmLVER(), vdsSpmIdToFence);
        }
    }
    return spmStatus;
}
#end_block

#method_before
private SpmStatusResult startSpm(final StoragePool storagePool, VDS selectedVds, int prevId, String lver, int vdsSpmIdToFence) {
    storagePool.setStatus(StoragePoolStatus.Contend);
    storagePool.setSpmVdsId(selectedVds.getId());
    TransactionSupport.executeInNewTransaction(() -> {
        storagePoolDao.update(storagePool);
        return null;
    });
    log.info("starting spm on vds '{}', storage pool '{}', prevId '{}', LVER '{}'", selectedVds.getName(), storagePool.getName(), prevId, lver);
    SpmStatusResult spmStatus = (SpmStatusResult) resourceManager.runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.getId(), _storagePoolId, prevId, lver, storagePool.getRecoveryMode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
    if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
        getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        if (spmStatus != null) {
            TransactionSupport.executeInNewTransaction(() -> {
                StoragePool pool = storagePoolDao.get(storagePool.getId());
                pool.setSpmVdsId(null);
                storagePoolDao.update(pool);
                return null;
            });
        }
        throw new IrsSpmStartFailedException();
    }
    return spmStatus;
}
#method_after
private SpmStatusResult startSpm(final StoragePool storagePool, VDS selectedVds, int prevId, String lver, int vdsSpmIdToFence) {
    storagePool.setStatus(StoragePoolStatus.Contend);
    storagePool.setSpmVdsId(selectedVds.getId());
    TransactionSupport.executeInNewTransaction(() -> {
        storagePoolDao.update(storagePool);
        return null;
    });
    log.info("starting spm on vds '{}', storage pool '{}', prevId '{}', LVER '{}'", selectedVds.getName(), storagePool.getName(), prevId, lver);
    SpmStatusResult spmStatus = (SpmStatusResult) resourceManager.runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.getId(), storagePoolId, prevId, lver, storagePool.getRecoveryMode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
    if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
        getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        if (spmStatus != null) {
            TransactionSupport.executeInNewTransaction(() -> {
                StoragePool pool = storagePoolDao.get(storagePool.getId());
                pool.setSpmVdsId(null);
                storagePoolDao.update(pool);
                return null;
            });
        }
        throw new IrsSpmStartFailedException();
    }
    return spmStatus;
}
#end_block

#method_before
public void resetIrs() {
    nullifyInternalProxies();
    StoragePool storagePool = storagePoolDao.get(_storagePoolId);
    if (storagePool != null) {
        storagePool.setSpmVdsId(null);
        storagePoolDao.update(storagePool);
    }
}
#method_after
public void resetIrs() {
    nullifyInternalProxies();
    StoragePool storagePool = storagePoolDao.get(storagePoolId);
    if (storagePool != null) {
        storagePool.setSpmVdsId(null);
        storagePoolDao.update(storagePool);
    }
}
#end_block

#method_before
public void updateVdsDomainsData(VDS vds, final ArrayList<VDSDomainsData> data) {
    if (!shouldProcessVdsDomainReport(vds)) {
        return;
    }
    StoragePool storagePool = storagePoolDao.get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        Guid vdsId = vds.getId();
        String vdsName = vds.getName();
        try {
            Set<Guid> monitoredDomains = new HashSet<>();
            for (VDSDomainsData tempData : data) {
                monitoredDomains.add(tempData.getDomainId());
            }
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = Collections.emptyMap();
            if (StoragePoolDomainHelper.vdsDomainsActiveMonitoringStatus.contains(vds.getStatus())) {
                domainsProblematicReportInfo = handleMonitoredDomainsForHost(vdsId, vdsName, data, monitoredDomains);
            }
            Set<Guid> domainsInMaintenance = Collections.emptySet();
            if (StoragePoolDomainHelper.vdsDomainsMaintenanceMonitoringStatus.contains(vds.getStatus())) {
                domainsInMaintenance = handleDomainsInMaintenanceForHost(monitoredDomains);
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#method_after
public void updateVdsDomainsData(VDS vds, final ArrayList<VDSDomainsData> data) {
    if (!shouldProcessVdsDomainReport(vds)) {
        return;
    }
    StoragePool storagePool = storagePoolDao.get(storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        Guid vdsId = vds.getId();
        String vdsName = vds.getName();
        try {
            Set<Guid> monitoredDomains = new HashSet<>();
            for (VDSDomainsData tempData : data) {
                monitoredDomains.add(tempData.getDomainId());
            }
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = Collections.emptyMap();
            if (StoragePoolDomainHelper.vdsDomainsActiveMonitoringStatus.contains(vds.getStatus())) {
                domainsProblematicReportInfo = handleMonitoredDomainsForHost(vdsId, vdsName, data, monitoredDomains);
            }
            Set<Guid> domainsInMaintenance = Collections.emptySet();
            if (StoragePoolDomainHelper.vdsDomainsMaintenanceMonitoringStatus.contains(vds.getStatus())) {
                domainsInMaintenance = handleDomainsInMaintenanceForHost(monitoredDomains);
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#end_block

#method_before
private Set<Guid> handleDomainsInMaintenanceForHost(Collection<Guid> monitoredDomains) {
    Set<Guid> domainsInMaintenance = new HashSet<>();
    Set<Guid> maintInPool = new HashSet<>(storageDomainStaticDao.getAllIds(_storagePoolId, StorageDomainStatus.Maintenance));
    maintInPool.addAll(storageDomainStaticDao.getAllIds(_storagePoolId, StorageDomainStatus.PreparingForMaintenance));
    for (Guid tempDomainId : maintInPool) {
        if (!monitoredDomains.contains(tempDomainId)) {
            domainsInMaintenance.add(tempDomainId);
        }
    }
    return domainsInMaintenance;
}
#method_after
private Set<Guid> handleDomainsInMaintenanceForHost(Collection<Guid> monitoredDomains) {
    Set<Guid> domainsInMaintenance = new HashSet<>();
    Set<Guid> maintInPool = new HashSet<>(storageDomainStaticDao.getAllIds(storagePoolId, StorageDomainStatus.Maintenance));
    maintInPool.addAll(storageDomainStaticDao.getAllIds(storagePoolId, StorageDomainStatus.PreparingForMaintenance));
    for (Guid tempDomainId : maintInPool) {
        if (!monitoredDomains.contains(tempDomainId)) {
            domainsInMaintenance.add(tempDomainId);
        }
    }
    return domainsInMaintenance;
}
#end_block

#method_before
private Map<Guid, DomainMonitoringResult> handleMonitoredDomainsForHost(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data, Collection<Guid> monitoredDomains) {
    Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = new HashMap<>();
    // build a list of all domains in pool
    // which are in status Active or Unknown
    Set<Guid> activeDomainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(_storagePoolId, StorageDomainStatus.Active));
    Set<Guid> unknownDomainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
    Set<Guid> inActiveDomainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(_storagePoolId, StorageDomainStatus.Inactive));
    // visible by the host.
    for (Guid tempDomainId : activeDomainsInPool) {
        if (!monitoredDomains.contains(tempDomainId)) {
            domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
        }
    }
    for (Guid tempDomainId : unknownDomainsInPool) {
        if (!monitoredDomains.contains(tempDomainId)) {
            domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
        }
    }
    Collection<Guid> storageDomainsToSync = new LinkedList<>();
    // Unknown domains in pool
    for (VDSDomainsData tempData : data) {
        StorageDomainStatic storageDomain = storageDomainStaticDao.get(tempData.getDomainId());
        if (activeDomainsInPool.contains(tempData.getDomainId()) || unknownDomainsInPool.contains(tempData.getDomainId())) {
            DomainMonitoringResult domainMonitoringResult = analyzeDomainReport(tempData, false);
            if (domainMonitoringResult.invalidAndActual()) {
                domainsProblematicReportInfo.put(tempData.getDomainId(), domainMonitoringResult);
            } else if (domainMonitoringResult.actual() && tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                logDelayedDomain(vdsName, storageDomain.getName(), tempData.getDelay());
            }
        } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && analyzeDomainReport(tempData, false).validAndActual()) {
            log.warn("Storage Domain '{}' was reported by Host '{}' as Active in Pool '{}', moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
            StoragePoolIsoMap map = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
            map.setStatus(StorageDomainStatus.Active);
            storagePoolIsoMapDao.update(map);
            if (storageDomain.getStorageType().isBlockDomain()) {
                storageDomainsToSync.add(storageDomain.getId());
            }
        }
    }
    // For block domains, synchronize LUN details comprising the storage domain with the DB
    if (!storageDomainsToSync.isEmpty()) {
        getEventListener().syncStorageDomainsLuns(vdsId, storageDomainsToSync);
    }
    return domainsProblematicReportInfo;
}
#method_after
private Map<Guid, DomainMonitoringResult> handleMonitoredDomainsForHost(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data, Collection<Guid> monitoredDomains) {
    Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = new HashMap<>();
    // build a list of all domains in pool
    // which are in status Active or Unknown
    Set<Guid> activeDomainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(storagePoolId, StorageDomainStatus.Active));
    Set<Guid> unknownDomainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(storagePoolId, StorageDomainStatus.Unknown));
    Set<Guid> inActiveDomainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(storagePoolId, StorageDomainStatus.Inactive));
    // visible by the host.
    for (Guid tempDomainId : activeDomainsInPool) {
        if (!monitoredDomains.contains(tempDomainId)) {
            domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
        }
    }
    for (Guid tempDomainId : unknownDomainsInPool) {
        if (!monitoredDomains.contains(tempDomainId)) {
            domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
        }
    }
    Collection<Guid> storageDomainsToSync = new LinkedList<>();
    // Unknown domains in pool
    for (VDSDomainsData tempData : data) {
        StorageDomainStatic storageDomain = storageDomainStaticDao.get(tempData.getDomainId());
        if (activeDomainsInPool.contains(tempData.getDomainId()) || unknownDomainsInPool.contains(tempData.getDomainId())) {
            DomainMonitoringResult domainMonitoringResult = analyzeDomainReport(tempData, false);
            if (domainMonitoringResult.invalidAndActual()) {
                domainsProblematicReportInfo.put(tempData.getDomainId(), domainMonitoringResult);
            } else if (domainMonitoringResult.actual() && tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                logDelayedDomain(vdsName, storageDomain.getName(), tempData.getDelay());
            }
        } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && analyzeDomainReport(tempData, false).validAndActual()) {
            log.warn("Storage Domain '{}' was reported by Host '{}' as Active in Pool '{}', moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, storagePoolId);
            StoragePoolIsoMap map = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(tempData.getDomainId(), storagePoolId));
            map.setStatus(StorageDomainStatus.Active);
            storagePoolIsoMapDao.update(map);
            if (storageDomain.getStorageType().isBlockDomain()) {
                storageDomainsToSync.add(storageDomain.getId());
            }
        }
    }
    // For block domains, synchronize LUN details comprising the storage domain with the DB
    if (!storageDomainsToSync.isEmpty()) {
        getEventListener().syncStorageDomainsLuns(vdsId, storageDomainsToSync);
    }
    return domainsProblematicReportInfo;
}
#end_block

#method_before
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Map<Guid, DomainMonitoringResult> domainsInProblem, final Set<Guid> domainsInMaintenance) {
    getEventQueue().submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING, ""), () -> {
        EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
        updateProblematicVdsData(vdsId, vdsName, domainsInProblem);
        updateMaintenanceVdsData(vdsId, vdsName, domainsInMaintenance);
        return result;
    });
}
#method_after
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Map<Guid, DomainMonitoringResult> domainsInProblem, final Set<Guid> domainsInMaintenance) {
    getEventQueue().submitEventSync(new Event(storagePoolId, null, vdsId, EventType.DOMAINMONITORING, ""), () -> {
        EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
        updateProblematicVdsData(vdsId, vdsName, domainsInProblem);
        updateMaintenanceVdsData(vdsId, vdsName, domainsInMaintenance);
        return result;
    });
}
#end_block

#method_before
public List<Guid> obtainDomainsReportedAsProblematic(List<VDSDomainsData> vdsDomainsData) {
    List<Guid> domainsInProblem = new LinkedList<>();
    Set<Guid> domainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(_storagePoolId, StorageDomainStatus.Active));
    domainsInPool.addAll(storageDomainStaticDao.getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
    List<Guid> domainWhichWereSeen = new ArrayList<>();
    for (VDSDomainsData vdsDomainData : vdsDomainsData) {
        if (domainsInPool.contains(vdsDomainData.getDomainId())) {
            if (analyzeDomainReport(vdsDomainData, true).invalidAndActual()) {
                domainsInProblem.add(vdsDomainData.getDomainId());
            }
            domainWhichWereSeen.add(vdsDomainData.getDomainId());
        }
    }
    domainsInPool.removeAll(domainWhichWereSeen);
    if (domainsInPool.size() > 0) {
        for (Guid domainId : domainsInPool) {
            log.error("Domain '{}' is not seen by Host", domainId);
        }
        domainsInProblem.addAll(domainsInPool);
    }
    return domainsInProblem;
}
#method_after
public List<Guid> obtainDomainsReportedAsProblematic(List<VDSDomainsData> vdsDomainsData) {
    List<Guid> domainsInProblem = new LinkedList<>();
    Set<Guid> domainsInPool = new HashSet<>(storageDomainStaticDao.getAllIds(storagePoolId, StorageDomainStatus.Active));
    domainsInPool.addAll(storageDomainStaticDao.getAllIds(storagePoolId, StorageDomainStatus.Unknown));
    List<Guid> domainWhichWereSeen = new ArrayList<>();
    for (VDSDomainsData vdsDomainData : vdsDomainsData) {
        if (domainsInPool.contains(vdsDomainData.getDomainId())) {
            if (analyzeDomainReport(vdsDomainData, true).invalidAndActual()) {
                domainsInProblem.add(vdsDomainData.getDomainId());
            }
            domainWhichWereSeen.add(vdsDomainData.getDomainId());
        }
    }
    domainsInPool.removeAll(domainWhichWereSeen);
    if (domainsInPool.size() > 0) {
        for (Guid domainId : domainsInPool) {
            log.error("Domain '{}' is not seen by Host", domainId);
        }
        domainsInProblem.addAll(domainsInPool);
    }
    return domainsInProblem;
}
#end_block

#method_before
private void updateProblematicVdsData(final Guid vdsId, final String vdsName, Map<Guid, DomainMonitoringResult> problematicDomains) {
    // for all problematic domains
    // update cache of _domainsInProblem
    // and _vdssInProblem and add a new
    // timer for new domains in problem
    boolean newDomainUnreachableByHost = false;
    List<Guid> domainsUnreachableByHost = new LinkedList<>();
    for (Map.Entry<Guid, DomainMonitoringResult> entry : problematicDomains.entrySet()) {
        Guid domainId = entry.getKey();
        DomainMonitoringResult domainMonitoringResult = entry.getValue();
        HashSet<Guid> hostsReportedDomainAsProblematic = _domainsInProblem.get(domainId);
        boolean domainNotFound = domainMonitoringResult == DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        if (domainNotFound) {
            domainsUnreachableByHost.add(domainId);
        }
        if (hostsReportedDomainAsProblematic != null) {
            if (!hostsReportedDomainAsProblematic.contains(vdsId) && domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // existing domains in problem
            updateDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        } else {
            if (domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // new domains in problems
            addDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        }
    }
    if (domainsUnreachableByHost.isEmpty()) {
        Guid clearedReport = clearVdsReportInfoOnUnseenDomain(vdsId);
        if (clearedReport != null) {
            log.info("Host '{}' no longer storage access problem to any relevant domain " + " clearing it's report (report id: '{}')", vdsId, clearedReport);
        }
    } else if (newDomainUnreachableByHost) {
        Guid newReportId = Guid.newGuid();
        log.info("Host '{}' has reported new storage access problem to the following domains '{}'" + " marking it for storage connections and pool metadata refresh (report id: '{}')", vdsId, StringUtils.join(domainsUnreachableByHost, ","), newReportId);
        vdsReportsOnUnseenDomain.put(vdsId, newReportId);
    }
    Set<Guid> notReportedDomainsByHost = new HashSet<>(_domainsInProblem.keySet());
    notReportedDomainsByHost.removeAll(problematicDomains.keySet());
    for (Guid domainId : notReportedDomainsByHost) {
        Set<Guid> vdsForDomain = _domainsInProblem.get(domainId);
        if (vdsForDomain != null && vdsForDomain.contains(vdsId)) {
            domainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#method_after
private void updateProblematicVdsData(final Guid vdsId, final String vdsName, Map<Guid, DomainMonitoringResult> problematicDomains) {
    // for all problematic domains
    // update cache of domainsInProblem
    // and _vdssInProblem and add a new
    // timer for new domains in problem
    boolean newDomainUnreachableByHost = false;
    List<Guid> domainsUnreachableByHost = new LinkedList<>();
    for (Map.Entry<Guid, DomainMonitoringResult> entry : problematicDomains.entrySet()) {
        Guid domainId = entry.getKey();
        DomainMonitoringResult domainMonitoringResult = entry.getValue();
        HashSet<Guid> hostsReportedDomainAsProblematic = domainsInProblem.get(domainId);
        boolean domainNotFound = domainMonitoringResult == DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        if (domainNotFound) {
            domainsUnreachableByHost.add(domainId);
        }
        if (hostsReportedDomainAsProblematic != null) {
            if (!hostsReportedDomainAsProblematic.contains(vdsId) && domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // existing domains in problem
            updateDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        } else {
            if (domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // new domains in problems
            addDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        }
    }
    if (domainsUnreachableByHost.isEmpty()) {
        Guid clearedReport = clearVdsReportInfoOnUnseenDomain(vdsId);
        if (clearedReport != null) {
            log.info("Host '{}' no longer storage access problem to any relevant domain " + " clearing it's report (report id: '{}')", vdsId, clearedReport);
        }
    } else if (newDomainUnreachableByHost) {
        Guid newReportId = Guid.newGuid();
        log.info("Host '{}' has reported new storage access problem to the following domains '{}'" + " marking it for storage connections and pool metadata refresh (report id: '{}')", vdsId, StringUtils.join(domainsUnreachableByHost, ","), newReportId);
        vdsReportsOnUnseenDomain.put(vdsId, newReportId);
    }
    Set<Guid> notReportedDomainsByHost = new HashSet<>(domainsInProblem.keySet());
    notReportedDomainsByHost.removeAll(problematicDomains.keySet());
    for (Guid domainId : notReportedDomainsByHost) {
        Set<Guid> vdsForDomain = domainsInProblem.get(domainId);
        if (vdsForDomain != null && vdsForDomain.contains(vdsId)) {
            domainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#end_block

#method_before
private void domainRecoveredFromProblem(Guid domainId, Guid vdsId, String vdsName) {
    String domainIdTuple = getDomainIdTuple(domainId);
    log.info("Domain '{}' recovered from problem. vds: '{}'", domainIdTuple, vdsName);
    _domainsInProblem.get(domainId).remove(vdsId);
    if (_domainsInProblem.get(domainId).size() == 0) {
        log.info("Domain '{}' has recovered from problem. No active host in the DC is reporting it as" + " problematic, so clearing the domain recovery timer.", domainIdTuple);
        _domainsInProblem.remove(domainId);
        clearTimer(domainId);
    }
}
#method_after
private void domainRecoveredFromProblem(Guid domainId, Guid vdsId, String vdsName) {
    String domainIdTuple = getDomainIdTuple(domainId);
    log.info("Domain '{}' recovered from problem. vds: '{}'", domainIdTuple, vdsName);
    domainsInProblem.get(domainId).remove(vdsId);
    if (domainsInProblem.get(domainId).size() == 0) {
        log.info("Domain '{}' has recovered from problem. No active host in the DC is reporting it as" + " problematic, so clearing the domain recovery timer.", domainIdTuple);
        domainsInProblem.remove(domainId);
        clearTimer(domainId);
    }
}
#end_block

#method_before
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    _domainsInProblem.put(domainId, new HashSet<>(Arrays.asList(vdsId)));
    log.warn("domain '{}' in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFailureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#method_after
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    domainsInProblem.put(domainId, new HashSet<>(Arrays.asList(vdsId)));
    log.warn("domain '{}' in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    ScheduledFuture job = schedulerService.schedule(() -> onTimer(domainId), Config.<Long>getValue(ConfigValues.StorageDomainFailureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    timersMap.put(domainId, job);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer(final Guid domainId) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER, ""), () -> {
        EventResult result = null;
        if (_domainsInProblem.containsKey(domainId)) {
            log.info("starting processDomainRecovery for domain '{}'.", getDomainIdTuple(domainId));
            result = processDomainRecovery(domainId);
        }
        _timers.remove(domainId);
        return result;
    });
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer(final Guid domainId) {
    getEventQueue().submitEventAsync(new Event(storagePoolId, domainId, null, EventType.DOMAINFAILOVER, ""), () -> {
        EventResult result = null;
        if (domainsInProblem.containsKey(domainId)) {
            log.info("starting processDomainRecovery for domain '{}'.", getDomainIdTuple(domainId));
            result = processDomainRecovery(domainId);
        }
        timersMap.remove(domainId);
        return result;
    });
}
#end_block

#method_before
@OnTimerMethodAnnotation("hostsStorageConnectionsAndPoolMetadataRefresh")
public void hostsStorageConnectionsAndPoolMetadataRefresh() {
    Map<Guid, Guid> reportsToHandle = procceedReportsThreatmenet();
    if (reportsToHandle.isEmpty()) {
        return;
    }
    List<Callable<Void>> connectStorageTasks = new ArrayList<>();
    final List<Callable<Void>> refreshStoragePoolTasks = new ArrayList<>();
    final StoragePool storagePool = storagePoolDao.get(_storagePoolId);
    final Guid masterDomainId = storageDomainDao.getMasterStorageDomainIdForPool(_storagePoolId);
    final List<StoragePoolIsoMap> storagePoolIsoMap = storagePoolIsoMapDao.getAllForStoragePool(_storagePoolId);
    Map<String, Pair<String, String>> acquiredLocks = new HashMap<>();
    try {
        for (Map.Entry<Guid, Guid> entry : reportsToHandle.entrySet()) {
            Guid vdsId = entry.getKey();
            Guid currentReportId = entry.getValue();
            vdsHandeledReportsOnUnseenDomains.put(vdsId, currentReportId);
            Map<String, Pair<String, String>> lockMap = Collections.singletonMap(vdsId.toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString()));
            EngineLock engineLock = new EngineLock(lockMap, null);
            if (!lockManager.acquireLock(engineLock).getFirst()) {
                log.info("Failed to acquire lock to refresh storage connection and pool metadata for host '{}', skipping it", vdsId);
                continue;
            }
            final VDS vds = vdsDao.get(entry.getKey());
            if (vds.getStatus() != VDSStatus.Up) {
                log.info("Skipping storage connection and pool metadata information for host '{}' as it's no longer in status UP", vdsId);
                lockManager.releaseLock(engineLock);
                continue;
            }
            acquiredLocks.putAll(lockMap);
            connectStorageTasks.add(() -> {
                getEventListener().connectHostToDomainsInActiveOrUnknownStatus(vds);
                return null;
            });
            refreshStoragePoolTasks.add(() -> {
                storagePoolDomainHelper.refreshHostPoolMetadata(vds, storagePool, masterDomainId, storagePoolIsoMap);
                return null;
            });
        }
        final Set<String> handledHosts = acquiredLocks.keySet();
        log.info("Running storage connections refresh for hosts '{}'", handledHosts);
        ThreadPoolUtil.invokeAll(connectStorageTasks);
        log.info("Submitting to the event queue pool refresh for hosts '{}'", handledHosts);
        getEventQueue().submitEventSync(new Event(_storagePoolId, null, null, EventType.POOLREFRESH, ""), () -> {
            log.info("Running storage pool metadata refresh for hosts '{}'", handledHosts);
            ThreadPoolUtil.invokeAll(refreshStoragePoolTasks);
            return new EventResult(true, EventType.POOLREFRESH);
        });
    } finally {
        if (!acquiredLocks.isEmpty()) {
            lockManager.releaseLock(new EngineLock(acquiredLocks, null));
        }
    }
}
#method_after
@OnTimerMethodAnnotation("hostsStorageConnectionsAndPoolMetadataRefresh")
public void hostsStorageConnectionsAndPoolMetadataRefresh() {
    Map<Guid, Guid> reportsToHandle = procceedReportsThreatmenet();
    if (reportsToHandle.isEmpty()) {
        return;
    }
    List<Callable<Void>> connectStorageTasks = new ArrayList<>();
    final List<Callable<Void>> refreshStoragePoolTasks = new ArrayList<>();
    final StoragePool storagePool = storagePoolDao.get(storagePoolId);
    final Guid masterDomainId = storageDomainDao.getMasterStorageDomainIdForPool(storagePoolId);
    final List<StoragePoolIsoMap> storagePoolIsoMap = storagePoolIsoMapDao.getAllForStoragePool(storagePoolId);
    Map<String, Pair<String, String>> acquiredLocks = new HashMap<>();
    try {
        for (Map.Entry<Guid, Guid> entry : reportsToHandle.entrySet()) {
            Guid vdsId = entry.getKey();
            Guid currentReportId = entry.getValue();
            vdsHandeledReportsOnUnseenDomains.put(vdsId, currentReportId);
            Map<String, Pair<String, String>> lockMap = Collections.singletonMap(vdsId.toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString()));
            EngineLock engineLock = new EngineLock(lockMap, null);
            if (!lockManager.acquireLock(engineLock).getFirst()) {
                log.info("Failed to acquire lock to refresh storage connection and pool metadata for host '{}', skipping it", vdsId);
                continue;
            }
            final VDS vds = vdsDao.get(entry.getKey());
            if (vds.getStatus() != VDSStatus.Up) {
                log.info("Skipping storage connection and pool metadata information for host '{}' as it's no longer in status UP", vdsId);
                lockManager.releaseLock(engineLock);
                continue;
            }
            acquiredLocks.putAll(lockMap);
            connectStorageTasks.add(() -> {
                getEventListener().connectHostToDomainsInActiveOrUnknownStatus(vds);
                return null;
            });
            refreshStoragePoolTasks.add(() -> {
                storagePoolDomainHelper.refreshHostPoolMetadata(vds, storagePool, masterDomainId, storagePoolIsoMap);
                return null;
            });
        }
        final Set<String> handledHosts = acquiredLocks.keySet();
        log.info("Running storage connections refresh for hosts '{}'", handledHosts);
        ThreadPoolUtil.invokeAll(connectStorageTasks);
        log.info("Submitting to the event queue pool refresh for hosts '{}'", handledHosts);
        getEventQueue().submitEventSync(new Event(storagePoolId, null, null, EventType.POOLREFRESH, ""), () -> {
            log.info("Running storage pool metadata refresh for hosts '{}'", handledHosts);
            ThreadPoolUtil.invokeAll(refreshStoragePoolTasks);
            return new EventResult(true, EventType.POOLREFRESH);
        });
    } finally {
        if (!acquiredLocks.isEmpty()) {
            lockManager.releaseLock(new EngineLock(acquiredLocks, null));
        }
    }
}
#end_block

#method_before
private void updateDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    log.debug("domain '{}' still in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    _domainsInProblem.get(domainId).add(vdsId);
}
#method_after
private void updateDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    log.debug("domain '{}' still in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    domainsInProblem.get(domainId).add(vdsId);
}
#end_block

#method_before
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<>();
    // Note - this method is used as it returns only hosts from VIRT supported clusters
    // (we use the domain monitoring results only from those clusters hosts).
    // every change to it should be inspected carefully.
    List<VDS> allVds = vdsDao.getAllForStoragePoolAndStatus(_storagePoolId, null);
    Map<Guid, VDS> vdsMap = new HashMap<>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = storageDomainStaticDao.get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warn("vds '{}' reported domain '{}' - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warn("vds '{}' reported domain '{}' as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    final Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", storageDomain.getName());
                    ThreadPoolUtil.execute(() -> resourceManager.getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId, customLogValues));
                    nonOpVdss.add(vdsId);
                } else {
                    log.warn("vds '{}' reported domain '{}' as in problem, vds is in status '{}', no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warn("Storage domain '{}' is not visible to one or more hosts. " + "Since the domain's type is '{}', hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTORAGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.error("Domain '{}' was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warn("Domain '{}' was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<>();
    // Note - this method is used as it returns only hosts from VIRT supported clusters
    // (we use the domain monitoring results only from those clusters hosts).
    // every change to it should be inspected carefully.
    List<VDS> allVds = vdsDao.getAllForStoragePoolAndStatus(storagePoolId, null);
    Map<Guid, VDS> vdsMap = new HashMap<>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = storageDomainStaticDao.get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warn("vds '{}' reported domain '{}' - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warn("vds '{}' reported domain '{}' as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    final Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", storageDomain.getName());
                    ThreadPoolUtil.execute(() -> resourceManager.getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId, customLogValues));
                    nonOpVdss.add(vdsId);
                } else {
                    log.warn("vds '{}' reported domain '{}' as in problem, vds is in status '{}', no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warn("Storage domain '{}' is not visible to one or more hosts. " + "Since the domain's type is '{}', hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTORAGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.error("Domain '{}' was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = getEventListener().storageDomainNotOperational(domainId, storagePoolId);
        } else {
            log.warn("Domain '{}' was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = getEventListener().masterDomainNotOperational(domainId, storagePoolId, false, false);
        }
    }
    // clear from cache of domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
private void clearTimer(Guid domainId) {
    String jobId = _timers.remove(domainId);
    if (jobId != null) {
        getSchedulUtil().deleteJob(jobId);
    }
}
#method_after
private void clearTimer(Guid domainId) {
    ScheduledFuture job = timersMap.remove(domainId);
    if (job != null) {
        cancelJob(job);
    }
}
#end_block

#method_before
private void clearDomainFromCache(Guid domainId, List<Guid> nonOpVdss) {
    if (domainId != null) {
        _domainsInProblem.remove(domainId);
    }
    removeVdsAsProblematic(nonOpVdss);
    removeVdsFromDomainMaintenance(nonOpVdss);
    removeVdsFromUnseenDomainsReport(nonOpVdss);
}
#method_after
private void clearDomainFromCache(Guid domainId, List<Guid> nonOpVdss) {
    if (domainId != null) {
        domainsInProblem.remove(domainId);
    }
    removeVdsAsProblematic(nonOpVdss);
    removeVdsFromDomainMaintenance(nonOpVdss);
    removeVdsFromUnseenDomainsReport(nonOpVdss);
}
#end_block

#method_before
private void removeVdsAsProblematic(List<Guid> nonOpVdss) {
    Iterator<Map.Entry<Guid, HashSet<Guid>>> iterDomainsInProblem = _domainsInProblem.entrySet().iterator();
    while (iterDomainsInProblem.hasNext()) {
        Map.Entry<Guid, HashSet<Guid>> entry = iterDomainsInProblem.next();
        entry.getValue().removeAll(nonOpVdss);
        if (entry.getValue().isEmpty()) {
            iterDomainsInProblem.remove();
            clearTimer(entry.getKey());
            log.info("Domain '{}' has recovered from problem. No active host in the DC is reporting it as poblematic, so clearing the domain recovery timer.", getDomainIdTuple(entry.getKey()));
        }
    }
}
#method_after
private void removeVdsAsProblematic(List<Guid> nonOpVdss) {
    Iterator<Map.Entry<Guid, HashSet<Guid>>> iterDomainsInProblem = domainsInProblem.entrySet().iterator();
    while (iterDomainsInProblem.hasNext()) {
        Map.Entry<Guid, HashSet<Guid>> entry = iterDomainsInProblem.next();
        entry.getValue().removeAll(nonOpVdss);
        if (entry.getValue().isEmpty()) {
            iterDomainsInProblem.remove();
            clearTimer(entry.getKey());
            log.info("Domain '{}' has recovered from problem. No active host in the DC is reporting it as poblematic, so clearing the domain recovery timer.", getDomainIdTuple(entry.getKey()));
        }
    }
}
#end_block

#method_before
public void clearCache() {
    log.info("clearing cache for problematic entities in pool '{}'.", _storagePoolId);
    // clear lists
    _timers.clear();
    _domainsInProblem.clear();
}
#method_after
public void clearCache() {
    log.info("clearing cache for problematic entities in pool '{}'.", storagePoolId);
    // clear lists
    timersMap.clear();
    domainsInProblem.clear();
}
#end_block

#method_before
public void clearPoolTimers() {
    log.info("clear domain error-timers for pool '{}'.", _storagePoolId);
    for (String jobId : _timers.values()) {
        try {
            getSchedulUtil().deleteJob(jobId);
        } catch (Exception e) {
            log.warn("failed deleting job '{}'.", jobId);
        }
    }
}
#method_after
public void clearPoolTimers() {
    log.info("clear domain error-timers for pool '{}'.", storagePoolId);
    for (Map.Entry<Guid, ScheduledFuture> entry : timersMap.entrySet()) {
        try {
            cancelJob(entry.getValue());
        } catch (Exception e) {
            log.warn("failed deleting job for domain '{}'.", entry.getKey());
        }
    }
}
#end_block

#method_before
public void clearVdsFromCache(Guid vdsId, String vdsName) {
    log.info("Clearing cache of pool: '{}' for problematic entities of VDS: '{}'.", _storagePoolId, vdsName);
    clearDomainFromCache(null, Arrays.asList(vdsId));
}
#method_after
public void clearVdsFromCache(Guid vdsId, String vdsName) {
    log.info("Clearing cache of pool: '{}' for problematic entities of VDS: '{}'.", storagePoolId, vdsName);
    clearDomainFromCache(null, Arrays.asList(vdsId));
}
#end_block

#method_before
public void dispose() {
    runInControlledConcurrency(() -> {
        log.info("IrsProxy::disposing");
        resetIrs();
        getSchedulUtil().deleteJob(storagePoolRefreshJobId);
        getSchedulUtil().deleteJob(domainRecoverOnHostJobId);
        _disposed = true;
    });
}
#method_after
public void dispose() {
    runInControlledConcurrency(() -> {
        log.info("IrsProxy::disposing");
        resetIrs();
        cancelJob(storagePoolRefreshJob);
        cancelJob(domainRecoverOnHostJob);
        _disposed = true;
    });
}
#end_block

#method_before
private List<VdsNetworkInterface> getAllInterfacesByDataCenterId(Guid dataCenterId) {
    return getCallsHandler().executeReadList("GetInterfacesByDataCenterId", vdsNetworkInterfaceRowMapper, getCustomMapSqlParameterSource().addValue("data_center_id", dataCenterId));
}
#method_after
@Override
public List<VdsNetworkInterface> getAllInterfacesByDataCenterId(Guid dataCenterId) {
    return getCallsHandler().executeReadList("GetInterfacesByDataCenterId", vdsNetworkInterfaceRowMapper, getCustomMapSqlParameterSource().addValue("data_center_id", dataCenterId));
}
#end_block

#method_before
public int getMaxMaxMemorySize(Integer osId, Version compatVersion) {
    String usedVersion = (compatVersion != null) ? compatVersion.getValue() : Version.getLast().getValue();
    if (osId == null) {
        return getMaxMaxMemoryForAllOss(usedVersion);
    }
    final ConfigValues maxMaxMemoryConfigValue = getMaxMaxMemoryConfigValue(osId);
    return (Integer) getConfigValuePreConverted(maxMaxMemoryConfigValue, usedVersion);
}
#method_after
public int getMaxMaxMemorySize(Integer osId, Version compatVersion) {
    String usedVersion = compatVersion != null ? compatVersion.getValue() : Version.getLast().getValue();
    if (osId == null) {
        return getMaxMaxMemoryForAllOss(usedVersion);
    }
    final ConfigValues maxMaxMemoryConfigValue = getMaxMaxMemoryConfigValue(osId);
    return (Integer) getConfigValuePreConverted(maxMaxMemoryConfigValue, usedVersion);
}
#end_block

#method_before
public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) {
    final ConfigValues configValue = getMaxMemConfigValueByOsId(osId);
    return Config.<Integer>getValue(configValue, (compatibilityVersion != null) ? compatibilityVersion.getValue() : Version.getLast().getValue());
}
#method_after
public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) {
    final ConfigValues configValue = getMaxMemConfigValueByOsId(osId);
    return Config.<Integer>getValue(configValue, compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue());
}
#end_block

