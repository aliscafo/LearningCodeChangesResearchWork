1159
#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
boolean validate(boolean ignoreNoChanges) throws IOException {
    if (inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !ignoreNoChanges) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    warnMalformedMessage(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (newProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    warnMalformedMessage(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                return change;
            }
        });
        if (change == null) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToLatestPatchSet(db, change);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : patchSetApprovals) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        approvalsUtil.addReviewers(db, change, newPatchSet, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    replication.fire(project.getNameKey(), newPatchSet.getRefName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, newPatchSet.getId());
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : patchSetApprovals) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        approvalsUtil.addReviewers(db, change, newPatchSet, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    replication.fire(project.getNameKey(), newPatchSet.getRefName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    // Execute commit validation plugins
    for (CommitValidationListener validator : commitValidators) {
        try {
            List<CommitValidationMessage> results = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
            messages.addAll(results);
        } catch (CommitValidationException error) {
            reject(cmd, error.getMessage());
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    // Execute commit validation plugins
    for (CommitValidationListener validator : commitValidators) {
        try {
            messages.addAll(validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser)));
        } catch (CommitValidationException error) {
            reject(cmd, error.getMessage());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
public static void all(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "ALL").addParameterTrue("all").addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(callback));
}
#method_after
public static void all(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "ALL").addParameterTrue("all").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(callback));
}
#end_block

#method_before
public static void permissions(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PERMISSIONS").addParameterTrue("all").addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(callback));
}
#method_after
public static void permissions(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PERMISSIONS").addParameterTrue("all").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(callback));
}
#end_block

#method_before
public static void parentCandidates(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PARENT_CANDIDATES").addParameterTrue("all").addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(callback));
}
#method_after
public static void parentCandidates(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PARENT_CANDIDATES").addParameterTrue("all").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(callback));
}
#end_block

#method_before
public static void suggest(String prefix, int limit, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/" + URL.encode(prefix).replaceAll("[?]", "%3F")).addParameterRaw("type", "ALL").addParameter("n", limit).addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(cb));
}
#method_after
public static void suggest(String prefix, int limit, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/").addParameter("p", prefix).addParameter("n", limit).addParameterRaw("type", "ALL").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(cb));
}
#end_block

#method_before
public static void match(String match, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/" + URL.encode(match).replaceAll("[?]", "%3F")).addParameterRaw("type", "ALL").addParameterTrue(// description
    "d").addParameterTrue("subname").send(NativeMap.copyKeysIntoChildren(cb));
}
#method_after
public static void match(String match, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/").addParameter("m", match).addParameterRaw("type", "ALL").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(cb));
}
#end_block

#method_before
protected void display(final ProjectMap result) {
    projects.display(result);
    projects.finishDisplay();
}
#method_after
private void display(final ProjectMap result) {
    projects.display(result);
    projects.finishDisplay();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, 3, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProjectAdmin(item.name_key(), ProjectScreen.INFO);
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            table.setWidget(row, 1, new Hyperlink(k.name(), link(k)));
            table.setText(row, 2, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, 3, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, 3, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProjectAdmin(item.name_key(), ProjectScreen.INFO);
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new InlineHyperlink(k.name(), link(k)));
            table.setWidget(row, 1, fp);
            table.setText(row, 2, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, 3, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#end_block

#method_before
protected void initPageHeader() {
}
#method_after
private void initPageHeader() {
    final HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    final Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(subname);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            subname = filterTxt.getValue();
            refresh();
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#end_block

#method_before
public ListProjects setFormat(OutputFormat fmt) {
    this.format = fmt;
    return this;
}
#method_after
public ListProjects setFormat(OutputFormat fmt) {
    format = fmt;
    return this;
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = parentState.getProject().getDescription();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription && !e.getProject().getDescription().isEmpty()) {
                    info.description = e.getProject().getDescription();
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
public JsonElement display(OutputStream displayOutputStream) {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.setName(parentState.getProject().getName());
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.setName(projectName.get());
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (stdout == null) {
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, Object>>() {
            }.getType());
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private Iterable<NameKey> scan() {
    if (recent) {
        return recentProjectsCache.getProjects(userProvider.get().getAccountId());
    } else if (match != null) {
        if (byPrefix) {
            return projectCache.byName(match);
        } else {
            return projectCache.bySubname(match);
        }
    } else {
        return projectCache.all();
    }
}
#method_after
private Iterable<Project.NameKey> scan() {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else {
        return projectCache.all();
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = new PatchSet.Id(change.getId(), Change.INITIAL_PATCH_SET_ID);
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = nextPatchSetId(git, changeToRevert.currentPatchSetId());
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = new PatchSet.Id(change.getId(), Change.INITIAL_PATCH_SET_ID);
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    bind(AnonymousUser.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapRealmModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    install(new LdapModule());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username;
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(new AuthUser.UUID(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username;
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(new AuthUser.UUID(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private void defaultStyle(final int row, final CellFormatter fmt) {
    fmt.addStyleName(row, A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffText());
    if (isDisplayBinary) {
        fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffTextForBinaryInSidyBySide());
    }
    fmt.addStyleName(row, B, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void defaultStyle(final int row, final CellFormatter fmt) {
    fmt.addStyleName(row, A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffText());
    if (isDisplayBinary) {
        fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffTextForBinaryInSideBySide());
    }
    fmt.addStyleName(row, B, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[There is no diff output.\n" + " Reason: This change has more than two parents.\n" + " Gerrit does not support for generating diff output\n" + " between this kind change and its parents by far.]\n";
        }
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(args.settings.maximumDiffSize);
    DiffFormatter fmt = new DiffFormatter(buf);
    Repository git;
    try {
        git = args.server.openRepository(change.getProject());
    } catch (IOException e) {
        log.error("Cannot open repository to format patch", e);
        return "";
    }
    try {
        fmt.setRepository(git);
        fmt.setDetectRenames(true);
        fmt.format(patchList.getOldId(), patchList.getNewId());
        return RawParseUtils.decode(buf.toByteArray());
    } catch (IOException e) {
        if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
            return "";
        }
        log.error("Cannot format patch", e);
        return "";
    } finally {
        fmt.release();
        git.close();
    }
}
#method_after
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[Octopus merge; cannot be formatted as a diff.]\n";
        }
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(args.settings.maximumDiffSize);
    DiffFormatter fmt = new DiffFormatter(buf);
    Repository git;
    try {
        git = args.server.openRepository(change.getProject());
    } catch (IOException e) {
        log.error("Cannot open repository to format patch", e);
        return "";
    }
    try {
        fmt.setRepository(git);
        fmt.setDetectRenames(true);
        fmt.format(patchList.getOldId(), patchList.getNewId());
        return RawParseUtils.decode(buf.toByteArray());
    } catch (IOException e) {
        if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
            return "";
        }
        log.error("Cannot format patch", e);
        return "";
    } finally {
        fmt.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final String newMessage = message + '\n';
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Date now = myIdent.getWhen();
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            if (commit.getFullMessage().equals(newMessage)) {
                throw new InvalidChangeOperationException("The commit message is unchanged");
            }
            PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(newMessage);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user.getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            if (commit.getFullMessage().equals(message)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            Date now = myIdent.getWhen();
            Change change = db.changes().get(changeId);
            PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user.getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setHTML(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        ValueRadioButton b = new ValueRadioButton(ct.getCategory(), buttonValue);
        SafeHtml buf = new SafeHtmlBuilder().append(buttonValue.format());
        buf = CommentLinkProcessor.apply(buf);
        SafeHtml.set(b, buf);
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, false, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    revision = r.getPatchSetInfo().getRevId();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    ReviewInput data = ReviewInput.create();
    data.message(ChangeApi.emptyToNull(message.getText().trim()));
    data.init();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            data.label(b.category.getLabelName(), b.value.getValue());
        }
    }
    enableForm(false);
    new RestApi("/changes/" + patchSetId.getParentKey().get() + "/revisions/" + revision + "/review").data(data).post(new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#method_after
private void submit() {
    ChangeApi.submit(patchSetId.getParentKey().get(), revision, new GerritCallback<SubmitInfo>() {

        public void onSuccess(SubmitInfo result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
            } else {
                super.onFailure(err);
            }
            goChange();
        }
    });
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        ValueRadioButton b = new ValueRadioButton(ct.getCategory(), buttonValue);
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            if (c.getLine() == AbstractPatchContentTable.R_HEAD) {
                editor.setAuthorNameText(Util.C.fileComment());
            } else {
                editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            }
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, false, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    revision = r.getPatchSetInfo().getRevId();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            if (c.getLine() == AbstractPatchContentTable.R_HEAD) {
                editor.setAuthorNameText(Util.C.fileCommentHeader());
            } else {
                editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            }
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    ReviewInput data = ReviewInput.create();
    data.message(ChangeApi.emptyToNull(message.getText().trim()));
    data.init();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            data.label(b.category.getLabelName(), b.value.getValue());
        }
    }
    enableForm(false);
    new RestApi("/changes/" + patchSetId.getParentKey().get() + "/revisions/" + revision + "/review").data(data).post(new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#method_after
private void submit() {
    ChangeApi.submit(patchSetId.getParentKey().get(), revision, new GerritCallback<SubmitInfo>() {

        public void onSuccess(SubmitInfo result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
            } else {
                super.onFailure(err);
            }
            goChange();
        }
    });
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc) throws BadRequestException, OrmException {
    List<Object> reviewers = new ArrayList<Object>();
    ReviewDb db = dbProvider.get();
    Change.Id changeId = rsrc.getChange().getId();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        Account account = accountCache.get(patchSetApproval.getAccountId()).getAccount();
        reviewers.add(json.format(new ReviewerResource(rsrc, account)));
    }
    return reviewers;
}
#method_after
@Override
public Object apply(ChangeResource rsrc) throws BadRequestException, OrmException {
    Map<Account.Id, Object> reviewers = Maps.newLinkedHashMap();
    ReviewDb db = dbProvider.get();
    Change.Id changeId = rsrc.getChange().getId();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        Account.Id accountId = patchSetApproval.getAccountId();
        if (!reviewers.containsKey(accountId)) {
            Account account = accountCache.get(accountId).getAccount();
            reviewers.put(accountId, json.format(new ReviewerResource(rsrc, account)));
        }
    }
    return reviewers.values();
}
#end_block

#method_before
@Override
public ReviewerResource parse(ChangeResource changeResource, String id) throws OrmException, ResourceNotFoundException {
    // Get the account id
    if (!id.matches("^[0-9]+$")) {
        throw new ResourceNotFoundException(id);
    }
    Account.Id accountId = Account.Id.parse(id);
    // See if the id exists as a reviewer for this change
    if (fetchAccountIds(changeResource).contains(accountId)) {
        Account account = accountCache.get(accountId).getAccount();
        return new ReviewerResource(changeResource, account);
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public ReviewerResource parse(ChangeResource rsrc, String id) throws OrmException, ResourceNotFoundException, AuthException {
    Account.Id accountId;
    if (id.equals("self")) {
        CurrentUser user = rsrc.getControl().getCurrentUser();
        if (user instanceof IdentifiedUser) {
            accountId = ((IdentifiedUser) user).getAccountId();
        } else if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else {
            throw new ResourceNotFoundException(id);
        }
    } else if (id.matches("^[0-9]+$")) {
        accountId = Account.Id.parse(id);
    } else {
        throw new ResourceNotFoundException(id);
    }
    // See if the id exists as a reviewer for this change
    if (fetchAccountIds(rsrc).contains(accountId)) {
        Account account = accountCache.get(accountId).getAccount();
        return new ReviewerResource(rsrc, account);
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
private Set<Account.Id> fetchAccountIds(ChangeResource changeResource) throws OrmException {
    ReviewDb db = dbProvider.get();
    Change.Id changeId = changeResource.getChange().getId();
    Set<Account.Id> accountIds = new HashSet<Account.Id>();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        accountIds.add(patchSetApproval.getAccountId());
    }
    return accountIds;
}
#method_after
private Set<Account.Id> fetchAccountIds(ChangeResource rsrc) throws OrmException {
    Set<Account.Id> accountIds = Sets.newHashSet();
    for (PatchSetApproval a : dbProvider.get().patchSetApprovals().byChange(rsrc.getChange().getId())) {
        accountIds.add(a.getAccountId());
    }
    return accountIds;
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!newChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : newChanges) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, newChanges.size(), project.getName()));
        return;
    }
    try {
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                replace.insertPatchSet();
            }
        }
        for (CreateRequest create : newChanges) {
            create.insertChange();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't inserting changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, newChanges.size(), project.getName()));
        return;
    }
    try {
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                replace.insertPatchSet();
            }
        }
        for (CreateRequest create : newChanges) {
            create.insertChange();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#end_block

#method_before
void insertChange() throws IOException, OrmException {
    rp.getRevWalk().parseBody(commit);
    warnMalformedMessage(commit);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = commit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    replication.fire(project.getNameKey(), ps.getRefName());
    hooks.doPatchsetCreatedHook(change, ps, db);
    newProgress.update(1);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#method_after
void insertChange() throws IOException, OrmException {
    rp.getRevWalk().parseBody(commit);
    warnMalformedMessage(commit);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = commit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    created = true;
    replication.fire(project.getNameKey(), ps.getRefName());
    hooks.doPatchsetCreatedHook(change, ps, db);
    newProgress.update(1);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (RepositoryNotFoundException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(openRepository(change), patchsetCreatedHook, args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(openRepository(change), commentAddedHook, args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(openRepository(change), changeMergedHook, args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(openRepository(change), changeAbandonedHook, args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(openRepository(refName.getParentKey()), refUpdatedHook, args);
}
#method_after
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-id", cla.getId().toString());
        runHook(claSignedHook, args);
    }
}
#method_after
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, File hook, List<String> args) {
    if (project != null && hook.exists()) {
        hookQueue.execute(new AsyncHookTask(project, hook, args));
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Repository repo, File hook, List<String> args) throws TimeoutException {
    if (hook.exists()) {
        SyncHookTask syncHook = new SyncHookTask(repo, hook, args);
        FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
        syncHookThreadPool.execute(task);
        try {
            return task.get(syncHookTimeout, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (ExecutionException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (TimeoutException e) {
            log.error("Synchronous hook timed out " + hook.getAbsolutePath());
            throw e;
        }
    }
    return null;
}
#method_after
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) throws TimeoutException {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public HookResult call() throws Exception {
    HookResult result = null;
    StringBuilder output = new StringBuilder();
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (repo != null) {
            pb.directory(repo.getDirectory());
            final Map<String, String> env = pb.environment();
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        Process ps = pb.start();
        ps.getOutputStream().close();
        BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
        try {
            String line = br.readLine();
            while (line != null) {
                output.append(line);
                line = br.readLine();
                if (line != null) {
                    output.append(System.getProperty("line.separator"));
                }
            }
        } finally {
            try {
                br.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output.toString());
        }
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return result;
}
#method_after
@Override
public HookResult call() throws Exception {
    return super.runHook();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        // Run the update hook, if it returns output then reject the push
        // passing the output back to the user
        String output = hooks.doUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (output != null) {
            reject(cmd, output);
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        Map<String, Ref> refs = repo.getAllRefs();
        existingObjects = new ArrayList<ObjectId>(refs.size());
        for (Ref r : refs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#method_after
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        existingObjects = new ArrayList<ObjectId>(allRefs.size());
        for (Ref r : allRefs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        final String message = validationResult.getValidationReason();
        if (!validationResult.isValidated()) {
            reject(cmd, message);
            return false;
        } else if (!Strings.isNullOrEmpty(message)) {
            addMessage(String.format("(W) %s", message));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException {
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    db.changes().beginTransaction(revision.getChange().getId());
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        insertComments(revision, input.comments, input.drafts);
        if (change.getStatus().isOpen() && input.labels != null) {
            // TODO Allow updating some labels even when closed.
            updateLabels(revision, input.labels);
        }
        insertMessage(revision, input.message);
        db.changes().update(Collections.singleton(change));
        db.commit();
    } finally {
        db.rollback();
    }
    email.create(change, revision.getPatchSet(), revision.getAuthorId(), message, comments).sendAsync();
    fireCommentAddedHook(revision);
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#method_after
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException {
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    db.changes().beginTransaction(revision.getChange().getId());
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        insertComments(revision, input.comments, input.drafts);
        updateLabels(revision, input.labels);
        insertMessage(revision, input.message);
        db.changes().update(Collections.singleton(change));
        db.commit();
    } finally {
        db.rollback();
    }
    email.create(change, revision.getPatchSet(), revision.getAuthorId(), message, comments).sendAsync();
    fireCommentAddedHook(revision);
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
private void updateLabels(RevisionResource rsrc, Map<String, Short> labels) throws OrmException {
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ins = Lists.newArrayList();
    List<PatchSetApproval> upd = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(rsrc, del);
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        // TODO Support arbitrary label names.
        ApprovalType at = approvalTypes.byLabel(ent.getKey());
        String name = at.getCategory().getLabelName();
        PatchSetApproval c = current.get(name);
        if (ent.getValue() == null) {
            if (c != null) {
                // User requested delete of this label.
                del.add(c);
                labelDelta.add("-" + name);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            upd.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), rsrc.getAuthorId(), at.getCategory().getId()), ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            ins.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        }
    }
    db.patchSetApprovals().delete(del);
    db.patchSetApprovals().insert(ins);
    db.patchSetApprovals().update(upd);
}
#method_after
private void updateLabels(RevisionResource rsrc, Map<String, Short> labels) throws OrmException {
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ins = Lists.newArrayList();
    List<PatchSetApproval> upd = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(rsrc, del);
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        // TODO Support arbitrary label names.
        ApprovalType at = approvalTypes.byLabel(ent.getKey());
        String name = at.getCategory().getLabelName();
        if (change.getStatus().isClosed()) {
            // TODO Allow updating some labels even when closed.
            continue;
        }
        PatchSetApproval c = current.remove(name);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                del.add(c);
                labelDelta.add("-" + name);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            upd.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(name, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), rsrc.getAuthorId(), at.getCategory().getId()), ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            ins.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        }
    }
    forceCallerAsReviewer(rsrc, current, ins, upd, del);
    db.patchSetApprovals().delete(del);
    db.patchSetApprovals().insert(ins);
    db.patchSetApprovals().update(upd);
}
#end_block

#method_before
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    if (patchSetId != null && starred != null && Gerrit.isSignedIn()) {
        Change.Id changeId = patchSetId.getParentKey();
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (patchSetId != null) {
        Change.Id changeId = patchSetId.getParentKey();
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            final String newCommitMessage = getMessageText();
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, newCommitMessage, createCallback());
                            display(newCommitMessage);
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    if (patchSetId != null && starred != null && Gerrit.isSignedIn()) {
        Change.Id changeId = patchSetId.getParentKey();
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (patchSetId != null) {
        final Change.Id changeId = patchSetId.getParentKey();
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), new AsyncCallback<ChangeDetail>() {

                                @Override
                                public void onSuccess(ChangeDetail result) {
                                    Gerrit.display(PageLinks.toChange(changeId));
                                    hide();
                                }

                                @Override
                                public void onFailure(Throwable caught) {
                                    enableButtons(true);
                                    new ErrorDialog(caught.getMessage()).center();
                                }
                            });
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.addParentId(commit.getParent(0));
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setAuthor(authorIdent);
            commitBuilder.setCommitter(myIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(change.getCreatedOn());
            newPatchSet.setUploader(change.getOwner());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(authorIdent);
            commitBuilder.setCommitter(myIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(change.getCreatedOn());
            newPatchSet.setUploader(change.getOwner());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Override
public DashboardResource parse(ProjectResource parent, String id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    ProjectControl myCtl = parent.getControl();
    if ("default".equals(id)) {
        return DashboardResource.projectDefault(myCtl);
    }
    List<String> parts = Lists.newArrayList(Splitter.on(':').limit(2).split(id));
    if (parts.size() != 2) {
        throw new ResourceNotFoundException(id);
    }
    String ref = URLDecoder.decode(parts.get(0), "UTF-8");
    String path = URLDecoder.decode(parts.get(1), "UTF-8");
    Set<Project.NameKey> seen = Sets.newHashSet();
    Project.NameKey name = myCtl.getProject().getNameKey();
    ProjectControl ctl = myCtl;
    seen.add(name);
    do {
        try {
            return parse(ctl, ref, path, myCtl);
        } catch (Exception e) {
            try {
                ProjectState ps = ctl.getProjectState().getParentState();
                if (ps == null) {
                    break;
                }
                name = ps.getProject().getNameKey();
                if (!seen.add(name)) {
                    break;
                }
                ctl = projectFactory.controlFor(name, ctl.getCurrentUser());
            } catch (NoSuchProjectException pnf) {
                throw new ResourceNotFoundException(id);
            }
        }
    } while (ctl != null);
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public DashboardResource parse(ProjectResource parent, String id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    ProjectControl myCtl = parent.getControl();
    if ("default".equals(id)) {
        return DashboardResource.projectDefault(myCtl);
    }
    List<String> parts = Lists.newArrayList(Splitter.on(':').limit(2).split(id));
    if (parts.size() != 2) {
        throw new ResourceNotFoundException(id);
    }
    String ref = URLDecoder.decode(parts.get(0), "UTF-8");
    String path = URLDecoder.decode(parts.get(1), "UTF-8");
    ProjectControl ctl = myCtl;
    Set<Project.NameKey> seen = Sets.newHashSet(ctl.getProject().getNameKey());
    for (; ; ) {
        try {
            return parse(ctl, ref, path, myCtl);
        } catch (AmbiguousObjectException e) {
            throw new ResourceNotFoundException(id);
        } catch (IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } catch (ResourceNotFoundException e) {
            ProjectState ps = ctl.getProjectState().getParentState();
            if (ps != null && seen.add(ps.getProject().getNameKey())) {
                ctl = ps.controlFor(ctl.getCurrentUser());
                continue;
            }
            throw new ResourceNotFoundException(id);
        }
    }
}
#end_block

#method_before
private DashboardResource parse(ProjectControl ctl, String ref, String path, ProjectControl myCtl) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    String id = ref + ":" + path;
    if (!ref.startsWith(REFS_DASHBOARDS)) {
        ref = REFS_DASHBOARDS + ref;
    }
    if (!Repository.isValidRefName(ref) || !ctl.controlForRef(ref).canRead()) {
        throw new ResourceNotFoundException(id);
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getProject().getNameKey());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(id);
    }
    try {
        ObjectId objId;
        try {
            objId = git.resolve(id);
        } catch (AmbiguousObjectException e) {
            throw new ResourceNotFoundException(id);
        } catch (IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        }
        if (objId == null) {
            throw new ResourceNotFoundException(id);
        }
        BlobBasedConfig cfg = new BlobBasedConfig(null, git, objId);
        return new DashboardResource(myCtl, ref, path, cfg, false);
    } finally {
        git.close();
    }
}
#method_after
private DashboardResource parse(ProjectControl ctl, String ref, String path, ProjectControl myCtl) throws ResourceNotFoundException, IOException, AmbiguousObjectException, IncorrectObjectTypeException, ConfigInvalidException {
    String id = ref + ":" + path;
    if (!ref.startsWith(REFS_DASHBOARDS)) {
        ref = REFS_DASHBOARDS + ref;
    }
    if (!Repository.isValidRefName(ref) || !ctl.controlForRef(ref).canRead()) {
        throw new ResourceNotFoundException(id);
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getProject().getNameKey());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(id);
    }
    try {
        ObjectId objId = git.resolve(ref + ":" + path);
        if (objId == null) {
            throw new ResourceNotFoundException(id);
        }
        BlobBasedConfig cfg = new BlobBasedConfig(null, git, objId);
        return new DashboardResource(myCtl, ref, path, cfg, false);
    } finally {
        git.close();
    }
}
#end_block

#method_before
public static void abandon(int changeId, String message, AsyncCallback<ChangeInfo> callback) {
    RestApi call = new RestApi(URI + changeId + "/abandon");
    Message msg = new Message();
    msg.setMessage(message);
    call.data(msg).post(callback);
}
#method_after
public static void abandon(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    Input input = Input.create();
    input.message(emptyToNull(msg));
    api(id, "abandon").data(input).post(cb);
}
#end_block

#method_before
public static void restore(int changeId, String message, AsyncCallback<ChangeInfo> callback) {
    RestApi call = new RestApi(URI + changeId + "/restore");
    Message msg = new Message();
    msg.setMessage(message);
    call.data(msg).post(callback);
}
#method_after
public static void restore(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    Input input = Input.create();
    input.message(emptyToNull(msg));
    api(id, "restore").data(input).post(cb);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AlterTopicHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EditCommitMessageHandler.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b) {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(patchSet.getId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b) {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            ChangeControl ctl = changeControlFactory.controlFor(patchSetId.getParentKey());
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            ChangeControl ctl = changeControlFactory.controlFor(patchSetId.getParentKey());
            try {
                restore.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    PostReview.Input review = new PostReview.Input();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = PostReview.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    try {
        ChangeControl ctl = changeControlFactory.controlFor(patchSetId.getParentKey());
        reviewProvider.get().apply(new RevisionResource(new ChangeResource(ctl), db.patchSets().get(patchSetId)), review);
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            try {
                restore.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(ListProjects.class);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(RebaseChange.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(RebaseChange.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(RestoredSender.Factory.class);
}
#method_after
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(RestoredSender.Factory.class);
}
#end_block

#method_before
@Override
public ReviewerResource parse(ChangeResource changeResource, String id) throws ResourceNotFoundException, Exception {
    // Get the account id
    if (!id.matches("^[0-9]+$")) {
        throw new ResourceNotFoundException(id);
    }
    Account.Id accountId = Account.Id.parse(id);
    // Fetch the PatchSetApproval
    ReviewDb db = dbProvider.get();
    Change.Id changeId = changeResource.getChange().getId();
    List<PatchSetApproval> patchSetApprovals = db.patchSetApprovals().byChange(changeId).toList();
    for (PatchSetApproval patchSetApproval : patchSetApprovals) {
        System.out.println(id.toString() + " " + patchSetApproval.getAccountId());
        if (patchSetApproval.getAccountId().equals(accountId)) {
            Account account = db.accounts().get(accountId);
            return new ReviewerResource(changeResource, account);
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public ReviewerResource parse(ChangeResource changeResource, String id) throws OrmException, ResourceNotFoundException {
    // Get the account id
    if (!id.matches("^[0-9]+$")) {
        throw new ResourceNotFoundException(id);
    }
    Account.Id accountId = Account.Id.parse(id);
    // See if the id exists as a reviewer for this change
    if (fetchAccountIds(changeResource).contains(accountId)) {
        Account account = accountCache.get(accountId).getAccount();
        return new ReviewerResource(changeResource, account);
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
public ReviewerInfo format(ReviewerResource reviewerResource) {
    Account account = reviewerResource.getAccount();
    int id = account.getId().get();
    String email = null;
    String name = null;
    try {
        email = URLEncoder.encode(account.getPreferredEmail(), "UTF-8");
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException("Cannot encode reviewer email", e);
    }
    name = account.getFullName();
    if (name != null) {
        try {
            name = URLEncoder.encode(account.getFullName(), "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("Cannot encode reviewer name", e);
        }
    }
    return new ReviewerInfo(id, email, name);
}
#method_after
public ReviewerInfo format(ReviewerResource reviewerResource) {
    ReviewerInfo reviewerInfo = new ReviewerInfo();
    Account account = reviewerResource.getAccount();
    reviewerInfo.id = account.getId().toString();
    reviewerInfo.email = account.getPreferredEmail();
    reviewerInfo.name = account.getFullName();
    return reviewerInfo;
}
#end_block

#method_before
static DashboardInfo parse(Project project, String refName, String path, Config config) throws UnsupportedEncodingException {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.title = config.getString("dashboard", null, "title");
    info.description = config.getString("dashboard", null, "description");
    info.allQueries = config.getString("dashboard", null, "allQueries");
    info.isDefault = info.id.equals(defaultOf(project)) ? true : null;
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", Objects.firstNonNull(info.title, info.path));
    if (info.allQueries != null) {
        u.put("allQueries", replace(project.getName(), info.allQueries));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project.getName(), s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#method_after
static DashboardInfo parse(Project project, String refName, String path, Config config, boolean setDefault) throws UnsupportedEncodingException {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.title = config.getString("dashboard", null, "title");
    info.description = config.getString("dashboard", null, "description");
    info.isDefault = setDefault ? (info.id.equals(defaultOf(project)) ? true : null) : null;
    info.foreach = config.getString("dashboard", null, "foreach");
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", Objects.firstNonNull(info.title, info.path));
    if (info.foreach != null) {
        u.put("foreach", replace(project.getName(), info.foreach));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project.getName(), s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar groupsBar = new LinkMenuBar();
        addLink(groupsBar, C.menuGroupsList(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(groupsBar, C.menuGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
            }
        }, CREATE_GROUP);
        menuLeft.add(groupsBar, C.menuGroups());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(groupsBar) + 1);
                }
            }
        }, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar groupsBar = new LinkMenuBar();
        addLink(groupsBar, C.menuGroupsList(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(groupsBar, C.menuGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
            }
        }, CREATE_GROUP);
        menuLeft.add(groupsBar, C.menuGroups());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(groupsBar) + 1);
                }
            }
        }, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.nextPatchSetId();
        change.setTopic(changeToRevert.getTopic());
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        Change change = db.changes().get(changeId);
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.addParentId(commit);
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setAuthor(authorIdent);
        commitBuilder.setCommitter(myIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        change.nextPatchSetId();
        final PatchSet originalPS = db.patchSets().get(patchSetId);
        final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
        newPatchSet.setCreatedOn(change.getCreatedOn());
        newPatchSet.setUploader(change.getOwner());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange;
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.addParentId(commit);
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setAuthor(authorIdent);
            commitBuilder.setCommitter(myIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(change.getCreatedOn());
            newPatchSet.setUploader(change.getOwner());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus() == Change.Status.NEW && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus().isOpen() && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AbandonChangeHandler.Factory.class);
            factory(EditCommitMessageHandler.Factory.class);
            factory(AlterTopicHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EditCommitMessageHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#end_block

#method_before
public void display(final String commitMessage) {
    display(null, null, null, commitMessage);
}
#method_after
public void display(final String commitMessage) {
    display(null, null, false, commitMessage);
}
#end_block

#method_before
public void display(Change.Id changeId, final PatchSet.Id patchSetId, Boolean starred, final String commitMessage) {
    starPanel.clear();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null && patchSetId != null) {
        ChangeDetailCache detailCache = ChangeCache.get(patchSetId.getParentKey()).getChangeDetailCache();
        ChangeDetail changeDetail = detailCache.get();
        if (changeDetail.canEditCommitMessage()) {
            permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
            permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new EditCommitMessageActionDialog() {

                        {
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.editCommitMessage(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            edit.addStyleName(Gerrit.RESOURCES.css().changeInfoBlockEdit());
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    Change.Id changeId = patchSetId.getParentKey();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null) {
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new InvalidChangeOperationException("Not allowed to add new Patch Sets to: " + changeId.toString());
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
public void display(Change chg, Boolean starred, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.getId(), chg.currentPatchSetId(), starred, info.getMessage());
}
#method_after
public void display(Change chg, Boolean starred, Boolean canEditCommitMessage, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.currentPatchSetId(), starred, canEditCommitMessage, info.getMessage());
}
#end_block

#method_before
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#method_after
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (column > C_ARROW && getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(nc);
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                padLineNumberForSideB(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumberForSideA(nc);
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == 0) {
            fora = cd.getForA(0);
            forb = cd.getForB(0);
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
        } else {
            row++;
            continue;
        }
        row++;
        if (!fora.isEmpty() && !forb.isEmpty()) {
            all.clear();
            all.addAll(fora);
            all.addAll(forb);
            Collections.sort(all, BY_DATE);
            row = insert(all, row, expandComments);
        } else if (!fora.isEmpty()) {
            row = insert(fora, row, expandComments);
        } else if (!forb.isEmpty()) {
            row = insert(forb, row, expandComments);
        }
    }
}
#method_after
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == R_HEAD) {
            fora = cd.getForA(R_HEAD);
            forb = cd.getForB(R_HEAD);
            row++;
            if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            }
            rowOfTableHeaderB = row;
            borderRowOfFileComment = row + 1;
            if (!forb.isEmpty()) {
                // Skip the Header of sideB.
                row++;
                row = insert(forb, row, expandComments);
                borderRowOfFileComment = row;
                createFileCommentBorderRow();
            }
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
            row++;
            if (!fora.isEmpty() && !forb.isEmpty()) {
                all.clear();
                all.addAll(fora);
                all.addAll(forb);
                Collections.sort(all, BY_DATE);
                row = insert(all, row, expandComments);
            } else if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            } else if (!forb.isEmpty()) {
                row = insert(forb, row, expandComments);
            }
        } else {
            row++;
            continue;
        }
    }
}
#end_block

#method_before
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, PC - 2, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC, Gerrit.RESOURCES.css().diffText());
}
#method_after
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    defaultStyle(row, fmt);
}
#end_block

#method_before
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        insertRow(row);
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#method_after
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        if (c.getLine() == R_HEAD) {
            insertFileCommentRow(row);
        } else {
            insertRow(row);
        }
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#end_block

#method_before
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#end_block

#method_before
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void destroyEditor(final int row, final int col) {
    table.clearCell(row, col);
    final int span = table.getFlexCellFormatter().getRowSpan(row, col);
    boolean removeRow = true;
    final int nCells = table.getCellCount(row);
    for (int cell = 0; cell < nCells; cell++) {
        if (table.getWidget(row, cell) != null) {
            removeRow = false;
            break;
        }
    }
    if (removeRow) {
        for (int r = row - 1; 0 <= r; r--) {
            boolean data = false;
            for (int c = 0; c < table.getCellCount(r); c++) {
                data |= table.getWidget(r, c) != null;
                final int s = table.getFlexCellFormatter().getRowSpan(r, c) - 1;
                if (r + s == row) {
                    table.getFlexCellFormatter().setRowSpan(r, c, s);
                }
            }
            if (!data) {
                break;
            }
        }
        table.removeRow(row);
        removeFileCommentBorderRow(row, col);
    } else {
        // 
        table.getFlexCellFormatter().setStyleName(row, col, Gerrit.RESOURCES.css().diffText());
        if (span != 1) {
            table.getFlexCellFormatter().setRowSpan(row, col, 1);
            for (int r = row + 1; r < row + span; r++) {
                table.insertCell(r, col);
                // 
                table.getFlexCellFormatter().setStyleName(r, col, Gerrit.RESOURCES.css().diffText());
            }
        }
    }
}
#method_after
private void destroyEditor(final int row, final int col) {
    table.clearCell(row, col);
    final int span = table.getFlexCellFormatter().getRowSpan(row, col);
    boolean removeRow = true;
    final int nCells = table.getCellCount(row);
    for (int cell = 0; cell < nCells; cell++) {
        if (table.getWidget(row, cell) != null) {
            removeRow = false;
            break;
        }
    }
    if (removeRow) {
        destroyCommentRow(row);
    } else {
        destroyComment(row, col, span);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
    // Populate icons to lineNumber column header.
    if (psListOfHeaderA.isFile) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (psListOfHeaderB.isFile) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
    // Populate icons to lineNumber column header.
    if (headerSideA.isFile()) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (headerSideB.isFile()) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#end_block

#method_before
private void createFileCommentBorderRow(final int row) {
    if (row == 1 && !isFileCommentBorderRowExist) {
        isFileCommentBorderRowExist = true;
        table.insertRow(R_HEAD + 2);
        final CellFormatter fmt = table.getCellFormatter();
        // 
        fmt.addStyleName(// 
        R_HEAD + 2, // 
        C_ARROW, Gerrit.RESOURCES.css().iconCellOfFileCommentRow());
        defaultStyle(R_HEAD + 2, fmt);
        final Element iconCell = fmt.getElement(R_HEAD + 2, C_ARROW);
        UIObject.setStyleName(DOM.getParent(iconCell), Gerrit.RESOURCES.css().borderRowOfFileComment(), true);
    }
}
#method_after
private void createFileCommentBorderRow(final int row) {
    if (row == 1 && !isFileCommentBorderRowExist) {
        isFileCommentBorderRowExist = true;
        table.insertRow(R_HEAD + 2);
        final CellFormatter fmt = table.getCellFormatter();
        // 
        fmt.addStyleName(// 
        R_HEAD + 2, // 
        C_ARROW, Gerrit.RESOURCES.css().iconCellOfFileCommentRow());
        defaultStyle(R_HEAD + 2, fmt);
        final Element iconCell = fmt.getElement(R_HEAD + 2, C_ARROW);
        UIObject.setStyleName(DOM.getParent(iconCell), Gerrit.RESOURCES.css().fileCommentBorder(), true);
    }
}
#end_block

#method_before
public static String toProjectDashboard(Project.NameKey projectName, String dashboardId) {
    return PROJECTS + URL.encodePathSegment(projectName.get()) + DASHBOARDS + PageLinks.encodeDashboardId(dashboardId);
}
#method_after
public static String toProjectDashboard(Project.NameKey projectName, String dashboardId) {
    return PROJECTS + projectName.get() + DASHBOARDS + dashboardId;
}
#end_block

#method_before
public static String defaultOf(Project proj) {
    return Objects.firstNonNull(proj.getLocalDefaultDashboard(), Strings.nullToEmpty(proj.getDefaultDashboard()));
}
#method_after
public static String defaultOf(Project proj) {
    final String defaultId = Objects.firstNonNull(proj.getLocalDefaultDashboard(), Strings.nullToEmpty(proj.getDefaultDashboard()));
    if (defaultId.startsWith(REFS_DASHBOARDS)) {
        return defaultId.substring(REFS_DASHBOARDS.length());
    } else {
        return defaultId;
    }
}
#end_block

#method_before
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#method_after
@Override
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#end_block

#method_before
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            createCommentEditor(suggestRow, column, newComment).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#method_after
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            findOrCreateCommentEditor(suggestRow, column, newComment, true).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#end_block

#method_before
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    createEditor(newComment).setFocus(true);
}
#method_after
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    findOrCreateEditor(newComment, true).setFocus(true);
}
#end_block

#method_before
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = createEditor(newComment);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                createEditor(result).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#method_after
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = findOrCreateEditor(newComment, false);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            @Override
            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                findOrCreateEditor(result, true).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, DoubleClickHandler handler) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    doubleClickPanel.addDoubleClickHandler(handler);
    if (isFile) {
        doubleClickPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    patchSet.addDoubleClickHandler(handler);
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    if (isFile()) {
        linkPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private boolean isFile() {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    return !(// 
    isCommitMessage || // 
    (side == Side.A && 0 >= script.getA().size()) || (side == Side.B && 0 >= script.getB().size()));
}
#method_after
public boolean isFile() {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    return !(// 
    isCommitMessage || // 
    (side == Side.A && 0 >= script.getA().size()) || (side == Side.B && 0 >= script.getB().size()));
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, PC, psListOfHeaderA);
    table.setWidget(rowOfTableHeaderB, PC, psListOfHeaderB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#end_block

#method_before
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#method_after
@Override
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#end_block

#method_before
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            createCommentEditor(suggestRow, column, newComment).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#method_after
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            findOrCreateCommentEditor(suggestRow, column, newComment, true).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#end_block

#method_before
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    createEditor(newComment).setFocus(true);
}
#method_after
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    findOrCreateEditor(newComment, true).setFocus(true);
}
#end_block

#method_before
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = createEditor(newComment);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                createEditor(result).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#method_after
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = findOrCreateEditor(newComment, false);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            @Override
            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                findOrCreateEditor(result, true).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
    // Populate icons to lineNumber column header.
    if (psListOfHeaderA.isFile) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (psListOfHeaderB.isFile) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
    // Populate icons to lineNumber column header.
    if (headerSideA.isFile()) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (headerSideB.isFile()) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, PC, psListOfHeaderA);
    table.setWidget(rowOfTableHeaderB, PC, psListOfHeaderB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#end_block

#method_before
public Widget topic(final Change chg) {
    final Branch.NameKey dst = chg.getDest();
    FlowPanel fp = new FlowPanel();
    fp.add(new BranchLink(chg.getTopic(), chg.getProject(), chg.getStatus(), dst.get(), chg.getTopic()));
    ChangeDetailCache detailCache = ChangeCache.get(chg.getId()).getChangeDetailCache();
    ChangeDetail changeDetail = detailCache.get();
    if (changeDetail.canEditTopicName()) {
        final Image edit = new Image(Gerrit.RESOURCES.edit());
        edit.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AlterTopicDialog(chg).center();
            }
        });
        edit.addStyleName(Gerrit.RESOURCES.css().changeInfoBlockEdit());
        fp.add(edit);
    }
    return fp;
}
#method_after
public Widget topic(final Change chg) {
    final Branch.NameKey dst = chg.getDest();
    FlowPanel fp = new FlowPanel();
    fp.addStyleName(Gerrit.RESOURCES.css().changeInfoTopicPanel());
    fp.add(new BranchLink(chg.getTopic(), chg.getProject(), chg.getStatus(), dst.get(), chg.getTopic()));
    ChangeDetailCache detailCache = ChangeCache.get(chg.getId()).getChangeDetailCache();
    ChangeDetail changeDetail = detailCache.get();
    if (changeDetail.canEditTopicName()) {
        final Image edit = new Image(Gerrit.RESOURCES.edit());
        edit.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AlterTopicDialog(chg).center();
            }
        });
        fp.add(edit);
    }
    return fp;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return typeRuleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<String> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate().toJava();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    // Take only the first result and convert it to SubmitTypeRecord
    // This logic will need to change once we support multiple submit types
    // in the UI
    String typeName = results.get(0);
    try {
        return SubmitTypeRecord.OK(Project.SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#method_after
@SuppressWarnings("unchecked")
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    try {
        if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<String> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate().toJava();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    // Take only the first result and convert it to SubmitTypeRecord
    // This logic will need to change once we support multiple submit types
    // in the UI
    String typeName = results.get(0);
    try {
        return SubmitTypeRecord.OK(Project.SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    final PatchSet.Id pId = patchSet.getId();
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            Account.Id authoId = psInfoFactory.get(db, pId).getAuthor().getAccount();
            if (authoId == null) {
                p.author = new AccountAttribute();
                p.author.email = "";
                p.author.name = "[Forge Author or non-gerrit User]";
                p.author.username = "";
            } else {
                p.author = asAccountAttribute(authoId);
            }
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    final PatchSet.Id pId = patchSet.getId();
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            UserIdentity author = psInfoFactory.get(db, pId).getAuthor();
            if (author.getAccount() == null) {
                p.author = new AccountAttribute();
                p.author.email = author.getEmail();
                p.author.name = author.getName();
                p.author.username = "";
            } else {
                p.author = asAccountAttribute(author.getAccount());
            }
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    final Project.NameKey projectName = new Project.NameKey(entityName);
                    final ProjectState projectState = projectCache.get(projectName);
                    if (defaultDashboard) {
                        dashboards = Maps.newTreeMap();
                        DashboardInfo info = findProjectDefaultDashboard(projectState);
                        dashboards.put(info.id, info);
                    } else {
                        dashboards = allDashboardsFor(projectState);
                    }
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    final Project.NameKey projectName = new Project.NameKey(entityName);
                    final ProjectState projectState = projectCache.get(projectName);
                    DashboardInfo defaultInfo = findProjectDefaultDashboard(projectState);
                    if (defaultDashboard) {
                        dashboards = Maps.newTreeMap();
                        if (defaultInfo != null) {
                            dashboards.put(defaultInfo.id, defaultInfo);
                        }
                    } else {
                        dashboards = allDashboardsFor(projectState, defaultInfo != null ? defaultInfo.id : null);
                    }
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private Map<String, DashboardInfo> allDashboardsFor(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards);
        parent = projectState.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        projectState = projectCache.get(parent);
    } while (projectState != null);
    projectState = projectCache.getAllProjects();
    parent = projectState.getProject().getNameKey();
    if (seen.add(parent)) {
        dashboards = addProjectDashboards(projectState, dashboards);
    }
    for (String id : dashboards.keySet()) {
        DashboardInfo info = dashboards.get(id);
        info.parameters = info.parameters.replaceAll("[$][{]project[}]", projectName.get());
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> allDashboardsFor(ProjectState projectState, final String defaultId) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards, defaultId);
        parent = projectState.getProject().getParent(allProjects);
        projectState = projectCache.get(parent);
    } while (projectState != null && seen.add(parent));
    for (String id : dashboards.keySet()) {
        replaceTokens(dashboards.get(id), projectName.get());
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState);
    dashboards.putAll(all);
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState, defaultId);
    dashboards.putAll(all);
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectControl.getProject(), repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectControl.getProject(), repo, revWalk, ref, defaultId));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> loadDashboards(final Project project, final Repository repo, final RevWalk revWalk, final Ref ref) throws IOException {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            final DashboardInfo info = loadDashboard(project, ref.getName(), treeWalk.getPathString(), loader);
            dashboards.put(info.id, info);
        }
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> loadDashboards(final Project project, final Repository repo, final RevWalk revWalk, final Ref ref, final String defaultId) throws IOException {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            final DashboardInfo info = loadDashboard(project, ref.getName(), treeWalk.getPathString(), defaultId, loader);
            dashboards.put(info.id, info);
        }
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#end_block

#method_before
private DashboardInfo findProjectDefaultDashboard(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    DashboardInfo info;
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    boolean considerLocal = true;
    do {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
        if (info != null) {
            return info;
        }
        parent = projectState.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        projectState = projectCache.get(parent);
        considerLocal = false;
    } while (projectState != null);
    projectState = projectCache.getAllProjects();
    parent = projectState.getProject().getNameKey();
    if (seen.add(parent)) {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
    }
    return info;
}
#method_after
private DashboardInfo findProjectDefaultDashboard(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    DashboardInfo info;
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    boolean considerLocal = true;
    do {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
        if (info != null) {
            replaceTokens(info, projectName.get());
            return info;
        }
        considerLocal = false;
        parent = projectState.getProject().getParent(allProjects);
        projectState = projectCache.get(parent);
    } while (projectState != null && seen.add(parent));
    return null;
}
#end_block

#method_before
private DashboardInfo loadProjectDefaultDashboard(final ProjectState projectState, boolean considerLocal) {
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return null;
    }
    final Project project = projectControl.getProject();
    String defaultDashboardId = project.getDefaultDashboard();
    if (considerLocal && project.getLocalDefaultDashboard() != null) {
        defaultDashboardId = project.getLocalDefaultDashboard();
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    DashboardInfo info = loadDashboard(projectControl, defaultDashboardId);
    info.parameters = info.parameters.replaceAll("[$][{]project[}]", projectName.get());
    return info;
}
#method_after
private DashboardInfo loadProjectDefaultDashboard(final ProjectState projectState, boolean considerLocal) {
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return null;
    }
    final Project project = projectControl.getProject();
    String defaultDashboardId = project.getDefaultDashboard();
    if (considerLocal && project.getLocalDefaultDashboard() != null) {
        defaultDashboardId = project.getLocalDefaultDashboard();
    }
    if (defaultDashboardId == null) {
        return null;
    }
    return loadDashboard(projectControl, defaultDashboardId, defaultDashboardId);
}
#end_block

#method_before
private DashboardInfo loadDashboard(final Project project, final String refName, final String path, final ObjectLoader loader) throws IOException, ConfigInvalidException {
    DashboardInfo info = new DashboardInfo();
    info.dashboardName = path;
    info.refName = refName;
    info.projectName = project.getName();
    info.id = createId(info.refName, info.dashboardName);
    final String defaultDashboardId = project.getLocalDefaultDashboard() != null ? project.getLocalDefaultDashboard() : project.getDefaultDashboard();
    info.isDefault = info.id.equals(defaultDashboardId);
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    loader.copyTo(out);
    Config dashboardConfig = new Config();
    dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
    info.description = dashboardConfig.getString("main", null, "description");
    final StringBuilder query = new StringBuilder();
    query.append("title=");
    query.append(info.dashboardName.replaceAll(" ", "+"));
    final Set<String> sections = dashboardConfig.getSubsections("section");
    for (final String section : sections) {
        query.append("&");
        query.append(section.replaceAll(" ", "+"));
        query.append("=");
        query.append(dashboardConfig.getString("section", section, "query"));
    }
    info.parameters = query.toString();
    return info;
}
#method_after
private DashboardInfo loadDashboard(final ProjectControl projectControl, final String dashboardId, final String defaultId) {
    StringTokenizer t = new StringTokenizer(dashboardId, ":");
    if (t.countTokens() != 2) {
        throw new IllegalStateException("failed to load dashboard, invalid dashboard id: " + dashboardId);
    }
    final String refName = t.nextToken();
    final String path = t.nextToken();
    Repository repo = null;
    RevWalk revWalk = null;
    TreeWalk treeWalk = null;
    try {
        repo = repoManager.openRepository(projectControl.getProject().getNameKey());
        final Ref ref = repo.getRef(refName);
        if (ref == null) {
            return null;
        }
        if (!projectControl.controlForRef(ref.getName()).canRead()) {
            return null;
        }
        revWalk = new RevWalk(repo);
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        treeWalk = new TreeWalk(repo);
        treeWalk.addTree(commit.getTree());
        treeWalk.setRecursive(true);
        treeWalk.setFilter(PathFilter.create(path));
        if (!treeWalk.next()) {
            return null;
        }
        final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
        return loadDashboard(projectControl.getProject(), refName, path, defaultId, loader);
    } catch (IOException e) {
        log.warn("Failed to load default dashboard", e);
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + projectControl.getProject().getName() + " from ref " + refName, e);
    } finally {
        if (treeWalk != null) {
            treeWalk.release();
        }
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return null;
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> output;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    output = allDashboardsFor(new Project.NameKey(entityName));
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            output = Maps.newTreeMap();
        }
        format.newGson().toJson(output, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    final Project.NameKey projectName = new Project.NameKey(entityName);
                    final ProjectState projectState = projectCache.get(projectName);
                    DashboardInfo defaultInfo = findProjectDefaultDashboard(projectState);
                    if (defaultDashboard) {
                        dashboards = Maps.newTreeMap();
                        if (defaultInfo != null) {
                            dashboards.put(defaultInfo.id, defaultInfo);
                        }
                    } else {
                        dashboards = allDashboardsFor(projectState, defaultInfo != null ? defaultInfo.id : null);
                    }
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private Map<String, DashboardInfo> allDashboardsFor(final Project.NameKey projectName) {
    ProjectState projectState = projectCache.get(projectName);
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards);
        parent = projectState.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        projectState = projectCache.get(parent);
    } while (projectState != null);
    projectState = projectCache.getAllProjects();
    parent = projectState.getProject().getNameKey();
    if (seen.add(parent)) {
        dashboards = addProjectDashboards(projectState, dashboards);
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> allDashboardsFor(ProjectState projectState, final String defaultId) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards, defaultId);
        parent = projectState.getProject().getParent(allProjects);
        projectState = projectCache.get(parent);
    } while (projectState != null && seen.add(parent));
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState);
    dashboards.putAll(all);
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState, defaultId);
    dashboards.putAll(all);
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState) {
    final Map<String, DashboardInfo> output = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return output;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                revWalk = new RevWalk(repo);
                output.putAll(loadDashboards(repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards", e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return output;
}
#method_after
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectControl.getProject(), repo, revWalk, ref, defaultId));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> loadDashboards(final Repository repo, final RevWalk revWalk, final Ref ref) throws IOException {
    final Map<String, DashboardInfo> output = Maps.newTreeMap();
    final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
    final RevTree tree = commit.getTree();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            DashboardInfo info = new DashboardInfo();
            final String path = treeWalk.getPathString();
            info.name = ref.getName().substring(REFS_DASHBOARDS.length()) + " " + path;
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            loader.copyTo(out);
            Config dashboardConfig = new Config();
            try {
                dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
            } catch (ConfigInvalidException e) {
                log.warn("Failed to load dashboards", e);
            }
            info.description = dashboardConfig.getString("main", null, "description");
            final StringBuilder query = new StringBuilder();
            query.append("title=");
            query.append(path.replaceAll(" ", "+"));
            final Set<String> sections = dashboardConfig.getSubsections("section");
            for (final String section : sections) {
                query.append("&");
                query.append(section.replaceAll(" ", "+"));
                query.append("=");
                query.append(dashboardConfig.getString("section", section, "query"));
            }
            info.parameters = query.toString();
            output.put(info.name, info);
        }
    } finally {
        treeWalk.release();
    }
    return output;
}
#method_after
private Map<String, DashboardInfo> loadDashboards(final Project project, final Repository repo, final RevWalk revWalk, final Ref ref, final String defaultId) throws IOException {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            final DashboardInfo info = loadDashboard(project, ref.getName(), treeWalk.getPathString(), defaultId, loader);
            dashboards.put(info.id, info);
        }
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#end_block

#method_before
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix("/admin/groups/", token)) {
                group();
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix("/admin/projects/", token)) {
                Gerrit.display(token, selectProject());
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            AccountGroup.Id groupId = null;
            AccountGroup.UUID groupUUID = null;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    groupUUID = AccountGroup.UUID.parse(p);
                    panel = null;
                } else {
                    groupUUID = AccountGroup.UUID.parse(p.substring(0, c));
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix("/admin/groups/", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    groupId = AccountGroup.Id.parse(p);
                    panel = null;
                } else {
                    groupId = AccountGroup.Id.parse(p.substring(0, c));
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            Util.GROUP_SVC.groupDetail(groupId, groupUUID, new GerritCallback<GroupDetail>() {

                @Override
                public void onSuccess(GroupDetail groupDetail) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (groupDetail.group.getType() == AccountGroup.Type.INTERNAL) {
                            Gerrit.display(toGroup(groupDetail.group.getId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(groupDetail, token));
                        } else {
                            Gerrit.display(toGroup(groupDetail.group.getId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(groupDetail, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(groupDetail, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(groupDetail, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix("/admin/projects/", token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashesScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix("/admin/groups/", token)) {
                group();
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix("/admin/projects/", token)) {
                Gerrit.display(token, selectProject());
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            AccountGroup.Id groupId = null;
            AccountGroup.UUID groupUUID = null;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    groupUUID = AccountGroup.UUID.parse(p);
                    panel = null;
                } else {
                    groupUUID = AccountGroup.UUID.parse(p.substring(0, c));
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix("/admin/groups/", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    groupId = AccountGroup.Id.parse(p);
                    panel = null;
                } else {
                    groupId = AccountGroup.Id.parse(p.substring(0, c));
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            Util.GROUP_SVC.groupDetail(groupId, groupUUID, new GerritCallback<GroupDetail>() {

                @Override
                public void onSuccess(GroupDetail groupDetail) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (groupDetail.group.getType() == AccountGroup.Type.INTERNAL) {
                            Gerrit.display(toGroup(groupDetail.group.getId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(groupDetail, token));
                        } else {
                            Gerrit.display(toGroup(groupDetail.group.getId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(groupDetail, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(groupDetail, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(groupDetail, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix("/admin/projects/", token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
public void display(DashboardMap dashes) {
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    List<DashboardInfo> list = dashes.values().asList();
    Collections.sort(list, new Comparator<DashboardInfo>() {

        @Override
        public int compare(DashboardInfo a, DashboardInfo b) {
            return a.name().compareTo(b.name());
        }
    });
    for (DashboardInfo d : list) {
        insert(table.getRowCount(), d);
    }
    finishDisplay();
}
#method_after
public void display(DashboardMap dashes) {
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    List<DashboardInfo> list = dashes.values().asList();
    Collections.sort(list, new Comparator<DashboardInfo>() {

        @Override
        public int compare(DashboardInfo a, DashboardInfo b) {
            return a.id().compareTo(b.id());
        }
    });
    String section = null;
    for (DashboardInfo d : list) {
        if (!d.refName().equals(section)) {
            section = d.refName();
            insertTitleRow(table.getRowCount(), section);
        }
        insert(table.getRowCount(), d);
    }
    finishDisplay();
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            p.author = asAccountAttribute(psInfoFactory.get(db, patchSet.getId()).getAuthor().getAccount());
            Change change = db.changes().get(patchSet.getId().getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(patchSet.getId());
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s ", patchSet.getId()), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get deletions and insertions for %s ", patchSet.getId()), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    final PatchSet.Id pId = patchSet.getId();
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            p.author = asAccountAttribute(psInfoFactory.get(db, pId).getAuthor().getAccount());
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> output;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    output = projectDashboards(new Project.NameKey(entityName));
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            output = Maps.newTreeMap();
        }
        format.newGson().toJson(output, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    dashboards = projectDashboards(new Project.NameKey(entityName));
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private Map<String, DashboardInfo> projectDashboards(final Project.NameKey projectName) {
    final Map<String, DashboardInfo> output = Maps.newTreeMap();
    final ProjectState projectState = projectCache.get(projectName);
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return output;
    }
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                revWalk = new RevWalk(repo);
                output.putAll(loadDashboards(projectName, repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards", e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return output;
}
#method_after
private Map<String, DashboardInfo> projectDashboards(final Project.NameKey projectName) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectState projectState = projectCache.get(projectName);
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectName, repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> loadDashboards(final Project.NameKey projectName, final Repository repo, final RevWalk revWalk, final Ref ref) throws IOException {
    final Map<String, DashboardInfo> output = Maps.newTreeMap();
    final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
    final RevTree tree = commit.getTree();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            DashboardInfo info = new DashboardInfo();
            info.name = treeWalk.getPathString();
            info.refName = ref.getName();
            info.projectName = projectName.get();
            info.id = createId(info.refName, info.name);
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            loader.copyTo(out);
            Config dashboardConfig = new Config();
            try {
                dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
            } catch (ConfigInvalidException e) {
                log.warn("Failed to load dashboards", e);
            }
            info.description = dashboardConfig.getString("main", null, "description");
            final StringBuilder query = new StringBuilder();
            query.append("title=");
            query.append(info.name.replaceAll(" ", "+"));
            final Set<String> sections = dashboardConfig.getSubsections("section");
            for (final String section : sections) {
                query.append("&");
                query.append(section.replaceAll(" ", "+"));
                query.append("=");
                query.append(dashboardConfig.getString("section", section, "query"));
            }
            info.parameters = query.toString();
            output.put(info.id, info);
        }
    } finally {
        treeWalk.release();
    }
    return output;
}
#method_after
private Map<String, DashboardInfo> loadDashboards(final Project.NameKey projectName, final Repository repo, final RevWalk revWalk, final Ref ref) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            DashboardInfo info = new DashboardInfo();
            info.dashboardName = treeWalk.getPathString();
            info.refName = ref.getName();
            info.projectName = projectName.get();
            info.id = createId(info.refName, info.dashboardName);
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            loader.copyTo(out);
            Config dashboardConfig = new Config();
            dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
            info.description = dashboardConfig.getString("main", null, "description");
            final StringBuilder query = new StringBuilder();
            query.append("title=");
            query.append(info.dashboardName.replaceAll(" ", "+"));
            final Set<String> sections = dashboardConfig.getSubsections("section");
            for (final String section : sections) {
                query.append("&");
                query.append(section.replaceAll(" ", "+"));
                query.append("=");
                query.append(dashboardConfig.getString("section", section, "query"));
            }
            info.parameters = query.toString();
            dashboards.put(info.id, info);
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get() + " from ref " + ref.getName(), e);
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + projectName.get() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), CommitValidatorListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    newProgress.end();
    doReplaces();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                commandProgress.update(1);
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        if (cmd.getResult().equals(ReceiveCommand.Result.NOT_ATTEMPTED)) {
            cmd.execute(rp);
        }
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidatorListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.validate(cmd, project, ctl.getRefName(), c, currentUser);
        if (!validationResult.validated) {
            reject(cmd, validationResult.why);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        String pluginName = pluginLoader.getPluginName(validator);
        if (!validationResult.validated) {
            reject(cmd, String.format("%s (rejected by plugin %s)", validationResult.message, pluginName));
            return false;
        } else if (!Strings.isNullOrEmpty(validationResult.message)) {
            addMessage(String.format("%s (from plugin %s)", pluginName));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public static CommitValidationResult newFailure(String why) {
    return new CommitValidationResult(false, why);
}
#method_after
public static CommitValidationResult newFailure(String message) {
    return new CommitValidationResult(false, message);
}
#end_block

#method_before
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    String browserCssName;
    String prettifyCssName;
    String prettifyJsName;
    serveRegex(ROOT_REGEX).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#method_after
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    serveRegex(ROOT_REGEX).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#end_block

#method_before
private void setDefaultFields(FilterConfig config) throws ServletException {
    if (renderer != null && urls != null && accessFactory != null && resolver != null && visibilityCache != null) {
        return;
    }
    String configPath = config.getInitParameter(CONFIG_PATH_PARAM);
    if (configPath == null) {
        throw new ServletException("Missing required parameter " + configPath);
    }
    FileBasedConfig jgitConfig = new FileBasedConfig(new File(configPath), FS.DETECTED);
    try {
        jgitConfig.load();
    } catch (IOException e) {
        throw new ServletException(e);
    } catch (ConfigInvalidException e) {
        throw new ServletException(e);
    }
    if (renderer == null) {
        String staticPrefix = config.getServletContext().getContextPath() + STATIC_PREFIX;
        String customTemplates = jgitConfig.getString("gitiles", null, "customTemplates");
        String siteTitle = jgitConfig.getString("gitiles", null, "siteTitle");
        // TODO(dborowitz): Automatically set to true when run with mvn jetty:run.
        if (jgitConfig.getBoolean("gitiles", null, "reloadTemplates", false)) {
            renderer = new DebugRenderer(staticPrefix, customTemplates, Joiner.on(File.separatorChar).join(System.getProperty("user.dir"), "gitiles-servlet", "src", "main", "resources", "com", "google", "gitiles", "templates"), siteTitle);
        } else {
            renderer = new DefaultRenderer(staticPrefix, Renderer.toFileURL(customTemplates), siteTitle);
        }
    }
    if (urls == null) {
        try {
            urls = new DefaultUrls(jgitConfig.getString("gitiles", null, "canonicalHostName"), getBaseGitUrl(jgitConfig), getGerritUrl(jgitConfig));
        } catch (UnknownHostException e) {
            throw new ServletException(e);
        }
    }
    linkifier = new Linkifier(urls);
    if (accessFactory == null || resolver == null) {
        String basePath = jgitConfig.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = jgitConfig.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(jgitConfig), fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
    if (visibilityCache == null) {
        if (jgitConfig.getSubsections("cache").contains("visibility")) {
            visibilityCache = new VisibilityCache(false, ConfigUtil.getCacheBuilder(jgitConfig, "visibility"));
        } else {
            visibilityCache = new VisibilityCache(false);
        }
    }
}
#method_after
private void setDefaultFields(FilterConfig config) throws ServletException {
    if (renderer != null && urls != null && accessFactory != null && resolver != null && visibilityCache != null) {
        return;
    }
    String configPath = config.getInitParameter(CONFIG_PATH_PARAM);
    if (configPath == null) {
        throw new ServletException("Missing required parameter " + configPath);
    }
    FileBasedConfig jgitConfig = new FileBasedConfig(new File(configPath), FS.DETECTED);
    try {
        jgitConfig.load();
    } catch (IOException e) {
        throw new ServletException(e);
    } catch (ConfigInvalidException e) {
        throw new ServletException(e);
    }
    if (renderer == null) {
        String staticPrefix = config.getServletContext().getContextPath() + STATIC_PREFIX;
        String customTemplates = jgitConfig.getString("gitiles", null, "customTemplates");
        String siteTitle = Objects.firstNonNull(jgitConfig.getString("gitiles", null, "siteTitle"), "Gitiles");
        // TODO(dborowitz): Automatically set to true when run with mvn jetty:run.
        if (jgitConfig.getBoolean("gitiles", null, "reloadTemplates", false)) {
            renderer = new DebugRenderer(staticPrefix, customTemplates, Joiner.on(File.separatorChar).join(System.getProperty("user.dir"), "gitiles-servlet", "src", "main", "resources", "com", "google", "gitiles", "templates"), siteTitle);
        } else {
            renderer = new DefaultRenderer(staticPrefix, Renderer.toFileURL(customTemplates), siteTitle);
        }
    }
    if (urls == null) {
        try {
            urls = new DefaultUrls(jgitConfig.getString("gitiles", null, "canonicalHostName"), getBaseGitUrl(jgitConfig), getGerritUrl(jgitConfig));
        } catch (UnknownHostException e) {
            throw new ServletException(e);
        }
    }
    linkifier = new Linkifier(urls);
    if (accessFactory == null || resolver == null) {
        String basePath = jgitConfig.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = jgitConfig.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(jgitConfig), fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
    if (visibilityCache == null) {
        if (jgitConfig.getSubsections("cache").contains("visibility")) {
            visibilityCache = new VisibilityCache(false, ConfigUtil.getCacheBuilder(jgitConfig, "visibility"));
        } else {
            visibilityCache = new VisibilityCache(false);
        }
    }
}
#end_block

#method_before
private void add(RecipientType type, Watchers.List list) {
    for (Account.Id user : list.accounts) {
        add(type, user);
    }
    for (Address addr : list.emails) {
        add(type, addr);
    }
}
#method_after
protected void add(RecipientType type, Watchers.List list) {
    for (Account.Id user : list.accounts) {
        add(type, user);
    }
    for (Address addr : list.emails) {
        add(type, addr);
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && ChangeUtil.canDoRebase(db, change, repoManager));
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<PatchSet.Id> descendants = new HashSet<PatchSet.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                if (descendants.add(a.getPatchSet())) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null && ac.getProject().equals(detail.getChange().getProject())) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final PatchSet.Id a : descendants) {
        final Change ac = m.get(a.getParentKey());
        if (ac != null && ac.currentPatchSetId().equals(a)) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    currentDepPatchSets = new ArrayList<PatchSet>();
    currentDepChanges = new ArrayList<Change>();
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    currentPatchSetAncestors = db.patchSetAncestors().ancestorsOf(psId).toList();
    for (PatchSetAncestor a : currentPatchSetAncestors) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            currentDepPatchSets.add(p);
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<PatchSet.Id> descendants = new HashSet<PatchSet.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                if (descendants.add(a.getPatchSet())) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final CurrentUser currentUser = control.getCurrentUser();
    Account.Id currentUserId = null;
    if (currentUser instanceof IdentifiedUser) {
        currentUserId = ((IdentifiedUser) currentUser).getAccountId();
    }
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null && ac.getProject().equals(detail.getChange().getProject())) {
            currentDepChanges.add(ac);
            if (ac.getStatus().getCode() != Change.STATUS_DRAFT || ac.getOwner().equals(currentUserId) || isReviewer(ac)) {
                dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
            }
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final PatchSet.Id a : descendants) {
        final Change ac = m.get(a.getParentKey());
        if (ac != null && ac.currentPatchSetId().equals(a)) {
            if (ac.getStatus().getCode() != Change.STATUS_DRAFT || ac.getOwner().equals(currentUserId) || isReviewer(ac)) {
                neededBy.add(newChangeInfo(ac, null));
            }
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
protected void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#method_after
private void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final String username = webSession.get().getCurrentUser().getUserName();
    final String what = "sign out";
    final AuditEvent record = new AuditEvent(sid, username, what, null);
    try {
        doLogout(req, rsp);
    } finally {
        record.setResult("{\"Success\":true}");
        audit.track(record);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final CurrentUser currentUser = webSession.get().getCurrentUser();
    final String what = "sign out";
    final long when = System.currentTimeMillis();
    try {
        doLogout(req, rsp);
    } finally {
        audit.dispatch(new AuditEvent(sid, currentUser, what, when, null, null));
    }
}
#end_block

#method_before
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = new Context(s, commandLine);
}
#method_after
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = sshScope.newContext(s, commandLine);
}
#end_block

#method_before
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = SshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            SshScope.set(old);
        }
    }
}
#method_after
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = sshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            sshScope.set(old);
        }
    }
}
#end_block

#method_before
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = SshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                SshScope.set(old);
            }
        }
    }
}
#method_after
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = sshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                sshScope.set(old);
            }
        }
    }
}
#end_block

#method_before
static String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#method_after
static public String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", Collections.emptyList());
}
#method_after
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", new String[] {});
}
#end_block

#method_before
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", Arrays.asList(sd.getRemoteAddressAsString()));
}
#method_after
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", new String[] { sd.getRemoteAddressAsString() });
}
#end_block

#method_before
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), getCommandArgs(commandLine));
}
#method_after
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), CommandFactoryProvider.split(commandLine));
}
#end_block

#method_before
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", Collections.emptyList());
}
#method_after
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", new String[] {});
}
#end_block

#method_before
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#method_after
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#end_block

#method_before
void audit(Object result, String commandName, List<?> args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final String username = extractUsername(ctx);
    final long elapsed = extractElapsed(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.track(new AuditEvent(sid, username, "ssh:" + what, created, args, result, elapsed));
}
#method_after
void audit(Object result, String commandName, String[] args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + what, created, Arrays.asList(args), result));
}
#end_block

#method_before
private String extractWhat(String commandName, List<?> args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.size() > 1)
            result = "gerrit" + "." + args.get(1);
    }
    return result;
}
#method_after
private String extractWhat(String commandName, String[] args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.length > 1)
            result = "gerrit" + "." + args[1];
    }
    return result;
}
#end_block

#method_before
@Override
protected GsonBuilder createGsonBuilder() {
    final GsonBuilder g = super.createGsonBuilder();
    g.registerTypeAdapter(org.eclipse.jgit.diff.Edit.class, new org.eclipse.jgit.diff.EditDeserializer());
    return g;
}
#method_after
@Override
protected GsonBuilder createGsonBuilder() {
    return gerritDefaultGsonBuilder();
}
#end_block

#method_before
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        try {
            audit();
        } catch (Throwable ignoreExceptionWhileLogging) {
        } finally {
            currentCall.set(null);
        }
    }
}
#method_after
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        audit();
        currentCall.set(null);
    }
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final Gson gson = createGsonBuilder().setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).setVersion(1.0).create();
            final String sid = call.getWebSession().getToken();
            final String username = extractUsername(call);
            final List<Object> args = extractParams(note, call, gson);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.track(new AuditEvent(sid, username, what, call.getWhen(), args, result, call.getElapsed()));
        }
    } catch (Throwable all) {
        LOG.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getToken();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final List<Object> args = extractParams(note, call);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private List<Object> extractParams(final Audit note, final GerritCall call, Gson gson) {
    final List<Object> args = new ArrayList<Object>();
    final Object[] params = call.getParams();
    final int[] obfuscate = note.obfuscate();
    for (int i = 0; i < params.length; i++) {
        Object param = params[i];
        if (obfuscate.length > 0) {
            for (int id : obfuscate) {
                if (id == i) {
                    param = "*****";
                    break;
                }
            }
        }
        args.add(param);
    }
    return args;
}
#method_after
private List<Object> extractParams(final Audit note, final GerritCall call) {
    List<Object> args = Lists.newArrayList(Arrays.asList(call.getParams()));
    for (int idx : note.obfuscate()) {
        args.set(idx, "*****");
    }
    return args;
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (Character.isLowerCase(c) != ccase) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#end_block

#method_before
public Object getResult() {
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        LOG.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        LOG.error("No permissions to access result field");
    }
    return null;
}
#method_after
public Object getResult() {
    if (resultField == null) {
        return null;
    }
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        log.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        log.error("No permissions to access result field");
    }
    return null;
}
#end_block

#method_before
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null)
        return super.getMethod();
    else
        return currentMethod.get();
}
#method_after
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null) {
        return super.getMethod();
    } else {
        return currentMethod.get();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return asString().hashCode();
}
#method_after
@Override
public int hashCode() {
    return uuid.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.asString().equals(other.asString());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.uuid.equals(other.uuid);
}
#end_block

#method_before
@Override
public String toString() {
    return asString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            Object param = params.get(i);
            if (param == null) {
                sb.append("null");
            } else {
                sb.append(param);
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#end_block

#method_before
private InitStep loadInitStep(File jar) {
    try {
        ClassLoader pluginLoader = new URLClassLoader(new URL[] { jar.toURI().toURL() }, InitPluginStepsLoader.class.getClassLoader());
        JarFile jarFile = new JarFile(jar);
        Attributes jarFileAttributes = jarFile.getManifest().getMainAttributes();
        String initClassName = jarFileAttributes.getValue("Gerrit-InitStep");
        if (initClassName == null) {
            return null;
        }
        @SuppressWarnings("unchecked")
        Class<? extends InitStep> initStepClass = (Class<? extends InitStep>) pluginLoader.loadClass(initClassName);
        return initInjector.getInstance(initStepClass);
    } catch (ClassCastException e) {
        log.warn("InitStep from plugin " + jar.getName() + " does not implement " + InitStep.class.getName(), e);
        return null;
    } catch (Exception e) {
        log.error("Cannot load and get plugin init step for " + jar, e);
        return null;
    }
}
#method_after
private InitStep loadInitStep(File jar) {
    try {
        ClassLoader pluginLoader = new URLClassLoader(new URL[] { jar.toURI().toURL() }, InitPluginStepsLoader.class.getClassLoader());
        JarFile jarFile = new JarFile(jar);
        Attributes jarFileAttributes = jarFile.getManifest().getMainAttributes();
        String initClassName = jarFileAttributes.getValue("Gerrit-InitStep");
        if (initClassName == null) {
            return null;
        }
        @SuppressWarnings("unchecked")
        Class<? extends InitStep> initStepClass = (Class<? extends InitStep>) pluginLoader.loadClass(initClassName);
        return getPluginInjector(jar).getInstance(initStepClass);
    } catch (ClassCastException e) {
        ui.message("WARN: InitStep from plugin %s does not implement %s (Exception: %s)", jar.getName(), InitStep.class.getName(), e.getMessage());
        return null;
    } catch (Exception e) {
        ui.message("WARN: Cannot load and get plugin init step for %s (Exception: %s)", jar, e.getMessage());
        return null;
    }
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") && pathname.isFile());
        }
    });
    if (matches == null) {
        ui.message("WARN: Cannot list %s", pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    Arrays.sort(matches, new Comparator<File>() {

        @Override
        public int compare(File o1, File o2) {
            return o1.getName().compareTo(o2.getName());
        }
    });
    return Arrays.asList(matches);
}
#end_block

#method_before
private void initPlugins() throws Exception {
    Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps();
    for (InitStep initStep : pluginsInitSteps) {
        initStep.run();
    }
}
#method_after
private void initPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        initStep.run();
    }
}
#end_block

#method_before
private void recursivelyExpandGroups(final Set<String> groupDNs, final LdapSchema schema, final DirContext ctx, final String groupDN) {
    if (groupDNs.add(groupDN) && schema.accountMemberField != null) {
        Set<String> cachedGroupDNs = groupsByInclude.getIfPresent(groupDN);
        if (cachedGroupDNs != null) {
            for (String cachedGroupDN : cachedGroupDNs) {
                recursivelyExpandGroups(groupDNs, schema, ctx, cachedGroupDN);
            }
        } else {
            // 
            try {
                final Name compositeGroupName = new CompositeName().add(groupDN);
                final Attribute in = ctx.getAttributes(compositeGroupName).get(schema.accountMemberField);
                cachedGroupDNs = new HashSet<String>();
                if (in != null) {
                    final NamingEnumeration<?> groups = in.getAll();
                    try {
                        while (groups.hasMore()) {
                            final String nextDN = (String) groups.next();
                            cachedGroupDNs.add(nextDN);
                            recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
                        }
                    } catch (PartialResultException e) {
                    }
                }
                groupsByInclude.put(groupDN, cachedGroupDNs);
            } catch (NamingException e) {
                LdapRealm.log.warn("Could not find group " + groupDN, e);
            }
        }
    }
}
#method_after
private void recursivelyExpandGroups(final Set<String> groupDNs, final LdapSchema schema, final DirContext ctx, final String groupDN) {
    if (groupDNs.add(groupDN) && schema.accountMemberField != null) {
        ImmutableSet<String> cachedGroupDNs = groupsByInclude.getIfPresent(groupDN);
        if (cachedGroupDNs == null) {
            // Recursively identify the groups it is a member of.
            ImmutableSet.Builder<String> dns = ImmutableSet.builder();
            try {
                final Name compositeGroupName = new CompositeName().add(groupDN);
                final Attribute in = ctx.getAttributes(compositeGroupName).get(schema.accountMemberField);
                if (in != null) {
                    final NamingEnumeration<?> groups = in.getAll();
                    try {
                        while (groups.hasMore()) {
                            dns.add((String) groups.next());
                        }
                    } catch (PartialResultException e) {
                    }
                }
            } catch (NamingException e) {
                LdapRealm.log.warn("Could not find group " + groupDN, e);
            }
            cachedGroupDNs = dns.build();
            groupsByInclude.put(groupDN, cachedGroupDNs);
        }
        for (String dn : cachedGroupDNs) {
            recursivelyExpandGroups(groupDNs, schema, ctx, dn);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    cache(GROUP_EXIST_CACHE, String.class, new TypeLiteral<Boolean>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.ExistenceLoader.class);
    cache(GROUPS_BY_INCLUDED, String.class, new TypeLiteral<Set<String>>() {
    }).expireAfterWrite(1, HOURS);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    cache(GROUP_EXIST_CACHE, String.class, new TypeLiteral<Boolean>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.ExistenceLoader.class);
    cache(GROUPS_BYINCLUDE_CACHE, String.class, new TypeLiteral<ImmutableSet<String>>() {
    }).expireAfterWrite(1, HOURS);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
}
#end_block

#method_before
private BufferingPrologControl newEmptyMachine(ClassLoader cl) {
    BufferingPrologControl ctl = new BufferingPrologControl();
    ctl.setMaxArity(PrologEnvironment.MAX_ARITY);
    ctl.setMaxDatabaseSize(DB_MAX);
    ctl.setPrologClassLoader(new PrologClassLoader(new PredicateClassLoader(predicateProviders, cl)));
    ctl.setEnabled(EnumSet.allOf(Prolog.Feature.class), false);
    List<String> packages = new LinkedList<String>(PACKAGE_LIST);
    for (PredicateProvider predicateProvider : predicateProviders) {
        packages.addAll(predicateProvider.getPackages());
    }
    // Bootstrap the interpreter and ensure there is clean state.
    ctl.initialize(packages.toArray(new String[packages.size()]));
    return ctl;
}
#method_after
private BufferingPrologControl newEmptyMachine(ClassLoader cl) {
    BufferingPrologControl ctl = new BufferingPrologControl();
    ctl.setMaxArity(PrologEnvironment.MAX_ARITY);
    ctl.setMaxDatabaseSize(DB_MAX);
    ctl.setPrologClassLoader(new PrologClassLoader(new PredicateClassLoader(predicateProviders, cl)));
    ctl.setEnabled(EnumSet.allOf(Prolog.Feature.class), false);
    List<String> packages = Lists.newArrayList();
    packages.addAll(PACKAGE_LIST);
    for (PredicateProvider predicateProvider : predicateProviders) {
        packages.addAll(predicateProvider.getPackages());
    }
    // Bootstrap the interpreter and ensure there is clean state.
    ctl.initialize(packages.toArray(new String[packages.size()]));
    return ctl;
}
#end_block

#method_before
@Override
protected Class<?> findClass(final String className) throws ClassNotFoundException {
    final Set<ClassLoader> classLoaders = packageClassLoaderMap.get(getPackageName(className));
    if (classLoaders != null) {
        for (final ClassLoader cl : classLoaders) {
            try {
                return Class.forName(className, true, cl);
            } catch (ClassNotFoundException e) {
            // ignore
            }
        }
    }
    throw new ClassNotFoundException(className);
}
#method_after
@Override
protected Class<?> findClass(final String className) throws ClassNotFoundException {
    final Collection<ClassLoader> classLoaders = packageClassLoaderMap.get(getPackageName(className));
    for (final ClassLoader cl : classLoaders) {
        try {
            return Class.forName(className, true, cl);
        } catch (ClassNotFoundException e) {
        // ignore
        }
    }
    throw new ClassNotFoundException(className);
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
            loadPlugins(result.plugnis);
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#end_block

#method_before
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    loadPlugins(hpd, token);
}
#end_block

#method_before
private void loadPlugins(String[] pluginsUrls) {
    for (final String url : pluginsUrls) {
        ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

            @Override
            public void onSuccess(Void result) {
            // does nothing
            }

            @Override
            public void onFailure(Exception reason) {
                Window.alert("Failed load pluing: " + url);
            }
        }).inject();
    }
}
#method_after
private void loadPlugins(HostPageData hpd, final String token) {
    if (hpd.plugins != null) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d = new ErrorDialog(reason);
                    d.setTitle(M.pluginFailed(url));
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar menuBar = new LinkMenuBar();
        addLink(menuBar, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(menuBar, C.menuPlugins(), PageLinks.ADMIN_PLUGINS);
                }
            }
        }, ADMINISTRATE_SERVER);
        menuLeft.add(menuBar, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar groupsBar = new LinkMenuBar();
        addLink(groupsBar, C.menuGroupsList(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(groupsBar, C.menuGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
            }
        }, CREATE_GROUP);
        menuLeft.add(groupsBar, C.menuGroups());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(groupsBar) + 1);
                }
            }
        }, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final byte[] raw;
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        final StringWriter w = new StringWriter();
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
        final byte[] userData = w.toString().getBytes("UTF-8");
        raw = concat(page.part1, userData, page.part2);
    } else {
        raw = page.full;
    }
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = raw == page.full ? page.full_gz : HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.removeAttribute("id");
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
@Override
public String getUrl() {
    // not used
    return null;
}
#method_after
@Override
public String getUrl() {
    // not used
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public String getUrl() {
    String database = optional(cfg, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#method_after
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    return required(cfg, "url");
}
#method_after
@Override
public String getUrl() {
    return ConfigUtil.getRequired(cfg, "database", "url");
}
#end_block

#method_before
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    String driver = optional(cfg, "driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = optional(cfg, "url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = optional(cfg, "username");
    String password = optional(cfg, "password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#method_after
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#end_block

#method_before
@Override
public final NamedInputStream getIndexScript() {
    return getScriptAsStream(indexScript);
}
#method_after
@Override
public ScriptRunner getIndexScript() throws IOException {
    return getScriptRunner("index_generic.sql");
}
#end_block

#method_before
@Override
public final NamedInputStream getNextValScript() {
    return getScriptAsStream(nextValScript);
}
#method_after
@Override
public ScriptRunner getNextValScript() throws IOException {
    return ScriptRunner.NOOP;
}
#end_block

#method_before
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    runScript(dataSourceType.getIndexScript(), db);
    runScript(dataSourceType.getNextValScript(), db);
}
#method_after
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    dataSourceType.getIndexScript().run(db);
    dataSourceType.getNextValScript().run(db);
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:postgresql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:postgresql://");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append("/");
    b.append(dbc.required("database"));
    return b.toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:mysql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbs = new ConfigSection(cfg, "database");
    b.append("jdbc:mysql://");
    b.append(hostname(dbs.optional("hostname")));
    b.append(port(dbs.optional("port")));
    b.append("/");
    b.append(dbs.required("database"));
    return b.toString();
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            display(result.getBranches());
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            if (caught instanceof RemoteJsonException) {
                final String msg = caught.getMessage();
                String userMsg = null;
                if (InvalidNameException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(nameTxtBox);
                    userMsg = Gerrit.M.invalidBranchName(branchName);
                } else if (InvalidRevisionException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(irevTxtBox);
                    userMsg = Gerrit.M.invalidRevision(rev);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String refnamePrefix = caught.getMessage().substring(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(refnamePrefix);
                } else if (msg.startsWith(BranchAlreadyExistsException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchAlreadyExistsException.MESSAGE.length());
                    userMsg = Gerrit.M.branchAlreadyExists(existingBranchName);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderExistingBranch.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchCreationNotAllowedUnderExistingBranch.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderExistingBranch(branchName, existingBranchName);
                }
                if (userMsg != null) {
                    new ErrorDialog(userMsg).center();
                    return;
                }
            }
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<AddBranchResult>() {

        public void onSuccess(final AddBranchResult result) {
            addBranch.setEnabled(true);
            if (!result.hasError()) {
                nameTxtBox.setText("");
                irevTxtBox.setText("");
                display(result.getListBranchesResult().getBranches());
            } else {
                final AddBranchResult.Error error = result.getError();
                final String msg;
                switch(error.getType()) {
                    case INVALID_NAME:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.invalidBranchName(branchName);
                        break;
                    case INVALID_REVISION:
                        selectAllAndFocus(irevTxtBox);
                        msg = Gerrit.M.invalidRevision(rev);
                        break;
                    case BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(error.getRefname());
                        break;
                    case BRANCH_ALREADY_EXISTS:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchAlreadyExists(error.getRefname());
                        break;
                    case BRANCH_CREATION_CONFLICT:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationConflict(branchName, error.getRefname());
                        break;
                    default:
                        msg = Gerrit.M.branchCreationFailed(branchName, error.toString());
                }
                new ErrorDialog(msg).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void deleteChecked() {
    final StringBuilder message = new StringBuilder();
    message.append("<b>").append(Gerrit.C.branchDeletionConfirmationMessage()).append("</b>");
    message.append("<p>");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                message.append(", <br>");
            }
            message.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    message.append("</p>");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

        @Override
        public void onOk() {
            Util.PROJECT_SVC.deleteBranch(getProjectKey(), ids, new GerritCallback<Set<Branch.NameKey>>() {

                public void onSuccess(final Set<Branch.NameKey> deleted) {
                    for (int row = 1; row < table.getRowCount(); ) {
                        final Branch k = getRowItem(row);
                        if (k != null && deleted.contains(k.getNameKey())) {
                            table.removeRow(row);
                        } else {
                            row++;
                        }
                    }
                }
            });
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException, BranchCreationNotAllowedUnderRefnamePrefixException, BranchAlreadyExistsException, BranchCreationNotAllowedUnderExistingBranch {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    if (MagicBranch.isMagicBranch(refname)) {
        throw new BranchCreationNotAllowedUnderRefnamePrefixException(MagicBranch.getMagicRefNamePrefix(refname));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        throw new BranchAlreadyExistsException(refname);
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new BranchCreationNotAllowedUnderExistingBranch(refPrefix);
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#method_after
@Override
public AddBranchResult call() throws NoSuchProjectException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_NAME, refname));
    }
    if (MagicBranch.isMagicBranch(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX, MagicBranch.getMagicRefNamePrefix(refname)));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_ALREADY_EXISTS, refname));
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_CONFLICT, refPrefix));
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_REVISION));
    } finally {
        repo.close();
    }
    return new AddBranchResult(listBranchesFactory.create(projectName).call());
}
#end_block

#method_before
private String getRefPrefix(final String refName) {
    int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#method_after
private static String getRefPrefix(final String refName) {
    final int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append("      $ scp -p -P 29418 review.example.com:hooks/commit-msg .git/hooks/");
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = rw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#method_after
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    try {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    } finally {
        rw.release();
    }
}
#end_block

#method_before
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final boolean isMergeable = !toMerge.isEmpty() ? createStrategy().dryRun(branchTip, toMerge.remove(0)) : false;
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable);
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            if (!toMerge.isEmpty()) {
                final Entry<SubmitType, CodeReviewCommit> e = toMerge.entries().iterator().next();
                final boolean isMergeable = createStrategy(e.getKey()).dryRun(branchTip, e.getValue());
                // update sha1 tested merge.
                if (destBranchRef != null) {
                    change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
                } else {
                    change.setLastSha1MergeTested(new RevId(""));
                }
                change.setMergeable(isMergeable);
                db.changes().update(Collections.singleton(change));
            } else {
                log.error("Test merge attempt for change: " + change.getId() + " failed");
            }
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        final List<Change> submitted = db.changes().submitted(destBranch).toList();
        final RefUpdate branchUpdate = openBranch();
        validateChangeList(submitted);
        preMerge();
        updateBranch(branchUpdate);
        updateChangeStatus(submitted);
        updateSubscriptions(submitted);
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void preMerge() throws MergeException {
    final SubmitStrategy strategy = createStrategy();
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#method_after
private void preMerge(final SubmitStrategy strategy, final List<CodeReviewCommit> toMerge) throws MergeException {
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#end_block

#method_before
private SubmitStrategy createStrategy() throws MergeException {
    return submitStrategyFactory.create(destProject.getSubmitType(), db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#end_block

#method_before
private void validateChangeList(final List<Change> submitted) throws MergeException {
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        commit.add(canMergeFlag);
        toMerge.add(commit);
    }
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateBranch(final RefUpdate branchUpdate) throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    potentiallyStillSubmittable.add(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#method_after
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            return createRandomObjectId();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#method_after
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        private final MutableObjectId buf = new MutableObjectId();

        private final static int LAST_BYTE = Constants.OBJECT_ID_LENGTH - 1;

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            // create non-existing dummy ID
            buf.setByte(LAST_BYTE, buf.getByte(LAST_BYTE) + 1);
            return buf.copy();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#end_block

#method_before
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#method_after
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#end_block

#method_before
private static CodeReviewCommit failed(final RevWalk rw, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#method_after
private static CodeReviewCommit failed(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#end_block

#method_before
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#method_after
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#end_block

#method_before
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final SubmitType submitType = toMerge.keys().iterator().next();
            preMerge(createStrategy(submitType), toMerge.get(submitType));
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable(change));
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final SubmitType submitType = toMerge.keySet().iterator().next();
            preMerge(createStrategy(submitType), toMerge.get(submitType));
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable(change));
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            for (final SubmitType submitType : toMerge.keys()) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                    }
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
public void start() {
    try {
        final ReviewDb db = schema.open();
        try {
            final CurrentSchemaVersion sVer = getSchemaVersion(db);
            final int eVer = version.get().getVersionNbr();
            if (sVer == null) {
                throw new ProvisionException("Schema not yet initialized." + "  Run init to initialize the schema:\n" + "$ java -jar gerrit.war init -d " + site.site_path.getAbsolutePath());
            }
            if (sVer.versionNbr != eVer) {
                throw new ProvisionException("Unsupported schema version " + sVer.versionNbr + "; expected schema version " + eVer + ".  Run init to upgrade:\n" + "$ java -jar gerrit.war init -d " + site.site_path.getAbsolutePath());
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        throw new ProvisionException("Cannot read schema_version", e);
    }
}
#method_after
public void start() {
    try {
        final ReviewDb db = schema.open();
        try {
            final CurrentSchemaVersion currentVer = getSchemaVersion(db);
            final int expectedVer = version.get().getVersionNbr();
            if (currentVer == null) {
                throw new ProvisionException("Schema not yet initialized." + "  Run init to initialize the schema:\n" + "$ java -jar gerrit.war init -d " + site.site_path.getAbsolutePath());
            }
            if (currentVer.versionNbr < expectedVer) {
                throw new ProvisionException("Unsupported schema version " + currentVer.versionNbr + "; expected schema version " + expectedVer + ".  Run init to upgrade:\n" + "$ java -jar gerrit.war init -d " + site.site_path.getAbsolutePath());
            } else if (currentVer.versionNbr > expectedVer) {
                throw new ProvisionException("Unsupported schema version " + currentVer.versionNbr + "; expected schema version " + expectedVer + ". Downgrade is not supported.");
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        throw new ProvisionException("Cannot read schema_version", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        final RevWalk recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                    }
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        ReviewDb reviewDb = schemaFactory.open();
        try {
            submitter = getSubmitter(reviewDb, c.currentPatchSetId());
        } finally {
            reviewDb.close();
        }
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    int h = 0;
    h = h * 31 + aId.hashCode();
    h = h * 31 + bId.hashCode();
    h = h * 31 + ignoreWhitespace.hashCode();
    return h;
}
#method_after
@Override
public int hashCode() {
    int h = 0;
    h = h * 31 + aId.hashCode();
    h = h * 31 + bId.hashCode();
    h = h * 31 + (ignoreWhitespace ? 1 : 0);
    return h;
}
#end_block

#method_before
@Override
public boolean equals(final Object o) {
    if (o instanceof IntraLineDiffKey) {
        final IntraLineDiffKey k = (IntraLineDiffKey) o;
        return // 
        aId.equals(k.aId) && // 
        bId.equals(k.bId) && ignoreWhitespace.equals(k.ignoreWhitespace);
    }
    return false;
}
#method_after
@Override
public boolean equals(final Object o) {
    if (o instanceof IntraLineDiffKey) {
        final IntraLineDiffKey k = (IntraLineDiffKey) o;
        return // 
        aId.equals(k.aId) && // 
        bId.equals(k.bId) && ignoreWhitespace == k.ignoreWhitespace;
    }
    return false;
}
#end_block

#method_before
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer();
}
#method_after
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#method_after
public boolean canRestore() {
    return // Anyone who can abandon the change can restore it back
    canAbandon() && // as long as you can upload too
    getRefControl().canUpload();
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    return evaluatePrologRules(db, patchSet, cd, fastEvalLabels, "submit_rule", "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, fastEvalLabels, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#end_block

#method_before
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#method_after
public static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
public void close() {
// FIXME: TBC
}
#method_after
public void close() {
// Do not really know at the moment if there should be something to release
// on the Jira side. Cannot find at the moment a "logout" XML-RPC API for this.
}
#end_block

#method_before
public void start() {
    try {
        JiraClientSession session = newSession();
        session.close();
    } catch (Exception e) {
        log.error("Cannot connect to Jira:", e);
    }
}
#method_after
public void start() {
    try {
        JiraClientSession session = newSession();
        session.close();
    } catch (XmlRpcException e) {
        log.error("Cannot validate Jira configuration and connectivity", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public void onGitReferenceUpdated(Event event) {
    try {
        final Repository repo = new RepositoryBuilder().setGitDir(new File(gitDir, event.getProjectName() + ".git")).setBare().build();
        RevWalk revWalk = new RevWalk(repo);
        JiraClientSession jira = jiraRpc.newSession();
        for (Update u : event.getUpdates()) {
            String newObjId = u.getNewObjectId();
            if (newObjId == null)
                continue;
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(newObjId));
            process(jira, u.getRefName(), commit);
        }
    } catch (Exception e) {
        log.error("Error processing event " + event, e);
    }
}
#method_after
public void onGitReferenceUpdated(Event event) {
    Repository repo;
    try {
        repo = repositoryManager.openRepository(new NameKey(event.getProjectName()));
    } catch (IOException e) {
        log.error("Cannot open Gerrit Project " + event.getProjectName(), e);
        return;
    }
    try {
        RevWalk revWalk = new RevWalk(repo);
        JiraClientSession jira;
        try {
            jira = jiraRpc.newSession();
        } catch (XmlRpcException e) {
            log.error("Cannot open a new session to Jira", e);
            return;
        }
        try {
            for (Update u : event.getUpdates()) {
                String newObjId = u.getNewObjectId();
                if (newObjId == null) {
                    continue;
                }
                RevCommit commit;
                try {
                    commit = revWalk.parseCommit(ObjectId.fromString(newObjId));
                } catch (Exception e) {
                    log.error("Unable to parse commit object " + newObjId + ": skipping to next update event", e);
                    continue;
                }
                process(jira, event.getProjectName(), u.getRefName(), commit);
            }
        } finally {
            jira.close();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private void process(JiraClientSession jira, String refName, RevCommit commit) throws XmlRpcException {
    String commitMsg = commit.getFullMessage();
    Matcher matcher = commentPattern.matcher(commitMsg);
    while (matcher.find()) {
        String matched = matcher.group();
        try {
            addComment(jira, matched, refName, commit);
        } catch (XmlRpcException e) {
            log.warn("Jira issue " + matched + " was not found: comment not added");
        }
    }
}
#method_after
private void process(JiraClientSession jira, String projectName, String refName, RevCommit commit) {
    String commitMsg = commit.getFullMessage();
    Matcher matcher = commentPattern.matcher(commitMsg);
    while (matcher.find()) {
        String matched = matcher.group();
        try {
            addComment(jira, matched, projectName, refName, commit);
        } catch (XmlRpcException e) {
            log.error("Unable to add new comment to Jira issue " + matched, e);
        }
    }
}
#end_block

#method_before
private void addComment(JiraClientSession jira, String commentMatch, String refName, RevCommit commit) throws XmlRpcException {
    Matcher matcher = issuePattern.matcher(commentMatch);
    if (!matcher.find())
        return;
    jira.addComment(matcher.group(), getComment(refName, commit));
}
#method_after
private void addComment(JiraClientSession jira, String commentMatch, String projectName, String refName, RevCommit commit) throws XmlRpcException {
    Matcher matcher = issuePattern.matcher(commentMatch);
    if (!matcher.find()) {
        return;
    }
    jira.addComment(matcher.group(), getComment(projectName, refName, commit));
}
#end_block

#method_before
private String getComment(String refName, RevCommit commit) {
    String commitId = commit.getName();
    String comment = String.format("Git commit: %s\n" + "Branch: %s\n" + "Author: %s\n" + "Committer: %s\n" + "%s", commitId, refName, getIdentity(commit.getAuthorIdent()), getIdentity(commit.getCommitterIdent()), commit.getFullMessage());
    if (gitwebUrl != null) {
        comment = comment + "\n" + gitwebUrl + "?p=dev-test.git;a=commit;h=" + commitId;
    }
    return comment;
}
#method_after
private String getComment(String projectName, String refName, RevCommit commit) {
    String commitId = commit.getName();
    String comment = String.format("Git commit: %s\n" + "Branch: %s\n" + "Author: %s\n" + "Committer: %s\n" + "%s", commitId, refName, getIdentity(commit.getAuthorIdent()), getIdentity(commit.getCommitterIdent()), commit.getFullMessage());
    if (gitwebUrl != null) {
        comment = String.format("%s\n%s?p=%s.git;a=commit;h=%s", comment, gitwebUrl, projectName, commitId);
    }
    return comment;
}
#end_block

#method_before
public List<ChangeData> queryChanges(final String queryString) throws OrmException, QueryParseException {
    final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
    Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
    List<ChangeData> results = new ArrayList<ChangeData>();
    HashSet<Change.Id> want = new HashSet<Change.Id>();
    for (ChangeData d : ((ChangeDataSource) s).read()) {
        if (d.hasChange()) {
            // 
            if (visibleToMe.match(d)) {
                results.add(d);
            }
        } else {
            want.add(d.getId());
        }
    }
    if (!want.isEmpty()) {
        for (Change c : db.get().changes().get(want)) {
            ChangeData d = new ChangeData(c);
            if (visibleToMe.match(d)) {
                results.add(d);
            }
        }
    }
    Collections.sort(results, sortkeyAfter != null ? cmpAfter : cmpBefore);
    int limit = limit(s);
    if (results.size() > maxLimit) {
        setMoreResults(true);
    }
    if (limit < results.size()) {
        results = results.subList(0, limit);
    }
    if (sortkeyAfter != null) {
        Collections.reverse(results);
    }
    return results;
}
#method_after
public List<ChangeData> queryChanges(final String queryString) throws OrmException, QueryParseException {
    final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
    Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
    List<ChangeData> results = new ArrayList<ChangeData>();
    HashSet<Change.Id> want = new HashSet<Change.Id>();
    for (ChangeData d : ((ChangeDataSource) s).read()) {
        if (d.hasChange()) {
            // 
            if (visibleToMe.match(d)) {
                results.add(d);
            }
        } else {
            want.add(d.getId());
        }
    }
    if (!want.isEmpty()) {
        for (Change c : db.get().changes().get(want)) {
            ChangeData d = new ChangeData(c);
            if (visibleToMe.match(d)) {
                results.add(d);
            }
        }
    }
    Collections.sort(results, sortkeyAfter != null ? cmpAfter : cmpBefore);
    int limit = limit(s);
    if (results.size() > maxLimit) {
        moreResults = true;
    }
    if (limit < results.size()) {
        results = results.subList(0, limit);
    }
    if (sortkeyAfter != null) {
        Collections.reverse(results);
    }
    return results;
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (hasMoreResults()) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (moreResults) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case FAST_FORWARD_ONLY:
                            break;
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                        default:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                        case FAST_FORWARD_ONLY:
                            // Not mergeable, no need to recheck.
                            break;
                        default:
                            log.warn("Lock failure in project with unknown merge type " + destProject.getSubmitType());
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = ConsoleUI.getInstance(batchMode);
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule());
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            bind(ReloadSiteLibrary.class).toInstance(new ReloadSiteLibrary() {

                @Override
                public void reload() {
                    Init.super.loadSiteLib();
                }
            });
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getLocalizedMessage());
        while (why != null) {
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = ConsoleUI.getInstance(batchMode);
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule());
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            bind(ReloadSiteLibrary.class).toInstance(new ReloadSiteLibrary() {

                @Override
                public void reload() {
                    Init.super.loadSiteLib();
                }
            });
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    try {
                        PatchSet.Id psId = d.getChange().currentPatchSetId();
                        Change.Id changeId = psId.getParentKey();
                        ChangeControl control = changeControlFactory.validateFor(changeId);
                        List<SubmitRecord> submitResult = control.canSubmit(db.get(), psId);
                        eventFactory.addSubmitRecords(c, submitResult);
                    } catch (OrmException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    } catch (NoSuchChangeException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    }
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    Change.Id changeId = psId.getParentKey();
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        switch(submitRecord.status) {
            case OK:
                sa.status = "OK";
                break;
            case NOT_READY:
                sa.status = "NOT_READY";
                if (!submitRecord.labels.isEmpty()) {
                    sa.labels = new ArrayList<SubmitLabelAttribute>();
                    for (SubmitRecord.Label lbl : submitRecord.labels) {
                        SubmitLabelAttribute la = new SubmitLabelAttribute();
                        la.label = lbl.label;
                        switch(lbl.status) {
                            case OK:
                                la.status = "OK";
                                break;
                            case REJECT:
                                la.status = "REJECT";
                                break;
                            case NEED:
                                la.status = "NEED";
                                break;
                            case IMPOSSIBLE:
                                la.status = "IMPOSSIBLE";
                                break;
                            default:
                                throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                        }
                        sa.labels.add(la);
                    }
                }
                break;
            case CLOSED:
                sa.status = "CLOSED";
                break;
            case RULE_ERROR:
                sa.status = "RULE_ERROR";
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#method_after
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        sa.status = submitRecord.status.name();
        if (submitRecord.status != SubmitRecord.Status.RULE_ERROR) {
            addSubmitRecordLabels(submitRecord, sa);
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    // reviewer see a draft.
                    if (control.forUser(user).isRefVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        // reviewer see a draft.
        if (!control.forUser(user).isRefVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final Change change = control.getChange();
    final PatchSet.Id psid = change.currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Execute hook for added reviewers
    // 
    final PatchSet patchSet = db.patchSets().get(psid);
    for (final Account.Id reviewer : added) {
        final Account account = db.accounts().get(reviewer);
        hooks.doReviewerAddedHook(change, account, patchSet, db);
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    // reviewer see a draft.
                    if (control.forUser(user).isRefVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        // reviewer see a draft.
        if (!control.forUser(user).isRefVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final Change change = control.getChange();
    final PatchSet.Id psid = change.currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Execute hook for added reviewers
    // 
    final PatchSet patchSet = db.patchSets().get(psid);
    for (final Account.Id id : added) {
        final Account account = accountCache.get(id).getAccount();
        hooks.doReviewerAddedHook(change, account, patchSet, db);
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd);
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd);
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            final Image readOnlyIcon = new Image(Gerrit.RESOURCES.readonly());
            readOnlyIcon.setTitle(Gerrit.C.userCannotVoteToolTip());
            table.setWidget(row, col, readOnlyIcon);
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    final Account account = db.accounts().get(id);
    boolean accountUpdated = false;
    boolean sshKeysUpdated = false;
    for (String email : addEmails) {
        link(id, email);
    }
    for (String email : deleteEmails) {
        deleteMail(id, email);
    }
    if (fullName != null) {
        if (realm.allowsEdit(FieldName.FULL_NAME)) {
            account.setFullName(fullName);
        } else {
            throw new UnloggedFailure(1, "The realm doesn't allow editing names");
        }
    }
    if (httpPassword != null) {
        setHttpPassword(account.getId(), httpPassword);
        accountUpdated = true;
    }
    if (active) {
        accountUpdated = true;
        account.setActive(true);
    } else if (inactive) {
        accountUpdated = true;
        account.setActive(false);
    }
    addSshKeys = readSshKey(addSshKeys);
    if (!addSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        addSshKeys(addSshKeys, account);
    }
    deleteSshKeys = readSshKey(deleteSshKeys);
    if (!deleteSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        deleteSshKeys(deleteSshKeys, account);
    }
    if (accountUpdated) {
        db.accounts().update(Collections.singleton(account));
        byIdCache.evict(id);
    }
    if (sshKeysUpdated) {
        sshKeyCache.evict(account.getUserName());
    }
    db.close();
}
#method_after
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    final Account account = db.accounts().get(id);
    boolean accountUpdated = false;
    boolean sshKeysUpdated = false;
    for (String email : addEmails) {
        link(id, email);
    }
    for (String email : deleteEmails) {
        deleteMail(id, email);
    }
    if (fullName != null) {
        if (realm.allowsEdit(FieldName.FULL_NAME)) {
            account.setFullName(fullName);
        } else {
            throw new UnloggedFailure(1, "The realm doesn't allow editing names");
        }
    }
    if (httpPassword != null) {
        setHttpPassword(id, httpPassword);
    }
    if (active) {
        accountUpdated = true;
        account.setActive(true);
    } else if (inactive) {
        accountUpdated = true;
        account.setActive(false);
    }
    addSshKeys = readSshKey(addSshKeys);
    if (!addSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        addSshKeys(addSshKeys, account);
    }
    deleteSshKeys = readSshKey(deleteSshKeys);
    if (!deleteSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        deleteSshKeys(deleteSshKeys, account);
    }
    if (accountUpdated) {
        db.accounts().update(Collections.singleton(account));
        byIdCache.evict(id);
    }
    if (sshKeysUpdated) {
        sshKeyCache.evict(account.getUserName());
    }
    db.close();
}
#end_block

#method_before
private void setHttpPassword(Account.Id id, final String httpPassword) throws UnloggedFailure, OrmException {
    ResultSet<AccountExternalId> ids = db.accountExternalIds().byAccount(id);
    for (AccountExternalId extId : ids) {
        extId.setPassword(httpPassword);
        db.accountExternalIds().update(Collections.singleton(extId));
    }
}
#method_after
private void setHttpPassword(Account.Id id, final String httpPassword) throws UnloggedFailure, OrmException {
    ResultSet<AccountExternalId> ids = db.accountExternalIds().byAccount(id);
    for (AccountExternalId extId : ids) {
        if (extId.isScheme(AccountExternalId.SCHEME_USERNAME)) {
            extId.setPassword(httpPassword);
            db.accountExternalIds().update(Collections.singleton(extId));
            byIdCache.evict(id);
        }
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, 3, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProjectAdmin(item.name_key(), ProjectScreen.INFO);
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            table.getFlexCellFormatter().addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            table.setWidget(row, 1, new Hyperlink(k.name(), link(k)));
            table.setText(row, 2, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, 3, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, 3, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProjectAdmin(item.name_key(), ProjectScreen.INFO);
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            table.setWidget(row, 1, new Hyperlink(k.name(), link(k)));
            table.setText(row, 2, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, 3, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String token = "token=" + verifier.encode(currentUser.get().getUserName(), getReqUrl(req));
    sendText(req, res, token);
}
#method_after
@Override
protected final void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser)) {
        sendError(res, SC_UNAUTHORIZED, "API requires authentication");
        return;
    }
    TokenInfo info = new TokenInfo();
    info._authkey = verifier.sign(((IdentifiedUser) user).getAccountId(), computeUrl(req));
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    String type;
    buf.write(JSON_MAGIC);
    if (acceptsJson(req)) {
        type = JSON_TYPE;
        buf.write(gson.toJson(info).getBytes(UTF_8));
    } else {
        type = FORM_ENCODED;
        buf.write(String.format("%s=%s", AUTHKEY_NAME, URLEncoder.encode(info._authkey, UTF_8)).getBytes(UTF_8));
    }
    res.setContentType(type);
    res.setCharacterEncoding(UTF_8);
    res.setHeader("Content-Disposition", "attachment");
    send(req, res, buf.toByteArray());
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        noCache(res);
        sendText(req, res, err.getMessage());
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        sendError(res, SC_FORBIDDEN, err.getMessage());
    } catch (Error err) {
        handleException(err, req, res);
    } catch (RuntimeException err) {
        handleException(err, req, res);
    }
}
#end_block

#method_before
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), ((IdentifiedUser) user).getNameEmail()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#method_after
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), user instanceof IdentifiedUser ? ((IdentifiedUser) user).getNameEmail() : user.toString()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#end_block

#method_before
protected static void sendText(HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#method_after
protected static void sendText(@Nullable HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#end_block

#method_before
protected static void send(HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#method_after
protected static void send(@Nullable HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && req != null && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, Response res) {
    String text = res.getText();
    if (text.startsWith("token=")) {
        RestApi.this.sendPost(cb, text);
        return;
    }
    RpcStatus.INSTANCE.onRpcComplete();
    int status = res.getStatusCode();
    if (status != 200) {
        if ((400 <= status && status < 500) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json.substring(JSON_MAGIC.length()));
    } catch (RuntimeException e) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
}
#method_after
@Override
public void onResponseReceived(Request req, Response res) {
    int status = res.getStatusCode();
    if (status != 200) {
        RpcStatus.INSTANCE.onRpcComplete();
        if ((400 <= status && status < 600) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    json = json.substring(JSON_MAGIC.length());
    if (wasGet && json.startsWith("{\"_authkey\":")) {
        RestApi.this.resendPost(cb, json);
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json);
    } catch (RuntimeException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
    RpcStatus.INSTANCE.onRpcComplete();
}
#end_block

#method_before
public RestApi addParameter(String name, int value) {
    return addParameterRaw(name, String.valueOf(value));
}
#method_after
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#end_block

#method_before
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#method_after
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(true, cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#end_block

#method_before
private void populateReviewedPanel() {
    reviewedPanel.clear();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedAnchor = getReviewedAnchor();
    reviewedPanel.add(reviewedAnchor);
}
#method_after
private void populateReviewedPanel() {
    reviewedPanel.clear();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(getReviewedAnchor());
}
#end_block

#method_before
private Anchor getReviewedAnchor() {
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(PatchUtil.C.next());
    text.append(SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    Anchor reviewedAnchor = new Anchor("");
    SafeHtml.set(reviewedAnchor, text);
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
        }
    });
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = fileList.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        final PatchLink reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                reviewedLink.go();
            }
        });
    } else {
        final ChangeLink upLink = new ChangeLink("", patchKey.getParentKey());
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                upLink.go();
            }
        });
    }
    return reviewedAnchor;
}
#method_after
private Anchor getReviewedAnchor() {
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(PatchUtil.C.next());
    text.append(SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    Anchor reviewedAnchor = new Anchor("");
    SafeHtml.set(reviewedAnchor, text);
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = fileList.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
    } else {
        reviewedLink = new ChangeLink("", patchKey.getParentKey());
    }
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
            reviewedLink.go();
        }
    });
    return reviewedAnchor;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewedPanel);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    if (Gerrit.isSignedIn()) {
        keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
        keysAction.add(new MarkAsReviewedAndGoToNextCmd(0, 'v', PatchUtil.C.markAsReviewedAndGoToNext()));
    }
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewedPanel);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    if (Gerrit.isSignedIn()) {
        keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
        keysAction.add(new ToggleReviewedCmd(0, 'm', PatchUtil.C.toggleReviewed()));
        keysAction.add(new MarkAsReviewedAndGoToNextCmd(0, 'M', PatchUtil.C.markAsReviewedAndGoToNext()));
    }
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (reviewedAnchor != null) {
        DomEvent.fireNativeEvent(Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false), reviewedAnchor);
    }
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (reviewedLink != null) {
        setReviewedByCurrentUser(true);
        reviewedLink.go();
    }
}
#end_block

#method_before
@Deprecated
public Change.Id getId() {
    return changeId;
}
#method_after
public Change.Id getId() {
    return changeId;
}
#end_block

#method_before
@Deprecated
public int getChangeId() {
    return changeId.get();
}
#method_after
public int getChangeId() {
    return changeId.get();
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case ALREADY_MERGED:
                {
                    setMerged(c, null);
                    break;
                }
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    String str = dependencyError(commit);
                    if (submitStillPossible) {
                        if (str != null) {
                            sendMergeFail(c, message(c, str), false, false);
                        }
                    } else {
                        setNew(c, message(c, str));
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).runTestMerge(change);
}
#method_after
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).verifyMergeability(change);
}
#end_block

#method_before
public static void submit(MergeOp.Factory opFactory, PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db, MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (change.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, change.getDest());
    }
}
#method_after
public static void submit(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db, final MergeOp.Factory opFactory, final MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, updatedChange.getDest());
    }
}
#end_block

#method_before
public static PatchSetApproval createSubmitApproval(PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#method_after
public static PatchSetApproval createSubmitApproval(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canPushToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
    ChangeUtil.testMerge(opFactory, change);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    ChangeUtil.testMerge(opFactory, change);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                change.setLastSha1MergeTested(null);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        ChangeUtil.mergeTestChangesByBranch(opFactory, destBranch);
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    if (!isMergeable) {
        final Label lbl = new Label();
        lbl.setText(Util.C.messageMergeFail());
        actionsPanel.add(lbl);
    }
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.setEnabled(isMergeable);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display("change,publish," + patchSet.getId().toString(), new PublishCommentScreen(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display(Dispatcher.toPublish(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
    errorlabel.setText(Util.C.messageMergeFail());
    body.add(errorlabel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
}
#end_block

#method_before
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    for (final ApprovalType ct : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        if (r.isAllowed(ct.getCategory().getId())) {
            initApprovalType(r, body, ct);
        }
    }
}
#method_after
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    ApprovalTypes types = Gerrit.getConfig().getApprovalTypes();
    for (PermissionRange range : r.getLabels()) {
        ApprovalType type = types.byLabel(range.getLabel());
        if (type != null) {
            // Legacy type, use radio buttons.
            initApprovalType(r, body, type, range);
        } else {
        // TODO Newer style label.
        }
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final Set<ApprovalCategoryValue.Id> allowed = r.getAllowed(catId);
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!allowed.contains(buttonValue.getId())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.isSubmitAllowed());
    submit.setEnabled(r.getChange().isMergeable());
    errorlabel.setVisible(!r.getChange().isMergeable());
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }
    });
}
#method_after
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void configureServlets() {
    bind(HttpPluginServlet.class);
    serve("/plugins/*").with(HttpPluginServlet.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?plugins/(.*)?$").with(HttpPluginServlet.class);
    bind(StartPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(HttpPluginServlet.class);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(HttpPluginServlet.class);
    bind(ModuleGenerator.class).to(HttpAutoRegisterModuleGenerator.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(PLUGIN_RESOURCES, ResourceKey.class, Resource.class).maximumWeight(2 << 20).weigher(ResourceWeigher.class);
        }
    });
}
#method_after
@Override
protected void configureServlets() {
    bind(HttpPluginServlet.class);
    serve("/plugins/*").with(HttpPluginServlet.class);
    serveRegex("^/(?:a/)?plugins/(.*)?$").with(HttpPluginServlet.class);
    bind(StartPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(HttpPluginServlet.class);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(HttpPluginServlet.class);
    bind(ModuleGenerator.class).to(HttpAutoRegisterModuleGenerator.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(PLUGIN_RESOURCES, ResourceKey.class, Resource.class).maximumWeight(2 << 20).weigher(ResourceWeigher.class);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.setOf(binder(), CacheRemovalListenerFactory.class);
    bind(MasterRemovalListenerFactory.class).in(Scopes.SINGLETON);
    bind(DefaultCacheFactory.class);
    bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class);
    bind(PersistentCacheFactory.class).to(H2CacheFactory.class);
    listener().to(H2CacheFactory.class);
}
#method_after
@Override
protected void configure() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ForwardingRemovalListener.Factory.class);
        }
    });
    bind(DefaultCacheFactory.class);
    bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class);
    bind(PersistentCacheFactory.class).to(H2CacheFactory.class);
    listener().to(H2CacheFactory.class);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
<K, V> CacheBuilder<K, V> create(CacheBinding<K, V> def, boolean unwrapValueHolder) {
    CacheBuilder<K, V> builder = newCacheBuilder();
    builder.recordStats();
    builder.maximumWeight(cfg.getLong("cache", def.name(), "memoryLimit", def.maximumWeight()));
    builder.removalListener(masterRemovalListenerFactory.get(def.name()));
    Weigher<K, V> weigher = def.weigher();
    if (weigher != null && unwrapValueHolder) {
        final Weigher<K, V> impl = weigher;
        weigher = (Weigher<K, V>) new Weigher<K, ValueHolder<V>>() {

            @Override
            public int weigh(K key, ValueHolder<V> value) {
                return impl.weigh(key, value.value);
            }
        };
    } else if (weigher == null) {
        weigher = unitWeight();
    }
    builder.weigher(weigher);
    Long age = def.expireAfterWrite(TimeUnit.SECONDS);
    if (has(def.name(), "maxAge")) {
        builder.expireAfterWrite(ConfigUtil.getTimeUnit(cfg, "cache", def.name(), "maxAge", age != null ? age : 0, TimeUnit.SECONDS), TimeUnit.SECONDS);
    } else if (age != null) {
        builder.expireAfterWrite(age, TimeUnit.SECONDS);
    }
    return builder;
}
#method_after
@SuppressWarnings("unchecked")
<K, V> CacheBuilder<K, V> create(CacheBinding<K, V> def, boolean unwrapValueHolder) {
    CacheBuilder<K, V> builder = newCacheBuilder();
    builder.recordStats();
    builder.maximumWeight(cfg.getLong("cache", def.name(), "memoryLimit", def.maximumWeight()));
    builder.removalListener(forwardingRemovalListenerFactory.create(def.name()));
    Weigher<K, V> weigher = def.weigher();
    if (weigher != null && unwrapValueHolder) {
        final Weigher<K, V> impl = weigher;
        weigher = (Weigher<K, V>) new Weigher<K, ValueHolder<V>>() {

            @Override
            public int weigh(K key, ValueHolder<V> value) {
                return impl.weigh(key, value.value);
            }
        };
    } else if (weigher == null) {
        weigher = unitWeight();
    }
    builder.weigher(weigher);
    Long age = def.expireAfterWrite(TimeUnit.SECONDS);
    if (has(def.name(), "maxAge")) {
        builder.expireAfterWrite(ConfigUtil.getTimeUnit(cfg, "cache", def.name(), "maxAge", age != null ? age : 0, TimeUnit.SECONDS), TimeUnit.SECONDS);
    } else if (age != null) {
        builder.expireAfterWrite(age, TimeUnit.SECONDS);
    }
    return builder;
}
#end_block

#method_before
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowCrLf()) {
        html = showCrLf(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#method_after
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowLineEndings()) {
        html = showLineEndings(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#end_block

#method_before
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src.substring(0, cr + 1));
            buf.append('\n');
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#method_after
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src);
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#end_block

#method_before
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    crlfErrors.setValue(dp.isShowCrLf());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#method_after
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    showLineEndings.setValue(dp.isShowLineEndings());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#end_block

#method_before
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowCrLf(crlfErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#method_after
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowLineEndings(showLineEndings.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#end_block

#method_before
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowCrLf(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#method_after
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    if (query.length() == 0) {
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#method_after
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    // NOTE: this method is not called if the query is empty.
    if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions.tailSet(lastWord)) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            if (suggestion.contains("self") && !Gerrit.isSignedIn()) {
                continue;
            }
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to install");
        }
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to enable");
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#method_after
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#end_block

#method_before
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    for (index++; index < patchList.size(); index++) {
        InlineHyperlink link = createLink(index, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#end_block

#method_before
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((listenablePrefs.get().isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (listenablePrefs.get().isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    loadedInfoTable(detail);
    loadedActionPanel(detail);
    loadedPatchTable(detail);
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    loadInfoTable(detail);
    loadActionPanel(detail);
    loadPatchTable(detail);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadedActionPanel(result);
                }
                loadedPatchTable(result);
            }
        });
    }
}
#method_after
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadActionPanel(result);
                }
                loadPatchTable(result);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadedInfoTable(result);
                loadedActionPanel(result);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadInfoTable(result);
                loadActionPanel(result);
            }
        });
    }
}
#end_block

#method_before
public <T> boolean parse(T param, HttpServletRequest req, HttpServletResponse res) throws IOException {
    return parse(param, req, res, new ArrayList<String>());
}
#method_after
public <T> boolean parse(T param, HttpServletRequest req, HttpServletResponse res) throws IOException {
    return parse(param, req, res, Collections.<String>emptySet());
}
#end_block

#method_before
public <T> boolean parse(T param, HttpServletRequest req, HttpServletResponse res, List<String> argNames) throws IOException {
    CmdLineParser clp = parserFactory.create(param);
    try {
        @SuppressWarnings("unchecked")
        Map<String, String[]> parameterMap = req.getParameterMap();
        clp.parseOptionMap(parameterMap, argNames);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            res.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            sendText(req, res, e.getMessage());
            return false;
        }
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter msg = new StringWriter();
        clp.printQueryStringUsage(req.getRequestURI(), msg);
        msg.write('\n');
        msg.write('\n');
        clp.printUsage(msg, null);
        msg.write('\n');
        sendText(req, res, msg.toString());
        return false;
    }
    return true;
}
#method_after
public <T> boolean parse(T param, HttpServletRequest req, HttpServletResponse res, Set<String> argNames) throws IOException {
    CmdLineParser clp = parserFactory.create(param);
    try {
        @SuppressWarnings("unchecked")
        Map<String, String[]> parameterMap = req.getParameterMap();
        clp.parseOptionMap(parameterMap, argNames);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            res.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            sendText(req, res, e.getMessage());
            return false;
        }
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter msg = new StringWriter();
        clp.printQueryStringUsage(req.getRequestURI(), msg);
        msg.write('\n');
        msg.write('\n');
        clp.printUsage(msg, null);
        msg.write('\n');
        sendText(req, res, msg.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException {
    parseOptionMap(parameters, new ArrayList<String>());
}
#method_after
public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException {
    parseOptionMap(parameters, Collections.<String>emptySet());
}
#end_block

#method_before
public void parseOptionMap(Map<String, String[]> parameters, List<String> argNames) throws CmdLineException {
    ArrayList<String> tmp = new ArrayList<String>();
    for (Map.Entry<String, String[]> ent : parameters.entrySet()) {
        String name = ent.getKey();
        if (!name.startsWith("-")) {
            if (name.length() == 1) {
                name = "-" + name;
            } else {
                name = "--" + name;
            }
        }
        if (findHandler(name) instanceof BooleanOptionHandler) {
            boolean on = false;
            for (String value : ent.getValue()) {
                on = toBoolean(ent.getKey(), value);
            }
            if (on) {
                tmp.add(name);
            }
        } else {
            for (String value : ent.getValue()) {
                if (!argNames.contains(ent.getKey())) {
                    tmp.add(name);
                }
                tmp.add(value);
            }
        }
    }
    parser.parseArgument(tmp.toArray(new String[tmp.size()]));
}
#method_after
public void parseOptionMap(Map<String, String[]> parameters, Set<String> argNames) throws CmdLineException {
    ArrayList<String> tmp = new ArrayList<String>();
    for (Map.Entry<String, String[]> ent : parameters.entrySet()) {
        String name = ent.getKey();
        if (!name.startsWith("-")) {
            if (name.length() == 1) {
                name = "-" + name;
            } else {
                name = "--" + name;
            }
        }
        if (findHandler(name) instanceof BooleanOptionHandler) {
            boolean on = false;
            for (String value : ent.getValue()) {
                on = toBoolean(ent.getKey(), value);
            }
            if (on) {
                tmp.add(name);
            }
        } else {
            for (String value : ent.getValue()) {
                if (!argNames.contains(ent.getKey())) {
                    tmp.add(name);
                }
                tmp.add(value);
            }
        }
    }
    parser.parseArgument(tmp.toArray(new String[tmp.size()]));
}
#end_block

#method_before
public static void doSignIn(String token) {
    switch(myConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
            Location.assign(loginRedirect(token));
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            Location.assign(selfRedirect("/become"));
            break;
        case OPENID_SSO:
            singleSignOnPanel.authenticate(SignInMode.SIGN_IN, token);
            break;
        case OPENID:
            new OpenIdSignInDialog(SignInMode.SIGN_IN, token, null).center();
            break;
        case LDAP:
        case LDAP_BIND:
            new UserPassSignInDialog(token, null).center();
            break;
    }
}
#method_after
public static void doSignIn(String token) {
    switch(myConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
            Location.assign(loginRedirect(token));
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            Location.assign(selfRedirect("/become"));
            break;
        case OPENID_SSO:
            final RootPanel gBody = RootPanel.get("gerrit_body");
            OpenIdSsoPanel singleSignOnPanel = new OpenIdSsoPanel();
            gBody.add(singleSignOnPanel);
            singleSignOnPanel.authenticate(SignInMode.SIGN_IN, token);
            break;
        case OPENID:
            new OpenIdSignInDialog(SignInMode.SIGN_IN, token, null).center();
            break;
        case LDAP:
        case LDAP_BIND:
            new UserPassSignInDialog(token, null).center();
            break;
    }
}
#end_block

#method_before
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    singleSignOnPanel = new OpenIdSsoPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(singleSignOnPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#method_after
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#end_block

#method_before
public void authenticate(SignInMode requestedMode, final String token) {
    OpenIdUtil.SVC.discover(ssoUrl, requestedMode, /* remember */
    false, token, new GerritCallback<DiscoveryResult>() {

        public void onSuccess(final DiscoveryResult result) {
            onDiscovery(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            super.onFailure(caught);
        }
    });
}
#method_after
public void authenticate(SignInMode requestedMode, final String token) {
    OpenIdUtil.SVC.discover(ssoUrl, requestedMode, /* remember */
    false, token, new GerritCallback<DiscoveryResult>() {

        public void onSuccess(final DiscoveryResult result) {
            onDiscovery(result);
        }
    });
}
#end_block

#method_before
public GroupDetail renameGroup(final AccountGroup.Id groupId, final String newName) throws OrmException, NameAlreadyUsedException, NoSuchGroupException, InvalidNameException {
    final GroupControl ctl = groupControlFactory.validateFor(groupId);
    final AccountGroup group = db.accountGroups().get(groupId);
    if (group == null || !ctl.isOwner()) {
        throw new NoSuchGroupException(groupId);
    }
    if (newName.isEmpty()) {
        throw new InvalidNameException();
    }
    final AccountGroup.NameKey old = group.getNameKey();
    final AccountGroup.NameKey key = new AccountGroup.NameKey(newName);
    try {
        final AccountGroupName id = new AccountGroupName(key, groupId);
        db.accountGroupNames().insert(Collections.singleton(id));
    } catch (OrmDuplicateKeyException dupeErr) {
        // If we are using this identity, don't report the exception.
        // 
        AccountGroupName other = db.accountGroupNames().get(key);
        if (other != null && other.getId().equals(groupId)) {
            return groupDetailFactory.create(groupId).call();
        }
        // 
        throw new NameAlreadyUsedException();
    }
    group.setNameKey(key);
    db.accountGroups().update(Collections.singleton(group));
    AccountGroupName priorName = db.accountGroupNames().get(old);
    if (priorName != null) {
        db.accountGroupNames().delete(Collections.singleton(priorName));
    }
    groupCache.evict(group);
    groupCache.evictAfterRename(old, key);
    // 
    renameGroupOpFactory.create(// 
    currentUser.newCommitterIdent(new Date(), TimeZone.getDefault()), // 
    group.getGroupUUID(), old.get(), newName).start(0, TimeUnit.MILLISECONDS);
    return groupDetailFactory.create(groupId).call();
}
#method_after
public GroupDetail renameGroup(final AccountGroup.Id groupId, final String newName) throws OrmException, NameAlreadyUsedException, NoSuchGroupException, InvalidNameException {
    final GroupControl ctl = groupControlFactory.validateFor(groupId);
    final AccountGroup group = db.accountGroups().get(groupId);
    if (group == null || !ctl.isOwner()) {
        throw new NoSuchGroupException(groupId);
    }
    if (newName.trim().isEmpty()) {
        throw new InvalidNameException();
    }
    final AccountGroup.NameKey old = group.getNameKey();
    final AccountGroup.NameKey key = new AccountGroup.NameKey(newName);
    try {
        final AccountGroupName id = new AccountGroupName(key, groupId);
        db.accountGroupNames().insert(Collections.singleton(id));
    } catch (OrmDuplicateKeyException dupeErr) {
        // If we are using this identity, don't report the exception.
        // 
        AccountGroupName other = db.accountGroupNames().get(key);
        if (other != null && other.getId().equals(groupId)) {
            return groupDetailFactory.create(groupId).call();
        }
        // 
        throw new NameAlreadyUsedException();
    }
    group.setNameKey(key);
    db.accountGroups().update(Collections.singleton(group));
    AccountGroupName priorName = db.accountGroupNames().get(old);
    if (priorName != null) {
        db.accountGroupNames().delete(Collections.singleton(priorName));
    }
    groupCache.evict(group);
    groupCache.evictAfterRename(old, key);
    // 
    renameGroupOpFactory.create(// 
    currentUser.newCommitterIdent(new Date(), TimeZone.getDefault()), // 
    group.getGroupUUID(), old.get(), newName).start(0, TimeUnit.MILLISECONDS);
    return groupDetailFactory.create(groupId).call();
}
#end_block

#method_before
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    reloadButton = new Button(Util.C.buttonReloadPlugins());
    reloadButton.setTitle(Util.C.buttonReloadPluginsToolTip());
    reloadButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doReloadPlugins();
        }
    });
    HorizontalPanel buttonPanel = new HorizontalPanel();
    buttonPanel.add(reloadButton);
    buttonPanel.addStyleName(Gerrit.RESOURCES.css().pluginsTableButtonPanel());
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    pluginPanel.add(buttonPanel);
    add(pluginPanel);
}
#method_after
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    table.setWidget(row, 2, new Anchor(plugin.name(), Gerrit.selfRedirect("/plugins/" + plugin.name() + "/")));
    table.setText(row, 3, plugin.version());
    if (plugin.isDisabled()) {
        table.setText(row, 4, Util.C.pluginDisabled());
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    if (plugin.isDisabled()) {
        table.setText(row, 1, plugin.name());
    } else {
        table.setWidget(row, 1, new Anchor(plugin.name(), Gerrit.selfRedirect("/plugins/" + plugin.name() + "/")));
    }
    table.setText(row, 2, plugin.version());
    if (plugin.isDisabled()) {
        table.setText(row, 3, Util.C.pluginDisabled());
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    Map<String, PluginInfo> output = Maps.newTreeMap();
    List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins(all));
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (!format.isJson()) {
        stdout.format("%-30s %-10s\n", "Name", "Version");
        stdout.print("----------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo();
        info.version = p.getVersion();
        info.isDisabled = p.isDisabled();
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s\n", p.getName() + (info.isDisabled ? " (DISABLED)" : ""), Strings.nullToEmpty(info.version));
        }
    }
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    Map<String, PluginInfo> output = Maps.newTreeMap();
    List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins(all));
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (!format.isJson()) {
        stdout.format("%-30s %-10s %-8s\n", "Name", "Version", "Status");
        stdout.print("-------------------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo();
        info.version = p.getVersion();
        info.disabled = p.isDisabled() ? true : null;
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s %-8s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "");
        }
    }
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
}
#end_block

#method_before
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            return (pathname.getName().endsWith(".jar") || pathname.getName().endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
public void add(RegistrationHandle handle) {
    if (handle instanceof ReloadableRegistrationHandle) {
        if (reloadableHandles == null) {
            reloadableHandles = Lists.newArrayList();
        }
        reloadableHandles.add((ReloadableRegistrationHandle<?>) handle);
    }
    manager.add(handle);
}
#method_after
public void add(RegistrationHandle handle) {
    if (manager != null) {
        if (handle instanceof ReloadableRegistrationHandle) {
            if (reloadableHandles == null) {
                reloadableHandles = Lists.newArrayList();
            }
            reloadableHandles.add((ReloadableRegistrationHandle<?>) handle);
        }
        manager.add(handle);
    }
}
#end_block

#method_before
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox();
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    Anchor reviewedAnchor = new Anchor(PatchUtil.C.reviewed());
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
        }
    });
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = patchSetDetail.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        final PatchLink reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                reviewedLink.go();
            }
        });
    } else {
        final ChangeLink upLink = new ChangeLink("", patchKey.getParentKey());
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                upLink.go();
            }
        });
    }
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(reviewedAnchor);
}
#method_after
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(getReviewedAnchor());
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = detail.getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#end_block

#method_before
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = detail.getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#method_after
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#end_block

#method_before
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SingleUserGroup.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(SingleUserGroup.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), GroupBackend.class).to(SingleUserGroup.class);
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(final IdentifiedUser user) {
    return new GroupMembership() {

        @Override
        public boolean contains(AccountGroup.UUID uuid) {
            return username(uuid).equals(user.getUserName());
        }

        @Override
        public boolean containsAnyOf(Iterable<AccountGroup.UUID> groups) {
            for (AccountGroup.UUID uuid : groups) {
                if (contains(uuid)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public Set<AccountGroup.UUID> getKnownGroups() {
            return Collections.emptySet();
        }
    };
}
#method_after
@Override
public GroupMembership membershipsOf(final IdentifiedUser user) {
    ImmutableList.Builder<AccountGroup.UUID> groups = ImmutableList.builder();
    groups.add(uuid(user.getAccountId()));
    if (user.getUserName() != null) {
        groups.add(uuid(user.getUserName()));
    }
    return new ListGroupMembership(groups.build());
}
#end_block

#method_before
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    AccountState state = accountCache.getByUsername(username(uuid));
    if (state != null) {
        final String name = nameOf(state);
        return new GroupDescription.Basic() {

            @Override
            public AccountGroup.UUID getGroupUUID() {
                return uuid;
            }

            @Override
            public String getName() {
                return name;
            }

            @Override
            public boolean isVisibleToAll() {
                return false;
            }
        };
    }
    return null;
}
#method_after
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    String ident = username(uuid);
    AccountState state;
    if (ident.matches(ACCOUNT_ID_PATTERN)) {
        state = accountCache.get(new Account.Id(Integer.parseInt(ident)));
    } else if (ident.matches(Account.USER_NAME_PATTERN)) {
        state = accountCache.getByUsername(ident);
    } else {
        return null;
    }
    if (state != null) {
        final String name = nameOf(uuid, state);
        return new GroupDescription.Basic() {

            @Override
            public AccountGroup.UUID getGroupUUID() {
                return uuid;
            }

            @Override
            public String getName() {
                return name;
            }

            @Override
            public boolean isVisibleToAll() {
                return false;
            }
        };
    }
    return null;
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name) {
    if (name.startsWith(NAME_PREFIX)) {
        name = name.substring(NAME_PREFIX.length());
    }
    if (name.length() < 3) {
        return Collections.emptyList();
    }
    try {
        AccountControl ctl = accountControlFactory.get();
        Set<Account.Id> ids = Sets.newHashSet();
        List<GroupReference> matches = Lists.newArrayListWithCapacity(MAX);
        String a = name;
        String b = end(a);
        ReviewDb db = schemaFactory.open();
        try {
            if (name.matches("[1-9][0-9]*")) {
                Account.Id id = new Account.Id(Integer.parseInt(name));
                if (db.accounts().get(id) != null && ctl.canSee(id)) {
                    add(matches, id);
                    if (!matches.isEmpty()) {
                        return matches;
                    }
                }
            }
            if (name.matches(Account.USER_NAME_PATTERN)) {
                for (AccountExternalId e : db.accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + b), MAX)) {
                    if (!e.getSchemeRest().startsWith(a)) {
                        break;
                    } else if (ids.add(e.getAccountId()) && ctl.canSee(e.getAccountId())) {
                        add(matches, e.getAccountId());
                    }
                    if (matches.size() == MAX) {
                        return matches;
                    }
                }
            }
            for (Account p : db.accounts().suggestByFullName(a, b, MAX)) {
                if (!p.getFullName().startsWith(a)) {
                    break;
                } else if (ids.add(p.getId()) && ctl.canSee(p.getId())) {
                    add(matches, p.getId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            for (Account p : db.accounts().suggestByPreferredEmail(a, b, MAX)) {
                if (!p.getPreferredEmail().startsWith(a)) {
                    break;
                } else if (ids.add(p.getId()) && ctl.canSee(p.getId())) {
                    add(matches, p.getId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, MAX)) {
                if (!e.getEmailAddress().startsWith(a)) {
                    break;
                } else if (ids.add(e.getAccountId()) && ctl.canSee(e.getAccountId())) {
                    add(matches, e.getAccountId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            return matches;
        } finally {
            db.close();
        }
    } catch (OrmException err) {
        log.warn("Cannot suggest users", err);
        return Collections.emptyList();
    }
}
#method_after
@Override
public Collection<GroupReference> suggest(String name) {
    if (name.startsWith(NAME_PREFIX)) {
        name = name.substring(NAME_PREFIX.length());
    } else if (name.startsWith(ACCOUNT_PREFIX)) {
        name = name.substring(ACCOUNT_PREFIX.length());
    }
    if (name.isEmpty()) {
        return Collections.emptyList();
    }
    try {
        AccountControl ctl = accountControlFactory.get();
        Set<Account.Id> ids = Sets.newHashSet();
        List<GroupReference> matches = Lists.newArrayListWithCapacity(MAX);
        String a = name;
        String b = end(a);
        ReviewDb db = schemaFactory.open();
        try {
            if (name.matches(ACCOUNT_ID_PATTERN)) {
                Account.Id id = new Account.Id(Integer.parseInt(name));
                if (db.accounts().get(id) != null) {
                    add(matches, ids, ctl, id);
                    return matches;
                }
            }
            if (name.matches(Account.USER_NAME_PATTERN)) {
                for (AccountExternalId e : db.accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + b), MAX)) {
                    if (!e.getSchemeRest().startsWith(a)) {
                        break;
                    }
                    add(matches, ids, ctl, e.getAccountId());
                }
            }
            for (Account p : db.accounts().suggestByFullName(a, b, MAX)) {
                if (!p.getFullName().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, p.getId());
            }
            for (Account p : db.accounts().suggestByPreferredEmail(a, b, MAX)) {
                if (!p.getPreferredEmail().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, p.getId());
            }
            for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, MAX)) {
                if (!e.getEmailAddress().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, e.getAccountId());
            }
            return matches;
        } finally {
            db.close();
        }
    } catch (OrmException err) {
        log.warn("Cannot suggest users", err);
        return Collections.emptyList();
    }
}
#end_block

#method_before
private void add(List<GroupReference> matches, Account.Id id) {
    AccountState state = accountCache.get(id);
    if (state != null && state.getUserName() != null) {
        matches.add(new GroupReference(uuid(state.getUserName()), nameOf(state)));
    }
}
#method_after
private void add(List<GroupReference> matches, Set<Account.Id> ids, AccountControl ctl, Account.Id id) {
    if (!ids.add(id) || !ctl.canSee(id)) {
        return;
    }
    AccountState state = accountCache.get(id);
    if (state == null) {
        return;
    }
    AccountGroup.UUID uuid;
    if (state.getUserName() != null) {
        uuid = uuid(state.getUserName());
    } else {
        uuid = uuid(id);
    }
    matches.add(new GroupReference(uuid, nameOf(uuid, state)));
}
#end_block

#method_before
private static AccountGroup.UUID uuid(String username) {
    return new AccountGroup.UUID(UUID_PREFIX + username);
}
#method_after
private static AccountGroup.UUID uuid(Account.Id ident) {
    return uuid(Integer.toString(ident.get()));
}
#end_block

#method_before
private static String nameOf(AccountState account) {
    if (account.getAccount().getFullName() != null) {
        return account.getAccount().getFullName();
    } else if (account.getUserName() != null) {
        return NAME_PREFIX + account.getUserName();
    } else {
        return NAME_PREFIX + account.getAccount().getId().get();
    }
}
#method_after
private static String nameOf(AccountGroup.UUID uuid, AccountState account) {
    StringBuilder buf = new StringBuilder();
    if (account.getAccount().getFullName() != null) {
        buf.append(account.getAccount().getFullName());
    }
    if (account.getUserName() != null) {
        if (buf.length() > 0) {
            buf.append(" (").append(account.getUserName()).append(")");
        } else {
            buf.append(account.getUserName());
        }
    } else if (buf.length() > 0) {
        buf.append(" (").append(account.getAccount().getId().get()).append(")");
    } else {
        buf.append(account.getAccount().getId().get());
    }
    String ident = username(uuid);
    if (ident.matches(ACCOUNT_ID_PATTERN)) {
        buf.insert(0, ACCOUNT_PREFIX);
    } else {
        buf.insert(0, NAME_PREFIX);
    }
    return buf.toString();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS, sugestParent);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectListPopup.setCoordinates(top, left);
            projectListPopup.display();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.suggestParentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.parentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible && !(showTree && pctl.isOwner())) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && format.isJson() || (type == FilterType.SUGGEST_PARENT_CANDIDATES)) {
                ProjectState parent = e.getParentState();
                if (parent != null) {
                    ProjectControl parentCtrl = parent.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                            info.name = parent.getProject().getName();
                            info.description = parent.getProject().getDescription();
                            if (format.isJson()) {
                                output.put(info.name, info);
                            }
                            continue;
                        }
                        info.parent = parent.getProject().getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getProject().getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getProject().getName(), info.parent);
                        }
                    }
                } else {
                    if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                        continue;
                    }
                }
            }
            info.name = projectName.get();
            if (showDescription && !e.getProject().getDescription().isEmpty()) {
                info.description = e.getProject().getDescription();
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = Maps.newLinkedHashMap();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    } finally {
                        git.close();
                    }
                } else if (!showTree && type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + info.description.replace("\n", "\\n"));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = parentState.getProject().getDescription();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final ProjectControl pctl = e.controlFor(currentUser);
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription && !e.getProject().getDescription().isEmpty()) {
                    info.description = e.getProject().getDescription();
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
    resetHandlerRegistration();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.permissions(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, this);
    projectListPopup.addProjectListPopupOnOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(nameBox.getText())) {
                nameBox.setText(projectName);
            }
        }

        @Override
        protected void openRow(String projectName) {
            nameBox.setText(projectName);
            doAddNew();
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS);
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
protected void initPopup() {
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            if (top + offsetHeight > Window.getClientWidth()) {
                top = Window.getClientWidth() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#method_after
public void initPopup(final String popupText, final String currentPageLink) {
    createWidgets(popupText, currentPageLink);
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = getPositionCallback();
}
#end_block

#method_before
protected void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            handlerManager.fireEvent(new ProjectListPopupOnMovePointerEvent(popingUp, getRowItem(row).getName()));
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            handlerManager.fireEvent(new ProjectListPopupOnOpenRowEvent(getRowItem(row).getName()));
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
            handlerManager.fireEvent(new ProjectListPopupOnCloseEvent());
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#method_after
private void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            onMovePointerTo(getRowItem(row).name());
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            openRow(getRowItem(row).name());
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#end_block

#method_before
public void closePopup() {
    popup.hide();
    resetHandlerRegistration();
}
#method_after
public void closePopup() {
    popup.hide();
}
#end_block

#method_before
protected void populateProjects() {
    Util.PROJECT_SVC.visibleProjects(new GerritCallback<ProjectList>() {

        @Override
        public void onSuccess(final ProjectList result) {
            projectsTab.display(result.getProjects());
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                display();
            }
        }
    });
}
#method_after
protected void populateProjects() {
    ProjectMap.all(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(final ProjectMap result) {
            projectsTab.display(result);
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                displayPopup();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(script, patchKey, idSideA, idSideB, getPatchScreenType());
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(patchSetDetail, script, patchKey, idSideA, idSideB);
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
public void display(final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, final PatchScreen.Type type) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.screenType = type;
    this.links = new LinkedList<Anchor>();
    linkPanel.add(new Label(PatchUtil.C.patchSet() + " "));
    if (side == Side.A) {
        addLink("Base", null);
    } else {
        links.add(null);
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    downloadLink();
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new LinkedList<Anchor>();
    if (screenType == PatchScreen.Type.UNIFIED) {
        sideMarker.setInnerText((side == Side.A) ? "(-)" : "(+)");
    }
    if (detail.getInfo().getParents().size() > 1) {
        addLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        addLink(PatchUtil.C.patchBase(), null);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = getDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(new Label(" - "));
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key k = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, k));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, k));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#method_after
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key keySideB = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, keySideB));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, keySideB));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#end_block

#method_before
public void display(PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB, PatchScreen.Type type) {
    listA.display(script, patchKey, idSideA, idSideB, type);
    listB.display(script, patchKey, idSideA, idSideB, type);
    if (type == PatchScreen.Type.UNIFIED) {
        aligner.getStyle().setDisplay(Display.NONE);
    }
}
#method_after
public void display(final PatchSetDetail detail, PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB) {
    listA.display(detail, script, patchKey, idSideA, idSideB);
    listB.display(detail, script, patchKey, idSideA, idSideB);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        String parentMsg = parent.shortMessage;
        if (parentMsg.length() > 80) {
            parentMsg = parentMsg.substring(0, 80) + "...";
        }
        parentsTable.setWidget(row, 1, new InlineLabel(parentMsg));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or change/patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
public BanCommitResult ban(final ProjectControl projectControl, final List<ObjectId> commitsToBan, final String reason) throws PermissionDeniedException, IOException, IncompleteUserInfoException, InterruptedException, MergeException {
    if (!projectControl.isOwner()) {
        throw new PermissionDeniedException("No project owner: not permitted to ban commits");
    }
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // add a note for each banned commit to notes
    final Repository repo = repoManager.openRepository(projectControl.getProject().getNameKey());
    final RevWalk revWalk = new RevWalk(repo);
    final ObjectInserter inserter = repo.newObjectInserter();
    try {
        for (final ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // ignore exception, also not existing commits can be banned
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan, e.getMessage());
                continue;
            }
            banCommitNotes.set(commitToBan, createNoteContent(reason, inserter));
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(repo);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REF_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#method_after
public BanCommitResult ban(final ProjectControl projectControl, final List<ObjectId> commitsToBan, final String reason) throws PermissionDeniedException, IOException, InterruptedException, MergeException, ConcurrentRefUpdateException {
    if (!projectControl.isOwner()) {
        throw new PermissionDeniedException("No project owner: not permitted to ban commits");
    }
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // add a note for each banned commit to notes
    final Repository repo = repoManager.openRepository(projectControl.getProject().getNameKey());
    try {
        final RevWalk revWalk = new RevWalk(repo);
        final ObjectInserter inserter = repo.newObjectInserter();
        try {
            for (final ObjectId commitToBan : commitsToBan) {
                try {
                    revWalk.parseCommit(commitToBan);
                } catch (MissingObjectException e) {
                // ignore exception, also not existing commits can be banned
                } catch (IncorrectObjectTypeException e) {
                    result.notACommit(commitToBan, e.getMessage());
                    continue;
                }
                banCommitNotes.set(commitToBan, createNoteContent(reason, inserter));
            }
            inserter.flush();
            NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(repo);
            NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REF_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
            for (Note n : banCommitNotes) {
                if (newlyCreated.contains(n)) {
                    result.commitBanned(n);
                } else {
                    result.commitAlreadyBanned(n);
                }
            }
            return result;
        } finally {
            revWalk.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private ObjectId createNoteContent(String reason, ObjectInserter inserter) throws UnsupportedEncodingException, IOException {
    String noteContent = reason != null ? reason : "";
    if (!noteContent.endsWith("\n")) {
        noteContent = noteContent + "\n";
    }
    return inserter.insert(Constants.OBJ_BLOB, noteContent.getBytes("UTF-8"));
}
#method_after
private ObjectId createNoteContent(String reason, ObjectInserter inserter) throws UnsupportedEncodingException, IOException {
    String noteContent = reason != null ? reason : "";
    if (noteContent.length() > 0 && !noteContent.endsWith("\n")) {
        noteContent = noteContent + "\n";
    }
    return inserter.insert(Constants.OBJ_BLOB, noteContent.getBytes("UTF-8"));
}
#end_block

#method_before
private PersonIdent createPersonIdent() throws IncompleteUserInfoException {
    final String userName = currentUser.get().getUserName();
    final Account account = accountCache.getByUsername(userName).getAccount();
    if (account.getFullName() == null) {
        throw new IncompleteUserInfoException(userName, "full name");
    }
    if (account.getPreferredEmail() == null) {
        throw new IncompleteUserInfoException(userName, "preferred email");
    }
    return new PersonIdent(account.getFullName(), account.getPreferredEmail());
}
#method_after
private PersonIdent createPersonIdent() {
    Date now = new Date();
    TimeZone tz = gerritIdent.getTimeZone();
    return currentUser.get().newCommitterIdent(now, tz);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ListProjects.class);
    bind(ApprovalsUtil.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ListProjects.class);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new EhcachePoolImpl.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                    factory(NotesBranchUtil.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new DefaultCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                    factory(NotesBranchUtil.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#end_block

#method_before
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
        for (CodeReviewCommit c : commits) {
            notes.set(c, createNoteContent(c.change, c));
            message.append("* ").append(c.getShortMessage()).append("\n");
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, message.toString());
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#method_after
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
        for (CodeReviewCommit c : commits) {
            notes.set(c, createNoteContent(c.change, c));
            message.append("* ").append(c.getShortMessage()).append("\n");
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, message.toString());
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } catch (ConcurrentRefUpdateException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#end_block

#method_before
public void create(List<Change> changes, PersonIdent author, String commitMessage, ProgressMonitor monitor) throws OrmException, IOException, CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        if (monitor == null) {
            monitor = NullProgressMonitor.INSTANCE;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        for (Change c : changes) {
            monitor.update(1);
            PatchSet ps = schema.patchSets().get(c.currentPatchSetId());
            if (ps == null) {
                continue;
            }
            ObjectId commitId = ObjectId.fromString(ps.getRevision().get());
            notes.set(commitId, createNoteContent(c, commitId));
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, commitMessage);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#method_after
public void create(List<Change> changes, PersonIdent author, String commitMessage, ProgressMonitor monitor) throws OrmException, IOException, CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        if (monitor == null) {
            monitor = NullProgressMonitor.INSTANCE;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        for (Change c : changes) {
            monitor.update(1);
            PatchSet ps = schema.patchSets().get(c.currentPatchSetId());
            ObjectId commitId = ObjectId.fromString(ps.getRevision().get());
            notes.set(commitId, createNoteContent(c, commitId));
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, commitMessage);
    } catch (ConcurrentRefUpdateException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#end_block

#method_before
public final void commitAllNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException {
    this.overwrite = true;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
}
#method_after
public final void commitAllNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException, ConcurrentRefUpdateException {
    this.overwrite = true;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
}
#end_block

#method_before
public final NoteMap commitNewNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException {
    this.overwrite = false;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
    NoteMap newlyCreated = NoteMap.newEmptyMap();
    for (Note n : notes) {
        if (!base.contains(n)) {
            newlyCreated.set(n, n.getData());
        }
    }
    return newlyCreated;
}
#method_after
public final NoteMap commitNewNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException, ConcurrentRefUpdateException {
    this.overwrite = false;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
    NoteMap newlyCreated = NoteMap.newEmptyMap();
    for (Note n : notes) {
        if (base == null || !base.contains(n)) {
            newlyCreated.set(n, n.getData());
        }
    }
    return newlyCreated;
}
#end_block

#method_before
private void commitNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        reader = db.newObjectReader();
        loadBase(notesBranch);
        if (overwrite) {
            addAllNotes(notes);
        } else {
            addNewNotes(notes);
        }
        if (base != null) {
            oursCommit = createCommit(ours, commitAuthor, commitMessage, baseCommit);
        } else {
            oursCommit = createCommit(ours, commitAuthor, commitMessage);
        }
        updateRef(notesBranch);
    } catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (ConcurrentRefUpdateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } finally {
        revWalk.release();
        inserter.release();
        reader.release();
    }
}
#method_after
private void commitNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException, ConcurrentRefUpdateException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        reader = db.newObjectReader();
        loadBase(notesBranch);
        if (overwrite) {
            addAllNotes(notes);
        } else {
            addNewNotes(notes);
        }
        if (base != null) {
            oursCommit = createCommit(ours, commitAuthor, commitMessage, baseCommit);
        } else {
            oursCommit = createCommit(ours, commitAuthor, commitMessage);
        }
        updateRef(notesBranch);
    } finally {
        revWalk.release();
        inserter.release();
        reader.release();
    }
}
#end_block

#method_before
private void addAllNotes(NoteMap notes) throws IOException {
    for (Note n : notes) {
        if (ours.contains(n)) {
            // merge the existing and the new note as if they are both new
            // means: base == null
            // there is not really a common ancestry for these two note revisions
            // use the same NoteMerger that is used from the NoteMapMerger
            NoteMerger noteMerger = new ReviewNoteMerger();
            ObjectId noteContent = noteMerger.merge(null, n, ours.getNote(n), reader, inserter).getData();
            ours.set(n, noteContent);
        } else {
            ours.set(n, n.getData());
        }
    }
}
#method_after
private void addAllNotes(NoteMap notes) throws IOException {
    for (Note n : notes) {
        if (ours.contains(n)) {
            // Merge the existing and the new note as if they are both new,
            // means: base == null
            // There is no really a common ancestry for these two note revisions
            NoteMerger noteMerger = new ReviewNoteMerger();
            ObjectId noteContent = noteMerger.merge(null, n, ours.getNote(n), reader, inserter).getData();
            ours.set(n, noteContent);
        } else {
            ours.set(n, n.getData());
        }
    }
}
#end_block

#method_before
private void loadBase(String notesBranch) throws IOException {
    Ref branch = db.getRef(notesBranch);
    if (branch != null) {
        baseCommit = revWalk.parseCommit(branch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
}
#method_after
private void loadBase(String notesBranch) throws IOException {
    Ref branch = db.getRef(notesBranch);
    if (branch != null) {
        baseCommit = revWalk.parseCommit(branch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
    if (baseCommit != null) {
        ours = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
}
#end_block

#method_before
private void updateRef(String notesBranch) throws IOException, InterruptedException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, db.getRef(notesBranch), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            break;
        }
    }
}
#method_after
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, db.getRef(notesBranch), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            break;
        }
    }
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String[] auths = new String(decoded, encoding(req)).split(":");
    if (auths.length < 2) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = auths[0];
    String password = auths[1];
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = getAuthRequest(who, password);
    if (whoAuth == null) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        session.get().setUserAccountId(whoAuthResult.getAccountId(), AuthMethod.PASSWORD);
        return true;
    } catch (AccountException e) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null) {
        // 
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        session.get().setUserAccountId(whoAuthResult.getAccountId(), AuthMethod.PASSWORD);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private String encoding(HttpServletRequest req) {
    String encoding = req.getCharacterEncoding();
    if (encoding == null)
        encoding = "UTF-8";
    return encoding;
}
#method_after
private String encoding(HttpServletRequest req) {
    return Objects.firstNonNull(req.getCharacterEncoding(), "UTF-8");
}
#end_block

#method_before
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append("Basic");
        v.append(" realm=\"" + REALM_NAME + "\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#method_after
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(LIT_BASIC);
        v.append("realm=\"" + REALM_NAME + "\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#end_block

#method_before
public void display(final Change chg, final AccountInfoCache acc) {
    final Branch.NameKey dst = chg.getDest();
    CopyableLabel changeIdLabel = new CopyableLabel("Change-Id: " + chg.getKey().get());
    changeIdLabel.setPreviewText(chg.getKey().get());
    table.setWidget(R_CHANGE_ID, 1, changeIdLabel);
    table.setWidget(R_OWNER, 1, AccountLink.link(acc, chg.getOwner()));
    table.setWidget(R_PROJECT, 1, new ProjectLink(chg.getProject(), chg.getStatus()));
    table.setWidget(R_BRANCH, 1, new BranchLink(dst.getShortName(), chg.getProject(), chg.getStatus(), dst.get(), null));
    table.setWidget(R_TOPIC, 1, new BranchLink(chg.getTopic(), chg.getProject(), chg.getStatus(), dst.get(), chg.getTopic()));
    table.setText(R_UPLOADED, 1, mediumFormat(chg.getCreatedOn()));
    table.setText(R_UPDATED, 1, mediumFormat(chg.getLastUpdatedOn()));
    table.setText(R_STATUS, 1, Util.toLongString(chg.getStatus()));
    boolean changeClosed = chg.getStatus().isClosed();
    if (Gerrit.getConfig().testChangeMerge()) {
        if (changeClosed) {
            table.getRowFormatter().setVisible(R_MERGE_TEST, false);
        } else {
            table.setText(R_MERGE_TEST, 1, chg.isMergeable() ? Util.C.changeInfoBlockCanMergeYes() : Util.C.changeInfoBlockCanMergeNo());
        }
    }
    if (changeClosed) {
        table.getCellFormatter().addStyleName(R_STATUS, 1, Gerrit.RESOURCES.css().closedstate());
    } else {
        table.getCellFormatter().removeStyleName(R_STATUS, 1, Gerrit.RESOURCES.css().closedstate());
    }
    final FlowPanel fp = new FlowPanel();
    fp.add(new ChangeLink(Util.C.changePermalink(), chg.getId()));
    fp.add(new CopyableLabel(ChangeLink.permalink(chg.getId()), false));
    table.setWidget(R_PERMALINK, 1, fp);
}
#method_after
public void display(final Change chg, final AccountInfoCache acc) {
    final Branch.NameKey dst = chg.getDest();
    CopyableLabel changeIdLabel = new CopyableLabel("Change-Id: " + chg.getKey().get());
    changeIdLabel.setPreviewText(chg.getKey().get());
    table.setWidget(R_CHANGE_ID, 1, changeIdLabel);
    table.setWidget(R_OWNER, 1, AccountLink.link(acc, chg.getOwner()));
    table.setWidget(R_PROJECT, 1, new ProjectLink(chg.getProject(), chg.getStatus()));
    table.setWidget(R_BRANCH, 1, new BranchLink(dst.getShortName(), chg.getProject(), chg.getStatus(), dst.get(), null));
    table.setWidget(R_TOPIC, 1, new BranchLink(chg.getTopic(), chg.getProject(), chg.getStatus(), dst.get(), chg.getTopic()));
    table.setText(R_UPLOADED, 1, mediumFormat(chg.getCreatedOn()));
    table.setText(R_UPDATED, 1, mediumFormat(chg.getLastUpdatedOn()));
    table.setText(R_STATUS, 1, Util.toLongString(chg.getStatus()));
    final Change.Status status = chg.getStatus();
    if (Gerrit.getConfig().testChangeMerge()) {
        if (status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) {
            table.getRowFormatter().setVisible(R_MERGE_TEST, true);
            table.setText(R_MERGE_TEST, 1, chg.isMergeable() ? Util.C.changeInfoBlockCanMergeYes() : Util.C.changeInfoBlockCanMergeNo());
        } else {
            table.getRowFormatter().setVisible(R_MERGE_TEST, false);
        }
    }
    if (status.isClosed()) {
        table.getCellFormatter().addStyleName(R_STATUS, 1, Gerrit.RESOURCES.css().closedstate());
    } else {
        table.getCellFormatter().removeStyleName(R_STATUS, 1, Gerrit.RESOURCES.css().closedstate());
    }
    final FlowPanel fp = new FlowPanel();
    fp.add(new ChangeLink(Util.C.changePermalink(), chg.getId()));
    fp.add(new CopyableLabel(ChangeLink.permalink(chg.getId()), false));
    table.setWidget(R_PERMALINK, 1, fp);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, repoManager, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase());
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final RevId cprev = loader.patchSet.getRevision();
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    if (cprev != null) {
        for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
            final Change.Id ck = a.getPatchSet().getParentKey();
            if (descendants.add(ck)) {
                changesToGet.add(a.getPatchSet().getParentKey());
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(ck);
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
public ReviewResult call() throws IllegalStateException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, repoManager, patchSetId);
    if (submitResult.isEmpty()) {
        throw new IllegalStateException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
                break;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws IllegalStateException, InvalidChangeOperationException, NoSuchChangeException, OrmException, IOException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patch);
    if (submitResult.isEmpty()) {
        throw new IllegalStateException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case MAY:
                            // The MAY label didn't cause the NOT_READY status
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
    }
    if (!ProjectUtil.branchExists(repoManager, control.getChange().getDest())) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.DEST_BRANCH_NOT_FOUND, "Destination branch \"" + control.getChange().getDest().get() + "\" not found."));
        return result;
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
                break;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#end_block

#method_before
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
public void login(final AuthResult res, final AuthMethod meth, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null);
    saveCookie();
    authMethod = meth;
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent event) {
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent event) {
    resetEditors();
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final Set<String> diffs = new HashSet<String>();
            final Map<String, AccessSection> wantedSections = new HashMap<String, AccessSection>();
            for (final AccessSection section : wantedAccess.getLocal()) {
                wantedSections.put(section.getName(), section);
            }
            for (final AccessSection newSection : newAccess.getLocal()) {
                final AccessSection wantedSection = wantedSections.remove(newSection.getName());
                if (wantedSection == null) {
                    diffs.add(newSection.getName());
                    continue;
                }
                if (wantedSection.compareTo(newSection) != 0) {
                    diffs.add(wantedSection.getName());
                    continue;
                }
            }
            for (final AccessSection wantedSection : wantedSections.values()) {
                diffs.add(wantedSection.getName());
            }
            return diffs;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            super.onFailure(caught);
        }
    });
}
#method_after
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final HashSet<AccessSection> same = new HashSet<AccessSection>(wantedAccess.getLocal());
            final HashSet<AccessSection> different = new HashSet<AccessSection>(wantedAccess.getLocal().size() + newAccess.getLocal().size());
            different.addAll(wantedAccess.getLocal());
            different.addAll(newAccess.getLocal());
            same.retainAll(newAccess.getLocal());
            different.removeAll(same);
            final Set<String> differentNames = new HashSet<String>();
            for (final AccessSection s : different) {
                differentNames.add(s.getName());
            }
            return differentNames;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public Account find(final String nameOrEmail) throws OrmException {
    Set<Account.Id> r = findAll(nameOrEmail);
    if (r.size() == 1) {
        byId.get(r.iterator().next()).getAccount();
    } else {
        // return best match
        final int lt = nameOrEmail.indexOf('<');
        final int gt = nameOrEmail.indexOf('>');
        if (lt >= 0 && gt > lt && nameOrEmail.contains("@")) {
            for (Account.Id id : r) {
                Account a = byId.get(id).getAccount();
                if (a.getFullName().equals(nameOrEmail.substring(0, lt - 1))) {
                    return a;
                }
            }
        }
    }
    // no good match, return null
    return null;
}
#method_after
public Account find(final String nameOrEmail) throws OrmException {
    Set<Account.Id> r = findAll(nameOrEmail);
    return r.size() == 1 ? byId.get(r.iterator().next()).getAccount() : null;
}
#end_block

#method_before
public Set<Account.Id> findAllByNameOrEmail(final String nameOrEmail) throws OrmException {
    final int lt = nameOrEmail.indexOf('<');
    final int gt = nameOrEmail.indexOf('>');
    if (lt >= 0 && gt > lt && nameOrEmail.contains("@")) {
        return byEmail.get(nameOrEmail.substring(lt + 1, gt));
    }
    if (nameOrEmail.contains("@")) {
        return byEmail.get(nameOrEmail);
    }
    final Account.Id id = realm.lookup(nameOrEmail);
    if (id != null) {
        return Collections.singleton(id);
    }
    List<Account> m = schema.get().accounts().byFullName(nameOrEmail).toList();
    if (m.size() == 1) {
        return Collections.singleton(m.get(0).getId());
    }
    // At this point we have no clue. Just perform a whole bunch of suggestions
    // and pray we come up with a reasonable result list.
    // 
    Set<Account.Id> result = new HashSet<Account.Id>();
    String a = nameOrEmail;
    String b = nameOrEmail + "\u9fa5";
    for (Account act : schema.get().accounts().suggestByFullName(a, b, 10)) {
        result.add(act.getId());
    }
    for (AccountExternalId extId : schema.get().accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, b), 10)) {
        result.add(extId.getAccountId());
    }
    for (AccountExternalId extId : schema.get().accountExternalIds().suggestByEmailAddress(a, b, 10)) {
        result.add(extId.getAccountId());
    }
    return result;
}
#method_after
public Set<Account.Id> findAllByNameOrEmail(final String nameOrEmail) throws OrmException {
    final int lt = nameOrEmail.indexOf('<');
    final int gt = nameOrEmail.indexOf('>');
    if (lt >= 0 && gt > lt && nameOrEmail.contains("@")) {
        Set<Account.Id> ids = byEmail.get(nameOrEmail.substring(lt + 1, gt));
        if (ids.isEmpty() || ids.size() == 1) {
            return ids;
        }
        // more than one match, try to return the best one
        String name = nameOrEmail.substring(0, lt - 1);
        Set<Account.Id> nameMatches = Sets.newHashSet();
        for (Account.Id id : ids) {
            Account a = byId.get(id).getAccount();
            if (name.equals(a.getFullName())) {
                nameMatches.add(id);
            }
        }
        return nameMatches.isEmpty() ? ids : nameMatches;
    }
    if (nameOrEmail.contains("@")) {
        return byEmail.get(nameOrEmail);
    }
    final Account.Id id = realm.lookup(nameOrEmail);
    if (id != null) {
        return Collections.singleton(id);
    }
    List<Account> m = schema.get().accounts().byFullName(nameOrEmail).toList();
    if (m.size() == 1) {
        return Collections.singleton(m.get(0).getId());
    }
    // At this point we have no clue. Just perform a whole bunch of suggestions
    // and pray we come up with a reasonable result list.
    // 
    Set<Account.Id> result = new HashSet<Account.Id>();
    String a = nameOrEmail;
    String b = nameOrEmail + "\u9fa5";
    for (Account act : schema.get().accounts().suggestByFullName(a, b, 10)) {
        result.add(act.getId());
    }
    for (AccountExternalId extId : schema.get().accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, b), 10)) {
        result.add(extId.getAccountId());
    }
    for (AccountExternalId extId : schema.get().accountExternalIds().suggestByEmailAddress(a, b, 10)) {
        result.add(extId.getAccountId());
    }
    return result;
}
#end_block

#method_before
private void validate() throws UnloggedFailure {
    if (isBothSet(contentMerge, noContentMerge)) {
        throw new UnloggedFailure(1, "--use-content-merge and --no-content-merge options are mutually exclusive.");
    }
    if (isBothSet(contributorAgreements, noContributorAgreements)) {
        throw new UnloggedFailure(1, "--use-contributor-agreements and --no-contributor-agreements options are mutually exclusive.");
    }
    if (isBothSet(signedOffBy, noSignedOffBy)) {
        throw new UnloggedFailure(1, "--use-signed-off-by and --no-signed-off-by options are mutually exclusive.");
    }
    if (isBothSet(requireChangeID, noRequireChangeID)) {
        throw new UnloggedFailure(1, "--use-change-id and --no-change-id options are mutually exclusive.");
    }
}
#method_after
private void validate() throws UnloggedFailure {
    checkExclusivity(contentMerge, "--use-content-merge", noContentMerge, "--no-content-merge");
    checkExclusivity(contributorAgreements, "--use-contributor-agreements", noContributorAgreements, "--no-contributor-agreements");
    checkExclusivity(signedOffBy, "--use-signed-off-by", noSignedOffBy, "--no-signed-off-by");
    checkExclusivity(requireChangeID, "--require-change-id", noRequireChangeID, "--no-change-id");
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ReviewCommand.class);
    command(gerrit, "create-account").to(CreateAccountCommand.class);
    command(gerrit, "create-group").to(CreateGroupCommand.class);
    command(gerrit, "rename-group").to(RenameGroupCommand.class);
    command(gerrit, "create-project").to(CreateProjectCommand.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "set-reviewers").to(SetReviewersCommand.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(Replicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "review").to(ReviewCommand.class);
    command(gerrit, "set-account").to(SetAccountCommand.class);
    command(gerrit, "set-project").to(SetProjectCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ReviewCommand.class);
    command(gerrit, "create-account").to(CreateAccountCommand.class);
    command(gerrit, "create-group").to(CreateGroupCommand.class);
    command(gerrit, "rename-group").to(RenameGroupCommand.class);
    command(gerrit, "create-project").to(CreateProjectCommand.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "set-reviewers").to(SetReviewersCommand.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "review").to(ReviewCommand.class);
    command(gerrit, "set-account").to(SetAccountCommand.class);
    command(gerrit, "set-project").to(SetProjectCommand.class);
}
#end_block

#method_before
public void display(Change.Id changeId, Boolean starred, String commitMessage) {
    if (changeId != null && starred != null && Gerrit.isSignedIn() && starPanel.getWidget() == null) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(Change.Id changeId, Boolean starred, String commitMessage) {
    starPanel.clear();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (!patch.isDraft()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.NOT_A_DRAFT));
        return result;
    }
    if (!control.canPublish(db)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.PUBLISH_NOT_PERMITTED));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if ((updatedChange != null) && (updatedChange.getStatus() == Change.Status.NEW)) {
                hooks.doDraftPublishedHook(updatedChange, patch, db);
            }
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (!patch.isDraft()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.NOT_A_DRAFT));
        return result;
    }
    if (!control.canPublish(db)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.PUBLISH_NOT_PERMITTED));
    } else {
        boolean published = false;
        final PatchSet updatedPatch = db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                    return patchset;
                }
                return null;
            }
        });
        if ((updatedPatch != null) && (!updatedPatch.isDraft())) {
            published = true;
        }
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if ((updatedChange != null) && (updatedChange.getStatus() == Change.Status.NEW)) {
                published = true;
            }
        }
        if (published) {
            hooks.doDraftPublishedHook(change, patch, db);
        }
    }
    return result;
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail);
    if (detail.getCurrentPatchSetDetail().getInfo().getParents().size() > 1) {
        patchesList.addItem(Util.C.autoMerge());
    } else {
        patchesList.addItem(Util.C.baseDiffItem());
    }
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    addComments(detail);
    // If any dependency change is still open, or is outdated,
    // or the change is needed by a change that is new or submitted,
    // show our dependency list.
    // 
    boolean depsOpen = false;
    int outdated = 0;
    if (!detail.getChange().getStatus().isClosed()) {
        if (detail.getDependsOn() != null) {
            for (final ChangeInfo ci : detail.getDependsOn()) {
                if (!ci.isLatest()) {
                    depsOpen = true;
                    outdated++;
                } else if (ci.getStatus() != Change.Status.MERGED) {
                    depsOpen = true;
                }
            }
        }
        if (detail.getNeededBy() != null) {
            for (final ChangeInfo ci : detail.getNeededBy()) {
                if ((ci.getStatus() == Change.Status.NEW) || (ci.getStatus() == Change.Status.SUBMITTED)) {
                    depsOpen = true;
                }
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    dependenciesPanel.getHeader().clear();
    if (outdated > 0) {
        dependenciesPanel.getHeader().add(new InlineLabel(Util.M.outdatedHeader(outdated)));
    }
    if (!isCurrentView()) {
        display();
    }
    patchSetsBlock.setRegisterKeys(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.isStarred(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail);
    if (detail.getCurrentPatchSetDetail().getInfo().getParents().size() > 1) {
        patchesList.addItem(Util.C.autoMerge());
    } else {
        patchesList.addItem(Util.C.baseDiffItem());
    }
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    addComments(detail);
    // If any dependency change is still open, or is outdated,
    // or the change is needed by a change that is new or submitted,
    // show our dependency list.
    // 
    boolean depsOpen = false;
    int outdated = 0;
    if (!detail.getChange().getStatus().isClosed()) {
        if (detail.getDependsOn() != null) {
            for (final ChangeInfo ci : detail.getDependsOn()) {
                if (!ci.isLatest()) {
                    depsOpen = true;
                    outdated++;
                } else if (ci.getStatus() != Change.Status.MERGED) {
                    depsOpen = true;
                }
            }
        }
        if (detail.getNeededBy() != null) {
            for (final ChangeInfo ci : detail.getNeededBy()) {
                if ((ci.getStatus() == Change.Status.NEW) || (ci.getStatus() == Change.Status.SUBMITTED)) {
                    depsOpen = true;
                }
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    dependenciesPanel.getHeader().clear();
    if (outdated > 0) {
        dependenciesPanel.getHeader().add(new InlineLabel(Util.M.outdatedHeader(outdated)));
    }
    if (!isCurrentView()) {
        display();
    }
    patchSetsBlock.setRegisterKeys(true);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
public void display(final String commitMessage) {
    display(null, commitMessage);
}
#method_after
public void display(final String commitMessage) {
    display(null, null, commitMessage);
}
#end_block

#method_before
public void display(final Id changeId, final String commitMessage) {
    if (changeId != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, false);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(Change.Id changeId, Boolean starred, String commitMessage) {
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    messageBlock.display(chg.getId(), info.getMessage());
}
#method_after
public void display(Change chg, Boolean starred, PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    messageBlock.display(chg.getId(), starred, info.getMessage());
}
#end_block

#method_before
private List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                for (final String permissionName : Permission.getPermissionNames()) {
                    if (!Permission.canBeOnWildProject(permissionName)) {
                        section.removePermission(permissionName);
                    }
                }
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
private List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
boolean isOwner(Set<AccountGroup.UUID> groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (CollectionsUtil.isAnyIncludedIn(s.localOwners, groups)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#method_after
boolean isOwner(GroupMembership groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (groups.containsAnyOf(s.localOwners)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#end_block

#method_before
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    Project.NameKey parentName = getProject().getParent();
    if (parentName == null) {
        parentName = allProjectsName;
    }
    return projectCache.get(parentName);
}
#method_after
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    return projectCache.get(getProject().getParent(allProjectsName));
}
#end_block

#method_before
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && AccessSection.isAccessSection(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#method_after
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && RefConfigSection.isValid(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (AccessSection.isAccessSection(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (RefConfigSection.isValid(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            addPermission(varName, perms);
        }
    } else if (AccessSection.isAccessSection(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            addPermission(varName, perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            addPermission(varName, perms);
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            addPermission(varName, perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
private void addPermission(final String permissionName, final List<String> permissionList) {
    if (value.getPermission(permissionName) != null) {
        return;
    }
    if (Gerrit.getConfig().getWildProject().equals(projectAccess.getProjectName()) && !Permission.canBeOnWildProject(permissionName)) {
        return;
    }
    permissionList.add(permissionName);
}
#method_after
private void addPermission(final String permissionName, final List<String> permissionList) {
    if (value.getPermission(permissionName) != null) {
        return;
    }
    if (Gerrit.getConfig().getWildProject().equals(projectAccess.getProjectName()) && !Permission.canBeOnAllProjects(value.getName(), permissionName)) {
        return;
    }
    permissionList.add(permissionName);
}
#end_block

#method_before
@Override
public PermissionEditor create(int index) {
    PermissionEditor subEditor = new PermissionEditor(readOnly, value);
    permissionContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionEditor create(int index) {
    PermissionEditor subEditor = new PermissionEditor(projectAccess.getProjectName(), readOnly, value);
    permissionContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.initHighlightUnreviewed(true, ownerId);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.setHighlightUnreviewed(true);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#end_block

#method_before
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), compare());
    Collections.sort(in.asList(), compare());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#method_after
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), outComparator());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#end_block

#method_before
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#method_after
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else if (optional()) {
        return SubmitRecord.Label.Status.MAY;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed, Account.Id accountId) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    boolean reviewScored = false;
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
        reviewScored = true;
    }
    boolean needHighlight = false;
    // patch set, we also don't highlight it.
    if (highlightUnreviewed && !reviewScored && accountId != null) {
        needHighlight = true;
        for (int i = 0; i < c.messageAuthorIds().length(); i++) {
            if (accountId.get() == c.messageAuthorIds().get(i)) {
                needHighlight = false;
                break;
            }
        }
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed, ownerId);
    }
}
#method_after
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed);
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.labels = labelsFor(cd);
    out.messageauthors = recentMessageAuthorIds(cd);
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd);
    return out;
}
#end_block

#method_before
private AccountAttribute asAccountAttribute(Account.Id user) {
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#method_after
private AccountAttribute asAccountAttribute(Account.Id user) {
    if (user == null) {
        return null;
    }
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, null);
    projectListPopup.addOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    projectsTab = new ProjectsTable() {

        {
            keysNavigation.add(new OpenKeyCommand(0, 'o', Util.C.projectListOpen()));
            keysNavigation.add(new OpenKeyCommand(0, KeyCodes.KEY_ENTER, Util.C.projectListOpen()));
        }

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            // prevent user input from being overwritten by simply poping up
            if (!popingUp || "".equals(nameBox.getText())) {
                nameBox.setText(getRowItem(row).name());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            nameBox.setText(getRowItem(row).name());
            doAddNew();
        }
    };
    projectsTab.setSavePointerId(PageLinks.SETTINGS_PROJECTS);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(Util.C.projects());
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    closePopup();
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail);
    if (detail.getCurrentPatchSetDetail().getInfo().getParents().size() > 1) {
        patchesList.addItem(Util.C.autoMerge());
    } else {
        patchesList.addItem(Util.C.baseDiffItem());
    }
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    addComments(detail);
    // If any dependency change is still open, or is outdated,
    // show our dependency list.
    // 
    boolean depsOpen = false;
    int outdated = 0;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (!ci.isLatest()) {
                depsOpen = true;
                outdated++;
            } else if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
            }
        }
        if (detail.getNeededBy() != null) {
            depsOpen = true;
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    dependenciesPanel.getHeader().clear();
    if (outdated > 0) {
        dependenciesPanel.getHeader().add(new InlineLabel(Util.M.outdatedHeader(outdated)));
    }
    if (!isCurrentView()) {
        display();
    }
    patchSetsBlock.setRegisterKeys(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail);
    if (detail.getCurrentPatchSetDetail().getInfo().getParents().size() > 1) {
        patchesList.addItem(Util.C.autoMerge());
    } else {
        patchesList.addItem(Util.C.baseDiffItem());
    }
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    addComments(detail);
    // If any dependency change is still open, or is outdated,
    // or the change is needed by a change that is new or submitted,
    // show our dependency list.
    // 
    boolean depsOpen = false;
    int outdated = 0;
    if (!detail.getChange().getStatus().isClosed()) {
        if (detail.getDependsOn() != null) {
            for (final ChangeInfo ci : detail.getDependsOn()) {
                if (!ci.isLatest()) {
                    depsOpen = true;
                    outdated++;
                } else if (ci.getStatus() != Change.Status.MERGED) {
                    depsOpen = true;
                }
            }
        }
        if (detail.getNeededBy() != null) {
            for (final ChangeInfo ci : detail.getNeededBy()) {
                if ((ci.getStatus() == Change.Status.NEW) || (ci.getStatus() == Change.Status.SUBMITTED)) {
                    depsOpen = true;
                }
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    dependenciesPanel.getHeader().clear();
    if (outdated > 0) {
        dependenciesPanel.getHeader().add(new InlineLabel(Util.M.outdatedHeader(outdated)));
    }
    if (!isCurrentView()) {
        display();
    }
    patchSetsBlock.setRegisterKeys(true);
}
#end_block

#method_before
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = SafeHtmlUtils.htmlEscape(splitCommitMessage[1]);
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    commitSummaryPre.setInnerText(commitSummary);
    // Linkify commit body for Change-Id etc.
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#method_after
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = splitCommitMessage[1];
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    // Linkify commit body
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#end_block

#method_before
@Override
public final int parseArguments(final Parameters params) throws CmdLineException {
    final String n = params.getParameter(0);
    final AccountGroup group = groupCache.get(new AccountGroup.NameKey(n));
    if (group == null) {
        throw new CmdLineException(owner, "Group \"" + n + "\" does not exist");
    }
    setter.addValue(group.getGroupUUID());
    return 1;
}
#method_after
@Override
public final int parseArguments(final Parameters params) throws CmdLineException {
    final String n = params.getParameter(0);
    final GroupReference group = GroupBackends.findBestSuggestion(groupBackend, n);
    if (group == null) {
        throw new CmdLineException(owner, "Group \"" + n + "\" does not exist");
    }
    setter.addValue(group.getUUID());
    return 1;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        final Provider<Command> p = commands.get(commandName);
        if (p == null) {
            String msg = (prefix.isEmpty() ? "Gerrit Code Review" : prefix) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (prefix.isEmpty())
                bc.setName(commandName);
            else
                bc.setName(prefix + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        final Provider<Command> p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!prefix.isEmpty()) {
        usage.append(" of ");
        usage.append(prefix);
    }
    usage.append(" are:\n");
    usage.append("\n");
    for (Map.Entry<String, Provider<Command>> e : commands.entrySet()) {
        usage.append("   ");
        usage.append(e.getKey());
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (prefix.indexOf(' ') < 0) {
        usage.append(prefix);
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#method_after
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    for (String name : Sets.newTreeSet(commands.keySet())) {
        usage.append("   ");
        usage.append(name);
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#end_block

#method_before
@Override
protected void run() {
    loader.rescan(true);
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (names == null || names.isEmpty()) {
        loader.rescan();
    } else {
        try {
            loader.reload(names);
        } catch (InvalidPluginException e) {
            throw die(e.getMessage());
        } catch (PluginInstallException e) {
            throw die(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        noCache(res);
        sendText(req, res, err.getMessage());
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#end_block

#method_before
private void checkRequiresCapability() throws RuntimeException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new RuntimeException(msg);
        }
    }
}
#method_after
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    Map<String, PluginInfo> output = Maps.newTreeMap();
    List<Plugin> plugins = pluginLoader.getPlugins();
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (!format.isJson()) {
        stdout.format("%-30s %-10s\n", "Name", "Version");
        stdout.print("----------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo();
        info.name = p.getName();
        info.version = p.getVersion();
        if (format.isJson()) {
            output.put(info.name, info);
        } else {
            stdout.format("%-30s %-10s\n", info.name, Strings.nullToEmpty(info.version));
        }
    }
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    Map<String, PluginInfo> output = Maps.newTreeMap();
    List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins());
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (!format.isJson()) {
        stdout.format("%-30s %-10s\n", "Name", "Version");
        stdout.print("----------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo();
        info.version = p.getVersion();
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s\n", p.getName(), Strings.nullToEmpty(info.version));
        }
    }
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
}
#end_block

#method_before
public static String toAccountQuery(final String fullname) {
    return "/q/owner:\"" + KeyUtil.encode(fullname) + "\"," + TOP;
}
#method_after
public static String toAccountQuery(final String fullname) {
    String query = op("owner", fullname) + " status:open";
    return toChangeQuery(query, TOP);
}
#end_block

#method_before
public static String toChangeQuery(String query, String page) {
    query = KeyUtil.encode(query).replaceAll("%3[Aa]", ":");
    return "/q/" + query + "," + page;
}
#method_after
public static String toChangeQuery(String query, String page) {
    return "/q/" + KeyUtil.encode(query) + "," + page;
}
#end_block

#method_before
public static String op(String name, String value) {
    if (value.indexOf(' ') >= 0) {
        return name + ":\"" + value + "\"";
    }
    return name + ":" + value;
}
#method_after
public static String op(String op, String value) {
    if (isSingleWord(value)) {
        return op + ":" + value;
    }
    return op + ":\"" + value + "\"";
}
#end_block

#method_before
private static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#method_after
public static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#end_block

#method_before
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
        }
    });
}
#end_block

#method_before
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    // TODO: create buttons and handlers here.
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#method_after
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#end_block

#method_before
void display(final PluginMap plugins) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    List<PluginInfo> list = plugins.values().asList();
    for (final PluginInfo p : list) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, p);
    }
}
#method_after
void display(final PluginMap plugins) {
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    for (final PluginInfo p : plugins.values().asList()) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, p);
    }
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    table.setText(row, 2, plugin.name());
    table.setText(row, 3, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    table.setText(row, 1, plugin.name());
    table.setText(row, 2, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
public String getUnifiedDiff() {
    StringBuilder detail = new StringBuilder();
    if (patchSet != null) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        DiffFormatter df = new DiffFormatter(out);
        db = openRepository();
        reader = db.newObjectReader();
        PatchList patchList = getPatchList();
        for (PatchListEntry p : patchList.getPatches()) {
            if (Patch.COMMIT_MSG.equals(p.getNewName())) {
                continue;
            }
            detail.append("\n");
            List<String> headers = p.getHeaderLines();
            for (String hdr : headers) {
                detail.append(hdr);
            }
            try {
                String filename = p.getNewName();
                RawText aText = resolve(patchList.getOldId(), filename);
                RawText bText = resolve(patchList.getNewId(), filename);
                df.format(toEditList(p.getEdits()), aText, bText);
                detail.append(out.toString());
            } catch (IOException err) {
            }
        }
        detail.append("\n");
    }
    return detail.toString();
}
#method_after
public String getUnifiedDiff() {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    Repository repo = getRepository();
    if (repo != null) {
        DiffFormatter df = new DiffFormatter(out);
        try {
            PatchList patchList = getPatchList();
            if (patchList.getOldId() != null) {
                df.setRepository(repo);
                df.setDetectRenames(true);
                df.format(patchList.getOldId(), patchList.getNewId());
            }
        } catch (PatchListNotAvailableException e) {
            log.error("Cannot format patch", e);
        } catch (IOException e) {
            log.error("Cannot format patch", e);
        } finally {
            df.release();
            repo.close();
        }
    }
    return RawParseUtils.decode(out.toByteArray());
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            for (int line = lineNbr - lines + 1; line <= lineNbr; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append(c.getMessage().trim());
            cmts.append("\n");
            for (int line = lineNbr + 1; line < lineNbr + lines; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#method_after
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            if (currentFileData != null) {
                int maxLines;
                try {
                    maxLines = currentFileData.getLineCount(side);
                } catch (Throwable e) {
                    maxLines = lineNbr;
                }
                final int startLine = Math.max(1, lineNbr - lines + 1);
                final int stopLine = Math.min(maxLines, lineNbr + lines);
                for (int line = startLine; line <= lineNbr; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
                cmts.append(c.getMessage().trim());
                cmts.append("\n");
                for (int line = lineNbr + 1; line < stopLine; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    if (fileData != null) {
        try {
            final String lineStr = fileData.getLine(side, line);
            cmts.append(": ");
            cmts.append(lineStr);
        } catch (Throwable cce) {
        // Don't quote the line if we can't safely convert it.
        }
    }
    cmts.append("\n");
}
#method_after
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    try {
        final String lineStr = fileData.getLine(side, line);
        cmts.append(": ");
        cmts.append(lineStr);
    } catch (Throwable e) {
    // Don't quote the line if we can't safely convert it.
    }
    cmts.append("\n");
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    // Find all groups that have an LDAP type.
    Map<AccountGroup.UUID, GroupReference> ldapUUIDMap = Maps.newHashMap();
    Set<AccountGroup.UUID> toResolve = Sets.newHashSet();
    List<AccountGroup.Id> toDelete = Lists.newArrayList();
    List<AccountGroup.NameKey> namesToDelete = Lists.newArrayList();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT group_id, group_uuid, external_name, name FROM account_groups" + " WHERE group_type ='LDAP'");
        try {
            Map<Integer, ContributorAgreement> agreements = Maps.newHashMap();
            while (rs.next()) {
                AccountGroup.Id groupId = new AccountGroup.Id(rs.getInt(1));
                AccountGroup.UUID groupUUID = new AccountGroup.UUID(rs.getString(2));
                AccountGroup.NameKey name = new AccountGroup.NameKey(rs.getString(4));
                String dn = rs.getString(3);
                if (isNullOrEmpty(dn)) {
                    // The LDAP group does not have a DN. Determine if the UUID is used.
                    toResolve.add(groupUUID);
                } else {
                    toDelete.add(groupId);
                    namesToDelete.add(name);
                    GroupReference ref = groupReference(dn);
                    ldapUUIDMap.put(groupUUID, ref);
                }
            }
        } catch (NamingException e) {
            throw new RuntimeException(e);
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
    if (toDelete.isEmpty() && toResolve.isEmpty()) {
        // No ldap groups. Nothing to do.
        return;
    }
    ui.message("Update LDAP groups to be GroupReferences.");
    // Update the groupOwnerUUID for LDAP groups to point to the new UUID.
    List<AccountGroup> toUpdate = Lists.newArrayList();
    Set<AccountGroup.UUID> resolveToUpdate = Sets.newHashSet();
    Map<AccountGroup.UUID, AccountGroup> resolveGroups = Maps.newHashMap();
    com.google.gwtorm.server.ResultSet<AccountGroup> rs = db.accountGroups().all();
    try {
        for (AccountGroup g : rs) {
            if (ldapUUIDMap.containsKey(g.getGroupUUID())) {
                // Ignore the LDAP groups with a valid DN.
                continue;
            } else if (toResolve.contains(g.getGroupUUID())) {
                // Keep the ones to resolve.
                resolveGroups.put(g.getGroupUUID(), g);
                continue;
            }
            GroupReference ref = ldapUUIDMap.get(g.getOwnerGroupUUID());
            if (ref != null) {
                // Update the owner group UUID to the new ldap UUID scheme.
                g.setOwnerGroupUUID(ref.getUUID());
                toUpdate.add(g);
            } else if (toResolve.contains(g.getOwnerGroupUUID())) {
                // The unresolved group is used as an owner.
                // Add to the list of LDAP groups to be made INTERNAL.
                resolveToUpdate.add(g.getOwnerGroupUUID());
            }
        }
    } finally {
        rs.close();
    }
    toResolve.removeAll(resolveToUpdate);
    // Update project.config group references to use the new LDAP GroupReference
    for (Project.NameKey name : mgr.list()) {
        Repository git;
        try {
            git = mgr.openRepository(name);
        } catch (RepositoryNotFoundException e) {
            throw new OrmException(e);
        } catch (IOException e) {
            throw new OrmException(e);
        }
        try {
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, name, git);
            md.getCommitBuilder().setAuthor(serverUser);
            md.getCommitBuilder().setCommitter(serverUser);
            ProjectConfig config = ProjectConfig.read(md);
            // Update the existing refences to the new reference.
            boolean updated = false;
            for (Map.Entry<AccountGroup.UUID, GroupReference> entry : ldapUUIDMap.entrySet()) {
                GroupReference ref = config.getGroup(entry.getKey());
                if (ref != null) {
                    updated = true;
                    ref.setName(entry.getValue().getName());
                    ref.setUUID(entry.getValue().getUUID());
                    config.resolve(ref);
                }
            }
            // Determine if a toResolve group is used and should be made INTERNAL.
            Iterator<AccountGroup.UUID> iter = toResolve.iterator();
            while (iter.hasNext()) {
                AccountGroup.UUID uuid = iter.next();
                if (config.getGroup(uuid) != null) {
                    resolveToUpdate.add(uuid);
                    iter.remove();
                }
            }
            if (!updated) {
                continue;
            }
            md.setMessage("Upgrade to Gerrit Code Review schema 68\n");
            if (!config.commit(md)) {
                throw new OrmException("Cannot update " + name);
            }
        } catch (IOException e) {
            throw new OrmException(e);
        } catch (ConfigInvalidException e) {
            throw new OrmException(e);
        } finally {
            git.close();
        }
    }
    for (AccountGroup.UUID uuid : resolveToUpdate) {
        AccountGroup group = resolveGroups.get(uuid);
        group.setType(AccountGroup.Type.INTERNAL);
        toUpdate.add(group);
        ui.message(String.format("*** Group has no DN and is inuse. Updated to be INTERNAL: %s", group.getName()));
    }
    for (AccountGroup.UUID uuid : toResolve) {
        AccountGroup group = resolveGroups.get(uuid);
        toDelete.add(group.getId());
        namesToDelete.add(group.getNameKey());
    }
    // Update group owners
    db.accountGroups().update(toUpdate);
    // Delete existing LDAP groups
    db.accountGroupNames().deleteKeys(namesToDelete);
    db.accountGroups().deleteKeys(toDelete);
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    // Find all groups that have an LDAP type.
    Map<AccountGroup.UUID, GroupReference> ldapUUIDMap = Maps.newHashMap();
    Set<AccountGroup.UUID> toResolve = Sets.newHashSet();
    List<AccountGroup.Id> toDelete = Lists.newArrayList();
    List<AccountGroup.NameKey> namesToDelete = Lists.newArrayList();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT group_id, group_uuid, external_name, name FROM account_groups" + " WHERE group_type ='LDAP'");
        try {
            while (rs.next()) {
                AccountGroup.Id groupId = new AccountGroup.Id(rs.getInt(1));
                AccountGroup.UUID groupUUID = new AccountGroup.UUID(rs.getString(2));
                AccountGroup.NameKey name = new AccountGroup.NameKey(rs.getString(4));
                String dn = rs.getString(3);
                if (isNullOrEmpty(dn)) {
                    // The LDAP group does not have a DN. Determine if the UUID is used.
                    toResolve.add(groupUUID);
                } else {
                    toDelete.add(groupId);
                    namesToDelete.add(name);
                    GroupReference ref = groupReference(dn);
                    ldapUUIDMap.put(groupUUID, ref);
                }
            }
        } catch (NamingException e) {
            throw new RuntimeException(e);
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
    if (toDelete.isEmpty() && toResolve.isEmpty()) {
        // No ldap groups. Nothing to do.
        return;
    }
    ui.message("Update LDAP groups to be GroupReferences.");
    // Update the groupOwnerUUID for LDAP groups to point to the new UUID.
    List<AccountGroup> toUpdate = Lists.newArrayList();
    Set<AccountGroup.UUID> resolveToUpdate = Sets.newHashSet();
    Map<AccountGroup.UUID, AccountGroup> resolveGroups = Maps.newHashMap();
    for (AccountGroup g : db.accountGroups().all()) {
        if (ldapUUIDMap.containsKey(g.getGroupUUID())) {
            // Ignore the LDAP groups with a valid DN.
            continue;
        } else if (toResolve.contains(g.getGroupUUID())) {
            // Keep the ones to resolve.
            resolveGroups.put(g.getGroupUUID(), g);
            continue;
        }
        GroupReference ref = ldapUUIDMap.get(g.getOwnerGroupUUID());
        if (ref != null) {
            // Update the owner group UUID to the new ldap UUID scheme.
            g.setOwnerGroupUUID(ref.getUUID());
            toUpdate.add(g);
        } else if (toResolve.contains(g.getOwnerGroupUUID())) {
            // The unresolved group is used as an owner.
            // Add to the list of LDAP groups to be made INTERNAL.
            resolveToUpdate.add(g.getOwnerGroupUUID());
        }
    }
    toResolve.removeAll(resolveToUpdate);
    // Update project.config group references to use the new LDAP GroupReference
    for (Project.NameKey name : mgr.list()) {
        Repository git;
        try {
            git = mgr.openRepository(name);
        } catch (RepositoryNotFoundException e) {
            throw new OrmException(e);
        } catch (IOException e) {
            throw new OrmException(e);
        }
        try {
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, name, git);
            md.getCommitBuilder().setAuthor(serverUser);
            md.getCommitBuilder().setCommitter(serverUser);
            ProjectConfig config = ProjectConfig.read(md);
            // Update the existing refences to the new reference.
            boolean updated = false;
            for (Map.Entry<AccountGroup.UUID, GroupReference> entry : ldapUUIDMap.entrySet()) {
                GroupReference ref = config.getGroup(entry.getKey());
                if (ref != null) {
                    updated = true;
                    ref.setName(entry.getValue().getName());
                    ref.setUUID(entry.getValue().getUUID());
                    config.resolve(ref);
                }
            }
            // Determine if a toResolve group is used and should be made INTERNAL.
            Iterator<AccountGroup.UUID> iter = toResolve.iterator();
            while (iter.hasNext()) {
                AccountGroup.UUID uuid = iter.next();
                if (config.getGroup(uuid) != null) {
                    resolveToUpdate.add(uuid);
                    iter.remove();
                }
            }
            if (!updated) {
                continue;
            }
            md.setMessage("Switch LDAP group UUIDs to DNs\n");
            if (!config.commit(md)) {
                throw new OrmException("Cannot update " + name);
            }
        } catch (IOException e) {
            throw new OrmException(e);
        } catch (ConfigInvalidException e) {
            throw new OrmException(e);
        } finally {
            git.close();
        }
    }
    for (AccountGroup.UUID uuid : resolveToUpdate) {
        AccountGroup group = resolveGroups.get(uuid);
        group.setType(AccountGroup.Type.INTERNAL);
        toUpdate.add(group);
        ui.message(String.format("*** Group has no DN and is inuse. Updated to be INTERNAL: %s", group.getName()));
    }
    for (AccountGroup.UUID uuid : toResolve) {
        AccountGroup group = resolveGroups.get(uuid);
        toDelete.add(group.getId());
        namesToDelete.add(group.getNameKey());
    }
    // Update group owners
    db.accountGroups().update(toUpdate);
    // Delete existing LDAP groups
    db.accountGroupNames().deleteKeys(namesToDelete);
    db.accountGroups().deleteKeys(toDelete);
}
#end_block

#method_before
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && (projectControl != null) && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#method_after
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && projectControl != null && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#end_block

#method_before
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            replication.replicateNewProject(nameKey, head);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException doesNotExist) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, err);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#method_after
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                l.onNewProjectCreated(event);
            }
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (IOException ioErr) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, ioErr);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                AccountGroup accountGroup = groupCache.get(ownerId);
                if (accountGroup != null) {
                    GroupReference group = config.resolve(accountGroup);
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    replication.scheduleUpdate(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                AccountGroup accountGroup = groupCache.get(ownerId);
                if (accountGroup != null) {
                    GroupReference group = config.resolve(accountGroup);
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    referenceUpdated.fire(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#end_block

#method_before
private void createEmptyCommits(final Repository repo, final Project.NameKey project, final List<String> refs) throws IOException {
    ObjectInserter oi = repo.newObjectInserter();
    try {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            final Result result = ru.update();
            switch(result) {
                case NEW:
                    replication.scheduleUpdate(project, ref);
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + createProjectArgs.getProjectName(), e);
        throw e;
    } finally {
        oi.release();
    }
}
#method_after
private void createEmptyCommits(final Repository repo, final Project.NameKey project, final List<String> refs) throws IOException {
    ObjectInserter oi = repo.newObjectInserter();
    try {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            final Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ref);
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + createProjectArgs.getProjectName(), e);
        throw e;
    } finally {
        oi.release();
    }
}
#end_block

#method_before
public String toString() {
    return "(" + label + ", " + status + ", " + appliedBy + ")";
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(label).append(": ").append(status);
    if (appliedBy != null) {
        sb.append(" by ").append(appliedBy);
    }
    return sb.toString();
}
#end_block

#method_before
public String toString() {
    StringBuffer labelList = new StringBuffer();
    if (labels != null) {
        for (Label label : labels) {
            if (labelList.length() != 0) {
                labelList.append(", ");
            }
            labelList.append(label.toString());
        }
    }
    return status + "[" + labelList + "]";
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(status);
    if (status == Status.RULE_ERROR && errorMessage != null) {
        sb.append('(').append(errorMessage).append(')');
    }
    sb.append('[');
    if (labels != null) {
        String delimiter = "";
        for (Label label : labels) {
            sb.append(delimiter).append(label);
            delimiter = ", ";
        }
    }
    sb.append(']');
    return sb.toString();
}
#end_block

#method_before
public static Module module() {
    return new AbstractModule() {

        @Override
        protected void configure() {
            bind(ThreadLocalRequestContext.class);
            bind(RequestContext.class).annotatedWith(Names.named("FALLBACK")).to(FallbackRequestContext.class);
        }

        @Provides
        RequestContext provideRequestContext(@Named("FALLBACK") RequestContext fallback) {
            return Objects.firstNonNull(local.get(), fallback);
        }

        @Provides
        CurrentUser provideCurrentUser(RequestContext ctx) {
            return ctx.getCurrentUser();
        }

        @Provides
        IdentifiedUser provideCurrentUser(CurrentUser user) {
            if (user instanceof IdentifiedUser) {
                return (IdentifiedUser) user;
            }
            throw new ProvisionException(NotSignedInException.MESSAGE, new NotSignedInException());
        }
    };
}
#method_after
public static Module module() {
    return new AbstractModule() {

        @Override
        protected void configure() {
            bind(ThreadLocalRequestContext.class);
            bind(RequestContext.class).annotatedWith(Names.named(FALLBACK)).to(FallbackRequestContext.class);
        }

        @Provides
        RequestContext provideRequestContext(@Named(FALLBACK) RequestContext fallback) {
            return Objects.firstNonNull(local.get(), fallback);
        }

        @Provides
        CurrentUser provideCurrentUser(RequestContext ctx) {
            return ctx.getCurrentUser();
        }

        @Provides
        IdentifiedUser provideCurrentUser(CurrentUser user) {
            if (user instanceof IdentifiedUser) {
                return (IdentifiedUser) user;
            }
            throw new ProvisionException(NotSignedInException.MESSAGE, new NotSignedInException());
        }
    };
}
#end_block

#method_before
public String getHtmlFromMarkdown(String markdownSource) {
    pegProcessor = new PegDownProcessor(ALL);
    String htmled;
    htmled = pegProcessor.markdownToHtml(markdownSource);
    return htmled;
}
#method_after
public byte[] getHtmlFromMarkdown(byte[] data, String charEnc) throws UnsupportedEncodingException {
    String decodedData = RawParseUtils.decode(Charset.forName(charEnc), data);
    String formatted = new PegDownProcessor(ALL).markdownToHtml(decodedData);
    data = formatted.getBytes(charEnc);
    return data;
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    String file = uri.substring(ctx.length() + 1);
    if (file.startsWith("Documentation/") || file.startsWith("static/")) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (file.startsWith("Documentation/") && !isValidEntry(entry)) {
            entry = getRealFileEntry(jar, file);
            if (isValidEntry(entry)) {
                sendResource(jar, entry, res, true);
                return;
            }
        }
        if (isValidEntry(entry)) {
            sendResource(jar, entry, res);
            return;
        }
    }
    noCache(res);
    res.sendError(HttpServletResponse.SC_NOT_FOUND);
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    String file = uri.substring(ctx.length() + 1);
    if (file.startsWith("Documentation/") || file.startsWith("static/")) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (file.startsWith("Documentation/") && !isValidEntry(entry)) {
            entry = getRealFileEntry(jar, file);
            if (isValidEntry(entry)) {
                sendResource(jar, entry, res, holder.plugin.getName(), true);
                return;
            }
        }
        if (isValidEntry(entry)) {
            sendResource(jar, entry, res, holder.plugin.getName());
            return;
        }
    }
    noCache(res);
    res.sendError(HttpServletResponse.SC_NOT_FOUND);
}
#end_block

#method_before
private JarEntry getRealFileEntry(JarFile jar, String file) {
    // TODO: Replace with a loop iterating over possible formatters
    String realFile = file.replaceAll("\\.html$", ".md");
    JarEntry entry = jar.getJarEntry(realFile);
    return entry;
}
#method_after
private JarEntry getRealFileEntry(JarFile jar, String file) {
    // TODO: Replace with a loop iterating over possible formatters
    return jar.getJarEntry(file.replaceAll("\\.html$", ".md"));
}
#end_block

#method_before
private Boolean isValidEntry(JarEntry entry) {
    if (entry != null && entry.getSize() > 0) {
        return true;
    }
    return false;
}
#method_after
private boolean isValidEntry(JarEntry entry) {
    return entry != null && entry.getSize() > 0;
}
#end_block

#method_before
private void sendResource(JarFile jar, JarEntry entry, HttpServletResponse res, Boolean format) throws IOException {
    String entryName = entry.getName();
    byte[] data = null;
    if (entry.getSize() <= 128 * 1024) {
        data = new byte[(int) entry.getSize()];
        InputStream in = jar.getInputStream(entry);
        try {
            IO.readFully(in, data, 0, data.length);
        } finally {
            in.close();
        }
    } else if (format == true) {
        log.warn(String.format("Plugin file %s to large to format", entryName));
    }
    String contentType = null;
    String characterEncoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        characterEncoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    MimeType type;
    if (contentType == null) {
        type = mimeUtil.getMimeType(entryName, data);
        contentType = type.toString();
    }
    if (characterEncoding == null) {
        characterEncoding = "UTF-8";
    }
    if (format == true && data != null) {
        MarkdownFormatter formatter = new MarkdownFormatter();
        String decodedData = RawParseUtils.decode(data);
        String formattedEntry = formatter.getHtmlFromMarkdown(decodedData);
        data = formattedEntry.getBytes(characterEncoding);
        res.setHeader("Content-Length", Long.toString(data.length));
        type = new MimeType("text/html");
        contentType = type.toString();
    } else {
        res.setHeader("Content-Length", Long.toString(entry.getSize()));
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setContentType(contentType);
    if (data != null) {
        res.getOutputStream().write(data);
    } else {
        InputStream in = jar.getInputStream(entry);
        try {
            OutputStream out = res.getOutputStream();
            try {
                byte[] tmp = new byte[1024];
                int n;
                while ((n = in.read(tmp)) > 0) {
                    out.write(tmp, 0, n);
                }
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
}
#method_after
private void sendResource(JarFile jar, JarEntry entry, HttpServletResponse res, String pluginName) throws IOException {
    sendResource(jar, entry, res, pluginName, false);
}
#end_block

#method_before
public void start(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    manager = new LifecycleManager();
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(name, env, jarFile, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        manager.add(sysInjector);
    } else if (auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        manager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (sshModule != null && env.hasSshModule()) {
        sshInjector = sysInjector.createChildInjector(env.getSshModule(), sysInjector.getInstance(sshModule));
        manager.add(sshInjector);
    } else if (auto.sshModule != null && env.hasSshModule()) {
        sshInjector = sysInjector.createChildInjector(env.getSshModule(), auto.sshModule);
        manager.add(sshInjector);
    }
    if (httpModule != null && env.hasHttpModule()) {
        httpInjector = sysInjector.createChildInjector(env.getHttpModule(), sysInjector.getInstance(httpModule));
        manager.add(httpInjector);
    } else if (auto.httpModule != null && env.hasHttpModule()) {
        httpInjector = sysInjector.createChildInjector(env.getHttpModule(), auto.httpModule);
        manager.add(httpInjector);
    }
    manager.start();
}
#method_after
public void start(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    manager = new LifecycleManager();
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(name, env, jarFile, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        manager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        manager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        if (sshModule != null) {
            sshInjector = sysInjector.createChildInjector(env.getSshModule(), sysInjector.getInstance(sshModule));
            manager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            sshInjector = sysInjector.createChildInjector(env.getSshModule(), auto.sshModule);
            manager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        if (httpModule != null) {
            httpInjector = sysInjector.createChildInjector(env.getHttpModule(), sysInjector.getInstance(httpModule));
            manager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            httpInjector = sysInjector.createChildInjector(env.getHttpModule(), auto.httpModule);
            manager.add(httpInjector);
        }
    }
    manager.start();
}
#end_block

#method_before
@Override
public final int parseArguments(final Parameters params) throws CmdLineException {
    final String token = params.getParameter(0);
    final String[] tokens = token.split(",");
    if (tokens.length != 3) {
        throw new CmdLineException(owner, "change should be specified as " + "<project>,<branch>,<change-id>");
    }
    Change.Key key;
    try {
        key = Change.Key.parse(tokens[2]);
        for (Change change : db.changes().byKeyRange(key, key.max())) {
            if (change.getProject().get().equals(tokens[0]) && change.getDest().getShortName().equals(tokens[1])) {
                setter.addValue(change.getId());
                return 1;
            }
            throw new CmdLineException(owner, change.getDest().get() + " " + change.getProject().get());
        }
    } catch (IllegalArgumentException e) {
        throw new CmdLineException(owner, "Change-Id is not valid");
    } catch (OrmException e) {
        throw new CmdLineException(owner, "Database error: " + e.getMessage());
    }
    throw new CmdLineException(owner, "\"" + token + "\": change not found");
}
#method_after
@Override
public final int parseArguments(final Parameters params) throws CmdLineException {
    final String token = params.getParameter(0);
    final String[] tokens = token.split(",");
    if (tokens.length != 3) {
        throw new CmdLineException(owner, "change should be specified as " + "<project>,<branch>,<change-id>");
    }
    try {
        final Change.Key key = Change.Key.parse(tokens[2]);
        final Project.NameKey project = new Project.NameKey(tokens[0]);
        final Branch.NameKey branch = new Branch.NameKey(project, tokens[1]);
        for (final Change change : db.changes().byBranchKey(branch, key)) {
            setter.addValue(change.getId());
            return 1;
        }
    } catch (IllegalArgumentException e) {
        throw new CmdLineException(owner, "Change-Id is not valid");
    } catch (OrmException e) {
        throw new CmdLineException(owner, "Database error: " + e.getMessage());
    }
    throw new CmdLineException(owner, "\"" + token + "\": change not found");
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore(repoManager));
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, repoManager, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch);
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore(repoManager)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException, RepositoryNotFoundException, IOException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
        return result;
    }
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Branch.NameKey destBranch = control.getChange().getDest();
    if (!ProjectUtil.branchExists(repoManager, destBranch)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.DEST_BRANCH_NOT_FOUND, destBranch.get()));
        return result;
    }
    // Create a message to accompany the restored change
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
    if (changeComment != null && changeComment.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(changeComment);
    }
    cmsg.setMessage(msgBuf.toString());
    // Restore the change
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
    hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            if (active && inactive) {
                throw new UnloggedFailure(1, "You can't use both --active and --inactive");
            }
            setAccount();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            validate();
            setAccount();
        }
    });
}
#end_block

#method_before
private void setAccount() throws OrmException, IOException, InvalidSshKeyException, UnloggedFailure {
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw die("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    final Account account;
    AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username);
    AccountExternalId accExtId = db.accountExternalIds().get(key);
    if (accExtId != null) {
        account = db.accounts().get(accExtId.getAccountId());
    } else {
        throw die("Could not find user : " + username);
    }
    Account.Id id = account.getId();
    if (newEmail != null) {
        link(id, newEmail);
    }
    if (oldEmail != null) {
        deleteMail(id, oldEmail);
    }
    if (fullName != null && realm.allowsEdit(FieldName.FULL_NAME)) {
        account.setFullName(fullName);
    }
    if (active) {
        account.setActive(true);
    } else if (inactive) {
        account.setActive(false);
    }
    final String readAddKey = readSshKey(addSshKey);
    if (readAddKey != null) {
        addSshKey(readAddKey, account);
    }
    final String readDeleteKey = readSshKey(deleteSshKey);
    if (readDeleteKey != null) {
        deleteSshKeys(readDeleteKey, account);
    }
    db.accounts().update(Collections.singleton(account));
    byIdCache.evict(id);
    db.close();
}
#method_after
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    final Account account = db.accounts().get(id);
    boolean accountUpdated = false;
    boolean sshKeysUpdated = false;
    for (String email : addEmails) {
        link(id, email);
    }
    for (String email : deleteEmails) {
        deleteMail(id, email);
    }
    if (fullName != null) {
        if (realm.allowsEdit(FieldName.FULL_NAME)) {
            account.setFullName(fullName);
        } else {
            throw new UnloggedFailure(1, "The realm doesn't allow editing names");
        }
    }
    if (active) {
        accountUpdated = true;
        account.setActive(true);
    } else if (inactive) {
        accountUpdated = true;
        account.setActive(false);
    }
    addSshKeys = readSshKey(addSshKeys);
    if (!addSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        addSshKeys(addSshKeys, account);
    }
    deleteSshKeys = readSshKey(deleteSshKeys);
    if (!deleteSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        deleteSshKeys(deleteSshKeys, account);
    }
    if (accountUpdated) {
        db.accounts().update(Collections.singleton(account));
        byIdCache.evict(id);
    }
    if (sshKeysUpdated) {
        sshKeyCache.evict(account.getUserName());
    }
    db.close();
}
#end_block

#method_before
private void deleteSshKeys(final String readDeleteKey, final Account account) throws OrmException {
    ResultSet<AccountSshKey> keys = db.accountSshKeys().byAccount(account.getId());
    if (readDeleteKey.equals("ALL")) {
        db.accountSshKeys().delete(keys);
    } else {
        for (AccountSshKey accountSshKey : keys) {
            if (accountSshKey.getSshPublicKey().equals(readDeleteKey)) {
                db.accountSshKeys().delete(Collections.singleton(accountSshKey));
            }
        }
    }
    sshKeyCache.evict(account.getUserName());
}
#method_after
private void deleteSshKeys(final List<String> keys, final Account account) throws OrmException {
    ResultSet<AccountSshKey> allKeys = db.accountSshKeys().byAccount(account.getId());
    if (keys.contains("ALL")) {
        db.accountSshKeys().delete(allKeys);
    } else {
        List<AccountSshKey> accountKeys = new ArrayList<AccountSshKey>();
        for (String key : keys) {
            for (AccountSshKey accountSshKey : allKeys) {
                if (key.trim().equals(accountSshKey.getSshPublicKey()) || accountSshKey.getComment().trim().equals(key)) {
                    accountKeys.add(accountSshKey);
                }
            }
        }
        db.accountSshKeys().delete(accountKeys);
    }
}
#end_block

#method_before
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids;
        try {
            ids = db.accountExternalIds().byAccount(id);
        } catch (OrmException e) {
            throw die("Could not query database: " + e.getMessage());
        }
        for (AccountExternalId extId : ids) {
            unlink(id, extId.getEmailAddress());
        }
    } else {
        unlink(id, mailAddress);
    }
}
#method_after
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure, OrmException {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids = db.accountExternalIds().byAccount(id);
        for (AccountExternalId extId : ids) {
            if (extId.isScheme(AccountExternalId.SCHEME_MAILTO)) {
                unlink(id, extId.getEmailAddress());
            }
        }
    } else {
        AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, mailAddress);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            unlink(id, mailAddress);
        }
    }
}
#end_block

#method_before
private String readSshKey(String sshKey) throws UnsupportedEncodingException, IOException, InvalidSshKeyException {
    if (sshKey == null) {
        return null;
    }
    if ("-".equals(sshKey)) {
        sshKey = "";
        BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
        String line;
        while ((line = br.readLine()) != null) {
            sshKey += line + "\n";
        }
    }
    return sshKey.trim();
}
#method_after
private List<String> readSshKey(final List<String> sshKeys) throws UnsupportedEncodingException, IOException {
    if (!sshKeys.isEmpty()) {
        String sshKey = "";
        int idx = sshKeys.indexOf("-");
        if (idx >= 0) {
            sshKey = "";
            BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
            String line;
            while ((line = br.readLine()) != null) {
                sshKey += line + "\n";
            }
            sshKeys.set(idx, sshKey);
        }
    }
    return sshKeys;
}
#end_block

#method_before
public ResultSet<PatchSetApproval> copyVetosToLatestPatchSet(Change change) throws OrmException, IOException {
    PatchSet.Id source;
    if (change.getNumberOfPatchSets() > 1) {
        source = new PatchSet.Id(change.getId(), change.getNumberOfPatchSets() - 1);
    } else {
        throw new IOException("Previous patch set could not be found");
    }
    PatchSet.Id dest = change.currPatchSetId();
    ResultSet<PatchSetApproval> patchSetApprovals = db.patchSetApprovals().byPatchSet(source);
    for (PatchSetApproval a : patchSetApprovals) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(dest, a)));
            }
        }
    }
    return patchSetApprovals;
}
#method_after
public List<PatchSetApproval> copyVetosToLatestPatchSet(Change change) throws OrmException, IOException {
    PatchSet.Id source;
    if (change.getNumberOfPatchSets() > 1) {
        source = new PatchSet.Id(change.getId(), change.getNumberOfPatchSets() - 1);
    } else {
        throw new IOException("Previous patch set could not be found");
    }
    PatchSet.Id dest = change.currPatchSetId();
    List<PatchSetApproval> patchSetApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : patchSetApprovals) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(source) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(dest, a)));
            }
        }
    }
    return patchSetApprovals;
}
#end_block

#method_before
public static void rebaseChange(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db, RebasedPatchSetSender.Factory rebasedPatchSetSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent, final ChangeControl.Factory changeControlFactory, final ApprovalsUtil approvalsUtil) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    Change change = changeControl.getChange();
    final Repository git = gitManager.openRepository(change.getProject());
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
            RevCommit branchTipCommit = null;
            List<PatchSetAncestor> patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
            if (patchSetAncestors.size() > 1) {
                throw new IOException("The patch set you are trying to rebase is dependent on several other patch sets: " + patchSetAncestors.toString());
            }
            if (patchSetAncestors.size() == 1) {
                List<PatchSet> depPatchSetList = db.patchSets().byRevision(patchSetAncestors.get(0).getAncestorRevision()).toList();
                if (!depPatchSetList.isEmpty()) {
                    PatchSet depPatchSet = depPatchSetList.get(0);
                    Change.Id depChangeId = depPatchSet.getId().getParentKey();
                    Change depChange = db.changes().get(depChangeId);
                    if (depChange.getStatus() == Status.ABANDONED) {
                        throw new IOException("Cannot rebase against an abandoned change: " + depChange.getKey().toString());
                    }
                    if (depChange.getStatus().isOpen()) {
                        PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
                        if (!depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                            branchTipCommit = revWalk.parseCommit(ObjectId.fromString(latestDepPatchSet.getRevision().get()));
                        } else {
                            throw new IOException("Change is already based on the latest patch set of the dependent change.");
                        }
                    }
                }
            }
            if (branchTipCommit == null) {
                // We are dependent on a merged PatchSet or have no PatchSet
                // dependencies at all.
                Ref destRef = git.getRef(change.getDest().get());
                if (destRef == null) {
                    throw new IOException("The destination branch does not exist: " + change.getDest().get());
                }
                branchTipCommit = revWalk.parseCommit(destRef.getObjectId());
            }
            final RevCommit originalCommit = revWalk.parseCommit(ObjectId.fromString(originalPatchSet.getRevision().get()));
            CommitBuilder rebasedCommitBuilder = rebaseCommit(git, originalCommit, branchTipCommit, myIdent);
            final ObjectInserter oi = git.newObjectInserter();
            final ObjectId rebasedCommitId;
            try {
                rebasedCommitId = oi.insert(rebasedCommitBuilder);
                oi.flush();
            } finally {
                oi.release();
            }
            Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        change.nextPatchSetId();
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (updatedChange == null) {
                throw new InvalidChangeOperationException("Change is closed: " + change.toString());
            } else {
                change = updatedChange;
            }
            final PatchSet rebasedPatchSet = new PatchSet(change.currPatchSetId());
            rebasedPatchSet.setCreatedOn(change.getCreatedOn());
            rebasedPatchSet.setUploader(user.getAccountId());
            rebasedPatchSet.setRevision(new RevId(rebasedCommitId.getName()));
            insertAncestors(db, rebasedPatchSet.getId(), revWalk.parseCommit(rebasedCommitId));
            db.patchSets().insert(Collections.singleton(rebasedPatchSet));
            final PatchSetInfo info = patchSetInfoFactory.get(db, rebasedPatchSet.getId());
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            final RefUpdate ru = git.updateRef(rebasedPatchSet.getRefName());
            ru.setNewObjectId(rebasedCommitId);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException("Failed to create ref " + rebasedPatchSet.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
            }
            replication.scheduleUpdate(change.getProject(), ru.getName());
            ResultSet<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToLatestPatchSet(change);
            final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
            final Set<Account.Id> oldCC = new HashSet<Account.Id>();
            for (PatchSetApproval a : patchSetApprovals) {
                if (a.getValue() != 0) {
                    oldReviewers.add(a.getAccountId());
                } else {
                    oldCC.add(a.getAccountId());
                }
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            cmsg.setMessage("Patch Set " + patchSetId.get() + ": Rebased");
            db.changeMessages().insert(Collections.singleton(cmsg));
            final ReplacePatchSetSender cm = rebasedPatchSetSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(rebasedPatchSet);
            cm.addReviewers(oldReviewers);
            cm.addExtraCC(oldCC);
            cm.send();
            hooks.doPatchsetCreatedHook(change, rebasedPatchSet, db);
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public static void rebaseChange(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db, RebasedPatchSetSender.Factory rebasedPatchSetSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent, final ChangeControl.Factory changeControlFactory, final ApprovalsUtil approvalsUtil) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    Change change = changeControl.getChange();
    final Repository git = gitManager.openRepository(change.getProject());
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
            RevCommit branchTipCommit = null;
            List<PatchSetAncestor> patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
            if (patchSetAncestors.size() > 1) {
                throw new IOException("The patch set you are trying to rebase is dependent on several other patch sets: " + patchSetAncestors.toString());
            }
            if (patchSetAncestors.size() == 1) {
                List<PatchSet> depPatchSetList = db.patchSets().byRevision(patchSetAncestors.get(0).getAncestorRevision()).toList();
                if (!depPatchSetList.isEmpty()) {
                    PatchSet depPatchSet = depPatchSetList.get(0);
                    Change.Id depChangeId = depPatchSet.getId().getParentKey();
                    Change depChange = db.changes().get(depChangeId);
                    if (depChange.getStatus() == Status.ABANDONED) {
                        throw new IOException("Cannot rebase against an abandoned change: " + depChange.getKey().toString());
                    }
                    if (depChange.getStatus().isOpen()) {
                        PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
                        if (!depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                            branchTipCommit = revWalk.parseCommit(ObjectId.fromString(latestDepPatchSet.getRevision().get()));
                        } else {
                            throw new IOException("Change is already based on the latest patch set of the dependent change.");
                        }
                    }
                }
            }
            if (branchTipCommit == null) {
                // We are dependent on a merged PatchSet or have no PatchSet
                // dependencies at all.
                Ref destRef = git.getRef(change.getDest().get());
                if (destRef == null) {
                    throw new IOException("The destination branch does not exist: " + change.getDest().get());
                }
                branchTipCommit = revWalk.parseCommit(destRef.getObjectId());
            }
            final RevCommit originalCommit = revWalk.parseCommit(ObjectId.fromString(originalPatchSet.getRevision().get()));
            CommitBuilder rebasedCommitBuilder = rebaseCommit(git, originalCommit, branchTipCommit, myIdent);
            final ObjectInserter oi = git.newObjectInserter();
            final ObjectId rebasedCommitId;
            try {
                rebasedCommitId = oi.insert(rebasedCommitBuilder);
                oi.flush();
            } finally {
                oi.release();
            }
            Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        change.nextPatchSetId();
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (updatedChange == null) {
                throw new InvalidChangeOperationException("Change is closed: " + change.toString());
            } else {
                change = updatedChange;
            }
            final PatchSet rebasedPatchSet = new PatchSet(change.currPatchSetId());
            rebasedPatchSet.setCreatedOn(change.getCreatedOn());
            rebasedPatchSet.setUploader(user.getAccountId());
            rebasedPatchSet.setRevision(new RevId(rebasedCommitId.getName()));
            insertAncestors(db, rebasedPatchSet.getId(), revWalk.parseCommit(rebasedCommitId));
            db.patchSets().insert(Collections.singleton(rebasedPatchSet));
            final PatchSetInfo info = patchSetInfoFactory.get(db, rebasedPatchSet.getId());
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            final RefUpdate ru = git.updateRef(rebasedPatchSet.getRefName());
            ru.setNewObjectId(rebasedCommitId);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException("Failed to create ref " + rebasedPatchSet.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
            }
            replication.scheduleUpdate(change.getProject(), ru.getName());
            List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToLatestPatchSet(change);
            final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
            final Set<Account.Id> oldCC = new HashSet<Account.Id>();
            for (PatchSetApproval a : patchSetApprovals) {
                if (a.getValue() != 0) {
                    oldReviewers.add(a.getAccountId());
                } else {
                    oldCC.add(a.getAccountId());
                }
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            cmsg.setMessage("Patch Set " + patchSetId.get() + ": Rebased");
            db.changeMessages().insert(Collections.singleton(cmsg));
            final ReplacePatchSetSender cm = rebasedPatchSetSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(rebasedPatchSet);
            cm.addReviewers(oldReviewers);
            cm.addExtraCC(oldCC);
            cm.send();
            hooks.doPatchsetCreatedHook(change, rebasedPatchSet, db);
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
public void initSshModule(String name) {
    name = pluginName;
}
#method_after
public void initSshModule(String pluginName) {
    command = Commands.named(pluginName);
}
#end_block

#method_before
@Override
protected LinkedBindingBuilder<Command> command(String name) {
    final CommandName parent = Commands.named(pluginName);
    return command(parent, name);
}
#method_after
protected LinkedBindingBuilder<Command> command(String subCmd) {
    return bind(Commands.key(command, subCmd));
}
#end_block

#method_before
protected void parseCommandLine() throws UnloggedFailure {
    processor.setOutput(out, QueryProcessor.OutputFormat.TEXT);
    super.parseCommandLine();
    if (processor.getIncludeFiles() && !(processor.getIncludePatchSets() || processor.getIncludeCurrentPatchSet())) {
        throw new UnloggedFailure(1, "--files option needs --patch-sets or --current-patch-set");
    }
}
#method_after
@Override
protected void parseCommandLine() throws UnloggedFailure {
    processor.setOutput(out, QueryProcessor.OutputFormat.TEXT);
    super.parseCommandLine();
    if (processor.getIncludeFiles() && !(processor.getIncludePatchSets() || processor.getIncludeCurrentPatchSet())) {
        throw new UnloggedFailure(1, "--files option needs --patch-sets or --current-patch-set");
    }
}
#end_block

#method_before
@Override
protected void onCellDoubleClick(final int row, int column) {
    if (column > 0 && getRowItem(row) instanceof PatchLine) {
        final PatchLine line = (PatchLine) getRowItem(row);
        final short file = (short) ((column - 1) / 2);
        if (column < (1 + file * 2 + 1)) {
            column++;
        }
        switch(file) {
            case 0:
                createCommentEditor(row + 1, column, line.getLineA(), file);
                break;
            case 1:
                createCommentEditor(row + 1, column, line.getLineB(), file);
                break;
        }
    }
}
#method_after
@Override
protected void onCellDoubleClick(final int row, int column) {
    if (column > 0 && getRowItem(row) instanceof PatchLine) {
        final PatchLine line = (PatchLine) getRowItem(row);
        if (column == 1 || column == A) {
            createCommentEditor(row + 1, A, line.getLineA(), (short) 0);
        } else if (column == B || column == 4) {
            createCommentEditor(row + 1, B, line.getLineB(), (short) 1);
        }
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
@Override
protected void onInsertComment(final PatchLine line) {
    final int row = getCurrentRow();
    createCommentEditor(row + 1, 4, line.getLineB(), (short) 1);
}
#method_after
@Override
protected void onInsertComment(final PatchLine line) {
    final int row = getCurrentRow();
    createCommentEditor(row + 1, B, line.getLineB(), (short) 1);
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    a = getSparseHtmlFileA(script);
    b = getSparseHtmlFileB(script);
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
    appendHeader(script, nc);
    lines.add(null);
    if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
        openLine(nc);
        appendModeLine(nc, script.getFileModeA());
        appendModeLine(nc, script.getFileModeB());
        closeLine(nc);
        lines.add(null);
    }
    int lastA = 0;
    int lastB = 0;
    final boolean ignoreWS = script.isIgnoreWhitespace();
    for (final EditList.Hunk hunk : script.getHunks()) {
        if (!hunk.isStartOfFile()) {
            appendSkipLine(nc, hunk.getCurB() - lastB);
            lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
        }
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                appendLineText(nc, hunk.getCurA(), CONTEXT, ctx, false, false);
                if (ignoreWS && b.contains(hunk.getCurB())) {
                    appendLineText(nc, hunk.getCurB(), CONTEXT, b, hunk.getCurB(), false);
                } else {
                    appendLineText(nc, hunk.getCurB(), CONTEXT, ctx, false, false);
                }
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isModifiedLine()) {
                final boolean del = hunk.isDeletedA();
                final boolean ins = hunk.isInsertedB();
                final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                openLine(nc);
                if (del) {
                    appendLineText(nc, hunk.getCurA(), DELETE, a, hunk.getCurA(), full);
                    hunk.incA();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNone(nc, DELETE);
                } else {
                    appendLineNone(nc, CONTEXT);
                }
                if (ins) {
                    appendLineText(nc, hunk.getCurB(), INSERT, b, hunk.getCurB(), full);
                    hunk.incB();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNone(nc, INSERT);
                } else {
                    appendLineNone(nc, CONTEXT);
                }
                closeLine(nc);
                if (del && ins) {
                    lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                } else if (del) {
                    lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                } else if (ins) {
                    lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                }
            }
        }
        lastA = hunk.getCurA();
        lastB = hunk.getCurB();
    }
    if (lastB != b.size()) {
        appendSkipLine(nc, b.size() - lastB);
        lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
    }
    resetHtml(nc);
    initScript(script);
    for (int row = 0; row < lines.size(); row++) {
        setRowItem(row, lines.get(row));
        if (lines.get(row) instanceof SkippedLine) {
            createSkipLine(row, (SkippedLine) lines.get(row));
        }
    }
}
#method_after
@Override
protected void render(final PatchScript script) {
    a = getSparseHtmlFileA(script);
    b = getSparseHtmlFileB(script);
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
    appendHeader(script, nc);
    lines.add(null);
    if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
        openLine(nc);
        appendModeLine(nc, script.getFileModeA());
        appendModeLine(nc, script.getFileModeB());
        closeLine(nc);
        lines.add(null);
    }
    int lastA = 0;
    int lastB = 0;
    final boolean ignoreWS = script.isIgnoreWhitespace();
    for (final EditList.Hunk hunk : script.getHunks()) {
        if (!hunk.isStartOfFile()) {
            appendSkipLine(nc, hunk.getCurB() - lastB);
            lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
        }
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                appendLineNumber(nc, hunk.getCurA(), false);
                appendLineText(nc, CONTEXT, ctx, false, false);
                if (ignoreWS && b.contains(hunk.getCurB())) {
                    appendLineText(nc, CONTEXT, b, hunk.getCurB(), false);
                } else {
                    appendLineText(nc, CONTEXT, ctx, false, false);
                }
                appendLineNumber(nc, hunk.getCurB(), true);
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isModifiedLine()) {
                final boolean del = hunk.isDeletedA();
                final boolean ins = hunk.isInsertedB();
                final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                openLine(nc);
                if (del) {
                    appendLineNumber(nc, hunk.getCurA(), false);
                    appendLineText(nc, DELETE, a, hunk.getCurA(), full);
                    hunk.incA();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNumber(nc, false);
                    appendLineNone(nc, DELETE);
                } else {
                    appendLineNumber(nc, false);
                    appendLineNone(nc, CONTEXT);
                }
                if (ins) {
                    appendLineText(nc, INSERT, b, hunk.getCurB(), full);
                    appendLineNumber(nc, hunk.getCurB(), true);
                    hunk.incB();
                } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                    appendLineNone(nc, INSERT);
                    appendLineNumber(nc, true);
                } else {
                    appendLineNone(nc, CONTEXT);
                    appendLineNumber(nc, true);
                }
                closeLine(nc);
                if (del && ins) {
                    lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                } else if (del) {
                    lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                } else if (ins) {
                    lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                }
            }
        }
        lastA = hunk.getCurA();
        lastB = hunk.getCurB();
    }
    if (lastB != b.size()) {
        appendSkipLine(nc, b.size() - lastB);
        lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
    }
    resetHtml(nc);
    initScript(script);
    for (int row = 0; row < lines.size(); row++) {
        setRowItem(row, lines.get(row));
        if (lines.get(row) instanceof SkippedLine) {
            createSkipLine(row, (SkippedLine) lines.get(row));
        }
    }
}
#end_block

#method_before
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    for (int row = 0; row < table.getRowCount(); ) {
        if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            final List<PatchLineComment> fora = cd.getForA(pLine.getLineA());
            final List<PatchLineComment> forb = cd.getForB(pLine.getLineB());
            row++;
            final Iterator<PatchLineComment> ai = fora.iterator();
            final Iterator<PatchLineComment> bi = forb.iterator();
            while (ai.hasNext() && bi.hasNext()) {
                final PatchLineComment ac = ai.next();
                final PatchLineComment bc = bi.next();
                insertRow(row);
                bindComment(row, COL_A, ac, !ai.hasNext(), expandComments);
                bindComment(row, COL_B, bc, !bi.hasNext(), expandComments);
                row++;
            }
            row = finish(ai, row, COL_A, expandComments);
            row = finish(bi, row, COL_B, expandComments);
        } else {
            row++;
        }
    }
}
#method_after
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    for (int row = 0; row < table.getRowCount(); ) {
        if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            final List<PatchLineComment> fora = cd.getForA(pLine.getLineA());
            final List<PatchLineComment> forb = cd.getForB(pLine.getLineB());
            row++;
            final Iterator<PatchLineComment> ai = fora.iterator();
            final Iterator<PatchLineComment> bi = forb.iterator();
            while (ai.hasNext() && bi.hasNext()) {
                final PatchLineComment ac = ai.next();
                final PatchLineComment bc = bi.next();
                insertRow(row);
                bindComment(row, A, ac, !ai.hasNext(), expandComments);
                bindComment(row, B, bc, !bi.hasNext(), expandComments);
                row++;
            }
            row = finish(ai, row, A, expandComments);
            row = finish(bi, row, B, expandComments);
        } else {
            row++;
        }
    }
}
#end_block

#method_before
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, COL_A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, COL_A, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, COL_B - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, COL_B, Gerrit.RESOURCES.css().diffText());
}
#method_after
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().lineNumber());
}
#end_block

#method_before
private void appendHeader(PatchScript script, final SafeHtmlBuilder m) {
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    if (script.getChangeType() == ChangeType.RENAMED || script.getChangeType() == ChangeType.COPIED) {
        m.append(script.getOldName());
    } else {
        m.append(PatchUtil.C.patchHeaderOld());
    }
    m.br();
    if (0 < script.getA().size()) {
        if (idSideA == null) {
            downloadLink(m, patchKey, "1");
        } else {
            downloadLink(m, new Patch.Key(idSideA, patchKey.get()), "0");
        }
    }
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    m.append(PatchUtil.C.patchHeaderNew());
    m.br();
    if (0 < script.getB().size()) {
        downloadLink(m, new Patch.Key(idSideB, patchKey.get()), "0");
    }
    m.closeTd();
    m.closeTr();
}
#method_after
private void appendHeader(PatchScript script, final SafeHtmlBuilder m) {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    if (script.getChangeType() == ChangeType.RENAMED || script.getChangeType() == ChangeType.COPIED) {
        m.append(script.getOldName());
    } else {
        m.append(PatchUtil.C.patchHeaderOld());
    }
    if (!isCommitMessage) {
        m.br();
        if (0 < script.getA().size()) {
            if (idSideA == null) {
                downloadLink(m, patchKey, "1");
            } else {
                downloadLink(m, new Patch.Key(idSideA, patchKey.get()), "0");
            }
        }
    }
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.setAttribute("width", "50%");
    m.append(PatchUtil.C.patchHeaderNew());
    if (!isCommitMessage) {
        m.br();
        if (0 < script.getB().size()) {
            downloadLink(m, new Patch.Key(idSideB, patchKey.get()), "0");
        }
    }
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader());
    m.addStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.closeTr();
}
#end_block

#method_before
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        // The overridden version of insertRow adds some css classes we don't
        // want.
        super.insertRow(row + i);
        table.getRowFormatter().setVerticalAlign(row + i, HasVerticalAlignment.ALIGN_TOP);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        addStyle(row + i, 1, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        addStyle(row + i, 3, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#method_after
private void expand(ClickEvent event, final int numRows) {
    int row = table.getCellForEvent(event).getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    CellFormatter fmt = table.getCellFormatter();
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        // The overridden version of insertRow adds some css classes we don't
        // want.
        super.insertRow(row + i);
        table.getRowFormatter().setVerticalAlign(row + i, HasVerticalAlignment.ALIGN_TOP);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        table.setHTML(row + i, A - 1, "<a href=\"javascript:;\">" + (lineA + 1) + "</a>");
        fmt.addStyleName(row + i, A - 1, Gerrit.RESOURCES.css().lineNumber());
        table.setHTML(row + i, A, a.getSafeHtmlLine(lineA).asString());
        fmt.addStyleName(row + i, A, Gerrit.RESOURCES.css().fileLine());
        fmt.addStyleName(row + i, A, Gerrit.RESOURCES.css().fileLineCONTEXT());
        table.setHTML(row + i, B, b.getSafeHtmlLine(lineB).asString());
        fmt.addStyleName(row + i, B, Gerrit.RESOURCES.css().fileLine());
        fmt.addStyleName(row + i, B, Gerrit.RESOURCES.css().fileLineCONTEXT());
        table.setHTML(row + i, B + 1, "<a href=\"javascript:;\">" + (lineB + 1) + "</a>");
        fmt.addStyleName(row + i, B + 1, Gerrit.RESOURCES.css().lineNumber());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        table.removeRow(row + loopTo);
    }
}
#end_block

#method_before
private void createSkipLine(int row, SkippedLine line) {
    FlowPanel p = new FlowPanel();
    Label l1 = new Label(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    Label l2 = new Label(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    all.addClickHandler(expandAllListener);
    if (line.getSize() > 30) {
        // We only show the expand before & after links if we skip more than
        // 30 lines.
        Anchor before = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        before.addClickHandler(expandBeforeListener);
        Anchor after = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
        after.addClickHandler(expandAfterListener);
        p.add(before);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(after);
    } else {
        p.add(l1);
        p.add(all);
        p.add(l2);
    }
    setWidget(row, 1, p);
}
#method_after
private void createSkipLine(int row, SkippedLine line) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND), true);
        Anchor a = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND), true);
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else {
        p.add(l1);
        p.add(all);
        p.add(l2);
    }
    table.setWidget(row, 1, p);
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(SafeHtml.asis("<a href=\"javascript:void(0)\">" + (lineNumberMinusOne + 1) + "</a>"));
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseHtmlFile src, final int i, final boolean fullBlock) {
    appendLineText(m, type, src.getSafeHtmlLine(i), src.hasTrailingEdit(i), fullBlock);
}
#end_block

#method_before
private void appendLineNone(final SafeHtmlBuilder m, final PatchLine.Type type) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type != null ? type : PatchLine.Type.CONTEXT) {
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            break;
        default:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineNone());
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineNone(final SafeHtmlBuilder m, final PatchLine.Type type) {
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type != null ? type : PatchLine.Type.CONTEXT) {
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            break;
        default:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineNone());
            break;
    }
    m.closeTd();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "Configuration changes can only be pushed by project owners\n" + "who also have 'Push' rights");
        } else {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "To push into this reference you need 'Push' rights." + MESSAGE_FOOTER);
        }
        reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "Deleting the project configuration is not allowed");
        } else {
            rp.sendMessage("You need 'Push' rights with the 'Force Push' flag set to delete references." + MESSAGE_FOOTER);
            reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        rp.sendMessage("You need 'Push' rights to upload code review requests.\n" + "Verify that you are pushing to the right branch." + MESSAGE_FOOTER);
        reject(cmd, "Current user '" + destBranchCtl.getCurrentUser().getUserName() + "' can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
        newProgress.update(1);
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#method_after
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request, false);
            replaceProgress.update(1);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request, boolean ignoreNoChanges) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq && !ignoreNoChanges) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet)) {
                    if (type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                        // If there was a negative vote on the prior patch set, carry it
                        // into this patch set.
                        // 
                        db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                    }
                }
            }
        }
        approvalsUtil.addReviewers(change, ps, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    ApprovalsUtil.syncChangeStatus(db, change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
@Override
public DeleteBranchesResult call() throws NoSuchProjectException, RepositoryNotFoundException, EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final DeleteBranchesResult result = new DeleteBranchesResult();
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        final List<Change> openChanges = db.changes().byBranchOpenAll(k).toList();
        if (!openChanges.isEmpty()) {
            if (!abandonOpenChanges) {
                result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.OPEN_CHANGES, k));
                branchIt.remove();
            } else {
                final boolean allAbandoned = abandon(openChanges, "Branch " + k.get() + " gets deleted.");
                if (!allAbandoned) {
                    result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.ABANDON_FAILED, k));
                    branchIt.remove();
                }
            }
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result refUpdateResult;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                refUpdateResult = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(refUpdateResult) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    result.setDeletedBranches(deleted);
    return result;
}
#method_after
@Override
public Set<Branch.NameKey> call() throws NoSuchProjectException, RepositoryNotFoundException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        if (db.changes().byBranchOpenAll(k).iterator().hasNext()) {
            branchIt.remove();
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result result;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                result = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(result) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + result.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + result.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    return deleted;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                abandonOpenChanges.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#end_block

#method_before
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    abandonOpenChanges.setVisible(branches.hasBranchCanDelete());
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#method_after
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#end_block

#method_before
private void enableForm(final boolean on) {
    abandonOpenChanges.setEnabled(on);
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#method_after
private void enableForm(final boolean on) {
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    abandonOpenChanges = new CheckBox(Util.C.checkboxAbandonOpenChanges());
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    final VerticalPanel v = new VerticalPanel();
    v.add(abandonOpenChanges);
    v.add(delBranch);
    add(v);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#end_block

#method_before
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    if (abandonOpenChanges.getValue()) {
        b.append(Gerrit.C.branchDeletionAndAbandonOpenChangesConfirmationMessage());
    } else {
        b.append(Gerrit.C.branchDeletionConfirmationMessage());
    }
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids, abandonOpenChanges.getValue());
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
private void deleteBranches(final Set<Branch.NameKey> branchIds, final boolean abandonOpenChanges) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, abandonOpenChanges, new GerritCallback<DeleteBranchesResult>() {

        public void onSuccess(final DeleteBranchesResult result) {
            final Set<NameKey> deletedBranches = result.getDeletedBranches();
            if (!deletedBranches.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deletedBranches.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            if (result.hasErrors()) {
                final SafeHtmlBuilder b = new SafeHtmlBuilder();
                final Set<Branch.NameKey> branchesWithOpenChanges = new HashSet<Branch.NameKey>();
                final Set<Branch.NameKey> branchesWithOpenChangesThatCannotBeAbandoned = new HashSet<Branch.NameKey>();
                for (final DeleteBranchesResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case OPEN_CHANGES:
                            branchesWithOpenChanges.add(e.getBranchKey());
                            break;
                        case ABANDON_FAILED:
                            branchesWithOpenChangesThatCannotBeAbandoned.add(e.getBranchKey());
                            break;
                        default:
                            b.append(Gerrit.M.branchDeletionFailed(e.getBranchKey().get(), e.toString()));
                            b.br();
                    }
                }
                if (!branchesWithOpenChanges.isEmpty()) {
                    b.append(Util.C.branchDeletionOpenChanges());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChanges);
                }
                if (!branchesWithOpenChangesThatCannotBeAbandoned.isEmpty()) {
                    b.append(Util.C.branchDeletionAbandonFailed());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChangesThatCannotBeAbandoned);
                }
                new ErrorDialog(b.toSafeHtml()).center();
            }
        }

        private void appendBranchOpenChangesLinks(final SafeHtmlBuilder b, final Set<Branch.NameKey> branches) {
            b.openElement("p");
            for (final Branch.NameKey branch : branches) {
                b.openAnchor();
                final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null);
                b.setAttribute("href", "/#" + link.getTargetHistoryToken());
                b.setAttribute("target", "_blank");
                b.append(branch.get());
                b.closeAnchor();
                b.br();
            }
            b.closeElement("p");
        }
    });
}
#method_after
private void deleteBranches(final Set<Branch.NameKey> branchIds) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, new GerritCallback<Set<Branch.NameKey>>() {

        public void onSuccess(final Set<Branch.NameKey> deleted) {
            if (!deleted.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deleted.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            branchIds.removeAll(deleted);
            if (!branchIds.isEmpty()) {
                final VerticalPanel p = new VerticalPanel();
                final ErrorDialog errorDialog = new ErrorDialog(p);
                final Label l = new Label(Util.C.branchDeletionOpenChanges());
                l.setStyleName(Gerrit.RESOURCES.css().errorDialogText());
                p.add(l);
                for (final Branch.NameKey branch : branchIds) {
                    final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null) {

                        @Override
                        public void go() {
                            errorDialog.hide();
                            super.go();
                        }
                    };
                    p.add(link);
                }
                errorDialog.center();
            }
        }
    });
}
#end_block

#method_before
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    try {
        final Project.NameKey nameKey = createProjectArgs.getProject();
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch;
        final Repository repo;
        try {
            repo = repoManager.createRepository(nameKey);
        } catch (RepositoryCaseMismatchException err) {
            throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", err);
        }
        try {
            replication.replicateNewProject(nameKey, head);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommit(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + createProjectArgs.getProject();
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#method_after
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch;
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            replication.replicateNewProject(nameKey, head);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommit(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException doesNotExist) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, err);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    final Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        final ResultSet rs = stmt.executeQuery("SELECT account_id, display_patch_sets_in_reverse_order, " + "       display_person_name_in_review_category " + "FROM accounts");
        try {
            final List<Account> accountsToUpdate = new LinkedList<Account>();
            while (rs.next()) {
                final boolean reversePatchSetOrder = rs.getBoolean(2);
                final boolean showUsernameInReviewCategory = rs.getBoolean(3);
                if (reversePatchSetOrder || showUsernameInReviewCategory) {
                    final Account.Id id = new Account.Id(rs.getInt(1));
                    final Account account = db.accounts().get(id);
                    final AccountGeneralPreferences prefs = account.getGeneralPreferences();
                    prefs.setReversePatchSetOrder(reversePatchSetOrder);
                    prefs.setShowUsernameInReviewCategory(showUsernameInReviewCategory);
                    accountsToUpdate.add(account);
                }
            }
            if (!accountsToUpdate.isEmpty()) {
                db.accounts().update(accountsToUpdate);
            }
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    final Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        stmt.executeUpdate("UPDATE accounts SET reverse_patch_set_order = 'Y' " + "WHERE display_patch_sets_in_reverse_order = 'Y'");
        stmt.executeUpdate("UPDATE accounts SET show_username_in_review_category = 'Y' " + "WHERE display_person_name_in_review_category = 'Y'");
    } finally {
        stmt.close();
    }
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    try {
        final ReviewDb db = schema.open();
        try {
            p.parentsRevision = patchSetInfoFactory.get(db, patchSet.getId()).getParentRevisons();
        } finally {
            db.close();
        }
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(e);
        e.printStackTrace();
    } catch (OrmException e) {
        log.error(e);
        e.printStackTrace();
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    }
    return p;
}
#end_block

#method_before
private void createSkipLine(int row, SkippedLine line) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor();
        Anchor a = new Anchor();
        b.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        a.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else {
        p.add(l1);
        p.add(all);
        p.add(l2);
    }
    table.setWidget(row, 1, p);
}
#method_after
private void createSkipLine(int row, SkippedLine line) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND), true);
        Anchor a = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND), true);
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else {
        p.add(l1);
        p.add(all);
        p.add(l2);
    }
    table.setWidget(row, 1, p);
}
#end_block

#method_before
public Image createStar() {
    final Image star = new Image(getResource());
    star.setVisible(Gerrit.isSignedIn());
    star.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            StarCache.this.toggleStar();
        }
    });
    cache.getChangeDetailCache().addValueChangeHandler(createStarUpdater(star, ChangeDetail.class));
    cache.getChangeInfoCache().addValueChangeHandler(createStarUpdater(star, ChangeInfo.class));
    this.addValueChangeHandler(createStarUpdater(star, Boolean.class));
    return star;
}
#method_after
@SuppressWarnings("unchecked")
public Image createStar() {
    final Image star = new Image(getResource());
    star.setVisible(Gerrit.isSignedIn());
    star.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            StarCache.this.toggleStar();
        }
    });
    @SuppressWarnings("rawtypes")
    ValueChangeHandler starUpdater = new ValueChangeHandler() {

        @Override
        public void onValueChange(ValueChangeEvent event) {
            star.setResource(StarCache.this.getResource());
        }
    };
    cache.getChangeDetailCache().addValueChangeHandler(starUpdater);
    cache.getChangeInfoCache().addValueChangeHandler(starUpdater);
    this.addValueChangeHandler(starUpdater);
    return star;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (ProjectConfigSection.isValidReferenceSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmConcurrencyException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValidReferenceSection(name)) {
                if (!projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefControl.validateRefPattern(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        if (config.commit(md)) {
            projectCache.evict(config.getProject());
            return projectAccessFactory.create(projectName).call();
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } finally {
        md.close();
    }
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmConcurrencyException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (!projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefControl.validateRefPattern(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        if (config.commit(md)) {
            projectCache.evict(config.getProject());
            return projectAccessFactory.create(projectName).call();
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } finally {
        md.close();
    }
}
#end_block

#method_before
public boolean isVisible() {
    return projectControl.visibleForReplication() || canPerform(Permission.READ);
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH);
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE);
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT);
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH);
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return canPushWithForce() || canDelete();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public static void validateRefPattern(String refPattern) throws InvalidNameException {
    if (refPattern.startsWith(ProjectConfigSection.REGEX_PREFIX)) {
        if (!Repository.isValidRefName(RefControl.shortestExample(refPattern))) {
            throw new InvalidNameException();
        }
    } else if (refPattern.equals(ProjectConfigSection.ALL)) {
    // This is a special case we have to allow, it fails below.
    } else if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!Repository.isValidRefName(prefix)) {
            throw new InvalidNameException(refPattern);
        }
    } else if (!Repository.isValidRefName(refPattern)) {
        throw new InvalidNameException(refPattern);
    }
}
#method_after
public static void validateRefPattern(String refPattern) throws InvalidNameException {
    if (refPattern.startsWith(RefConfigSection.REGEX_PREFIX)) {
        if (!Repository.isValidRefName(RefControl.shortestExample(refPattern))) {
            throw new InvalidNameException(refPattern);
        }
    } else if (refPattern.equals(RefConfigSection.ALL)) {
    // This is a special case we have to allow, it fails below.
    } else if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!Repository.isValidRefName(prefix)) {
            throw new InvalidNameException(refPattern);
        }
    } else if (!Repository.isValidRefName(refPattern)) {
        throw new InvalidNameException(refPattern);
    }
}
#end_block

#method_before
static SectionMatcher wrap(AccessSection section) {
    String ref = section.getName();
    if (AccessSection.isValidReferenceSection(ref)) {
        return wrap(ref, section);
    } else {
        return null;
    }
}
#method_after
static SectionMatcher wrap(AccessSection section) {
    String ref = section.getName();
    if (AccessSection.isValid(ref)) {
        return wrap(ref, section);
    } else {
        return null;
    }
}
#end_block

#method_before
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && ProjectConfigSection.isValidReferenceSection(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#method_after
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && RefConfigSection.isValid(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (ProjectConfigSection.isValidReferenceSection(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (RefConfigSection.isValid(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    } else if (ProjectConfigSection.isValidReferenceSection(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isValidReferenceSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isValidReferenceSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public int compare(final String pattern1, final String pattern2) {
    int cmp = distance(pattern1) - distance(pattern2);
    if (cmp == 0) {
        boolean p1_finite = finite(pattern1);
        boolean p2_finite = finite(pattern2);
        if (p1_finite && !p2_finite) {
            cmp = -1;
        } else if (!p1_finite && p2_finite) {
            cmp = 1;
        } else /* if (f1 == f2) */
        {
            cmp = 0;
        }
    }
    if (cmp == 0) {
        cmp = transitions(pattern1) - transitions(pattern2);
    }
    if (cmp == 0) {
        cmp = pattern2.length() - pattern1.length();
    }
    return cmp;
}
#method_after
@Override
public int compare(RefConfigSection a, RefConfigSection b) {
    return compare(a.getName(), b.getName());
}
#end_block

#method_before
@Rewrite("status:open P=(project:*) B=(branch:*) S=(sortkey_before:*) L=(limit:*)")
public Predicate<ChangeData> r05_byBranchOpenNext(@Named("P") final ProjectPredicate p, @Named("B") final BranchPredicate b, @Named("S") final SortKeyPredicate.Before s, @Named("L") final IntPredicate<ChangeData> l) {
    return new PaginatedSource(500, s.getValue(), l.intValue()) {

        @Override
        ResultSet<Change> scan(ChangeAccess a, String key, int limit) throws OrmException {
            return a.byBranchOpenNext(new Branch.NameKey(p.getValueKey(), b.getValue()), key, limit);
        }

        @Override
        public boolean match(ChangeData cd) throws OrmException {
            return // 
            cd.change(dbProvider).getStatus().isOpen() && // 
            p.match(cd) && // 
            b.match(cd) && s.match(cd);
        }
    };
}
#method_after
@Rewrite("status:open P=(project:*) B=(branch:*) S=(sortkey_before:*) L=(limit:*)")
public Predicate<ChangeData> r05_byBranchOpenNext(@Named("P") final ProjectPredicate p, @Named("B") final BranchPredicate b, @Named("S") final SortKeyPredicate.Before s, @Named("L") final IntPredicate<ChangeData> l) {
    return new PaginatedSource(500, s.getValue(), l.intValue()) {

        @Override
        ResultSet<Change> scan(ChangeAccess a, String key, int limit) throws OrmException {
            return a.byBranchOpenAll(new Branch.NameKey(p.getValueKey(), b.getValue()));
        }

        @Override
        public boolean match(ChangeData cd) throws OrmException {
            return // 
            cd.change(dbProvider).getStatus().isOpen() && // 
            p.match(cd) && // 
            b.match(cd) && s.match(cd);
        }
    };
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void publishApprovals(ChangeControl ctl) throws InvalidChangeOperationException, OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(ctl, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            functionState.normalize(types.byId(a.getCategoryId()), a);
        }
        if (o != a.getValue()) {
            throw new InvalidChangeOperationException(types.byId(a.getCategoryId()).getCategory().getLabelName() + "=" + o + " not permitted");
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#method_after
private void publishApprovals(ChangeControl ctl) throws InvalidChangeOperationException, OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(ctl, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            functionState.normalize(types.byId(a.getCategoryId()), a);
        }
        if (want.get() != a.getValue()) {
            throw new InvalidChangeOperationException(types.byId(a.getCategoryId()).getCategory().getLabelName() + "=" + want.get() + " not permitted");
        }
        if (o != a.getValue()) {
            // Value changed, ensure we update the database.
            // 
            a.setGranted();
            dirty.add(a.getCategoryId());
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#end_block

#method_before
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    if (message == null) {
        return;
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSetInfo patchSetInfo;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSetInfo = patchSetInfoFactory.get(reviewDb, patchSetId);
                } finally {
                    reviewDb.close();
                }
            } catch (PatchSetInfoNotAvailableException e) {
                log.error("Cannot read PatchSetInfo of " + patchSetId, e);
                return;
            } catch (OrmException e) {
                log.error("Cannot email comments for " + patchSetId, e);
                return;
            }
            try {
                final CommentSender cm = commentSenderFactory.create(change);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, patchSetInfo);
                cm.setChangeMessage(message);
                cm.setPatchLineComments(drafts);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot email comments for " + patchSetId, e);
            }
        }

        @Override
        public String toString() {
            return "send-email comments";
        }
    }));
}
#end_block

#method_before
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    return projectCache.get(parentResolver.get(getProject()));
}
#method_after
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    return projectCache.get(getProject().getParent(allProjectsName));
}
#end_block

#method_before
public Project.NameKey getParentName() {
    return parentResolver.get(project);
}
#method_after
public Project.NameKey getParentName() {
    return project.getParent(allProjectsName);
}
#end_block

#method_before
private Set<Project.NameKey> getAllParents(final Project.NameKey projectName) {
    final Set<Project.NameKey> parents = new HashSet<Project.NameKey>();
    Project.NameKey p = projectName;
    while (p != null && parents.add(p)) {
        final ProjectState e = projectCache.get(p);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            break;
        }
        p = parentResolver.get(e.getProject());
    }
    return parents;
}
#method_after
private Set<Project.NameKey> getAllParents(final Project.NameKey projectName) {
    final Set<Project.NameKey> parents = new HashSet<Project.NameKey>();
    Project.NameKey p = projectName;
    while (p != null && parents.add(p)) {
        final ProjectState e = projectCache.get(p);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            break;
        }
        p = e.getProject().getParent(allProjectsName);
    }
    return parents;
}
#end_block

#method_before
private List<Project> getChildren(final Project.NameKey parentName) {
    final List<Project> childProjects = new ArrayList<Project>();
    for (final Project.NameKey projectName : projectCache.all()) {
        final ProjectState e = projectCache.get(projectName);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            continue;
        }
        if (parentName.equals(parentResolver.get(e.getProject()))) {
            childProjects.add(e.getProject());
        }
    }
    return childProjects;
}
#method_after
private List<Project> getChildren(final Project.NameKey parentName) {
    final List<Project> childProjects = new ArrayList<Project>();
    for (final Project.NameKey projectName : projectCache.all()) {
        final ProjectState e = projectCache.get(projectName);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            continue;
        }
        if (parentName.equals(e.getProject().getParent(projectName))) {
            childProjects.add(e.getProject());
        }
    }
    return childProjects;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    detail.setInheritsFrom(parentResolver.get(config.getProject()));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
public void set(final boolean s) {
    if (Gerrit.isSignedIn() && s != get()) {
        final ToggleStarRequest req = new ToggleStarRequest();
        req.toggle(cache.getChangeId(), s);
        com.google.gerrit.client.changes.Util.LIST_SVC.toggleStars(req, new GerritCallback<VoidResult>() {

            public void onSuccess(final VoidResult result) {
                setStarred(s);
                fireEvent(new ValueChangeEvent<Boolean>(s) {
                });
            }
        });
    }
}
#method_after
public void set(final boolean s) {
    if (Gerrit.isSignedIn() && s != get()) {
        final ToggleStarRequest req = new ToggleStarRequest();
        req.toggle(cache.getChangeId(), s);
        Util.LIST_SVC.toggleStars(req, new GerritCallback<VoidResult>() {

            public void onSuccess(final VoidResult result) {
                setStarred(s);
                fireEvent(new ValueChangeEvent<Boolean>(s) {
                });
            }
        });
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchSideBySide(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchUnified(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    if (c.currPatchSetId().equals(ps.getId())) {
        d.isCurrentPatchSet = "true";
    } else {
        d.isCurrentPatchSet = "false";
    }
    return d;
}
#method_after
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    d.isCurrentPatchSet = c.currPatchSetId().equals(ps.getId());
    return d;
}
#end_block

#method_before
public Task beginSubTask(final String subTask, final int subTaskWork) {
    Task task = new Task(subTaskWork);
    tasks.put(subTask, task);
    return task;
}
#method_after
public Task beginSubTask(final String subTask, final int subTaskWork) {
    Task task = new Task(subTask, subTaskWork);
    tasks.add(task);
    return task;
}
#end_block

#method_before
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Map.Entry<String, Task> e : tasks.entrySet()) {
            Task t = e.getValue();
            if (t.count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ').append(e.getKey()).append(": ");
            if (t.total == UNKNOWN) {
                s.append(t.count);
            } else {
                s.append(t.count * 100 / t.total).append("% (").append(t.count).append('/').append(t.total).append(')');
            }
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#method_after
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Task t : tasks) {
            int count = t.count;
            if (count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ').append(t.name).append(": ");
            if (t.total == UNKNOWN) {
                s.append(count);
            } else {
                s.append(String.format("%d%% (%d/%d)", count * 100 / t.total, count, t.total));
            }
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#end_block

#method_before
private void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#end_block

#method_before
private void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
    sendMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands) {
    try {
        parseCommands(commands);
        if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            createNewChanges();
        }
        doReplaces();
        for (final ReceiveCommand c : commands) {
            if (c.getResult() == Result.OK) {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only schedule direct refs updates for replication.
                    // Change refs are scheduled when they are created.
                    // 
                    replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                    hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            }
        }
        if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
            final String url = canonicalWebUrl;
            addMessage("");
            addMessage("New Changes:");
            for (final Change c : allNewChanges) {
                if (c.getStatus() == Change.Status.DRAFT) {
                    addMessage("  " + url + c.getChangeId() + " [DRAFT]");
                } else {
                    addMessage("  " + url + c.getChangeId());
                }
            }
            addMessage("");
        }
    } finally {
        sendMessages();
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#end_block

#method_before
@Override
public void advertiseRefs(ReceiveSession rs) throws ServiceMayNotContinueException {
    base.advertiseRefs(rs);
    HashMap<String, Ref> r = new HashMap<String, Ref>();
    for (Map.Entry<String, Ref> e : rs.getAdvertisedRefs().entrySet()) {
        if (!e.getKey().startsWith("refs/changes/")) {
            r.put(e.getKey(), e.getValue());
        }
    }
    rs.setAdvertisedRefs(r, rs.getAdvertisedObjects());
}
#method_after
@Override
public void advertiseRefs(UploadPack us) {
    throw new UnsupportedOperationException("ReceiveCommitsAdvertiseRefsHook cannot be used for UploadPack");
}
#end_block

#method_before
@Override
public void onPreReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceiveSession().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    final ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    rp.setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rp;
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rc.getReceivePack();
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = (ReceivePack) receive.getReceiveSession();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send email for new change";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send email for new patch set";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send email for submitted patch set";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private void email() {
    if (message == null) {
        return;
    }
    final PatchSetInfo patchSetInfo;
    try {
        patchSetInfo = patchSetInfoFactory.get(db, patchSetId);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
        return;
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CommentSender cm = commentSenderFactory.create(change);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, patchSetInfo);
                cm.setChangeMessage(message);
                cm.setPatchLineComments(drafts);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send comments by email for patch set " + patchSetId, e);
            }
        }

        @Override
        public String toString() {
            return "send email for patch set comments";
        }
    }));
}
#method_after
private void email() {
    if (message == null) {
        return;
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSetInfo patchSetInfo;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSetInfo = patchSetInfoFactory.get(reviewDb, patchSetId);
                } finally {
                    reviewDb.close();
                }
            } catch (PatchSetInfoNotAvailableException e) {
                log.error("Cannot read PatchSetInfo of " + patchSetId, e);
                return;
            } catch (OrmException e) {
                log.error("Cannot email comments for " + patchSetId, e);
                return;
            }
            try {
                final CommentSender cm = commentSenderFactory.create(change);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, patchSetInfo);
                cm.setChangeMessage(message);
                cm.setPatchLineComments(drafts);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot email comments for " + patchSetId, e);
            }
        }

        @Override
        public String toString() {
            return "send-email comments";
        }
    }));
}
#end_block

#method_before
private PersonIdent computeAuthor(final List<CodeReviewCommit> codeReviewCommits) {
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : codeReviewCommits) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : codeReviewCommits) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(codeReviewCommits.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    return authorIdent;
}
#method_after
private PersonIdent computeAuthor(final List<CodeReviewCommit> codeReviewCommits) {
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : codeReviewCommits) {
        PatchSetApproval s = getSubmitter(db, c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : codeReviewCommits) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(codeReviewCommits.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    return authorIdent;
}
#end_block

#method_before
private void markCleanMerges() throws MergeException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.reset();
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.patchsetId != null) {
                c.statusCode = CommitMergeStatus.CLEAN_MERGE;
                if (branchUpdate.getRefLogIdent() == null) {
                    setRefLogIdent(getSubmitter(c.patchsetId));
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#method_after
private void markCleanMerges() throws MergeException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.reset();
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.patchsetId != null) {
                c.statusCode = CommitMergeStatus.CLEAN_MERGE;
                if (branchUpdate.getRefLogIdent() == null) {
                    setRefLogIdent(getSubmitter(db, c.patchsetId));
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private PatchSetApproval getSubmitter(PatchSet.Id c) {
    if (c == null) {
        return null;
    }
    PatchSetApproval submitter = null;
    try {
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byPatchSet(c).toList();
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter;
}
#method_after
private static PatchSetApproval getSubmitter(ReviewDb reviewDb, PatchSet.Id c) {
    if (c == null) {
        return null;
    }
    PatchSetApproval submitter = null;
    try {
        final List<PatchSetApproval> approvals = reviewDb.patchSetApprovals().byPatchSet(c).toList();
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final PatchSet patchSet = db.patchSets().get(c.currentPatchSetId());
        final PatchSetApproval from = submitter;
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(c);
                    if (from != null) {
                        cm.setFrom(from.getAccountId());
                    }
                    cm.setPatchSet(patchSet);
                    cm.send();
                } catch (EmailException e) {
                    log.error("Cannot send email for submitted patch set " + c.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send email for submitted patch set";
            }
        }));
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (OrmException e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final PatchSet patchSet = db.patchSets().get(c.currentPatchSetId());
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergeFailSender cm = mergeFailSenderFactory.create(c);
                    final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
                    if (submitter != null) {
                        cm.setFrom(submitter.getAccountId());
                    }
                    cm.setPatchSet(patchSet);
                    cm.setChangeMessage(msg);
                    cm.send();
                } catch (EmailException e) {
                    log.error("Cannot send email notifications about merge failure", e);
                }
            }

            @Override
            public String toString() {
                return "send email for merge failure";
            }
        }));
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (OrmException e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#end_block

#method_before
@Override
public final com.google.gwtorm.client.ResultSet<T> get(final Iterable<K> keys) throws OrmException {
    final Collection<K> keySet;
    if (keys instanceof Collection) {
        keySet = (Collection<K>) keys;
    } else {
        keySet = new ArrayList<K>();
        for (final K k : keys) {
            keySet.add(k);
        }
    }
    switch(keySet.size()) {
        case 0:
            // 
            return new ListResultSet<T>(Collections.<T>emptyList());
        case 1:
            {
                // Only one key requested, use a faster equality lookup.
                // 
                final T entity = get(keySet.iterator().next());
                if (entity != null) {
                    return new ListResultSet<T>(Collections.singletonList(entity));
                }
                return new ListResultSet<T>(Collections.<T>emptyList());
            }
        default:
            return getBySqlIn(keySet);
    }
}
#method_after
@Override
public final com.google.gwtorm.server.ResultSet<T> get(final Iterable<K> keys) throws OrmException {
    final Collection<K> keySet;
    if (keys instanceof Collection) {
        keySet = (Collection<K>) keys;
    } else {
        keySet = new ArrayList<K>();
        for (final K k : keys) {
            keySet.add(k);
        }
    }
    switch(keySet.size()) {
        case 0:
            // 
            return new ListResultSet<T>(Collections.<T>emptyList());
        case 1:
            {
                // Only one key requested, use a faster equality lookup.
                // 
                final T entity = get(keySet.iterator().next());
                if (entity != null) {
                    return new ListResultSet<T>(Collections.singletonList(entity));
                }
                return new ListResultSet<T>(Collections.<T>emptyList());
            }
        default:
            return getBySqlIn(keySet);
    }
}
#end_block

#method_before
protected com.google.gwtorm.client.ResultSet<T> getBySqlIn(final Collection<K> keys) throws OrmException {
    return super.get(keys);
}
#method_after
protected com.google.gwtorm.server.ResultSet<T> getBySqlIn(final Collection<K> keys) throws OrmException {
    return super.get(keys);
}
#end_block

#method_before
protected ListResultSet<T> queryList(final PreparedStatement ps) throws OrmException {
    try {
        try {
            final ResultSet rs = ps.executeQuery();
            try {
                final ArrayList<T> r = new ArrayList<T>();
                while (rs.next()) {
                    final T o = newEntityInstance();
                    bindOneFetch(rs, o);
                    r.add(o);
                }
                return new ListResultSet<T>(r);
            } finally {
                rs.close();
            }
        } finally {
            ps.close();
        }
    } catch (SQLException e) {
        throw convertError("fetch", e);
    }
}
#method_after
protected com.google.gwtorm.server.ResultSet<T> queryList(final PreparedStatement ps) throws OrmException {
    final ResultSet rs;
    try {
        rs = ps.executeQuery();
        if (!rs.next()) {
            rs.close();
            ps.close();
            return new ListResultSet<T>(Collections.<T>emptyList());
        }
    } catch (SQLException err) {
        try {
            ps.close();
        } catch (SQLException e) {
        // Ignored.
        }
        throw convertError("fetch", err);
    }
    return new JdbcResultSet<T, K>(this, rs, ps);
}
#end_block

#method_before
private void insertIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getInsertOneSql());
            }
            bindOneInsert(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void insertIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getInsertOneSql());
            }
            bindOneInsert(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private void updateIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getUpdateOneSql());
            }
            bindOneUpdate(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void updateIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getUpdateOneSql());
            }
            bindOneUpdate(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private Collection<T> attemptUpdateAsBatch(final Iterable<T> instances) throws OrmException {
    Collection<T> inserts = null;
    try {
        PreparedStatement ps = null;
        try {
            int cnt = 0;
            List<T> allInstances = new ArrayList<T>();
            for (final T o : instances) {
                if (ps == null) {
                    ps = schema.getConnection().prepareStatement(getUpdateOneSql());
                }
                bindOneUpdate(ps, o);
                ps.addBatch();
                allInstances.add(o);
                cnt++;
            }
            if (0 < cnt) {
                final int[] states = ps.executeBatch();
                if (states == null) {
                    inserts = new ArrayList<T>(cnt);
                    for (T o : allInstances) {
                        inserts.add(o);
                    }
                } else {
                    int i = 0;
                    for (T o : allInstances) {
                        if (states.length <= i || states[i] != 1) {
                            if (inserts == null) {
                                inserts = new ArrayList<T>(cnt - i);
                            }
                            inserts.add(o);
                        }
                        i++;
                    }
                }
            }
        } finally {
            if (ps != null) {
                ps.close();
            }
        }
    } catch (SQLException e) {
        throw convertError("update", e);
    }
    return inserts;
}
#method_after
private Collection<T> attemptUpdateAsBatch(final Iterable<T> instances) throws OrmException {
    Collection<T> inserts = null;
    try {
        PreparedStatement ps = null;
        try {
            int cnt = 0;
            List<T> allInstances = new ArrayList<T>();
            for (final T o : instances) {
                if (ps == null) {
                    ps = schema.getConnection().prepareStatement(getUpdateOneSql());
                }
                bindOneUpdate(ps, o);
                ps.addBatch();
                allInstances.add(o);
                cnt++;
            }
            if (0 < cnt) {
                final int[] states = ps.executeBatch();
                if (states == null) {
                    inserts = allInstances;
                } else {
                    int i = 0;
                    for (T o : allInstances) {
                        if (states.length <= i || states[i] != 1) {
                            if (inserts == null) {
                                inserts = new ArrayList<T>(cnt - i);
                            }
                            inserts.add(o);
                        }
                        i++;
                    }
                }
            }
        } finally {
            if (ps != null) {
                ps.close();
            }
        }
    } catch (SQLException e) {
        throw convertError("update", e);
    }
    return inserts;
}
#end_block

#method_before
private void deleteIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getDeleteOneSql());
            }
            bindOneDelete(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void deleteIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getDeleteOneSql());
            }
            bindOneDelete(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private OrmException convertError(final String op, final SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return schema.getDialect().convertError(op, getRelationName(), err);
}
#method_after
protected OrmException convertError(final String op, final SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return schema.getDialect().convertError(op, getRelationName(), err);
}
#end_block

#method_before
public long nextLong(final Connection conn, final String query) throws OrmException {
    try {
        final Statement st = conn.createStatement();
        try {
            final ResultSet rs = st.executeQuery(query);
            try {
                if (!rs.next()) {
                    throw new SQLException("No result row for sequence query");
                }
                final long r = rs.getLong(1);
                if (rs.next()) {
                    throw new SQLException("Too many results from sequence query");
                }
                return r;
            } finally {
                rs.close();
            }
        } finally {
            st.close();
        }
    } catch (SQLException e) {
        throw convertError("sequence", query, e);
    }
}
#method_after
public long nextLong(final Connection conn, final String poolName) throws OrmException {
    final String query = getNextSequenceValueSql(poolName);
    try {
        final Statement st = conn.createStatement();
        try {
            final ResultSet rs = st.executeQuery(query);
            try {
                if (!rs.next()) {
                    throw new SQLException("No result row for sequence query");
                }
                final long r = rs.getLong(1);
                if (rs.next()) {
                    throw new SQLException("Too many results from sequence query");
                }
                return r;
            } finally {
                rs.close();
            }
        } finally {
            st.close();
        }
    } catch (SQLException e) {
        throw convertError("sequence", query, e);
    }
}
#end_block

#method_before
private JdbcAccess<Data, Data.DataKey> createClassUnderTest() {
    final SqlDialect dialect = mock(SqlDialect.class, CALLS_REAL_METHODS);
    JdbcSchema schema = setupSchema(dialect);
    JdbcAccess<Data, Data.DataKey> classUnderTest = new DataJdbcAccess(schema);
    return classUnderTest;
}
#method_after
private JdbcAccess<Data, Data.DataKey> createClassUnderTest() {
    return createJdbcAccess(DIALECT);
}
#end_block

#method_before
private JdbcSchema setupSchema(final SqlDialect dialect) {
    @SuppressWarnings("rawtypes")
    Database db = mock(Database.class);
    try {
        stub(db.getDialect()).toReturn(dialect);
        JdbcSchema schema = new Schema(db, conn);
        return schema;
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private JdbcSchema setupSchema(final SqlDialect dialect) {
    @SuppressWarnings("rawtypes")
    Database db = mock(Database.class);
    try {
        when(db.getDialect()).thenReturn(dialect);
        when(db.newConnection()).thenReturn(conn);
        JdbcSchema schema = new Schema(db);
        return schema;
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Test
public void testInsertNothing() throws OrmException, SQLException {
    setup();
    createClassUnderTest().insert(NO_DATA);
}
#method_after
@Test
public void testInsertNothing() throws OrmException {
    setup();
    createClassUnderTest().insert(NO_DATA);
}
#end_block

#method_before
@Test
public void testInsertOne() throws OrmException, SQLException {
    stubExecuteBatchOK(INSERT, 1);
    createClassUnderTest().insert(ONE_ROW);
}
#method_after
@Test
public void testInsertOne() throws OrmException, SQLException {
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT, 1);
    createClassUnderTest().insert(ONE_ROW);
    assertUsedBatchingOnly(insert);
}
#end_block

#method_before
@Test
public void testUpdateNothing() throws OrmException, SQLException {
    createClassUnderTest().update(NO_DATA);
}
#method_after
@Test
public void testUpdateNothing() throws OrmException {
    createClassUnderTest().update(NO_DATA);
}
#end_block

#method_before
@Test
public void testUpdateOne() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE, 1);
    createClassUnderTest().update(ONE_ROW);
}
#method_after
@Test
public void testUpdateOne() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE, 1);
    createClassUnderTest().update(ONE_ROW);
    assertUsedBatchingOnly(update);
}
#end_block

#method_before
@Test
public void testUpsertOneExisting() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE, 1);
    createClassUnderTest().upsert(ONE_ROW);
}
#method_after
@Test
public void testUpsertOneExisting() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE, 1);
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT);
    createClassUnderTest().upsert(ONE_ROW);
    assertUsedBatchingOnly(update);
    assertNotUsed(insert);
}
#end_block

#method_before
@Test
public void testUpsertOneException() throws OrmException, SQLException {
    stubExecuteBatchException(UPDATE, new BatchUpdateException());
    try {
        createClassUnderTest().upsert(ONE_ROW);
        fail("missingException");
    } catch (OrmException e) {
    // expected
    }
}
#method_after
@Test
public void testUpsertOneException() throws OrmException, SQLException {
    SQLException exception = new BatchUpdateException();
    PreparedStatement update = stubStatementThrowExceptionOnExecute(UPDATE, exception);
    JdbcAccess<Data, Data.DataKey> classUnderTest = createClassUnderTest();
    try {
        classUnderTest.upsert(ONE_ROW);
        fail("missingException");
    } catch (OrmException e) {
        // expected
        assertSame(e.getCause(), exception);
    }
    assertUsedBatchingOnly(update);
}
#end_block

#method_before
@Test
public void testUpsertOneNotExisting() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE);
    PreparedStatement insert = stubExecuteBatchOK(INSERT, 1);
    createClassUnderTest().upsert(ONE_ROW);
    verifyIds(insert, 1);
}
#method_after
@Test
public void testUpsertOneNotExisting() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE);
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT, 1);
    createClassUnderTest().upsert(ONE_ROW);
    assertUsedBatchingOnly(update);
    assertUsedBatchingOnly(insert);
    assertExpectedIdsUsed(insert, 1);
}
#end_block

#method_before
@Test
public void testDeleteOneExisting() throws SQLException, OrmException {
    stubExecuteBatchOK(DELETE, 1);
    createClassUnderTest().delete(ONE_ROW);
}
#method_after
@Test
public void testDeleteOneExisting() throws SQLException, OrmException {
    PreparedStatement delete = stubStatementWithUpdateCounts(DELETE, 1);
    createClassUnderTest().delete(ONE_ROW);
    assertUsedBatchingOnly(delete);
}
#end_block

#method_before
@Test
public void testDeleteOneNotExisting() throws SQLException, OrmException {
    stubExecuteBatchOK(DELETE, 0);
    try {
        createClassUnderTest().delete(ONE_ROW);
        fail("missing OrmConcurrencyException");
    } catch (OrmConcurrencyException e) {
    // expected
    }
}
#method_after
@Test
public void testDeleteOneNotExisting() throws SQLException, OrmException {
    PreparedStatement delete = stubStatementWithUpdateCounts(DELETE, 0);
    JdbcAccess<Data, Data.DataKey> classUnderTest = createClassUnderTest();
    try {
        classUnderTest.delete(ONE_ROW);
        fail("missing OrmConcurrencyException");
    } catch (OrmConcurrencyException e) {
    // expected
    }
    assertUsedBatchingOnly(delete);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    if (openSchemas != null) {
        for (PhoneBookDb schema : openSchemas) {
            schema.close();
        }
        openSchemas = null;
    }
    super.tearDown();
}
#method_after
@After
public void tearDown() throws Exception {
    if (openSchemas != null) {
        for (PhoneBookDb schema : openSchemas) {
            schema.close();
        }
        openSchemas = null;
    }
}
#end_block

#method_before
@Test
public void testGetPeopleAccess() throws Exception {
    final PhoneBookDb schema = open();
    assertNotNull(schema.people());
}
#method_after
@Test
public void testGetPeopleAccess() throws Exception {
    final PhoneBookDb schema = open();
    assertNotNull(schema.people());
    assertEquals("people", schema.people().getRelationName());
    assertEquals(1, schema.people().getRelationID());
}
#end_block

#method_before
@Test
public void testGetAddressAccess() throws Exception {
    final PhoneBookDb schema = open();
    assertNotNull(schema.addresses());
}
#method_after
@Test
public void testGetAddressAccess() throws Exception {
    final PhoneBookDb schema = open();
    assertNotNull(schema.addresses());
    assertEquals("addresses", schema.addresses().getRelationName());
    assertEquals(2, schema.addresses().getRelationID());
}
#end_block

#method_before
@Test
public void testFetchNotPerson() throws Exception {
    final PhoneBookDb schema = openAndCreate();
    final ArrayList<Person> all = new ArrayList<Person>();
    all.add(new Person(new Person.Key("Bob"), 18));
    all.add(new Person(new Person.Key("Mary"), 22));
    all.add(new Person(new Person.Key("Zak"), 33));
    schema.people().insert(all);
    final List<Person> r = schema.people().notPerson(new Person.Key("Mary"), 10).toList();
    assertEquals(2, r.size());
    assertEquals(all.get(2).name(), r.get(0).name());
    assertEquals(all.get(0).name(), r.get(1).name());
}
#method_after
@Test
public void testFetchNotPerson() throws Exception {
    final PhoneBookDb schema = openAndCreate();
    final ArrayList<Person> all = new ArrayList<Person>();
    all.add(new Person(new Person.Key("Bob"), 18));
    all.add(new Person(new Person.Key("Mary"), 22));
    all.add(new Person(new Person.Key("Zak"), 33));
    schema.people().insert(all);
    final List<Person> r = schema.people().olderThanDescByName(18).toList();
    assertEquals(2, r.size());
    assertEquals(all.get(2).name(), r.get(0).name());
    assertEquals(all.get(1).name(), r.get(1).name());
}
#end_block

#method_before
@SuppressWarnings("cast")
@Test
public void testPerson() throws UnsupportedEncodingException {
    final ProtobufCodec<Person> e = CodecFactory.encoder(Person.class);
    final byte[] bin = new byte[] { // name
    0x0a, 0x09, // 
    0x0a, // 
    0x07, // 
    0x74, // 
    0x65, // 
    0x73, // 
    0x74, // 
    0x69, // 
    0x6e, // 
    0x67, // 
    0x10, // 
    (byte) 0x96, // 
    0x01, // 
    0x18, // 
    0x01 };
    Person p = e.decode(bin);
    assertNotNull(p);
    assertTrue(p instanceof Person);
    assertEquals("testing", p.name());
    assertEquals(75, p.age());
    assertTrue(p.isRegistered());
    final byte[] out = e.encode(p).toByteArray();
    assertEquals(new String(bin, "ISO-8859-1"), new String(out, "ISO-8859-1"));
    assertEquals(bin.length, e.sizeof(p));
}
#method_after
@SuppressWarnings("cast")
@Test
public void testPerson() throws UnsupportedEncodingException {
    final ProtobufCodec<Person> e = CodecFactory.encoder(Person.class);
    Person p = e.decode(testingBin);
    assertNotNull(p);
    assertTrue(p instanceof Person);
    assertEquals("testing", p.name());
    assertEquals(75, p.age());
    assertTrue(p.isRegistered());
    final byte[] out = e.encodeToByteArray(p);
    assertEquals(asString(testingBin), asString(out));
    assertEquals(testingBin.length, e.sizeof(p));
}
#end_block

#method_before
@Test
public void testAddress() {
    final ProtobufCodec<Address> e = CodecFactory.encoder(Address.class);
    Address a = e.decode(new byte[0]);
    assertNotNull(a);
    assertNull(a.location());
    Person.Key k = new Person.Key("bob");
    Person p = new Person(k, 42);
    Address b = new Address(new Address.Key(k, "ny"), "ny");
    byte[] act = e.encode(b).toByteArray();
    Address c = e.decode(act);
    assertEquals(c.location(), b.location());
    assertEquals(c.city(), b.city());
    assertEquals(c.key(), b.key());
}
#method_after
@Test
public void testAddress() {
    final ProtobufCodec<Address> e = CodecFactory.encoder(Address.class);
    Address a = e.decode(new byte[0]);
    assertNotNull(a);
    assertNull(a.location());
    Person.Key k = new Person.Key("bob");
    Person p = new Person(k, 42);
    Address b = new Address(new Address.Key(k, "ny"), "ny");
    byte[] act = e.encodeToByteArray(b);
    Address c = e.decode(act);
    assertEquals(c.location(), b.location());
    assertEquals(c.city(), b.city());
    assertEquals(c.key(), b.key());
}
#end_block

#method_before
@Before
protected void setUp() throws Exception {
    super.setUp();
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#method_after
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
protected void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", null, id);
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("", diffBase, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", null, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("unified", diffBase, id);
}
#end_block

#method_before
public static String toPatch(final PatchScreen.Type type, final Patch.Key id) {
    if (type == PatchScreen.Type.SIDE_BY_SIDE) {
        return toPatchSideBySide(id);
    } else {
        return toPatchUnified(id);
    }
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    PatchSet.Id ps = id.getParentKey();
    Change.Id c = ps.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(ps.get()).append("/").append(KeyUtil.encode(id.get()));
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static void patch(String token, final Patch.Key id, final int patchIndex, final PatchSetDetail patchSetDetail, final PatchTable patchTable, final PatchScreen.TopView topView, final String panelType) {
    final String parametersUrl;
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        parametersUrl = token.substring(token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) + 1);
        token = token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START));
    } else {
        parametersUrl = null;
    }
    final PatchScreen.TopView top = topView == null ? Gerrit.getPatchScreenTopView() : topView;
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (id != null) {
                String panel = panelType;
                if (panel == null) {
                    int c = token.lastIndexOf(',');
                    panel = 0 <= c ? token.substring(c + 1) : "";
                }
                if ("".equals(panel)) {
                    return new // 
                    PatchScreen.SideBySide(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                } else if ("unified".equals(panel)) {
                    return new // 
                    PatchScreen.Unified(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
public static void patch(String token, PatchSet.Id base, Patch.Key id, int patchIndex, PatchSetDetail patchSetDetail, PatchTable patchTable, PatchScreen.TopView topView) {
    patch(token, base, id, patchIndex, patchSetDetail, patchTable, topView, null);
}
#end_block

#method_before
private static String skip(String token) {
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        return token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START)).substring(prefixlen);
    } else {
        return token.substring(prefixlen);
    }
}
#method_after
private static String skip(String token) {
    return token.substring(prefixlen);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(idSideA, result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(idSideA, result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    addHandlerForDiffButton(detail);
    actionsPanel.add(diffAllSideBySide);
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    Gerrit.display(PageLinks.MINE);
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                public void onSuccess(final ChangeDetail result) {
                    if (result != null) {
                        changeScreen.update(result);
                    } else {
                        Gerrit.display(PageLinks.MINE);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
            hOfdiffAllSideBySide.removeHandler();
            hOfdiffAllUnified.removeHandler();
            addHandlerForDiffButton(result);
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#method_after
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    base, // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean revd = false;
        if (isFirst && !prefs.get().isManualReview()) {
            revd = true;
            setReviewedByCurrentUser(revd);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    revd = p.isReviewedByCurrentUser();
                }
            }
        }
        reviewed.setValue(revd);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = fetchChangeData(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(RetrieveParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(VisibleProjectDetails.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(SuggestParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects());
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    bp.add(browse);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    Util.PROJECT_SVC.suggestParentCandidates(new GerritCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void addGrid(final VerticalPanel fp) {
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#method_after
private void addGrid(final VerticalPanel fp) {
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    RetrieveParentCandidatesHandlerFactory.create().to(callback);
}
#method_after
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    suggestParentCandidatesHandlerFactory.create().to(callback);
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base;
    if (baseRevision != null && !baseRevision.isEmpty()) {
        base = ObjectId.fromString(baseRevision);
    } else {
        base = null;
    }
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#end_block

#method_before
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            ReviewResult result = null;
            try {
                result = deleteDraftFactory.create(psid).call();
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(result.getChangeId()));
            }
            if (result.getErrors().size() > 0) {
                throw new Failure(new NoSuchEntityException());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            ReviewResult result = null;
            try {
                result = deleteDraftPatchSetFactory.create(psid).call();
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(result.getChangeId()));
            }
            if (result.getErrors().size() > 0) {
                throw new Failure(new NoSuchEntityException());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraft.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change/patch set";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case NOT_A_DRAFT:
                errMsg += "change is not a draft";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDelete()) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
public boolean canPublish(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canPublish(final ReviewDb db) throws OrmException {
    return change.getStatus() == Change.Status.DRAFT && isOwner() && isVisible(db);
}
#end_block

#method_before
public boolean canDelete(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canDelete(final ReviewDb db) throws OrmException {
    return change.getStatus() == Change.Status.DRAFT && isOwner() && isVisible(db);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanPublish(control.canDelete(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(control.canDelete(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case CHANGE_NOT_VISIBLE:
                errMsg += "not permitted to review change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.isVisible(db) && !control.isOwner()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_NOT_VISIBLE));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.canPublish(db)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.PUBLISH_NOT_PERMITTED));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (!changeControl.isOwner() || !changeControl.isVisible(db)) {
        throw new IllegalStateException("Cannot publish patchset");
    }
    ChangeUtil.publishDraftPatchSet(db, patchSetId);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (!changeControl.canPublish(db)) {
        throw new IllegalStateException("Cannot publish patchset");
    }
    ChangeUtil.publishDraftPatchSet(db, patchSetId);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canCreateProject()) {
                String msg = String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
            }
            parseCommandLine();
            if (!suggestParent) {
                // 
                if (projectName == null) {
                    throw new Failure(1, "fatal: Option \"--name (-n)\" is required");
                }
                try {
                    final CreateProjectArgs args = new CreateProjectArgs();
                    args.setProjectName(projectName);
                    args.setOwnerIds(ownerIds);
                    args.setNewParent(newParent);
                    args.setPermissionsOnly(permissionsOnly);
                    args.setProjectDescription(projectDescription);
                    args.setSubmitType(submitType);
                    args.setContributorAgreements(contributorAgreements);
                    args.setSignedOffBy(signedOffBy);
                    args.setContentMerge(contentMerge);
                    args.setChangeIdRequired(requireChangeID);
                    args.setBranch(branch);
                    args.setCreateEmptyCommit(createEmptyCommit);
                    final CreateProject createProject = CreateProjectFactory.create(args);
                    createProject.createProject();
                } catch (ProjectCreationFailedException err) {
                    throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
                }
            } else {
                List<Project> parentCandidates = retrieveParentCandidatesFactory.create().getParentCandidates();
                PrintWriter p = toPrintWriter(out);
                for (Project parent : parentCandidates) {
                    p.print(parent.getNameKey() + "\n");
                }
                p.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canCreateProject()) {
                String msg = String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
            }
            PrintWriter p = toPrintWriter(out);
            parseCommandLine();
            try {
                if (!suggestParent) {
                    if (projectName == null) {
                        throw new UnloggedFailure(1, "fatal: Project name is required.");
                    }
                    final CreateProjectArgs args = new CreateProjectArgs();
                    args.setProjectName(projectName);
                    args.ownerIds = ownerIds;
                    args.newParent = newParent;
                    args.permissionsOnly = permissionsOnly;
                    args.projectDescription = projectDescription;
                    args.submitType = submitType;
                    args.contributorAgreements = contributorAgreements;
                    args.signedOffBy = signedOffBy;
                    args.contentMerge = contentMerge;
                    args.changeIdRequired = requireChangeID;
                    args.branch = branch;
                    args.createEmptyCommit = createEmptyCommit;
                    final CreateProject createProject = CreateProjectFactory.create(args);
                    createProject.createProject();
                } else {
                    Set<Project.NameKey> parentCandidates = retrieveParentCandidatesFactory.create().get();
                    for (Project.NameKey parent : parentCandidates) {
                        p.print(parent + "\n");
                    }
                }
            } catch (ProjectCreationFailedException err) {
                throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
            } finally {
                p.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final ReviewResult result = submitFactory.create(patchSetId).call();
    if (result.getErrors().size() > 0) {
        throw new IllegalStateException("Cannot submit " + result.getErrors().get(0));
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final ReviewResult result = submitFactory.create(patchSetId).call();
    if (result.getErrors().size() > 0) {
        throw new IllegalStateException("Cannot submit " + result.getErrors().get(0).getMessageOrType());
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
// public ReviewResult call() throws EmailException,
@Override
public ReviewResult call() throws InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patchSetId);
    if (submitResult.isEmpty()) {
        throw new InvalidChangeOperationException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new InvalidChangeOperationException("Unsupported SubmitRecord.Label.status");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
            default:
                throw new InvalidChangeOperationException("Unsupported SubmitRecord.status");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws IllegalStateException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patchSetId);
    if (submitResult.isEmpty()) {
        throw new IllegalStateException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
                break;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ReviewResult result = null;
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            result = abandonChangeFactory.create(patchSetId, changeComment).call();
        } else if (restoreChange) {
            result = restoreChangeFactory.create(patchSetId, changeComment).call();
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> submitResult = changeControl.canSubmit(db, patchSetId);
        if (submitResult.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(submitResult.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : submitResult.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (submitResult.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + submitResult.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + submitResult.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
    if (result != null) {
        for (ReviewResult.Error resultError : result.getErrors()) {
            switch(resultError.getType()) {
                case ABANDON_NOT_PERMITTED:
                    writeError("error: not permitted to abandon change");
                case RESTORE_NOT_PERMITTED:
                    writeError("error: not permitted to restore change");
                default:
                    writeError("error: failure in review");
            }
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ReviewResult result = null;
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            result = abandonChangeFactory.create(patchSetId, changeComment).call();
        } else if (restoreChange) {
            result = restoreChangeFactory.create(patchSetId, changeComment).call();
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> submitResult = changeControl.canSubmit(db, patchSetId);
        if (submitResult.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(submitResult.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : submitResult.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (submitResult.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + submitResult.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + submitResult.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
    if (result != null) {
        for (ReviewResult.Error resultError : result.getErrors()) {
            switch(resultError.getType()) {
                case ABANDON_NOT_PERMITTED:
                    writeError("error: not permitted to abandon change");
                    break;
                case RESTORE_NOT_PERMITTED:
                    writeError("error: not permitted to restore change");
                    break;
                default:
                    writeError("error: failure in review");
            }
        }
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a messaage to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
        updateSubscriptions();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : rw.getRepository().getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#method_after
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : db.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#end_block

#method_before
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final Merger m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m;
    if (destProject.isUseContentMerge()) {
        // Settings for this project allow us to try and
        // automatically resolve conflicts within files if needed.
        // Use ResolveMerge and instruct to operate in core.
        m = MergeStrategy.RESOLVE.newMerger(db, true);
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    }
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip, n });
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    mergeTip = (CodeReviewCommit) rw.parseCommit(id);
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip });
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (branchTip == null || branchTip != mergeTip) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void updateSubscriptions() {
    // Note: The merge is already performed so we shall not throw an exception
    // on failure.
    Transaction txn = null;
    final String gitmodulesFile = ".gitmodules";
    File tmpGitmodulesFile = null;
    try {
        final TreeWalk tw = TreeWalk.forPath(db, gitmodulesFile, mergeTip.getTree());
        if ((tw != null) && (tw.getFileMode(0).getObjectType() == Constants.OBJ_BLOB)) {
            tmpGitmodulesFile = File.createTempFile(gitmodulesFile, ".tmp");
            final byte[] blobData = db.openBlob(tw.getObjectId(0)).getCachedBytes();
            FileOutputStream fos = new FileOutputStream(tmpGitmodulesFile.getCanonicalPath());
            fos.write(blobData);
            fos.close();
            final FileBasedConfig cfg = new FileBasedConfig(tmpGitmodulesFile);
            final String thisServer = getSrvName(urlProvider.get());
            if (thisServer == null) {
                throw new DataFormatException("At parse of " + gitmodulesFile + ": problem retrieving name of this server.");
            }
            txn = schema.beginTransaction();
            schema.subscriptions().delete(schema.subscriptions().getSubscription(destBranch), txn);
            cfg.load();
            for (String id : cfg.getSubsections("submodule")) {
                final String url = cfg.getString("submodule", id, "url");
                final String path = cfg.getString("submodule", id, "path");
                String revision = cfg.getString("submodule", id, "revision");
                if (url != null && url.length() > 0 && path != null && path.length() > 0 && revision != null && revision.length() > 0) {
                    boolean pathIsRelative = url.startsWith("/");
                    String server = null;
                    if (!pathIsRelative)
                        server = getSrvName(url);
                    if ((pathIsRelative) || (server != null && server.equalsIgnoreCase(thisServer))) {
                        if (revision.equals(".")) {
                            revision = destBranch.get();
                        }
                        schema.subscriptions().insert(Collections.singleton(new Subscription(new Subscription.Id(schema.nextSubscriptionId()), new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get()), new Branch.NameKey(new Project.NameKey(path), revision))), txn);
                    }
                }
            }
            txn.commit();
        }
    } catch (OrmException e) {
        log.error("Database problem at update of subscriptions table from " + gitmodulesFile + " file.", e);
    } catch (ConfigInvalidException e) {
        log.error("Problem at update of subscriptions table: " + gitmodulesFile + " config file is invalid.", e);
    } catch (IOException e) {
        log.error("Problem at update of subscriptions table from " + gitmodulesFile + ".", e);
    } catch (DataFormatException e) {
        log.error(e.getMessage(), e);
    } finally {
        if (txn != null) {
            try {
                txn.rollback();
            } catch (OrmException e) {
            }
        }
        if (tmpGitmodulesFile != null) {
            tmpGitmodulesFile.delete();
        }
    }
}
#method_after
private void updateSubscriptions() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        SubmoduleOp subOp = subOpFactory.create(destBranch, mergeTip, rw, db, destProject, submitted, commits);
        try {
            subOp.update();
        } catch (SubmoduleException e) {
            log.error("The gitLinks were not updated according to the subscriptions " + e.getMessage());
        }
    }
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()), schema);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canUploadToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isHead(c) || isTag(c)) {
                // We only schedule heads and tags for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.find(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.findByNameOrEmail(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    final RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    final RevObject oldObject, newObject;
    try {
        oldObject = rp.getRevWalk().parseAny(cmd.getOldId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getOldId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    try {
        newObject = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (oldObject instanceof RevCommit && newObject instanceof RevCommit && ctl.canForceUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    if (rp.getAdvertisedRefs().containsKey(destBranchName)) {
        // We advertised the branch to the client so we know
        // the branch exists. Target this branch for the upload.
        // 
        destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
    } else {
        // We didn't advertise the branch, because it doesn't exist yet.
        // Allow it anyway if HEAD is a symbolic reference to the name.
        // 
        final String head;
        try {
            head = repo.getFullBranch();
        } catch (IOException e) {
            log.error("Cannot read HEAD symref", e);
            reject(cmd, "internal error");
            return;
        }
        if (head.equals(destBranchName)) {
            destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
        }
    }
    if (destBranch == null) {
        String n = destBranchName;
        if (n.startsWith(Constants.R_HEADS))
            n = n.substring(Constants.R_HEADS.length());
        reject(cmd, "branch " + n + " not found");
        return;
    }
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // Schedule as a replacement to this one matching change.
                    // 
                    requestReplace(newChange, changes.get(0), c);
                    continue;
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    rp.sendMessage(// 
                    "(W) " + c.abbreviate(repo, 6).name() + ":" + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : ""));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    if (65 < c.getShortMessage().length()) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            } else {
                log.warn("Replacement of Change-Id " + req.ontoChange + " with commit " + req.newCommit.name() + " did not import the new patch set.");
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (final Ref r : repo.getAllRefs().values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db);
    }
}
#method_after
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db, toTargetVersion);
    }
}
#end_block

#method_before
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        final List<String> pruneList = new ArrayList<String>();
        s.pruneSchema(new StatementExecutor() {

            public void execute(String sql) {
                pruneList.add(sql);
            }
        });
        if (!pruneList.isEmpty()) {
            ui.pruneSchema(e, pruneList);
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#method_after
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db, false);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        if (toTargetVersion) {
            final List<String> pruneList = new ArrayList<String>();
            s.pruneSchema(new StatementExecutor() {

                public void execute(String sql) {
                    pruneList.add(sql);
                }
            });
            if (!pruneList.isEmpty()) {
                ui.pruneSchema(e, pruneList);
            }
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateProjectImpl.Factory.class);
    bind(RetrieveParentCandidates.class).to(RetrieveParentCandidatesImpl.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(VisibleProjectDetails.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#end_block

#method_before
@Override
public ProjectList call() {
    final ProjectList result = new ProjectList();
    result.setProjects(getProjects());
    result.setCanCreateProject(user.getCapabilities().canCreateProject());
    return result;
}
#method_after
@Override
public ProjectList call() {
    ProjectList result = new ProjectList();
    result.setProjects(getProjects());
    result.setCanCreateProject(user.getCapabilities().canCreateProject());
    return result;
}
#end_block

#method_before
private List<Project> getProjects() {
    final List<Project> projects = new ArrayList<Project>();
    for (Project.NameKey p : projectCache.all()) {
        try {
            ProjectControl c = projectControlFactory.controlFor(p);
            if (c.isVisible() || c.isOwner()) {
                projects.add(c.getProject());
            }
        } catch (NoSuchProjectException e) {
            continue;
        }
    }
    Collections.sort(projects, new Comparator<Project>() {

        public int compare(final Project a, final Project b) {
            return a.getName().compareTo(b.getName());
        }
    });
    return projects;
}
#method_after
private List<Project> getProjects() {
    List<Project> result = new ArrayList<Project>();
    for (Project.NameKey p : projectCache.all()) {
        try {
            ProjectControl c = projectControlFactory.controlFor(p);
            if (c.isVisible() || c.isOwner()) {
                result.add(c.getProject());
            }
        } catch (NoSuchProjectException e) {
            continue;
        }
    }
    Collections.sort(result, new Comparator<Project>() {

        public int compare(final Project a, final Project b) {
            return a.getName().compareTo(b.getName());
        }
    });
    return result;
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchProjectException, ProjectCreationFailedException {
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(projectName);
    if (!parentName.equals("")) {
        final Project.NameKey nameKey = new Project.NameKey(parentName);
        args.setNewParent(projectControlFactory.validateFor(nameKey));
    }
    args.setProjectDescription("");
    args.setSubmitType(SubmitType.MERGE_IF_NECESSARY);
    args.setBranch(Constants.MASTER);
    args.setCreateEmptyCommit(emptyCommit);
    args.setPermissionsOnly(permissionsOnly);
    final CreateProject createProject = createProjectFactory.create(args);
    createProject.createProject();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws ProjectCreationFailedException {
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(projectName);
    if (!parentName.equals("")) {
        final Project.NameKey nameKey = new Project.NameKey(parentName);
        try {
            args.newParent = projectControlFactory.validateFor(nameKey);
        } catch (NoSuchProjectException e) {
            throw new ProjectCreationFailedException("Parent project \"" + parentName + "\" does not exist.", e);
        }
    }
    args.projectDescription = "";
    args.submitType = SubmitType.MERGE_IF_NECESSARY;
    args.branch = Constants.MASTER;
    args.createEmptyCommit = emptyCommit;
    args.permissionsOnly = permissionsOnly;
    final CreateProject createProject = createProjectFactory.create(args);
    createProject.createProject();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
public boolean isDraft() {
    return isDraft;
}
#method_after
public boolean isDraft() {
    return draft;
}
#end_block

#method_before
public void setDraft(boolean draftStatus) {
    isDraft = draftStatus;
}
#method_after
public void setDraft(boolean draftStatus) {
    draft = draftStatus;
}
#end_block

#method_before
public static void revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps);
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
private static void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#method_after
private static <T extends ReplyToChangeSender> void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory<T> senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    publishDrafts();
    final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
    if (isCurrent && change.getStatus().isOpen()) {
        publishApprovals(ctl);
    } else if (!approvals.isEmpty()) {
        throw new InvalidChangeOperationException("Change is closed");
    } else {
        publishMessageOnly();
    }
    touchChange();
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    db.changes().beginTransaction(changeId);
    try {
        publishDrafts();
        final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
        if (isCurrent && change.getStatus().isOpen()) {
            publishApprovals(ctl);
        } else if (approvals.isEmpty() || forceMessage) {
            publishMessageOnly();
        } else {
            throw new InvalidChangeOperationException("Change is closed");
        }
        touchChange();
        db.commit();
    } finally {
        db.rollback();
    }
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draft(patchSetId, user.getAccountId()).toList();
}
#method_after
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draftByPatchSetAuthor(patchSetId, user.getAccountId()).toList();
}
#end_block

#method_before
private void email() {
    try {
        final CommentSender cm = commentSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setPatchSet(patchSet, patchSetInfoFactory.get(patchSetId));
        cm.setChangeMessage(message);
        cm.setPatchLineComments(drafts);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        change.setStatus(Change.Status.NEW);
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a (magic branch)/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    result = checkMagicBranchRef(NEW_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_PUBLISH_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!isMagicBranch(c)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (isMagicBranch(cmd)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = getDestBranchName(cmd);
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        change.setStatus(Change.Status.NEW);
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (isMagicBranch(cmd) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (!ps.isDraft() || control.isDraftVisible(db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (!ps.isDraft() || control.isDraftVisible(db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#method_after
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (control.isPatchVisible(ps, db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#method_after
private boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
public static String toLongString(final Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case NEW:
            return C.statusLongNew();
        case SUBMITTED:
            return C.statusLongSubmitted();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        case DRAFT:
            return C.statusLongDraft();
        default:
            return status.name();
    }
}
#method_after
public static String toLongString(final Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case DRAFT:
            return C.statusLongDraft();
        case NEW:
            return C.statusLongNew();
        case SUBMITTED:
            return C.statusLongSubmitted();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        default:
            return status.name();
    }
}
#end_block

#method_before
public static void revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static void publishDraftPatchSet(final ReviewDb db, final PatchSet.Id patchSetId) throws OrmException, NoSuchChangeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    final PatchSet updatedPatchSet = db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

        @Override
        public PatchSet update(PatchSet patchset) {
            if (patchset.isDraft()) {
                patchset.setDraft(false);
            }
            return null;
        }
    });
    final Change change = db.changes().get(changeId);
    if (change.getStatus() == Change.Status.DRAFT) {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
    }
}
#method_after
public static void publishDraftPatchSet(final ReviewDb db, final PatchSet.Id patchSetId) throws OrmException, NoSuchChangeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

        @Override
        public PatchSet update(PatchSet patchset) {
            if (patchset.isDraft()) {
                patchset.setDraft(false);
            }
            return null;
        }
    });
    final Change change = db.changes().get(changeId);
    if (change.getStatus() == Change.Status.DRAFT) {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
    }
}
#end_block

#method_before
public static void deleteDraftChange(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change change = db.changes().get(changeId);
    if (change == null || change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps.getId(), gitManager, replication, db);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.trackingIds().delete(db.trackingIds().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
}
#method_after
public static void deleteDraftChange(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    if (change == null || change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps, change, gitManager, replication, db);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.trackingIds().delete(db.trackingIds().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
}
#end_block

#method_before
public static void deleteDraftPatchSet(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final PatchSetInfoFactory patchSetInfoFactory, final ReviewDb db) throws NoSuchChangeException, OrmException, PatchSetInfoNotAvailableException, IOException {
    deleteOnlyDraftPatchSet(patchSetId, gitManager, replication, db);
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    List<PatchSet> restOfPatches = db.patchSets().byChange(changeId).toList();
    if (restOfPatches.size() == 0) {
        deleteDraftChange(patchSetId, gitManager, replication, db);
    } else {
        PatchSet.Id highestId = null;
        for (PatchSet ps : restOfPatches) {
            if (highestId == null || ps.getPatchSetId() > highestId.get()) {
                highestId = ps.getId();
            }
        }
        if (change.currentPatchSetId().equals(patchSetId)) {
            change.lastPatchSetId();
            change.setCurrentPatchSet(patchSetInfoFactory.get(change.currPatchSetId()));
            db.changes().update(Collections.singleton(change));
        }
    }
}
#method_after
public static void deleteDraftPatchSet(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final PatchSetInfoFactory patchSetInfoFactory, final ReviewDb db) throws NoSuchChangeException, OrmException, PatchSetInfoNotAvailableException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    deleteOnlyDraftPatchSet(patch, change, gitManager, replication, db);
    List<PatchSet> restOfPatches = db.patchSets().byChange(changeId).toList();
    if (restOfPatches.size() == 0) {
        deleteDraftChange(patchSetId, gitManager, replication, db);
    } else {
        PatchSet.Id highestId = null;
        for (PatchSet ps : restOfPatches) {
            if (highestId == null || ps.getPatchSetId() > highestId.get()) {
                highestId = ps.getId();
            }
        }
        if (change.currentPatchSetId().equals(patchSetId)) {
            change.removeLastPatchSetId();
            change.setCurrentPatchSet(patchSetInfoFactory.get(db, change.currPatchSetId()));
            db.changes().update(Collections.singleton(change));
        }
    }
}
#end_block

#method_before
private static void deleteOnlyDraftPatchSet(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RefUpdate update = repo.updateRef(patch.getRefName());
        update.setForceUpdate(true);
        Result result = update.delete();
        if (result != Result.NEW && result != Result.FAST_FORWARD && result != Result.FORCED && result != Result.NO_CHANGE) {
            throw new IOException("Failed to delete ref " + patch.getRefName() + " in " + repo.getDirectory() + ": " + update.getResult());
        }
        replication.scheduleUpdate(change.getProject(), update.getName());
    } finally {
        repo.close();
    }
    db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(patchSetId));
    db.changeMessages().delete(db.changeMessages().byPatchSet(patchSetId));
    db.patchComments().delete(db.patchComments().byPatchSet(patchSetId));
    db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(patchSetId));
    db.patchSetAncestors().delete(db.patchSetAncestors().byPatchSet(patchSetId));
    db.patchSets().delete(Collections.singleton(patch));
}
#method_after
private static void deleteOnlyDraftPatchSet(final PatchSet patch, final Change change, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final PatchSet.Id patchSetId = patch.getId();
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(patchSetId.getParentKey());
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RefUpdate update = repo.updateRef(patch.getRefName());
        update.setForceUpdate(true);
        update.disableRefLog();
        switch(update.delete()) {
            case NEW:
            case FAST_FORWARD:
            case FORCED:
            case NO_CHANGE:
                // Successful deletion.
                break;
            default:
                throw new IOException("Failed to delete ref " + patch.getRefName() + " in " + repo.getDirectory() + ": " + update.getResult());
        }
        replication.scheduleUpdate(change.getProject(), update.getName());
    } finally {
        repo.close();
    }
    db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(patchSetId));
    db.changeMessages().delete(db.changeMessages().byPatchSet(patchSetId));
    db.patchComments().delete(db.patchComments().byPatchSet(patchSetId));
    db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(patchSetId));
    db.patchSetAncestors().delete(db.patchSetAncestors().byPatchSet(patchSetId));
    db.patchSets().delete(Collections.singleton(patch));
}
#end_block

#method_before
private static void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#method_after
private static <T extends ReplyToChangeSender> void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory<T> senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.isOwner() || !control.isVisible(db)) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.deleteDraftChange(patchSetId, gitManager, replication, db);
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.isOwner()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.deleteDraftChange(patchSetId, gitManager, replication, db);
    return VoidResult.INSTANCE;
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner() && control.isVisible(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
            if (detail.getPatchSet().isDraft()) {
                populatePublishAction();
            }
            if (canDeletePatchSet(detail)) {
                populateDeleteDraftPatchSetAction();
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                populatePublishAction();
            }
            if (canDeletePatchSet(detail)) {
                populateDeleteDraftPatchSetAction();
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#end_block

#method_before
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            try {
                final ChangeControl cc = changeControlFactory.validateFor(psid.getParentKey());
                if (!cc.isOwner() || !cc.isVisible(db)) {
                    throw new Failure(new NoSuchEntityException());
                }
                ChangeUtil.deleteDraftPatchSet(psid, gitManager, replication, patchSetInfoFactory, db);
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(psid.getParentKey()));
            } catch (PatchSetInfoNotAvailableException e) {
                throw new Failure(e);
            } catch (IOException e) {
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            try {
                final ChangeControl cc = changeControlFactory.validateFor(psid.getParentKey());
                if (!cc.isOwner()) {
                    throw new Failure(new NoSuchEntityException());
                }
                ChangeUtil.deleteDraftPatchSet(psid, gitManager, replication, patchSetInfoFactory, db);
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(psid.getParentKey()));
            } catch (PatchSetInfoNotAvailableException e) {
                throw new Failure(e);
            } catch (IOException e) {
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void publishComments(final PatchSet.Id psid, final String msg, final Set<ApprovalCategoryValue.Id> tags, final AsyncCallback<VoidResult> cb) {
    Handler.wrap(publishCommentsFactory.create(psid, msg, tags)).to(cb);
}
#method_after
public void publishComments(final PatchSet.Id psid, final String msg, final Set<ApprovalCategoryValue.Id> tags, final AsyncCallback<VoidResult> cb) {
    Handler.wrap(publishCommentsFactory.create(psid, msg, tags, false)).to(cb);
}
#end_block

#method_before
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            AccountPatchReview apr = db.accountPatchReviews().get(key);
            if (apr == null && reviewed) {
                db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
            } else if (apr != null && !reviewed) {
                db.accountPatchReviews().delete(Collections.singleton(apr));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            db.accounts().beginTransaction(account);
            try {
                AccountPatchReview apr = db.accountPatchReviews().get(key);
                if (apr == null && reviewed) {
                    db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
                } else if (apr != null && !reviewed) {
                    db.accountPatchReviews().delete(Collections.singleton(apr));
                }
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a (magic branch)/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    result = checkMagicBranchRef(NEW_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_PUBLISH_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!isMagicBranch(c)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (isMagicBranch(cmd)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = getDestBranchName(cmd);
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    if (isDraft(newChange)) {
        change.setStatus(Change.Status.DRAFT);
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    if (isDraft(request.cmd)) {
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    msg.setPatchSetId(ps.getId());
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        change.setStatus(Change.Status.DRAFT);
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (isMagicBranch(cmd) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    msg.setPatchSetId(result.info.getKey());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isOwner() && !isReviewer(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    if (change.getStatus() == Change.Status.DRAFT) {
        return ruleError("Cannot submit draft changes");
    }
    try {
        if (isDraftPatchSet(patchSetId, db)) {
            return ruleError("Cannot submit draft patch sets");
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (isDraftPatchSet(patchSetId, db)) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        return false;
    }
    return ps.isDraft();
}
#method_after
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        throw new OrmException("Patch set " + id + " not found");
    }
    return ps.isDraft();
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
        reject(cmd, "For non-fast forward updates, 'Force Push' privilege is needed");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            saveType.setVisible(result.canModify);
            delInclude.setVisible(result.canModify);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#method_after
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewMember();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#end_block

#method_before
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#method_after
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (value.isLabel()) {
                newRule.setRange(0, 1);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#method_after
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (rangeType != null) {
                int min = rangeType.getMin().getValue();
                int max = rangeType.getMax().getValue();
                newRule.setRange(min, max);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value != null && Permission.OWNER.equals(value.getName())) {
        inherit.setEnabled(false);
    } else {
        inherit.setEnabled(!readOnly);
    }
}
#method_after
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value.isLabel()) {
        rangeType = Gerrit.getConfig().getApprovalTypes().byLabel(value.getLabel());
    } else {
        rangeType = null;
    }
    if (value != null && Permission.OWNER.equals(value.getName())) {
        exclusiveGroup.setEnabled(false);
    } else {
        exclusiveGroup.setEnabled(!readOnly);
    }
}
#end_block

#method_before
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value, rangeType);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    local.getEditors().get(index).editRefPattern();
}
#method_after
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    AccessSectionEditor editor = local.getEditors().get(index);
    editor.enableEditing();
    editor.editRefPattern();
}
#end_block

#method_before
@Override
public void render(Action object, Appendable appendable) throws IOException {
    appendable.append(render(object));
}
#method_after
@Override
public String render(PermissionRule.Action object) {
    return object != null ? object.toString() : "";
}
#end_block

#method_before
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#method_after
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    if (suggestAccounts == SuggestAccountsEnum.OFF) {
        callback.onSuccess(Collections.<AccountInfo>emptyList());
        return;
    }
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#end_block

#method_before
private void addSuggestion(Map map, Account account, AccountInfo info, Boolean active) {
    if (active == null || active == account.isActive()) {
        map.put(account.getId(), info);
    }
}
#method_after
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, Boolean active) {
    if (map.containsKey(account.getId())) {
        return;
    }
    if (active != null && active != account.isActive()) {
        return;
    }
    switch(suggestAccounts) {
        case ALL:
            map.put(account.getId(), info);
            break;
        case SAME_GROUP:
            {
                Set<AccountGroup.UUID> usersGroups = groupsOf(account);
                usersGroups.remove(AccountGroup.ANONYMOUS_USERS);
                usersGroups.remove(AccountGroup.REGISTERED_USERS);
                usersGroups.remove(authConfig.getBatchUsersGroup());
                for (AccountGroup.UUID myGroup : currentUser.get().getEffectiveGroups()) {
                    if (usersGroups.contains(myGroup)) {
                        map.put(account.getId(), info);
                        break;
                    }
                }
                break;
            }
        case OFF:
            break;
        default:
            throw new IllegalStateException("Bad SuggestAccounts " + suggestAccounts);
    }
}
#end_block

#method_before
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName c : db.accountGroupNames().suggestByName(a, b, n)) {
                AccountGroup g = groupCache.get(c.getId());
                if (g != null && g.getGroupUUID() != null) {
                    r.add(GroupReference.forGroup(g));
                }
            }
            return r;
        }
    });
}
#method_after
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            Set<AccountGroup.UUID> memberOf = currentUser.get().getEffectiveGroups();
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName group : db.accountGroupNames().suggestByName(a, b, n)) {
                try {
                    if (memberOf.contains(group.getId()) || groupControlFactory.controlFor(group.getId()).isVisible()) {
                        AccountGroup g = groupCache.get(group.getId());
                        if (g != null && g.getGroupUUID() != null) {
                            r.add(GroupReference.forGroup(g));
                        }
                    }
                } catch (NoSuchGroupException e) {
                    continue;
                }
            }
            return r;
        }
    });
}
#end_block

#method_before
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#method_after
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final String q = "patchset=";
        final String[] t = s.split(",", 2);
        if (t.length > 1 && t[1].startsWith(q)) {
            return new ChangeScreen(PatchSet.Id.parse(t[0] + "," + skip(q, t[1])));
        }
        return new ChangeScreen(Change.Id.parse(t[0]));
    }
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#end_block

#method_before
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAdd(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAddMember(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemove(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemoveMember(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void setAction(Action action) {
    switch(action) {
        case ALLOW:
            setDeny(false);
            break;
        case DENY:
            setDeny(true);
            break;
        default:
            throw new IllegalArgumentException();
    }
}
#method_after
public void setAction(Action action) {
    if (action == null) {
        throw new NullPointerException("action");
    }
    setDeny(action == Action.DENY);
}
#end_block

#method_before
public int getMin() {
    return min;
}
#method_after
public Integer getMin() {
    return min;
}
#end_block

#method_before
public int getMax() {
    return max;
}
#method_after
public Integer getMax() {
    return max;
}
#end_block

#method_before
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#method_after
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = range(o) - range(this);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#end_block

#method_before
public String asString(boolean useRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (useRange) {
        if (getMin() == 0 && getMax() == 1) {
        } else if (getMin() == 1 && getMax() == 1) {
        } else if (getMin() < 0 && getMax() == 0) {
            r.append(getMin());
            r.append(' ');
        } else {
            if (getMin() != getMax()) {
                if (0 <= getMin())
                    r.append('+');
                r.append(getMin());
                r.append("..");
            }
            if (0 <= getMax())
                r.append('+');
            r.append(getMax());
            r.append(' ');
        }
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#method_after
public String asString(boolean canUseRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (canUseRange && (getMin() != 0 || getMax() != 0)) {
        if (0 <= getMin())
            r.append('+');
        r.append(getMin());
        r.append("..");
        if (0 <= getMax())
            r.append('+');
        r.append(getMax());
        r.append(' ');
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#end_block

#method_before
public static PermissionRule fromString(String src, boolean useRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (useRange) {
        if (src.startsWith("group ")) {
            rule.setRange(0, 1);
        } else {
            int sp = src.indexOf(' ');
            String range = src.substring(0, sp);
            if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
                int dotdot = range.indexOf("..");
                int min = parseInt(range.substring(0, dotdot));
                int max = parseInt(range.substring(dotdot + 2));
                rule.setRange(min, max);
            } else if (range.matches("^([+-]\\d)$")) {
                int v = parseInt(range);
                rule.setRange(v, v);
            } else {
                throw new IllegalArgumentException("Invalid range in rule: " + orig);
            }
            src = src.substring(sp + 1).trim();
        }
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#method_after
public static PermissionRule fromString(String src, boolean mightUseRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (mightUseRange && !src.startsWith("group ")) {
        int sp = src.indexOf(' ');
        String range = src.substring(0, sp);
        if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
            int dotdot = range.indexOf("..");
            int min = parseInt(range.substring(0, dotdot));
            int max = parseInt(range.substring(dotdot + 2));
            rule.setRange(min, max);
        } else {
            throw new IllegalArgumentException("Invalid range in rule: " + orig);
        }
        src = src.substring(sp + 1).trim();
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_DO_NOT_INHERIT)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setInherit(false);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (!perm.getInherit()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_DO_NOT_INHERIT, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_DO_NOT_INHERIT);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        rebuildPermissionSelector();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addDotDotDot());
        permissionSelector.setValue(Util.C.addDotDotDot());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            URIish adminURI = null;
            try {
                if (url != null && !url.isEmpty()) {
                    adminURI = new URIish(url);
                }
            } catch (URISyntaxException e) {
                log.error("The URL '" + url + "' is invalid");
            }
            if (adminURI != null) {
                final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
                if (replacedPath != null) {
                    adminURI = adminURI.setPath(replacedPath);
                    if (usingSSH(adminURI)) {
                        replicateProject(projectName, adminURI, head);
                        adminURLUsed = true;
                    } else {
                        log.error("The adminURL '" + url + "' is non-SSH which is not allowed");
                    }
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(projectName, uri, head);
            }
        }
    }
}
#method_after
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            URIish adminURI = null;
            try {
                if (url != null && !url.isEmpty()) {
                    adminURI = new URIish(url);
                }
            } catch (URISyntaxException e) {
                log.error("The URL '" + url + "' is invalid");
            }
            if (adminURI != null) {
                final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
                if (replacedPath != null) {
                    adminURI = adminURI.setPath(replacedPath);
                    if (usingSSH(adminURI)) {
                        replicateProject(adminURI, head);
                        adminURLUsed = true;
                    } else {
                        log.error("The adminURL '" + url + "' is non-SSH which is not allowed");
                    }
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(uri, head);
            }
        }
    }
}
#end_block

#method_before
private void replicateProject(final Project.NameKey projectName, final URIish replicateURI, final String head) {
    if (!replicateURI.isRemote()) {
        replicateProjectLocally(projectName, replicateURI, head);
    } else if (usingSSH(replicateURI)) {
        replicateProjectOverSsh(replicateURI, head);
    } else {
        log.warn("Cannot create new project on remote site since neither the " + "connection method is SSH nor the replication target is local: " + replicateURI.toString());
        return;
    }
}
#method_after
private void replicateProject(final URIish replicateURI, final String head) {
    if (!replicateURI.isRemote()) {
        replicateProjectLocally(replicateURI, head);
    } else if (usingSSH(replicateURI)) {
        replicateProjectOverSsh(replicateURI, head);
    } else {
        log.warn("Cannot create new project on remote site since neither the " + "connection method is SSH nor the replication target is local: " + replicateURI.toString());
        return;
    }
}
#end_block

#method_before
private void replicateProjectLocally(final Project.NameKey projectName, final URIish replicateURI, final String head) {
    Repository repo = null;
    try {
        repo = gitRepositoryManager.openRepository(projectName);
        FileUtils.copyDirectory(repo.getDirectory(), new File(replicateURI.getPath()));
    } catch (RepositoryNotFoundException e) {
        log.error("Failed to replicate project locally: " + replicateURI.toString());
    } catch (IOException e) {
        log.error("Failed to replicate project locally: " + replicateURI.toString());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
private void replicateProjectLocally(final URIish replicateURI, final String head) {
    try {
        final Repository repo = new FileRepository(replicateURI.getPath());
        try {
            repo.create(true);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        log.error("Failed to replicate project locally: " + replicateURI.getPath());
    }
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    publishDrafts();
    final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
    if (isCurrent && change.getStatus().isOpen()) {
        publishApprovals(ctl);
    } else if (!approvals.isEmpty() && !alwaysPublishMessage) {
        throw new InvalidChangeOperationException("Change is closed");
    } else {
        publishMessageOnly();
    }
    touchChange();
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    db.changes().beginTransaction(changeId);
    try {
        publishDrafts();
        final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
        if (isCurrent && change.getStatus().isOpen()) {
            publishApprovals(ctl);
        } else if (approvals.isEmpty() || forceMessage) {
            publishMessageOnly();
        } else {
            throw new InvalidChangeOperationException("Change is closed");
        }
        touchChange();
        db.commit();
    } finally {
        db.rollback();
    }
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draft(patchSetId, user.getAccountId()).toList();
}
#method_after
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draftByPatchSetAuthor(patchSetId, user.getAccountId()).toList();
}
#end_block

#method_before
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, alwaysPublishMsg).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
}
#end_block

#method_before
public void deleteDraft(final PatchLineComment.Key commentKey, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final PatchLineComment comment = db.patchComments().get(commentKey);
            if (comment == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!getAccountId().equals(comment.getAuthor())) {
                throw new Failure(new NoSuchEntityException());
            }
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            db.patchComments().delete(Collections.singleton(comment));
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraft(final PatchLineComment.Key commentKey, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            Change.Id id = commentKey.getParentKey().getParentKey().getParentKey();
            db.changes().beginTransaction(id);
            try {
                final PatchLineComment comment = db.patchComments().get(commentKey);
                if (comment == null) {
                    throw new Failure(new NoSuchEntityException());
                }
                if (!getAccountId().equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                    throw new Failure(new IllegalStateException("Comment published"));
                }
                db.patchComments().delete(Collections.singleton(comment));
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            AccountPatchReview apr = db.accountPatchReviews().get(key);
            if (apr == null && reviewed) {
                db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
            } else if (apr != null && !reviewed) {
                db.accountPatchReviews().delete(Collections.singleton(apr));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            db.accounts().beginTransaction(account);
            try {
                AccountPatchReview apr = db.accountPatchReviews().get(key);
                if (apr == null && reviewed) {
                    db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
                } else if (apr != null && !reviewed) {
                    db.accountPatchReviews().delete(Collections.singleton(apr));
                }
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public GroupList get() throws OrmException, NoSuchGroupException {
    final Iterable<AccountGroup> groups;
    if (projects != null && !projects.isEmpty()) {
        groups = getGroupsForProjects();
    } else if (user != null) {
        groups = getGroupsForUser();
    } else {
        groups = groupCache.all();
    }
    return createGroupList(filterGroups(groups));
}
#method_after
public GroupList get() throws OrmException, NoSuchGroupException {
    final Iterable<AccountGroup> groups = groupCache.all();
    return createGroupList(filterGroups(groups));
}
#end_block

#method_before
public GroupList get() throws OrmException, NoSuchGroupException {
    final Iterable<AccountGroup> groups;
    if (projects != null && !projects.isEmpty()) {
        groups = getGroupsForProjects();
    } else if (user != null) {
        groups = getGroupsForUser();
    } else {
        groups = groupCache.all();
    }
    return createGroupList(filterGroups(groups));
}
#method_after
public GroupList get(final Collection<ProjectControl> projects) throws OrmException, NoSuchGroupException {
    final Set<AccountGroup> groups = new TreeSet<AccountGroup>(new GroupComparator());
    for (final ProjectControl projectControl : projects) {
        final Set<GroupReference> groupsRefs = projectControl.getAllGroups();
        for (final GroupReference groupRef : groupsRefs) {
            final AccountGroup group = groupCache.get(groupRef.getUUID());
            if (group == null) {
                throw new NoSuchGroupException(groupRef.getUUID());
            }
            groups.add(group);
        }
    }
    return createGroupList(filterGroups(groups));
}
#end_block

#method_before
@Override
public List<GroupDetail> call() throws OrmException, NoSuchGroupException {
    final VisibleGroups visibleGroups = visibleGroupsFactory.create();
    visibleGroups.setUser(user);
    return visibleGroups.get().getGroups();
}
#method_after
@Override
public List<GroupDetail> call() throws OrmException, NoSuchGroupException {
    final VisibleGroups visibleGroups = visibleGroupsFactory.create();
    return visibleGroups.get(user).getGroups();
}
#end_block

#method_before
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    try {
        if (user != null && !projects.isEmpty()) {
            throw new UnloggedFailure(1, "fatal: --user and --project options are not compatible.");
        }
        final VisibleGroups visibleGroups = visibleGroupsFactory.create();
        visibleGroups.setProjects(projects);
        if (user != null) {
            visibleGroups.setUser(userFactory.create(user));
        }
        visibleGroups.setOnlyVisibleToAll(visibleToAll);
        visibleGroups.setGroupType(groupType);
        final GroupList groupList = visibleGroups.get();
        for (final GroupDetail groupDetail : groupList.getGroups()) {
            stdout.print(groupDetail.group.getName() + "\n");
        }
    } catch (OrmException e) {
        throw die(e);
    } catch (NoSuchGroupException e) {
        throw die(e);
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    try {
        if (user != null && !projects.isEmpty()) {
            throw new UnloggedFailure(1, "fatal: --user and --project options are not compatible.");
        }
        final VisibleGroups visibleGroups = visibleGroupsFactory.create();
        visibleGroups.setOnlyVisibleToAll(visibleToAll);
        visibleGroups.setGroupType(groupType);
        final GroupList groupList;
        if (!projects.isEmpty()) {
            groupList = visibleGroups.get(projects);
        } else if (user != null) {
            groupList = visibleGroups.get(userFactory.create(user));
        } else {
            groupList = visibleGroups.get();
        }
        for (final GroupDetail groupDetail : groupList.getGroups()) {
            stdout.print(groupDetail.group.getName() + "\n");
        }
    } catch (OrmException e) {
        throw die(e);
    } catch (NoSuchGroupException e) {
        throw die(e);
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encode(project.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", encode(project.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", encode(branch.getParentKey().get()));
    p.put("branch", encode(branch.get()));
    p.put("file", encode(file));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
}
#method_after
private String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
}
#end_block

#method_before
public String replacePathSeparator(String newSeparator) {
    if ('/' != pathSeparator) {
        return newSeparator.replace('/', pathSeparator);
    }
    return newSeparator;
}
#method_after
public String replacePathSeparator(String urlSegment) {
    if ('/' != pathSeparator) {
        return urlSegment.replace('/', pathSeparator);
    }
    return urlSegment;
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) {
    if (commitMessage == null) {
        try {
            PatchSet.Id psId = change.currentPatchSetId();
            String sha1 = db.get().patchSets().get(psId).getRevision().get();
            Project.NameKey name = change.getProject();
            Repository repo = repoManager.openRepository(name);
            RevWalk walk = new RevWalk(repo);
            RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
            commitMessage = c.getFullMessage();
            walk.release();
        } catch (RepositoryNotFoundException e) {
        } catch (IOException e) {
        } catch (OrmException e) {
        }
    }
    return commitMessage;
}
#method_after
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) throws IOException, OrmException {
    if (commitMessage == null) {
        PatchSet.Id psId = change(db).currentPatchSetId();
        String sha1 = db.get().patchSets().get(psId).getRevision().get();
        Project.NameKey name = change.getProject();
        Repository repo = repoManager.openRepository(name);
        try {
            RevWalk walk = new RevWalk(repo);
            try {
                RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
                commitMessage = c.getFullMessage();
            } finally {
                walk.release();
            }
        } finally {
            repo.close();
        }
    }
    return commitMessage;
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null);
}
#method_after
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    addPatchSets(ca, ps, approvals, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, boolean includeFiles, Change change) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
            if (includeFiles && change != null) {
                addPatchSetFileNames(psa, change, p);
            }
        }
    }
}
#end_block

#method_before
public boolean isVisible() {
    if (isOwner()) {
        return true;
    } else {
        return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && !isHidden();
    }
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && isActive();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && isActive();
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && isActive();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!isActive()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().isOwner() || control.getRefControl().isActive());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public boolean isVisible() {
    return visibleForReplication() || canPerformOnAnyRef(Permission.READ) && !isHidden();
}
#method_after
public boolean isVisible() {
    return (visibleForReplication() || canPerformOnAnyRef(Permission.READ)) && !isHidden();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, STATE, null, KEY_VALUE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, STATE, null, KEY_VALUE, p.getState(), defaultStateValue);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (isEditable()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
public void setParentName(String n) {
    parent = n != null ? new NameKey(n) : null;
}
#method_after
public void setParentName(NameKey n) {
    parent = n;
}
#end_block

#method_before
private void setState(final Project.State newState) {
    int index = -1;
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                index = i;
                break;
            }
        }
        state.setSelectedIndex(index);
    }
}
#method_after
private void setState(final Project.State newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
public void setCanModifyState(final boolean cmmt) {
    canModifyState = cmmt;
}
#method_after
public void setCanModifyState(final boolean cms) {
    canModifyState = cms;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            parseCommandLine();
            updateParents();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                updateParents();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as arguments or the --old-parent option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together with --old-parent");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    Project.NameKey newParentKey;
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    } else {
        // If no parent was selected, set to NULL to use the default.
        // 
        newParentKey = null;
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        final List<Project.NameKey> excluded = new ArrayList<Project.NameKey>(excludedChildren.size() + 1);
        if (newParentKey != null) {
            excluded.add(newParentKey);
        }
        for (final ProjectControl excludedChild : excludedChildren) {
            excluded.add(excludedChild.getProject().getNameKey());
        }
        final ProjectNode oldParentProject = createProjectHierarchyFactory.create().getProjectHierarchy(oldParent.getProject().getNameKey());
        for (final ProjectNode childProject : oldParentProject.getChildren()) {
            if (!excluded.contains(childProject.getProject().getNameKey())) {
                childProjects.add(childProject.getProject());
            }
        }
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#method_after
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as " + "arguments or the --children-of option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together " + "with --children-of");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        childProjects.addAll(getChildrenForReparenting(oldParent));
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#end_block

#method_before
private void onLogin() {
    hideError();
    final String user = username.getText();
    if (user == null || user.equals("")) {
        showError(Util.C.usernameRequired());
        username.setFocus(true);
        return;
    }
    final String pass = password.getText();
    if (pass == null || pass.equals("")) {
        showError(Util.C.passwordRequired());
        password.setFocus(true);
        return;
    }
    enable(false);
    Util.SVC.authenticate(user, pass, new GerritCallback<LoginResult>() {

        public void onSuccess(final LoginResult result) {
            if (result.success) {
                String to = token;
                if (!to.startsWith("/")) {
                    to = "/" + to;
                }
                if (result.isNew && !token.startsWith(PageLinks.REGISTER + "/")) {
                    to = PageLinks.REGISTER + to;
                }
                Location.replace(Location.getPath() + "login" + to);
            } else {
                final String message;
                switch(result.getError()) {
                    case LDAP_SERVER_UNAVAILABLE:
                        message = Util.C.ldapServerUnavailable();
                        break;
                    case INVALID_LOGIN:
                    default:
                        message = Util.C.invalidLogin();
                }
                showError(message);
                enable(true);
                password.selectAll();
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        password.setFocus(true);
                    }
                });
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            super.onFailure(caught);
            enable(true);
        }
    });
}
#method_after
private void onLogin() {
    hideError();
    final String user = username.getText();
    if (user == null || user.equals("")) {
        showError(Util.C.usernameRequired());
        username.setFocus(true);
        return;
    }
    final String pass = password.getText();
    if (pass == null || pass.equals("")) {
        showError(Util.C.passwordRequired());
        password.setFocus(true);
        return;
    }
    enable(false);
    Util.SVC.authenticate(user, pass, new GerritCallback<LoginResult>() {

        public void onSuccess(final LoginResult result) {
            if (result.success) {
                String to = token;
                if (!to.startsWith("/")) {
                    to = "/" + to;
                }
                if (result.isNew && !token.startsWith(PageLinks.REGISTER + "/")) {
                    to = PageLinks.REGISTER + to;
                }
                Location.replace(Location.getPath() + "login" + to);
            } else {
                final String message;
                switch(result.getError()) {
                    case AUTHENTICATION_UNAVAILABLE:
                        message = Util.M.authenticationUnavailable(result.getAuthType());
                        break;
                    case INVALID_LOGIN:
                    default:
                        message = Util.C.invalidLogin();
                }
                showError(message);
                enable(true);
                password.selectAll();
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        password.setFocus(true);
                    }
                });
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            super.onFailure(caught);
            enable(true);
        }
    });
}
#end_block

#method_before
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult();
    if (// 
    username == null || "".equals(username.trim()) || password == null || "".equals(password)) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    username = username.trim();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountUserNameException e) {
        // entered user name and password were correct, but user name could not be
        // set for the newly created account and this is why the login fails,
        // error screen with error message should be shown to the user
        callback.onFailure(e);
        return;
    } catch (LdapQueryException e) {
        result.setError(LoginResult.Error.LDAP_SERVER_UNAVAILABLE);
        callback.onSuccess(result);
        return;
    } catch (AccountException e) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, true);
    callback.onSuccess(result);
}
#method_after
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult(authType);
    if (// 
    username == null || "".equals(username.trim()) || password == null || "".equals(password)) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    username = username.trim();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountUserNameException e) {
        // entered user name and password were correct, but user name could not be
        // set for the newly created account and this is why the login fails,
        // error screen with error message should be shown to the user
        callback.onFailure(e);
        return;
    } catch (AuthenticationUnavailableException e) {
        result.setError(LoginResult.Error.AUTHENTICATION_UNAVAILABLE);
        callback.onSuccess(result);
        return;
    } catch (AccountException e) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, true);
    callback.onSuccess(result);
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, helper.queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new LdapQueryException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, helper.queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private boolean suggestGroupAsReviewer(final Project.NameKey project, final GroupReference group) throws OrmException {
    if (!AddReviewer.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        final PerformGroupMembers groupMembers = groupMembersFactory.create();
        groupMembers.setProject(project);
        final Set<Account> members = groupMembers.listAccounts(group.getUUID());
        if (members.isEmpty()) {
            return false;
        }
        final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", AddReviewer.DEFAULT_MAX_REVIEWERS);
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return true;
}
#method_after
private boolean suggestGroupAsReviewer(final Project.NameKey project, final GroupReference group) throws OrmException {
    if (!AddReviewer.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        final Set<Account> members = groupMembersFactory.create().listAccounts(group.getUUID(), project);
        if (members.isEmpty()) {
            return false;
        }
        final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", AddReviewer.DEFAULT_MAX_REVIEWERS);
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final PerformGroupMembers groupMembers = groupMembersFactory.create();
            groupMembers.setProject(control.getProject().getNameKey());
            final Set<Account> members = groupMembers.listAccounts(group.getGroupUUID());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    if (control.forUser(user).isVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        if (!control.forUser(user).isVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final PatchSet.Id psid = control.getChange().currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    if (control.forUser(user).isVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        if (!control.forUser(user).isVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final PatchSet.Id psid = control.getChange().currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(PerformGroupMembers.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformVisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembersFactory.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembersFactory.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(FlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "ls-groups").to(ListGroups.class);
    command(gerrit, "query").to(Query.class);
    command(gerrit, "show-caches").to(ShowCaches.class);
    command(gerrit, "show-connections").to(ShowConnections.class);
    command(gerrit, "show-queue").to(ShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(gerrit, "version").to(VersionCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(FlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "ls-groups").to(ListGroupsCommand.class);
    command(gerrit, "query").to(Query.class);
    command(gerrit, "show-caches").to(ShowCaches.class);
    command(gerrit, "show-connections").to(ShowConnections.class);
    command(gerrit, "show-queue").to(ShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(gerrit, "version").to(VersionCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#end_block

#method_before
@Override
public GroupList call() throws Exception {
    final IdentifiedUser user = identifiedUser.get();
    final List<AccountGroup> list;
    if (user.getCapabilities().canAdministrateServer()) {
        list = new LinkedList<AccountGroup>();
        for (final AccountGroup group : groupCache.all()) {
            list.add(group);
        }
    } else {
        list = new ArrayList<AccountGroup>();
        for (final AccountGroup group : groupCache.all()) {
            final GroupControl c = groupControlFactory.controlFor(group);
            if (c.isVisible()) {
                list.add(c.getAccountGroup());
            }
        }
    }
    List<GroupDetail> l = new ArrayList<GroupDetail>();
    for (AccountGroup group : list) {
        l.add(groupDetailFactory.create(group.getId()).call());
    }
    GroupList res = new GroupList();
    res.setGroups(l);
    res.setCanCreateGroup(user.getCapabilities().canCreateGroup());
    return res;
}
#method_after
@Override
public GroupList call() throws Exception {
    final IdentifiedUser user = identifiedUser.get();
    final List<AccountGroup> list = new ArrayList<AccountGroup>();
    if (user.getCapabilities().canAdministrateServer()) {
        CollectionUtils.addAll(list, groupCache.all().iterator());
    } else {
        for (final AccountGroup group : groupCache.all()) {
            final GroupControl c = groupControlFactory.controlFor(group);
            if (c.isVisible()) {
                list.add(c.getAccountGroup());
            }
        }
    }
    List<GroupDetail> l = new ArrayList<GroupDetail>();
    for (AccountGroup group : list) {
        l.add(groupDetailFactory.create(group.getId()).call());
    }
    return new GroupList(l, user.getCapabilities().canCreateGroup());
}
#end_block

#method_before
@Override
public Iterable<AccountGroup> all() {
    final List<AccountGroup> groups = new LinkedList<AccountGroup>();
    for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) {
        final AccountGroup group = get(groupName);
        if (group != null) {
            groups.add(group);
        }
    }
    return Collections.unmodifiableList(groups);
}
#method_after
@Override
public Iterable<AccountGroup> all() {
    final List<AccountGroup> groups = new ArrayList<AccountGroup>();
    for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) {
        final AccountGroup group = get(groupName);
        if (group != null) {
            groups.add(group);
        }
    }
    return Collections.unmodifiableList(groups);
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            projectCache.evict(config.getProject());
            userCache.get().evict(projectName);
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            userCache.get().evict(config.getProject());
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public void evict(Project.NameKey nameKey) {
    controls.remove(nameKey);
}
#method_after
public void evict(Project project) {
    projectCache.evict(project);
    controls.remove(project.getNameKey());
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getInheritsFrom(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#end_block

#method_before
public static GitWebType fromName(final String name) {
    final GitWebType type;
    if (name == null || name.isEmpty() || name.equalsIgnoreCase("gitweb")) {
        type = new GitWebType();
        type.setProject("?p=${project}.git;a=summary");
        type.setRevision("?p=${project}.git;a=commit;h=${commit}");
        type.setBranch("?p=${project}.git;a=shortlog;h=${branch}");
        type.setFileHistory("?p=${project}.git;a=history;hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("cgit")) {
        type = new GitWebType();
        type.setProject("${project}/summary");
        type.setRevision("${project}/commit/?id=${commit}");
        type.setBranch("${project}/log/?h=${branch}");
        type.setFileHistory("${project}/history/?hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("custom")) {
        type = new GitWebType();
    } else {
        type = null;
    }
    return type;
}
#method_after
public static GitWebType fromName(final String name) {
    final GitWebType type;
    if (name == null || name.isEmpty() || name.equalsIgnoreCase("gitweb")) {
        type = new GitWebType();
        type.setLinkName("gitweb");
        type.setProject("?p=${project}.git;a=summary");
        type.setRevision("?p=${project}.git;a=commit;h=${commit}");
        type.setBranch("?p=${project}.git;a=shortlog;h=${branch}");
        type.setFileHistory("?p=${project}.git;a=history;hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("cgit")) {
        type = new GitWebType();
        type.setLinkName("cgit");
        type.setProject("${project}/summary");
        type.setRevision("${project}/commit/?id=${commit}");
        type.setBranch("${project}/log/?h=${branch}");
        type.setFileHistory("${project}/log/${file}?h=${branch}");
    } else if (name.equalsIgnoreCase("custom")) {
        type = new GitWebType();
        // The custom name is not defined, let's keep the old style of using GitWeb
        type.setLinkName("gitweb");
    } else if (name.equalsIgnoreCase("disabled")) {
        type = null;
    } else {
        type = null;
    }
    return type;
}
#end_block

#method_before
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParamertizedString pattern = new ParamertizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParameterizedString pattern = new ParameterizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toProject(final Project.NameKey project) {
    ParamertizedString pattern = new ParamertizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toBranch(final Branch.NameKey branch) {
    ParamertizedString pattern = new ParamertizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toBranch(final Branch.NameKey branch) {
    ParameterizedString pattern = new ParameterizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParamertizedString pattern = new ParamertizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        insertRow(row + i);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#method_after
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        insertRow(row + i);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        addStyle(row + i, 1, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        addStyle(row + i, 3, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#end_block

#method_before
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    final TreeMap<String, TreeNode> treeMap = new TreeMap<String, TreeNode>();
    try {
        for (final Project.NameKey projectName : projectCache.all()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || pctl.isOwner();
            if (showTree) {
                treeMap.put(projectName.get(), new TreeNode(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible) {
                // 
                continue;
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (Ref ref : refs) {
                            if (ref == null) {
                                // Print stub (forty '-' symbols)
                                stdout.print("----------------------------------------");
                            } else {
                                stdout.print(ref.getObjectId().name());
                            }
                            stdout.print(' ');
                        }
                    } finally {
                        git.close();
                    }
                } else if (type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            stdout.print(projectName.get() + "\n");
        }
        if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    if (showTree && showDescription) {
        throw new UnloggedFailure(1, "fatal: --tree and --description options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    final TreeMap<String, TreeNode> treeMap = new TreeMap<String, TreeNode>();
    try {
        for (final Project.NameKey projectName : projectCache.all()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
            if (showTree) {
                treeMap.put(projectName.get(), new TreeNode(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible) {
                // 
                continue;
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (Ref ref : refs) {
                            if (ref == null) {
                                // Print stub (forty '-' symbols)
                                stdout.print("----------------------------------------");
                            } else {
                                stdout.print(ref.getObjectId().name());
                            }
                            stdout.print(' ');
                        }
                    } finally {
                        git.close();
                    }
                } else if (type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            stdout.print(projectName.get());
            String desc;
            if (showDescription && !(desc = e.getProject().getDescription()).isEmpty()) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + desc.replace("\n", "\\n"));
            }
            stdout.print("\n");
        }
        if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private List<Ref> getBranchRefs(Project.NameKey projectName, ProjectControl projectControl) {
    Ref[] result = new Ref[showBranch.size()];
    try {
        Repository git = repoManager.openRepository(projectName);
        try {
            for (int i = 0; i < showBranch.size(); i++) {
                Ref ref = git.getRef(showBranch.get(i));
                if (ref != null && ref.getObjectId() != null && projectControl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                    result[i] = ref;
                }
            }
        } finally {
            git.close();
        }
    } catch (IOException ioe) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#method_after
private List<Ref> getBranchRefs(Project.NameKey projectName, ProjectControl projectControl) {
    Ref[] result = new Ref[showBranch.size()];
    try {
        Repository git = repoManager.openRepository(projectName);
        try {
            for (int i = 0; i < showBranch.size(); i++) {
                Ref ref = git.getRef(showBranch.get(i));
                if (ref != null && ref.getObjectId() != null && (projectControl.controlForRef(ref.getLeaf().getName()).isVisible()) || (all && projectControl.isOwner())) {
                    result[i] = ref;
                }
            }
        } finally {
            git.close();
        }
    } catch (IOException ioe) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/query").with(ChangeQueryServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    filter("/p/*").through(ProjectAccessPathFilter.class);
    if (authConfig.isTrustContainerAuth())
        filter("/p/*").through(ContainerAuthFilter.class);
    else
        filter("/p/*").through(ProjectDigestFilter.class);
    serve("/p/*").with(ProjectServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/query").with(ChangeQueryServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    filter("/p/*").through(ProjectAccessPathFilter.class);
    if (authConfig.isTrustContainerAuth()) {
        filter("/p/*").through(ContainerAuthFilter.class);
    } else {
        filter("/p/*").through(ProjectDigestFilter.class);
    }
    serve("/p/*").with(ProjectServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, HttpServletResponseWrapper rsp) throws IOException {
    if (!authConfig.isTrustContainerAuth())
        return true;
    final String username = req.getRemoteUser();
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    session.get().setUserAccountId(who.getAccount().getId());
    return true;
}
#method_after
private boolean verify(HttpServletRequest req, HttpServletResponseWrapper rsp) throws IOException {
    final String username = req.getRemoteUser();
    final AccountState who = (username == null) ? null : accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    session.get().setUserAccountId(who.getAccount().getId());
    return true;
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name.get());
    } catch (RepositoryNotFoundException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (RepositoryNotFoundException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey().get();
    final ApprovalType at = approvalTypes.getApprovalType(approval.getKey());
    a.description = at.getCategory().getName();
    a.value = Short.toString(approval.getValue().get());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey().get();
    ApprovalType at = approvalTypes.byId(approval.getKey());
    if (at != null) {
        a.description = at.getCategory().getName();
    }
    a.value = Short.toString(approval.getValue().get());
    return a;
}
#end_block

#method_before
@Override
public void myGroups(final AsyncCallback<List<AccountGroup>> callback) {
    myGroupsFactory.create().to(callback);
}
#method_after
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groupDetails = new ArrayList<GroupDetail>();
            for (AccountGroup group : myGroupsFactory.create().call()) {
                groupDetails.add(groupDetailFactory.create(group.getId()).call());
            }
            return groupDetails;
        }
    });
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    try {
        final RegisterNewEmailSender sender;
        sender = registerNewEmailFactory.create(address);
        sender.send();
        cb.onSuccess(VoidResult.INSTANCE);
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<Account> cb) {
    if (authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(address));
            cb.onSuccess(user.get().getAccount());
        } catch (AccountException e) {
            cb.onFailure(e);
        }
    } else {
        try {
            final RegisterNewEmailSender sender;
            sender = registerNewEmailFactory.create(address);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        }
    }
}
#end_block

#method_before
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groups = new ArrayList<GroupDetail>();
            try {
                for (AccountGroup group : myGroupsFactory.create().call()) {
                    groups.add(groupDetailFactory.create(group.getId()).call());
                }
            } catch (Exception e) {
                throw new Failure(e);
            }
            return groups;
        }
    });
}
#method_after
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groupDetails = new ArrayList<GroupDetail>();
            for (AccountGroup group : myGroupsFactory.create().call()) {
                groupDetails.add(groupDetailFactory.create(group.getId()).call());
            }
            return groupDetails;
        }
    });
}
#end_block

#method_before
private void postLoad() {
    if (haveAccount && haveEmails) {
        if (currentEmail != null) {
            boolean found = false;
            for (int i = 0; i < emailPick.getItemCount(); i++) {
                if (currentEmail.equals(emailPick.getValue(i))) {
                    emailPick.setSelectedIndex(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                emailPick.addItem(currentEmail);
                emailPick.setSelectedIndex(emailPick.getItemCount() - 1);
            }
        }
        if (emailPick.getItemCount() > 0) {
            emailPick.setVisible(true);
            emailPick.setEnabled(true);
            if (canRegisterNewEmail()) {
                final String t = Util.C.buttonOpenRegisterNewEmail();
                emailPick.addItem("... " + t + "  ", t);
            }
        } else {
            emailPick.setVisible(false);
        }
        registerNewEmail.setEnabled(true);
    }
    display();
}
#method_after
private void postLoad() {
    if (haveAccount && haveEmails) {
        updateEmailList();
        registerNewEmail.setEnabled(true);
    }
    display();
}
#end_block

#method_before
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    box.hide();
                    switch(Gerrit.getConfig().getAuthType()) {
                        case HTTP:
                        case HTTP_LDAP:
                        case CLIENT_SSL_CERT_LDAP:
                        case OPENID:
                        case LDAP:
                        case LDAP_BIND:
                            break;
                        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                            Gerrit.upgradeUI(PageLinks.SETTINGS_CONTACT);
                            break;
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    body.add(new HTML(Util.C.descRegisterNewEmail()));
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#method_after
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                new ErrorDialog(Util.C.invalidUserEmail()).center();
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<Account>() {

                public void onSuccess(Account currentUser) {
                    box.hide();
                    if (Gerrit.getConfig().getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
                        currentEmail = addr;
                        if (emailPick.getItemCount() == 0) {
                            onSaveSuccess(currentUser);
                        } else {
                            save.setEnabled(true);
                        }
                        updateEmailList();
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    if (Gerrit.getConfig().getAuthType() != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        body.add(new HTML(Util.C.descRegisterNewEmail()));
    }
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    try {
        switch(authConfig.getAuthType()) {
            case OPENID:
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
            case LDAP:
            case LDAP_BIND:
                final RegisterNewEmailSender sender;
                sender = registerNewEmailFactory.create(address);
                sender.send();
                cb.onSuccess(VoidResult.INSTANCE);
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                registerMail(address, cb);
                break;
            default:
                log.error("Unsupported loginType: " + authConfig.getAuthType(), new ProvisionException("Unsupported loginType: " + authConfig.getAuthType()));
                throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
        }
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<Account> cb) {
    if (authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(address));
            cb.onSuccess(user.get().getAccount());
        } catch (AccountException e) {
            cb.onFailure(e);
        }
    } else {
        try {
            final RegisterNewEmailSender sender;
            sender = registerNewEmailFactory.create(address);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        }
    }
}
#end_block

#method_before
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        registerMail(newEmail, callback);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    }
}
#method_after
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        if (!newEmail.contains("@")) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(newEmail));
        callback.onSuccess(VoidResult.INSTANCE);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    } catch (AccountException e) {
        callback.onFailure(e);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    if (a2.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a2.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regexEdit = Pattern.compile(a2.name());
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchList pl = getPatchList(env, psInfo);
    Repository repo;
    try {
        repo = getRepository(env);
    } catch (RepositoryNotFoundException err) {
        throw new JavaException(this, 1, err);
    }
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            final RevCommit p = bCommit.getParent(0);
            rw.parseHeaders(p);
            aTree = p.getTree();
        }
        bTree = bCommit.getTree();
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    for (PatchListEntry entry : pl.getPatches()) {
        String newName = entry.getNewName();
        String oldName = entry.getOldName();
        if (regex.matcher(newName).find() || (oldName != null && regex.matcher(oldName).find())) {
            List<Edit> edits = entry.getEdits();
            if (edits.isEmpty()) {
                continue;
            }
            try {
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, repo);
                } else {
                    tA = load(aTree, newName, repo);
                }
                Text tB = load(bTree, newName, repo);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (regexEdit.matcher(aDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (regexEdit.matcher(bDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                }
            } catch (IOException err) {
                throw new JavaException(this, 1, err);
            }
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo = StoredValues.PATCH_SET_INFO.get(engine);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                List<Edit> edits = entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    return engine.fail();
}
#end_block

#method_before
private Text load(final ObjectId tree, final String path, final Repository repo) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(repo, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#method_after
private Text load(final ObjectId tree, final String path, final ObjectReader reader) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(reader, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#end_block

#method_before
private void showText(Object data, int depth) {
    for (Field f : fieldsOf(data.getClass())) {
        Object val;
        try {
            val = f.get(data);
        } catch (IllegalArgumentException err) {
            continue;
        } catch (IllegalAccessException err) {
            continue;
        }
        if (val == null) {
            continue;
        }
        indent(depth);
        out.print(f.getName());
        out.print(":");
        if (val instanceof Long && isDateField(f.getName())) {
            out.print(' ');
            out.print(sdf.format(new Date(((Long) val) * 1000L)));
            out.print('\n');
        } else {
            showTextValue(val, depth);
        }
    }
}
#method_after
private void showText(Object data, int depth) {
    for (Field f : fieldsOf(data.getClass())) {
        Object val;
        try {
            val = f.get(data);
        } catch (IllegalArgumentException err) {
            continue;
        } catch (IllegalAccessException err) {
            continue;
        }
        if (val == null) {
            continue;
        }
        showField(f.getName(), val, depth);
    }
}
#end_block

#method_before
private void indent(int depth) {
    for (int i = 0; i < depth; i++) {
        out.print("  ");
    }
}
#method_after
private String indent(int spaces) {
    if (spaces == 0) {
        return "";
    } else {
        return String.format("%" + spaces + "s", " ");
    }
}
#end_block

#method_before
public MessageAttribute asMessageAttribute(ChangeMessage message) {
    MessageAttribute a = new MessageAttribute();
    a.timestamp = message.getWrittenOn().getTime();
    a.author = accountCache.get(message.getAuthor()).getAccount().getFullName();
    a.message = message.getMessage();
    return a;
}
#method_after
public MessageAttribute asMessageAttribute(ChangeMessage message) {
    MessageAttribute a = new MessageAttribute();
    a.timestamp = message.getWrittenOn().getTime() / 1000L;
    a.reviewer = asAccountAttribute(message.getAuthor());
    a.message = message.getMessage();
    return a;
}
#end_block

#method_before
public PatchSetCommentAttribute asPatchSetLineAttribute(PatchLineComment c) {
    PatchSetCommentAttribute a = new PatchSetCommentAttribute();
    a.author = accountCache.get(c.getAuthor()).getAccount().getFullName();
    a.file = c.getKey().getParentKey().get();
    a.line = c.getLine();
    a.message = c.getMessage();
    return a;
}
#method_after
public PatchSetCommentAttribute asPatchSetLineAttribute(PatchLineComment c) {
    PatchSetCommentAttribute a = new PatchSetCommentAttribute();
    a.reviewer = asAccountAttribute(c.getAuthor());
    a.file = c.getKey().getParentKey().get();
    a.line = c.getLine();
    a.message = c.getMessage();
    return a;
}
#end_block

#method_before
public Collection<ChangeMessage> messages(Provider<ReviewDb> db) throws OrmException {
    if (messages == null) {
        messages = db.get().changeMessages().byChange(legacyId).toList();
    }
    return messages;
}
#method_after
public List<ChangeMessage> messages(Provider<ReviewDb> db) throws OrmException {
    if (messages == null) {
        messages = db.get().changeMessages().byChange(legacyId).toList();
    }
    return messages;
}
#end_block

#method_before
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParametrizedString pattern = new ParametrizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParameterizedString pattern = new ParameterizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toProject(final Project.NameKey project) {
    ParametrizedString pattern = new ParametrizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toBranch(final Branch.NameKey branch) {
    ParametrizedString pattern = new ParametrizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toBranch(final Branch.NameKey branch) {
    ParameterizedString pattern = new ParameterizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
static ParametrizedString paramString(Config c, String n, String d) {
    String expression = optdef(c, n, d);
    if (expression == null) {
        return null;
    } else if (expression.contains("${")) {
        return new ParametrizedString(expression);
    } else {
        return new ParametrizedString("${" + expression + "}");
    }
}
#method_after
static ParameterizedString paramString(Config c, String n, String d) {
    String expression = optdef(c, n, d);
    if (expression == null) {
        return null;
    } else if (expression.contains("${")) {
        return new ParameterizedString(expression);
    } else {
        return new ParameterizedString("${" + expression + "}");
    }
}
#end_block

#method_before
private static String apply(ParametrizedString p, LdapQuery.Result m) throws NamingException {
    if (p == null) {
        return null;
    }
    final Map<String, String> values = new HashMap<String, String>();
    for (final String name : m.attributes()) {
        values.put(name, m.get(name));
    }
    String r = p.replace(values);
    return r.isEmpty() ? null : r;
}
#method_after
private static String apply(ParameterizedString p, LdapQuery.Result m) throws NamingException {
    if (p == null) {
        return null;
    }
    final Map<String, String> values = new HashMap<String, String>();
    for (final String name : m.attributes()) {
        values.put(name, m.get(name));
    }
    String r = p.replace(values);
    return r.isEmpty() ? null : r;
}
#end_block

#method_before
@Override
public Set<AccountGroup.ExternalNameKey> lookupGroups(String name) {
    final Set<AccountGroup.ExternalNameKey> out;
    final Map<String, String> params = Collections.<String, String>emptyMap();
    out = new HashSet<AccountGroup.ExternalNameKey>();
    try {
        final DirContext ctx = helper.open();
        try {
            final LdapSchema schema = helper.getSchema(ctx);
            final ParametrizedString filter = ParametrizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            for (String groupBase : schema.groupBases) {
                final LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, Collections.<String>emptySet());
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(new AccountGroup.ExternalNameKey(res.getDN()));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#method_after
@Override
public Set<AccountGroup.ExternalNameKey> lookupGroups(String name) {
    final Set<AccountGroup.ExternalNameKey> out;
    final Map<String, String> params = Collections.<String, String>emptyMap();
    out = new HashSet<AccountGroup.ExternalNameKey>();
    try {
        final DirContext ctx = helper.open();
        try {
            final LdapSchema schema = helper.getSchema(ctx);
            final ParameterizedString filter = ParameterizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            for (String groupBase : schema.groupBases) {
                final LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, Collections.<String>emptySet());
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(new AccountGroup.ExternalNameKey(res.getDN()));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        try {
            while (parentState != null) {
                if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                    // parent has been seen before, stop walk up inheritance tree
                    break;
                }
                PrologEnvironment parentEnv;
                try {
                    parentEnv = parentState.newPrologEnvironment();
                } catch (CompileException err) {
                    return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
                }
                try {
                    parentEnv.copyStoredValues(childEnv);
                    Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
                    if (filterRule != null) {
                        try {
                            Term resultsTerm = toListTerm(results);
                            results.clear();
                            Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                            results.addAll(((ListTerm) template[2]).toJava());
                        } catch (PrologException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        } catch (RuntimeException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        }
                    }
                    parentState = parentState.getParentState();
                    childEnv = parentEnv;
                } finally {
                    // childEnv.close() below will handle it.
                    if (childEnv != parentEnv) {
                        parentEnv.close();
                    }
                }
            }
        } finally {
            childEnv.close();
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    child.delegateCleanup(cleanup);
}
#method_after
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    setCleanup(child.cleanup);
}
#end_block

#method_before
public void close() {
    for (Runnable task : cleanup) {
        task.run();
    }
    // ensure cleanup tasks run only once, even if close() is called again
    cleanup.clear();
}
#method_after
public void close() {
    for (final Iterator<Runnable> i = cleanup.iterator(); i.hasNext(); ) {
        try {
            i.next().run();
        } catch (Throwable err) {
            log.error("Failed to execute cleanup for PrologEnvironment", err);
        }
        i.remove();
    }
}
#end_block

#method_before
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will throw an exception
        obj = createValue(engine);
        set(engine, obj);
    }
    return obj;
}
#method_after
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will return null
        obj = createValue(engine);
        if (obj == null) {
            throw new SystemException("No " + key + " available");
        }
        set(engine, obj);
    }
    return obj;
}
#end_block

#method_before
protected T createValue(Prolog engine) {
    throw new SystemException("No " + key + " available");
}
#method_after
protected T createValue(Prolog engine) {
    return null;
}
#end_block

#method_before
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    if ("refs/meta/config".equals(k.getShortName()) || Constants.HEAD.equals(k.getShortName())) {
        fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().italic());
    }
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || Constants.HEAD.equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment parentEnv;
    PrologEnvironment childEnv = env;
    while (parentState != null) {
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                List<Term> filtered = new ArrayList<Term>();
                for (Term[] template : parentEnv.all("gerrit", "filter_results", filterRule, resultsTerm, new VariableTerm())) {
                    results.add(template[2]);
                }
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment childEnv = env;
    Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
    projectsSeen.add(getProject().getNameKey());
    while (parentState != null) {
        if (!projectsSeen.add(parentState.getProject().getNameKey())) {
            // parent has been seen before, stop walk up inheritance tree
            break;
        }
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                results.addAll(((ListTerm) template[2]).toJava());
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (Term term : terms) {
        list = new ListTerm(term, list);
    }
    return list;
}
#method_after
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            RefControl refControl = pctl.controlForRef(ref.getName());
            if ((// 
            ref.getName().startsWith(Constants.R_HEADS) || GitRepositoryManager.REF_CONFIG.equals(ref.getName())) && refControl.isVisible()) {
                final Branch b = createBranch(ref.getName());
                if (ref.getObjectId() != null) {
                    b.setRevision(new RevId(ref.getObjectId().name()));
                }
                b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
                branches.add(b);
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    Branch configBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = pctl.controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranch(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranch(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#end_block

#method_before
private Branch createBranch(final String name) {
    return new Branch(new Branch.NameKey(projectName, name));
}
#method_after
private Branch createBranch(final Ref ref, final RefControl refControl, final Set<String> targets) {
    final Branch b = createBranch(ref.getName());
    if (ref.getObjectId() != null) {
        b.setRevision(new RevId(ref.getObjectId().name()));
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#end_block

#method_before
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, "Base");
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, Util.M.patchSetHeader(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#method_after
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(0, 0, PatchUtil.C.patchHeaderPatchSet());
    fmt.setStyleName(0, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, PatchUtil.C.patchBase());
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, String.valueOf(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().patchHistoryTablePatchSetHeader());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#end_block

#method_before
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#method_after
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#end_block

#method_before
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerFactory.create(id, reviewers, confirmed).to(callback);
}
#method_after
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerHandlerFactory.create(id, reviewers, confirmed).to(callback);
}
#end_block

#method_before
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerFactory.create(id, reviewerId).to(callback);
}
#method_after
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerHandlerFactory.create(id, reviewerId).to(callback);
}
#end_block

#method_before
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
private void displayHeader() {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (final ApprovalType t : types) {
        table.setText(0, col, t.getCategory().getName());
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(0, col, Gerrit.RESOURCES.css().rightmost());
    col++;
}
#method_after
private void displayHeader(List<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), change);
        }
        table.setVisible(true);
    }
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Element li = DOM.createElement("li");
                li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                DOM.setInnerText(li, Util.M.needApproval(at.getCategory().getName(), at.getMax().formatValue(), at.getMax().getName()));
                DOM.appendChild(missingList, li);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.setVisible(Gerrit.isSignedIn() && change.getStatus().isOpen());
}
#method_after
void display(ChangeDetail detail) {
    reviewerSuggestOracle.setProject(detail.getChange().getProject());
    List<String> columns = new ArrayList<String>();
    List<ApprovalDetail> rows = detail.getApprovals();
    changeId = detail.getChange().getId();
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (detail.getSubmitRecords() != null) {
        HashSet<String> reportedMissing = new HashSet<String>();
        HashMap<Account.Id, ApprovalDetail> byUser = new HashMap<Account.Id, ApprovalDetail>();
        for (ApprovalDetail ad : detail.getApprovals()) {
            byUser.put(ad.getAccount(), ad);
        }
        for (SubmitRecord rec : detail.getSubmitRecords()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label lbl : rec.labels) {
                if (!columns.contains(lbl.label)) {
                    columns.add(lbl.label);
                }
                switch(lbl.status) {
                    case OK:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.approved(lbl.label);
                            }
                            break;
                        }
                    case REJECT:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.rejected(lbl.label);
                            }
                            break;
                        }
                    case NEED:
                    case IMPOSSIBLE:
                        if (reportedMissing.add(lbl.label)) {
                            Element li = DOM.createElement("li");
                            li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                            DOM.setInnerText(li, Util.M.needApproval(lbl.label));
                            DOM.appendChild(missingList, li);
                        }
                        break;
                }
            }
        }
        missing.setVisible(!reportedMissing.isEmpty());
    } else {
        for (ApprovalDetail ad : rows) {
            for (PatchSetApproval psa : ad.getPatchSetApprovals()) {
                ApprovalType legacyType = types.byId(psa.getCategoryId());
                if (legacyType == null) {
                    continue;
                }
                String labelName = legacyType.getCategory().getLabelName();
                if (psa.getValue() == legacyType.getMax().getValue()) {
                    ad.approved(labelName);
                } else if (psa.getValue() == legacyType.getMin().getValue()) {
                    ad.rejected(labelName);
                }
                if (!columns.contains(labelName)) {
                    columns.add(labelName);
                }
            }
            Collections.sort(columns, new Comparator<String>() {

                @Override
                public int compare(String o1, String o2) {
                    ApprovalType a = types.byLabel(o1);
                    ApprovalType b = types.byLabel(o2);
                    int cmp = 0;
                    if (a != null && b != null) {
                        cmp = a.getCategory().getPosition() - b.getCategory().getPosition();
                    }
                    if (cmp == 0) {
                        cmp = o1.compareTo(o2);
                    }
                    return cmp;
                }
            });
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(columns);
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), detail.getChange(), columns);
        }
        table.setVisible(true);
    }
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void doAddReviewer() {
    final String userNameOrEmailOrGroupName = addMemberBox.getText();
    if (userNameOrEmailOrGroupName.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(userNameOrEmailOrGroupName);
    addReviewers(reviewers, false);
}
#method_after
private void doAddReviewer() {
    final String reviewer = addMemberBox.getText();
    if (reviewer.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(reviewer);
    addReviewers(reviewers, false);
}
#end_block

#method_before
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail.getChange(), changeDetail.getMissingApprovals(), changeDetail.getApprovals());
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case ACCOUNT_OR_GROUP_NOT_FOUND:
                            r.append(Util.M.accountOrGroupNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                StringBuilder message = new StringBuilder();
                                message.append("<b>");
                                message.append(Util.M.groupManyMembersConfirmation(e.getName(), result.getMemberCount()));
                                message.append("</b>");
                                ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                                    @Override
                                    public void onOk() {
                                        addReviewers(reviewers, true);
                                    }
                                });
                                confirmationDialog.center();
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail);
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case REVIEWER_NOT_FOUND:
                            r.append(Util.M.reviewerNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                askForConfirmation(e.getName(), result.getMemberCount());
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        private void askForConfirmation(final String groupName, final int memberCount) {
            final StringBuilder message = new StringBuilder();
            message.append("<b>");
            message.append(Util.M.groupManyMembersConfirmation(groupName, memberCount));
            message.append("</b>");
            final ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewers(reviewers, true);
                }
            });
            confirmationDialog.center();
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (final ApprovalType type : types) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    table.setText(row, col, hint.toString());
    fmt.setStyleName(row, col, Gerrit.RESOURCES.css().rightmost());
    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().approvalhint());
    col++;
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
            } else {
                new ErrorDialog(result.getErrors().get(0).toString()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r);
            } else {
                final ReviewerResult.Error resultError = result.getErrors().get(0);
                String message;
                switch(resultError.getType()) {
                    case REMOVE_NOT_PERMITTED:
                        message = Util.C.approvalTableRemoveNotPermitted();
                        break;
                    case COULD_NOT_REMOVE:
                    default:
                        message = Util.C.approvalTableCouldNotRemove();
                }
                new ErrorDialog(message + " " + resultError.getName()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    // make a modifiable copy of the patches list
    List<PatchListEntry> patches = new ArrayList<PatchListEntry>();
    PatchList pl = plCache.get(plKey);
    for (PatchListEntry entry : pl.getPatches()) {
        patches.add(entry);
    }
    engine.areg1 = arg1;
    engine.areg5 = new JavaObjectTerm(patches);
    return commit_delta_4_top;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    engine.areg1 = new JavaObjectTerm(regex);
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    PatchList pl = plCache.get(plKey);
    Iterator<PatchListEntry> iter = pl.getPatches().iterator();
    engine.areg5 = new JavaObjectTerm(iter);
    return engine.jtry5(commit_delta_check, commit_delta_next);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    a1.dereference();
    a2.dereference();
    a3.dereference();
    a4.dereference();
    a5.dereference();
    String regex = a1.toString();
    List<PatchListEntry> patches = (List<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (!patches.isEmpty()) {
        PatchListEntry patch = patches.get(0);
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if ((oldName != null && oldName.matches(regex)) || newName.matches(regex)) {
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm changeSym = SymbolTerm.intern(changeType.toString());
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_modify);
}
#method_after
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_empty);
}
#end_block

#method_before
public PatchSet.Id getPatchSetId() {
    return psId;
}
#method_after
public PatchSet.Id getPatchSetId() {
    return patchSetId;
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(db, pc, meta, true, this.tagCache).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, db, pc, meta, true).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(GitTagCacheImpl.module());
    install(RegExpCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(TagCache.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            // 
            deferredTags.add(ref);
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        Map<Ref, List<Ref>> reachableTags = tagCache.get(db);
        for (Ref tag : reachableTags.keySet()) {
            for (Ref ref : reachableTags.get(tag)) {
                if (projectCtl.controlForRef(ref.getName()).isVisible()) {
                    result.put(tag.getName(), tag);
                    break;
                }
            }
        }
    }
    return result;
}
#method_after
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // 
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        TagMatcher tags = tagCache.get(projectName).matcher(db, result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get(), true, tagCache));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get(), true, tagCache));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, pc, db.get(), true));
    }
    return up;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.intern(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.create(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity author = psiFactory.get(id).getAuthor();
        Account.Id authorId = author.getAccount();
        if (authorId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(authorId.get());
        }
        String name = author.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = author.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    return exec(engine, author);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity committer = psiFactory.get(id).getCommitter();
        Account.Id committerId = committer.getAccount();
        if (committerId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(committerId.get());
        }
        String name = committer.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = committer.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity committer = psInfo.getCommitter();
    return exec(engine, committer);
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canPushToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        TreeFilter oldTF = walk.getTreeFilter();
        RevFilter oldRF = walk.getRevFilter();
        boolean oldRB = walk.isRetainBody();
        try {
            walk.reset();
            walk.setTreeFilter(TreeFilter.ALL);
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.setRetainBody(false);
            walk.markStart(tip);
            walk.markStart(h);
            ObjectId commonAncestor = walk.next();
            if (commonAncestor == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setTreeFilter(oldTF);
            walk.setRevFilter(oldRF);
            walk.setRetainBody(oldRB);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    // FIXME: why is this mergedInto detection even needed? was done
    // for issue GERRIT-54, but still unclear (to me) what it's for.
    // Disable it for now...
    // findMergedInto(change.getDest().get(), c);
    final Ref mergedInto = null;
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private File local(final HttpServletRequest req) {
    final String name = req.getPathInfo();
    if (name.length() < 2 || !name.startsWith("/")) {
        // 
        return null;
    }
    final File p = new File(staticBase, name.substring(1));
    // Ensure that the requested file is *actually* within the static dir base.
    try {
        if (!p.getCanonicalFile().getPath().startsWith(staticBase.getPath() + File.separator))
            return null;
    } catch (IOException e) {
        return null;
    }
    return p.isFile() ? p : null;
}
#method_after
private File local(final HttpServletRequest req) {
    final String name = req.getPathInfo();
    if (name.length() < 2 || !name.startsWith("/") || isUnreasonableName(name)) {
        // 
        return null;
    }
    final File p = new File(staticBase, name.substring(1));
    // Ensure that the requested file is *actually* within the static dir base.
    try {
        if (!p.getCanonicalFile().getPath().startsWith(staticBasePath))
            return null;
    } catch (IOException e) {
        return null;
    }
    return p.isFile() ? p : null;
}
#end_block

#method_before
private List<String> myAdvertisedAddresses() {
    if (advertisedAddrs != null)
        return advertisedAddrs;
    else {
        List<InetSocketAddress> addrs = myAddresses();
        List<String> str_addrs = new ArrayList<String>(addrs.size());
        for (final InetSocketAddress addr : addrs) {
            str_addrs.add(SocketUtil.format(addr, IANA_SSH_PORT));
        }
        return str_addrs;
    }
}
#method_after
private List<String> myAdvertisedAddresses() {
    if (advertisedAddress != null) {
        return advertisedAddress;
    } else {
        List<InetSocketAddress> addrs = myAddresses();
        List<String> strAddrs = new ArrayList<String>(addrs.size());
        for (final InetSocketAddress addr : addrs) {
            strAddrs.add(SocketUtil.format(addr, IANA_SSH_PORT));
        }
        return strAddrs;
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    dbInjector = createDbInjector(MULTI_USER);
    manager.add(dbInjector);
    manager.start();
    dbInjector.injectMembers(this);
    Project.NameKey project = getNameKey();
    Repository git = gitManager.openRepository(project);
    PrologJar jarMaker = new PrologJar(getSitePath(), git);
    boolean success = jarMaker.run();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    dbInjector = createDbInjector(SINGLE_USER);
    manager.add(dbInjector);
    manager.start();
    dbInjector.createChildInjector(new FactoryModule() {

        @Override
        protected void configure() {
            factory(PrologCompiler.Factory.class);
        }
    }).injectMembers(this);
    LinkedHashSet<Project.NameKey> names = new LinkedHashSet<Project.NameKey>();
    for (String name : projectNames) {
        names.add(new Project.NameKey(name));
    }
    if (all) {
        names.addAll(gitManager.list());
    }
    boolean error = false;
    for (Project.NameKey project : names) {
        Repository git = gitManager.openRepository(project);
        try {
            switch(jarFactory.create(git).call()) {
                case NO_RULES:
                    if (!all || projectNames.contains(project.get())) {
                        System.err.println("error: No rules.pl in " + project.get());
                        error = true;
                    }
                    break;
                case COMPILED:
                    if (!quiet) {
                        System.out.format("Compiled %-60s ... SUCCESS", project.get());
                        System.out.println();
                    }
                    break;
            }
        } catch (CompileException err) {
            if (showStackTrace) {
                err.printStackTrace();
            } else {
                System.err.println("fatal: " + err.getMessage());
            }
            error = true;
        } finally {
            git.close();
        }
    }
    return !error ? 0 : 1;
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() throws OrmException {
    if (!(user instanceof IdentifiedUser)) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = (IdentifiedUser) user;
    final ReviewDb db = schema.open();
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    OUTER: for (AccountGroup.UUID groupUUID : iUser.getEffectiveGroups()) {
        AccountGroup group = groupCache.get(groupUUID);
        if (group == null) {
            continue;
        }
        final List<AccountGroupAgreement> temp = db.accountGroupAgreements().byGroup(group.getId()).toList();
        Collections.reverse(temp);
        for (final AccountGroupAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break OUTER;
        }
    }
    if (bestAgreement == null) {
        final List<AccountAgreement> temp = db.accountAgreements().byAccount(iUser.getAccountId()).toList();
        Collections.reverse(temp);
        for (final AccountAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break;
        }
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(iUser.getAccount().getFullName());
        fail |= missing(iUser.getAccount().getPreferredEmail());
        fail |= !iUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() throws OrmException {
    if (!(user instanceof IdentifiedUser)) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = (IdentifiedUser) user;
    final ReviewDb db = schema.open();
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    try {
        OUTER: for (AccountGroup.UUID groupUUID : iUser.getEffectiveGroups()) {
            AccountGroup group = groupCache.get(groupUUID);
            if (group == null) {
                continue;
            }
            final List<AccountGroupAgreement> temp = db.accountGroupAgreements().byGroup(group.getId()).toList();
            Collections.reverse(temp);
            for (final AccountGroupAgreement a : temp) {
                final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
                if (cla == null) {
                    continue;
                }
                bestAgreement = a;
                bestCla = cla;
                break OUTER;
            }
        }
        if (bestAgreement == null) {
            final List<AccountAgreement> temp = db.accountAgreements().byAccount(iUser.getAccountId()).toList();
            Collections.reverse(temp);
            for (final AccountAgreement a : temp) {
                final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
                if (cla == null) {
                    continue;
                }
                bestAgreement = a;
                bestCla = cla;
                break;
            }
        }
    } finally {
        db.close();
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(iUser.getAccount().getFullName());
        fail |= missing(iUser.getAccount().getPreferredEmail());
        fail |= !iUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
public URLClassLoader getClassLoader(ObjectId rulesId) {
    // get rules.pl's sha1, if it exists
    String filePath = "";
    File cacheFolder = site.resolve(config.getString("cache", null, "directory"));
    if (cacheFolder != null) {
        filePath = cacheFolder.getPath();
    }
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = null;
    if (rulesId != null) {
        jarFile = new File(filePath + "/rules/rules-" + rulesId.getName() + ".jar");
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    if (cacheFolder != null && jarFile != null && jarFile.exists()) {
        URL url;
        try {
            url = jarFile.toURI().toURL();
        } catch (MalformedURLException e) {
            return null;
        }
        URL[] urls = new URL[] { url };
        return new URLClassLoader(urls, defaultLoader);
    } else {
        return null;
    }
}
#method_after
public synchronized ClassLoader getClassLoader(ObjectId rulesId) {
    if (rulesId == null || rulesDir == null) {
        return null;
    }
    Reference<? extends ClassLoader> ref = classLoaderCache.get(rulesId);
    if (ref != null) {
        ClassLoader cl = ref.get();
        if (cl != null) {
            return cl;
        }
        classLoaderCache.remove(rulesId);
        ref.enqueue();
    }
    cleanCache();
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = new File(rulesDir, "rules-" + rulesId.getName() + ".jar");
    if (!jarFile.isFile()) {
        return null;
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    URL url;
    try {
        url = jarFile.toURI().toURL();
    } catch (MalformedURLException e) {
        log.error("Path to rules jar is broken", e);
        return null;
    }
    ClassLoader urlLoader = new URLClassLoader(new URL[] { url }, defaultLoader);
    LoaderRef lRef = new LoaderRef(rulesId, urlLoader);
    classLoaderCache.put(rulesId, lRef);
    return urlLoader;
}
#end_block

#method_before
private ProjectState newProjectState() {
    final Map<Project.NameKey, ProjectState> all = new HashMap<Project.NameKey, ProjectState>();
    final ProjectCache projectCache = new ProjectCache() {

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }
    };
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    Project.NameKey wildProject = new Project.NameKey("All-Projects");
    ProjectControl.AssistedFactory projectControlFactory = null;
    all.put(local.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, local, null));
    all.put(parent.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, parent, null));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState() {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    all.put(local.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, local));
    all.put(parent.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, parent));
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env;
    if (urlLoader != null) {
        env = envFactory.create(urlLoader);
        return env;
    } else {
        env = envFactory.create(getClass().getClassLoader());
    }
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    if (ruleLoader != null) {
        return envFactory.create(ruleLoader);
    }
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public Collection<AccessSection> getInheritedAccessSections() {
    if (isWildProject()) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // Wild project is the parent, or the root of the tree
    if (parent == null) {
        ProjectState s = projectCache.get(wildProject);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
        }
    }
    return inherited;
}
#method_after
public Collection<AccessSection> getInheritedAccessSections() {
    if (isAllProjects) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // The root of the tree is the special "All-Projects" case.
    if (parent == null) {
        inherited.addAll(projectCache.getAllProjects().getLocalAccessSections());
    }
    return inherited;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isWildProject()) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (final Change.Id changeId : changeIds) {
                try {
                    ok = ok && modifyOne(changeId);
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while modifying reviewers in " + changeId + "\n");
                    log.error("internal error while modifying reviewers in " + changeId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more modifications of reviewers failed; review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (Change.Id changeId : changes) {
                try {
                    ok &= modifyOne(changeId);
                } catch (Exception err) {
                    ok = false;
                    log.error("Error updating reviewers on change " + changeId, err);
                    writeError("fatal", "internal error while updating " + changeId);
                }
            }
            if (!ok) {
                throw error("fatal: one or more updates failed; review output above");
            }
        }
    });
}
#end_block

#method_before
private boolean modifyOne(final Change.Id changeId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException, Exception {
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    boolean ok = true;
    for (final Account.Id accountId : reviewersToRemove) {
        final ReviewerResult result = removeReviewerFactory.create(changeId, accountId).call();
        for (ReviewerResult.Error resultError : result.getErrors()) {
            // sensitive information that we do not want to reveal to the user.
            if (resultError.getType() == ReviewerResult.Error.Type.COULD_NOT_REMOVE) {
                // For COULD_NOT_REMOVE, getName() contains the specific error
                // message with an id at the end
                final String message = resultError.getName();
                String regex = accountId + "$";
                if (message.matches("^.* " + regex)) {
                    writeError("error: " + message.replaceAll(regex, "\"" + allReviewers.get(accountId)) + "\"\n");
                } else {
                    writeError("error: " + "\"" + allReviewers.get(accountId) + "\" could not be removed\n");
                }
                ok = false;
            }
        }
    }
    final ReviewerResult result = addReviewerFactory.create(changeId, reviewersToAdd).call();
    // user and we have checked for this when we parsed the arguments.
    for (ReviewerResult.Error resultError : result.getErrors()) {
        ok = false;
        writeError("\"" + resultError.getName() + "\" could not be added\n");
    }
    return ok;
}
#method_after
private boolean modifyOne(Change.Id changeId) throws Exception {
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    ReviewerResult result;
    boolean ok = true;
    // Remove reviewers
    // 
    result = removeReviewerFactory.create(changeId, toRemove).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case REMOVE_NOT_PERMITTED:
                message = "not permitted to remove {0} from {1}";
                break;
            case COULD_NOT_REMOVE:
                message = "could not remove {0} from {1}";
                break;
            default:
                message = "could not remove {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    // Add reviewers
    // 
    result = addReviewerFactory.create(changeId, stringSet(toAdd)).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case ACCOUNT_NOT_FOUND:
                message = "account {0} not found";
                break;
            case ACCOUNT_INACTIVE:
                message = "account {0} inactive";
                break;
            case CHANGE_NOT_VISIBLE:
                message = "change {1} not visible to {0}";
                break;
            default:
                message = "could not add {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    return ok;
}
#end_block

#method_before
private Set<Change.Id> parseChangeId(final String changeIdentity) throws UnloggedFailure, OrmException {
    final Set<Change.Id> matches = new HashSet<Change.Id>();
    boolean foundInOtherProject = false;
    boolean matchesChangeKey = changeIdentity.matches("^I[0-9a-fA-F]*$");
    boolean matchesChangeId = changeIdentity.matches("^[1-9][0-9]*$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = matchesChangeKey;
    if (matchesChangeKey) {
        Change.Key changeKey = null;
        try {
            changeKey = Change.Key.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            final ResultSet<Change> changes = db.changes().byKeyRange(changeKey, changeKey.max());
            for (final Change change : changes) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = matchesChangeId;
    if (matchesChangeId) {
        Change.Id changeId = null;
        try {
            changeId = Change.Id.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeIdParses = false;
        }
        if (changeIdParses) {
            final Change change = db.changes().get(changeId);
            if (change != null) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    if (!changeKeyParses && !changeIdParses) {
        throw error("\"" + changeIdentity + "\" is not a valid change");
    }
    switch(matches.size()) {
        case 1:
            return matches;
        case 0:
            if (foundInOtherProject) {
                throw error("change " + changeIdentity + " not in project " + projectControl.getProject().getName());
            }
            throw error("\"" + changeIdentity + "\" no such change");
        default:
    }
    throw error("\"" + changeIdentity + "\" matches multiple changes");
}
#method_after
private Set<Change.Id> parseChangeId(String idstr) throws UnloggedFailure, OrmException {
    Set<Change.Id> matched = new HashSet<Change.Id>(4);
    boolean isCommit = idstr.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = false;
    if (idstr.matches("^I[0-9a-fA-F]*$")) {
        Change.Key key;
        try {
            key = Change.Key.parse(idstr);
            changeKeyParses = true;
        } catch (IllegalArgumentException e) {
            key = null;
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            for (Change change : db.changes().byKeyRange(key, key.max())) {
                matchChange(matched, change);
            }
        }
    }
    // 
    if (isCommit) {
        RevId id = new RevId(idstr);
        ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet ps : patches) {
            matchChange(matched, ps.getId().getParentKey());
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = false;
    if (idstr.matches("^[1-9][0-9]*$")) {
        Change.Id id;
        try {
            id = Change.Id.parse(idstr);
            changeIdParses = true;
        } catch (IllegalArgumentException e) {
            id = null;
            changeIdParses = false;
        }
        if (changeIdParses) {
            matchChange(matched, id);
        }
    }
    if (!changeKeyParses && !isCommit && !changeIdParses) {
        throw error("\"" + idstr + "\" is not a valid change");
    }
    switch(matched.size()) {
        case 0:
            throw error("\"" + idstr + "\" no such change");
        case 1:
            return matched;
        default:
            throw error("\"" + idstr + "\" matches multiple changes");
    }
}
#end_block

#method_before
private boolean inProject(final Change change) {
    if (projectControl == null) {
        // No --project option, so they want every project.
        return true;
    }
    return projectControl.getProject().getNameKey().equals(change.getProject());
}
#method_after
private boolean inProject(Change change) {
    if (projectControl != null) {
        return projectControl.getProject().getNameKey().equals(change.getProject());
    } else {
        // No --project option, so they want every project.
        return true;
    }
}
#end_block

#method_before
private void writeError(final String msg) {
    try {
        err.write(msg.getBytes(ENC));
    } catch (IOException e) {
    }
}
#method_after
private void writeError(String type, String msg) {
    try {
        err.write((type + ": " + msg + "\n").getBytes(ENC));
    } catch (IOException e) {
    }
}
#end_block

#method_before
private static UnloggedFailure error(final String msg) {
    return new UnloggedFailure(1, msg);
}
#method_after
private static UnloggedFailure error(String msg) {
    return new UnloggedFailure(1, msg);
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, final int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(idx + 1);
    m.closeAnchor();
    m.closeTd();
}
#method_after
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(idx + 1);
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(lineNumberMinusOne + 1);
    m.closeAnchor();
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(lineNumberMinusOne + 1);
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    return envFactory.create(getClass().getClassLoader());
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.makeSymbol("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it
    return canAbandon();
// back
}
#method_after
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#end_block

#method_before
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env = getProjectControl().getProjectState().newPrologEnvironment();
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    StructureTerm submitRule = SymbolTerm.makeSymbol("com.google.gerrit.rules.common", "default_submit", 1);
    ObjectStream ruleStream = getProjectControl().getProjectState().getPrologRules();
    if (ruleStream != null) {
        try {
            PushbackReader in = new PushbackReader(new InputStreamReader(ruleStream, Charset.forName("UTF-8")), Prolog.PUSHBACK_SIZE);
            JavaObjectTerm streamObject = new JavaObjectTerm(in);
            if (!env.execute(Prolog.BUILTIN, "consultStream", SymbolTerm.makeSymbol("submitrules"), streamObject)) {
                throw new CompileException("Cannot consult" + streamObject.toString());
            }
            // Replaces default_submit predicate with the submit_rule predicate in
            // the refs/meta/config:submit_rules.pl (if it exists)
            submitRule = SymbolTerm.makeSymbol("user", "submit_rule", 1);
        } catch (CompileException err) {
            log.error("Cannot consult provided submit_rules.pl", err);
        } finally {
            try {
                ruleStream.close();
            } catch (IOException err) {
                log.error("Close of ruleStream failed", err);
            }
        }
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#method_after
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env;
    try {
        env = getProjectControl().getProjectState().newPrologEnvironment();
    } catch (CompileException err) {
        log.error("cannot consult rules.pl", err);
        return new CanSubmitResult("Error reading submit rule");
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("com.google.gerrit.rules.common", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        log.error("Error in locate_submit_rule: no submit_rule found");
        return new CanSubmitResult("Error in finding submit rule");
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#end_block

#method_before
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    List<String> branchNames = new ArrayList<String>();
    if (showBranch != null) {
        branchNames = Arrays.asList(showBranch.split(","));
    }
    try {
        for (final Project.NameKey projectName : projectCache.all()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final List<Ref> refs = getBranchRefs(projectName, branchNames);
                    if (refs == null) {
                        continue;
                    }
                    boolean hasVisibleRefs = false;
                    for (int i = 0; i < refs.size(); i++) {
                        Ref ref = refs.get(i);
                        if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                            // No branch, or the user can't see this branch, so remove it.
                            refs.set(i, null);
                        } else {
                            hasVisibleRefs = true;
                        }
                    }
                    if (!hasVisibleRefs) {
                        continue;
                    }
                    for (Ref ref : refs) {
                        if (ref == null) {
                            // Print stub forty '-' symbols
                            stdout.print("----------------------------------------");
                        } else {
                            stdout.print(ref.getObjectId().name());
                        }
                        stdout.print(' ');
                    }
                }
                stdout.print(projectName.get() + "\n");
            } else {
                treeMap.put(projectName.get(), new TreeNode(pctl.getProject(), pctl.isVisible()));
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = treeMap.get(parentName);
                    if (node != null) {
                        node.addChild(key);
                    } else {
                        sortedNodes.add(key);
                    }
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
            stdout.flush();
        }
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project.NameKey projectName : projectCache.all()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final List<Ref> refs = getBranchRefs(projectName);
                    if (refs == null) {
                        continue;
                    }
                    boolean hasVisibleRefs = false;
                    for (int i = 0; i < refs.size(); i++) {
                        Ref ref = refs.get(i);
                        if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                            // No branch, or the user can't see this branch, so remove it.
                            refs.set(i, null);
                        } else {
                            hasVisibleRefs = true;
                        }
                    }
                    if (!hasVisibleRefs) {
                        continue;
                    }
                    for (Ref ref : refs) {
                        if (ref == null) {
                            // Print stub (forty '-' symbols)
                            stdout.print("----------------------------------------");
                        } else {
                            stdout.print(ref.getObjectId().name());
                        }
                        stdout.print(' ');
                    }
                }
                stdout.print(projectName.get() + "\n");
            } else {
                treeMap.put(projectName.get(), new TreeNode(pctl.getProject(), pctl.isVisible()));
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = treeMap.get(parentName);
                    if (node != null) {
                        node.addChild(key);
                    } else {
                        sortedNodes.add(key);
                    }
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
            stdout.flush();
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private List<Ref> getBranchRefs(Project.NameKey projectName, List<String> branches) {
    try {
        final Repository r = repoManager.openRepository(projectName);
        try {
            final List<Ref> result = new ArrayList<Ref>(branches.size());
            for (String branch : branches) {
                result.add(r.getRef(branch));
            }
            return result;
        } finally {
            r.close();
        }
    } catch (IOException ioe) {
        return null;
    }
}
#method_after
private List<Ref> getBranchRefs(Project.NameKey projectName) {
    try {
        final Repository r = repoManager.openRepository(projectName);
        try {
            final List<Ref> result = new ArrayList<Ref>(showBranch.size());
            for (String branch : showBranch) {
                result.add(r.getRef(branch));
            }
            return result;
        } finally {
            r.close();
        }
    } catch (IOException ioe) {
        return null;
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    try {
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.msg);
    }
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            toSubmit.add(patchSetId);
        } else {
            throw error(result.getMessage());
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    try {
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            toSubmit.add(patchSetId);
        } else {
            throw error(result.getMessage());
        }
    }
}
#end_block

#method_before
public static void abandon(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (updatedChange == null) {
        throw new InvalidChangeOperationException(changeId, "Change is no longer open");
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(updatedChange);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final AbandonedSender cm = abandonedSenderFactory.create(updatedChange);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
    hooks.doChangeAbandonedHook(updatedChange, user.getAccount(), message);
}
#method_after
public static void abandon(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (updatedChange == null) {
        throw new InvalidChangeOperationException("Change is no longer open or patchset is not latest");
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(updatedChange);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final AbandonedSender cm = abandonedSenderFactory.create(updatedChange);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
    hooks.doChangeAbandonedHook(updatedChange, user.getAccount(), message);
}
#end_block

#method_before
public static void restore(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (updatedChange == null) {
        throw new InvalidChangeOperationException(changeId, "Change is not abandonned or patchset is not latest");
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(updatedChange);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final AbandonedSender cm = abandonedSenderFactory.create(updatedChange);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
    hooks.doChangeRestoreHook(updatedChange, user.getAccount(), message);
}
#method_after
public static void restore(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (updatedChange == null) {
        throw new InvalidChangeOperationException("Change is not abandoned or patchset is not latest");
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(updatedChange);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final AbandonedSender cm = abandonedSenderFactory.create(updatedChange);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
    hooks.doChangeRestoreHook(updatedChange, user.getAccount(), message);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (GitRepositoryManager.REF_CONFIG.equals(c.getRefName())) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (GitRepositoryManager.REF_CONFIG.equals(cmd.getRefName())) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r) || isConfig(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.byId(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
private static boolean isConfig(final Ref ref) {
    return ref.getName().startsWith(GitRepositoryManager.REF_CONFIG);
}
#method_after
private static boolean isConfig(final Ref ref) {
    return ref.getName().equals(GitRepositoryManager.REF_CONFIG);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(GitRepositoryManager.REF_CONFIG);
}
#method_after
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(GitRepositoryManager.REF_CONFIG);
}
#end_block

#method_before
public static void revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git = gitManager.openRepository(db.changes().get(changeId).getProject());
    final RevWalk revWalk = new RevWalk(git);
    RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
    PersonIdent committerIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
    RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
    revWalk.parseHeaders(parentToCommitToRevert);
    CommitBuilder revertCommit = new CommitBuilder();
    revertCommit.addParentId(commitToRevert);
    revertCommit.setTreeId(parentToCommitToRevert.getTree());
    revertCommit.setAuthor(committerIdent);
    revertCommit.setCommitter(committerIdent);
    revertCommit.setMessage(message);
    ObjectInserter oi = git.newObjectInserter();
    ObjectId id = oi.insert(revertCommit);
    oi.flush();
    Change.Key changeKey = new Change.Key("I" + id.name());
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(user.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final RefUpdate ru = git.updateRef(ps.getRefName());
    ru.setNewObjectId(id);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: I" + id.getName());
    }
    cmsg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cmsg));
    revWalk.release();
    git.close();
    final RevertedSender cm = revertedSenderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
public static void revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps);
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = (new ListenableAccountDiffPreference()).get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = (new ListenableAccountDiffPreference()).get();
        }
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (selectedPatchSet.equals("Base")) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesList.addItem("Base");
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.oldVersionHistory());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (index == 0) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesList.addItem(Util.C.baseDiffItem());
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.oldVersionHistory());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (starChange != null) {
        setStarred(detail.isStarred());
    }
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null) {
        if (patchesList != null) {
            int index = -1;
            for (int i = 0; i < patchesList.getItemCount(); i++) {
                if (!patchesList.getValue(i).equals("Base")) {
                    if (diffBaseId.equals(PatchSet.Id.parse(patchesList.getValue(i)))) {
                        index = i;
                        break;
                    }
                }
            }
            patchesList.setSelectedIndex(index);
        }
    }
    patchSetsBlock.display(detail, diffBaseId);
    if (openPatchSetId != null) {
        patchSetsBlock.activate(openPatchSetId);
    }
    addComments(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (starChange != null) {
        setStarred(detail.isStarred());
    }
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    if (openPatchSetId != null) {
        patchSetsBlock.activate(openPatchSetId);
    }
    addComments(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
}
#end_block

#method_before
public void display(PatchSetDetail detail) {
    this.detail = detail;
    this.patchList = detail.getPatches();
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(patchList, patchSetIdToCompareWith);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#method_after
public void display(PatchSetDetail detail) {
    this.detail = detail;
    this.patchList = detail.getPatches();
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(patchList, patchSetIdToCompareWith);
    if (cmd.execute()) {
        cmd.initMeter();
        Scheduler.get().scheduleIncremental(cmd);
    } else {
        cmd.showTable();
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    final PatchList list;
    if (psIdOld != null) {
        newId = toObjectId(psIdNew);
        oldId = psIdOld != null ? toObjectId(psIdOld) : null;
        projectKey = control.getProject().getNameKey();
        final Repository git;
        try {
            git = repoManager.openRepository(projectKey);
        } catch (RepositoryNotFoundException e) {
            log.error("Repository " + projectKey + " not found", e);
            throw new NoSuchChangeException(control.getChange().getId(), e);
        }
        git.close();
        list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
    } else {
        // OK, means use base to compare
        list = patchListCache.get(control.getChange(), patchSet);
        if (list == null) {
            throw new NoSuchEntityException();
        }
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().published(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setInfo(infoFactory.get(psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draft(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    return detail;
}
#method_after
@SuppressWarnings("deprecation")
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    final PatchList list;
    if (psIdOld != null) {
        newId = toObjectId(psIdNew);
        oldId = psIdOld != null ? toObjectId(psIdOld) : null;
        projectKey = control.getProject().getNameKey();
        list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
    } else {
        // OK, means use base to compare
        list = patchListCache.get(control.getChange(), patchSet);
        if (list == null) {
            throw new NoSuchEntityException();
        }
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().published(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setInfo(infoFactory.get(psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draft(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    return detail;
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    Grant grant = (Grant) o;
    return group.equals(grant.group) && pattern.equals(grant.pattern);
}
#method_after
@Override
public boolean equals(Object o) {
    if (o == null)
        return false;
    Grant grant = (Grant) o;
    return group.equals(grant.group) && pattern.equals(grant.pattern);
}
#end_block

#method_before
public Set<AccountGroup.Id> getOwners() {
    return owners;
}
#method_after
public Set<AccountGroup.Id> getOwners() {
    if (!localOwners.isEmpty() || isSpecialWildProject() || project.getParent() == null) {
        return localOwners;
    }
    final ProjectState parent = projectCache.get(project.getParent());
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#end_block

#method_before
private List<PatchSetInfo.ParentInfo> toParentInfos(final RevCommit[] parents, final RevWalk walk) throws IOException, MissingObjectException {
    List<PatchSetInfo.ParentInfo> pInfos = new ArrayList<PatchSetInfo.ParentInfo>();
    for (RevCommit parent : parents) {
        if (parent != null && walk != null) {
            walk.parseBody(parent);
            RevId pRevId = new RevId(parent.getId().name());
            String pCommitMsg = parent.getShortMessage();
            pInfos.add(new PatchSetInfo.ParentInfo(pRevId, pCommitMsg));
        }
    }
    return pInfos;
}
#method_after
private List<PatchSetInfo.ParentInfo> toParentInfos(final RevCommit[] parents, final RevWalk walk) throws IOException, MissingObjectException {
    List<PatchSetInfo.ParentInfo> pInfos = new ArrayList<PatchSetInfo.ParentInfo>(parents.length);
    for (RevCommit parent : parents) {
        walk.parseBody(parent);
        RevId rev = new RevId(parent.getId().name());
        String msg = parent.getShortMessage();
        pInfos.add(new PatchSetInfo.ParentInfo(rev, msg));
    }
    return pInfos;
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel("Initial Commit"));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() throws OrmException {
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    OUTER: for (AccountGroup.UUID groupUUID : currentUser.getEffectiveGroups()) {
        AccountGroup group = groupCache.get(groupUUID);
        if (group == null) {
            continue;
        }
        final List<AccountGroupAgreement> temp = db.accountGroupAgreements().byGroup(group.getId()).toList();
        Collections.reverse(temp);
        for (final AccountGroupAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break OUTER;
        }
    }
    if (bestAgreement == null) {
        final List<AccountAgreement> temp = db.accountAgreements().byAccount(currentUser.getAccountId()).toList();
        Collections.reverse(temp);
        for (final AccountAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break;
        }
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(currentUser.getAccount().getFullName());
        fail |= missing(currentUser.getAccount().getPreferredEmail());
        fail |= !currentUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() throws OrmException {
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    OUTER: for (AccountGroup.Id groupId : currentUser.getEffectiveGroups()) {
        final List<AccountGroupAgreement> temp = db.accountGroupAgreements().byGroup(groupId).toList();
        Collections.reverse(temp);
        for (final AccountGroupAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break OUTER;
        }
    }
    if (bestAgreement == null) {
        final List<AccountAgreement> temp = db.accountAgreements().byAccount(currentUser.getAccountId()).toList();
        Collections.reverse(temp);
        for (final AccountAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break;
        }
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(currentUser.getAccount().getFullName());
        fail |= missing(currentUser.getAccount().getPreferredEmail());
        fail |= !currentUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = repo.getRef(destBranchName);
        boolean haveHeads = false;
        if (targetRef == null)
            for (final Ref r : rp.getAdvertisedRefs().values()) {
                if (isHead(r) || isTag(r) || isConfig(r)) {
                    try {
                        markWalk(walk, SIDE_HAVE, r);
                        haveHeads = true;
                    } catch (IOException e) {
                        continue;
                    }
                }
            }
        else {
            markWalk(walk, SIDE_HAVE, targetRef);
            haveHeads = true;
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.byId(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
void create(List<CodeReviewCommit> commits, PersonIdent author) throws MergeException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new MergeException("Couldn't create code review notes. Failed to lock the ref: " + REFS_NOTES_SUBMITTED);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                // TODO: NoteMapMerger.merge(base, ours,
                NoteMap merged = null;
                // theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new MergeException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new MergeException("Couldn't create code review notes", e);
    } catch (InterruptedException e) {
        throw new MergeException("Couldn't create code review notes", e);
    }
}
#method_after
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new CodeReviewNoteCreationException("Failed to lock the ref: " + REFS_NOTES_REVIEW);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                NoteMapMerger merger = new NoteMapMerger(db);
                NoteMap merged = merger.merge(base, ours, theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new CodeReviewNoteCreationException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } catch (InterruptedException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        reader.release();
        inserter.release();
        revWalk.release();
    }
}
#end_block

#method_before
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_SUBMITTED);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#method_after
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_REVIEW);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#end_block

#method_before
private void setOurs() throws IOException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Submitted the following changes:");
    for (CodeReviewCommit c : commits) {
        if (ours.contains(c)) {
            throw new IllegalStateException("Review summary note already exists for commit: " + c + ". Merging of notes not yet supported");
        }
        ObjectId id = inserter.insert(Constants.OBJ_BLOB, createNoteContent(c));
        inserter.flush();
        RevBlob blob = revWalk.lookupBlob(id);
        ours.set(c, blob);
        message.append(" ");
        message.append(c.change.getId());
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#method_after
private void setOurs() throws IOException, CodeReviewNoteCreationException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
    for (CodeReviewCommit c : commits) {
        ObjectId noteContent = createNoteContent(c);
        if (ours.contains(c)) {
            // merge the existing and the new note as if they are both new
            // means: base == null
            // there is not really a common ancestry for these two note revisions
            // use the same NoteMerger that is used from the NoteMapMerger
            DefaultNoteMerger noteMerger = new DefaultNoteMerger();
            Note newNote = new Note(c, noteContent);
            noteContent = noteMerger.merge(null, newNote, base.getNote(c), reader, inserter).getData();
        }
        ours.set(c, noteContent);
        message.append("* ").append(c.getShortMessage()).append("\n");
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#end_block

#method_before
private byte[] createNoteContent(CodeReviewCommit commit) throws UnsupportedEncodingException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter();
        formatter.appendChangeId(commit.change.getId());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(schema.approvalCategories().get(a.getCategoryId()), a.getValue(), schema.accounts().get(a.getAccountId()));
            }
        }
        formatter.appendBranch(schema.projects().get(commit.change.getProject()), commit.change.getDest());
        formatter.appendSubmittedBy(schema.accounts().get(submit.getAccountId()));
        formatter.appendSubmittedOn(submit.getGranted());
        return formatter.toString().getBytes("UTF-8");
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private ObjectId createNoteContent(CodeReviewCommit commit) throws CodeReviewNoteCreationException, IOException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter(author.getTimeZone());
        final List<String> idList = commit.getFooterLines(CHANGE_ID);
        if (idList.isEmpty())
            formatter.appendChangeId(commit.change.getKey());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount());
            }
        }
        formatter.appendSubmittedBy(accountCache.get(submit.getAccountId()).getAccount());
        formatter.appendSubmittedAt(submit.getGranted());
        formatter.appendReviewedOn(canonicalWebUrl, commit.change.getId());
        formatter.appendProject(commit.change.getProject().get());
        formatter.appendBranch(commit.change.getDest());
        return inserter.insert(Constants.OBJ_BLOB, formatter.toString().getBytes("UTF-8"));
    } catch (OrmException e) {
        throw new CodeReviewNoteCreationException(commit, e);
    }
}
#end_block

#method_before
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    ObjectInserter inserter = db.newObjectInserter();
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    return revWalk.parseCommit(inserter.insert(b));
}
#method_after
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws IOException {
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    ObjectId commitId = inserter.insert(b);
    inserter.flush();
    return revWalk.parseCommit(commitId);
}
#end_block

#method_before
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_SUBMITTED);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#method_after
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_REVIEW);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = new CreateCodeReviewNotes(schema, db, myIdent);
    codeReviewNotes.create(merged, computeAuthor(merged));
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), CreateCodeReviewNotes.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public void appendChangeId(Change.Id changeId) {
    sb.append("Change-Id: ").append(changeId).append("\n");
}
#method_after
void appendChangeId(Change.Key changeKey) {
    sb.append("Change-Id: ").append(changeKey.get()).append("\n");
}
#end_block

#method_before
public void appendApproval(ApprovalCategory category, short value, Account user) {
    sb.append(category.getName());
    sb.append(value < 0 ? "-" : "+").append(value).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendApproval(ApprovalCategory category, short value, Account user) {
    // TODO: use category.getLabel() when available
    sb.append(category.getName().replace(' ', '-'));
    sb.append(value < 0 ? "-" : "+").append(Math.abs(value)).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private void appendUserData(Account user) {
    sb.append(user.getFullName()).append(" <").append(user.getPreferredEmail()).append(">");
}
#method_after
private void appendUserData(Account user) {
    boolean needSpace = false;
    boolean wroteData = false;
    if (user.getFullName() != null && !user.getFullName().isEmpty()) {
        sb.append(user.getFullName());
        needSpace = true;
        wroteData = true;
    }
    if (user.getPreferredEmail() != null && !user.getPreferredEmail().isEmpty()) {
        if (needSpace) {
            sb.append(" ");
        }
        sb.append("<").append(user.getPreferredEmail()).append(">");
        wroteData = true;
    }
    if (!wroteData) {
        sb.append("Anonymous Coward #").append(user.getId());
    }
}
#end_block

#method_before
public void appendBranch(Project project, Branch.NameKey branch) {
    sb.append("Branch: ").append(project.getName()).append(" ").append(branch.get()).append("\n");
}
#method_after
void appendBranch(Branch.NameKey branch) {
    sb.append("Branch: ").append(branch.get()).append("\n");
}
#end_block

#method_before
public void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you [" + currentUser.getName() + " <" + currentUser.getEmailAddress() + ">]" + " are not author [" + author.getName() + " <" + author.getEmailAddress() + ">]");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you [" + currentUser.getName() + " <" + currentUser.getEmailAddress() + ">]" + " are not committer [" + committer.getName() + " <" + committer.getEmailAddress() + ">]");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initGroupNotifications();
    Label spacer = new Label("");
    spacer.setHeight("15px");
    add(spacer);
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initExternal();
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    onlyAuthors.setValue(group.isEmailOnlyAuthors());
    onlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    visibleToAllCheckBox.setEnabled(true);
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    emailOnlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
public void activate(final PatchSet.Id patchSetId) {
    if (indexOf(patchSetId) != -1) {
        if (!patchSetId.equals(activePatchSetId)) {
            deactivate();
            PatchSetComplexDisclosurePanel patchSetPanel = patchSetPanels.get(patchSetId);
            patchSetPanel.setOpen(true);
            patchSetPanel.setActive(true);
            activePatchSetId = patchSetId;
        }
    } else {
        Gerrit.display("change," + patchSetId.getParentKey().get());
    }
}
#method_after
public void activate(final PatchSet.Id patchSetId) {
    if (indexOf(patchSetId) != -1) {
        if (!patchSetId.equals(activePatchSetId)) {
            deactivate();
            PatchSetComplexDisclosurePanel patchSetPanel = patchSetPanels.get(patchSetId);
            patchSetPanel.setOpen(true);
            patchSetPanel.setActive(true);
            activePatchSetId = patchSetId;
        }
    } else {
        Gerrit.display(PageLinks.toChange(patchSetId.getParentKey()));
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initIncludedGroupList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includedGroupPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includedGroups.display(result.includedGroups);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, null, db, id);
}
#method_after
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, null, db, id);
}
#end_block

#method_before
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, null, id);
}
#method_after
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, null, id);
}
#end_block

#method_before
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, dbProvider, id);
}
#method_after
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, dbProvider, id);
}
#end_block

#method_before
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups = new HashSet<AccountGroup.Id>();
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups;
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#end_block

#method_before
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includedGroups = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        try {
            for (final AccountGroupIncludedGroup i : dbProvider.get().accountGroupIncludedGroups().byIncludedGroup(id)) {
                AccountGroup.Id groupId = i.getGroupId();
                if (!includedGroups.contains(groupId)) {
                    includedGroups.add(groupId);
                    groupQueue.add(groupId);
                }
            }
        } catch (OrmException e) {
            log.warn("Cannot query included groups", e);
        }
    }
    return includedGroups;
}
#method_after
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includes = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        for (final AccountGroup.Id groupId : groupIncludeCache.getByInclude(id)) {
            if (includes.add(groupId)) {
                groupQueue.add(groupId);
            }
        }
    }
    return Collections.unmodifiableSet(includes);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public boolean isVisible() {
    return isOwner();
}
#method_after
public boolean isVisible() {
    return group.isVisibleToAll() || isOwner();
}
#end_block

#method_before
public boolean canSeeMember(Account.Id id) {
    return isOwner();
}
#method_after
public boolean canSeeMember(Account.Id id) {
    return isVisible();
}
#end_block

#method_before
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, ownerGroupId, initialMembers.toArray(new Account.Id[initialMembers.size()]), initialIncludedGroups.toArray(new AccountGroup.Id[initialIncludedGroups.size()]));
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, visibleToAll, ownerGroupId, initialMembers, initialGroups);
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, null, new Account.Id[] { me }, null);
}
#method_after
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, false, null, Collections.singleton(me), null);
}
#end_block

#method_before
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchEntityException());
    }
    return g;
}
#method_after
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchGroupException(name));
    }
    return g;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludedGroups(loadIncludedGroups());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setGroups(gic.create());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#end_block

#method_before
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final AccountGroup.Id ownerGroupId, final Account.Id[] initialMembers, final AccountGroup.Id[] initialIncludedGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialIncludedGroups != null) {
        addIncludedGroups(groupId, initialIncludedGroups);
    }
    return groupId;
}
#method_after
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final boolean visibleToAll, final AccountGroup.Id ownerGroupId, final Collection<? extends Account.Id> initialMembers, final Collection<? extends AccountGroup.Id> initialGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    group.setVisibleToAll(visibleToAll);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialGroups != null) {
        addGroups(groupId, initialGroups);
    }
    return groupId;
}
#end_block

#method_before
private void addMembers(final AccountGroup.Id groupId, final Account.Id[] members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#method_after
private void addMembers(final AccountGroup.Id groupId, final Collection<? extends Account.Id> members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.redNot()).getElement().getString() + FormatUtil.name(ai));
            } else if (type.isMaxPositive(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.greenCheck()).getElement().getString() + FormatUtil.name(ai));
            } else {
                String vstr = String.valueOf(ca.getValue()) + " " + FormatUtil.name(ai);
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#method_after
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    boolean displayPersonNameInReviewCategory = false;
    if (Gerrit.isSignedIn()) {
        AccountGeneralPreferences prefs = Gerrit.getUserAccount().getGeneralPreferences();
        if (prefs.isDisplayPersonNameInReviewCategory()) {
            displayPersonNameInReviewCategory = true;
        }
    }
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.redNot()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
                }
            } else if (type.isMaxPositive(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.greenCheck()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
                }
            } else {
                String vstr = String.valueOf(ca.getValue());
                if (displayPersonNameInReviewCategory) {
                    vstr = vstr + " " + FormatUtil.name(ai);
                }
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#end_block

#method_before
public void visibleGroups(final AsyncCallback<List<AccountGroup>> callback) {
    run(callback, new Action<List<AccountGroup>>() {

        public List<AccountGroup> run(ReviewDb db) throws OrmException {
            final IdentifiedUser user = identifiedUser.get();
            final List<AccountGroup> result;
            if (user.isAdministrator()) {
                result = db.accountGroups().all().toList();
            } else {
                final HashSet<AccountGroup.Id> seen = new HashSet<AccountGroup.Id>();
                result = new ArrayList<AccountGroup>();
                for (final AccountGroup.Id myGroup : user.getEffectiveGroups()) {
                    for (AccountGroup group : db.accountGroups().ownedByGroup(myGroup)) {
                        final AccountGroup.Id id = group.getId();
                        if (!seen.add(id)) {
                            continue;
                        }
                        try {
                            GroupControl c = groupControlFactory.controlFor(id);
                            if (c.isOwner()) {
                                result.add(c.getAccountGroup());
                            }
                        } catch (NoSuchGroupException e) {
                            continue;
                        }
                    }
                }
            }
            for (final AccountGroup group : db.accountGroups().all().toList()) {
                if (group.isVisibleToAll() && !result.contains(group)) {
                    result.add(group);
                }
            }
            Collections.sort(result, new Comparator<AccountGroup>() {

                public int compare(final AccountGroup a, final AccountGroup b) {
                    return a.getName().compareTo(b.getName());
                }
            });
            return result;
        }
    });
}
#method_after
public void visibleGroups(final AsyncCallback<List<AccountGroup>> callback) {
    run(callback, new Action<List<AccountGroup>>() {

        public List<AccountGroup> run(ReviewDb db) throws OrmException {
            final IdentifiedUser user = identifiedUser.get();
            final List<AccountGroup> result;
            if (user.isAdministrator()) {
                result = db.accountGroups().all().toList();
            } else {
                result = new ArrayList<AccountGroup>();
                for (final AccountGroup group : db.accountGroups().all().toList()) {
                    final GroupControl c = groupControlFactory.controlFor(group);
                    if (c.isVisible()) {
                        result.add(c.getAccountGroup());
                    }
                }
            }
            Collections.sort(result, new Comparator<AccountGroup>() {

                public int compare(final AccountGroup a, final AccountGroup b) {
                    return a.getName().compareTo(b.getName());
                }
            });
            return result;
        }
    });
}
#end_block

#method_before
public void changeGroupOptions(final AccountGroup.Id groupId, final boolean visibleToAll, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            group.setVisibleToAll(visibleToAll);
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void changeGroupOptions(final AccountGroup.Id groupId, final GroupOptions groupOptions, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            group.setVisibleToAll(groupOptions.isVisibleToAll());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
private void initGroupOptions() {
    groupOptionsPanel = new VerticalPanel();
    groupOptionsPanel.add(new SmallHeading(Util.C.headingGroupOptions()));
    visibleToAllCheckBox = new CheckBox(Util.C.isVisibleToAll());
    groupOptionsPanel.add(visibleToAllCheckBox);
    saveGroupOptions = new Button(Util.C.buttonSaveGroupOptions());
    saveGroupOptions.setEnabled(false);
    saveGroupOptions.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final boolean visibleToAll = visibleToAllCheckBox.getValue();
            Util.GROUP_SVC.changeGroupOptions(groupId, visibleToAll, new GerritCallback<VoidResult>() {

                public void onSuccess(final VoidResult result) {
                    saveGroupOptions.setEnabled(false);
                }
            });
        }
    });
    groupOptionsPanel.add(saveGroupOptions);
    add(groupOptionsPanel);
    new OnEditEnabler(saveGroupOptions, visibleToAllCheckBox);
}
#method_after
private void initGroupOptions() {
    groupOptionsPanel = new VerticalPanel();
    groupOptionsPanel.add(new SmallHeading(Util.C.headingGroupOptions()));
    visibleToAllCheckBox = new CheckBox(Util.C.isVisibleToAll());
    groupOptionsPanel.add(visibleToAllCheckBox);
    saveGroupOptions = new Button(Util.C.buttonSaveGroupOptions());
    saveGroupOptions.setEnabled(false);
    saveGroupOptions.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final GroupOptions groupOptions = new GroupOptions(visibleToAllCheckBox.getValue());
            Util.GROUP_SVC.changeGroupOptions(groupId, groupOptions, new GerritCallback<VoidResult>() {

                public void onSuccess(final VoidResult result) {
                    saveGroupOptions.setEnabled(false);
                }
            });
        }
    });
    groupOptionsPanel.add(saveGroupOptions);
    add(groupOptionsPanel);
    new OnEditEnabler(saveGroupOptions, visibleToAllCheckBox);
}
#end_block

#method_before
HashSet<RefRight.Key> getRefRightIdsChecked() {
    final HashSet<RefRight.Key> refRightIds = new HashSet<RefRight.Key>();
    for (int row = 1; row < table.getRowCount(); row++) {
        RefRight r = getRowItem(row);
        if (r != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            refRightIds.add(r.getKey());
        }
    }
    return refRightIds;
}
#method_after
HashSet<RefRight.Key> getRefRightIdsChecked() {
    final HashSet<RefRight.Key> refRightIds = new HashSet<RefRight.Key>();
    for (int row = 1; row < table.getRowCount(); row++) {
        RefRight r = getRowItem(row).getRight();
        if (r != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            refRightIds.add(r.getKey());
        }
    }
    return refRightIds;
}
#end_block

#method_before
protected void onOpenRow(final int row) {
    if (row > 0) {
        RefRight right = getRowItem(row);
        rightEditor.load(right, groups.get(right.getAccountGroupId()));
    }
}
#method_after
protected void onOpenRow(final int row) {
    if (row > 0) {
        RefRight right = getRowItem(row).getRight();
        rightEditor.load(right, groups.get(right.getAccountGroupId()));
    }
}
#end_block

#method_before
void populate(final int row, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (r.isInherited()) {
        Project.NameKey fromProject = right.getKey().getProjectNameKey();
        table.setWidget(row, 2, new Hyperlink(fromProject.get(), Dispatcher.toProjectAdmin(fromProject, ACCESS)));
    } else {
        table.setText(row, 2, "");
    }
    table.setText(row, 3, ar != null ? ar.getCategory().getName() : right.getApprovalCategoryId().get());
    if (group != null) {
        table.setWidget(row, 4, new Hyperlink(group.getName(), Dispatcher.toAccountGroup(group.getId())));
    } else {
        table.setText(row, 4, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 5, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 6, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#method_after
void populate(final int row, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (r.isInherited()) {
        Project.NameKey fromProject = right.getKey().getProjectNameKey();
        table.setWidget(row, 2, new Hyperlink(fromProject.get(), Dispatcher.toProjectAdmin(fromProject, ACCESS)));
    } else {
        table.setText(row, 2, "");
    }
    table.setText(row, 3, ar != null ? ar.getCategory().getName() : right.getApprovalCategoryId().get());
    if (group != null) {
        table.setWidget(row, 4, new Hyperlink(group.getName(), Dispatcher.toAccountGroup(group.getId())));
    } else {
        table.setText(row, 4, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 5, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 6, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 6, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, r);
}
#end_block

#method_before
public void showInherited(boolean visible) {
    for (int r = 0; r < table.getRowCount(); r++) {
        if (table.getWidget(r, 2) instanceof Hyperlink) {
            table.getRowFormatter().setVisible(r, visible);
        }
    }
}
#method_after
public void showInherited(boolean visible) {
    for (int r = 0; r < table.getRowCount(); r++) {
        if (getRowItem(r) != null && getRowItem(r).isInherited()) {
            table.getRowFormatter().setVisible(r, visible);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    } else if (PAT_COMMIT.matcher(query).matches()) {
        return commit(query);
    } else if (PAT_EMAIL.matcher(query).find()) {
        try {
            return Predicate.or(owner(query), reviewer(query));
        } catch (OrmException err) {
            throw error("Cannot lookup user", err);
        }
    } else if (PAT_LABEL.matcher(query).find()) {
        return label(query);
    } else {
        throw error("Unsupported query:" + query);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    } else if (PAT_COMMIT.matcher(query).matches()) {
        return commit(query);
    } else if (PAT_EMAIL.matcher(query).find()) {
        try {
            return Predicate.or(owner(query), reviewer(query));
        } catch (OrmException err) {
            throw error("Cannot lookup user", err);
        }
    } else if (PAT_LABEL.matcher(query).find()) {
        return label(query);
    } else {
        // Try to match a project name by substring query.
        final List<ProjectPredicate> predicate = new ArrayList<ProjectPredicate>();
        try {
            for (final Project p : args.dbProvider.get().projects().all()) {
                if (p.getName().toLowerCase().contains(query.toLowerCase())) {
                    predicate.add(new ProjectPredicate(args.dbProvider, p.getName()));
                }
            }
            // only one contains that, return only that one predicate by itself.
            if (predicate.size() == 1) {
                return predicate.get(0);
            } else if (predicate.size() > 1) {
                return Predicate.or(predicate);
            }
        } catch (OrmException e) {
            throw error("Cannot lookup project.", e);
        }
        throw error("Unsupported query:" + query);
    }
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    final List<String> targets = new ArrayList<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                targets.add(target);
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            RefControl refControl = pctl.controlForRef(ref.getName());
            if (ref.getName().startsWith(Constants.R_HEADS) && refControl.isVisible()) {
                final Branch b = createBranch(ref.getName());
                if (ref.getObjectId() != null) {
                    b.setRevision(new RevId(ref.getObjectId().name()));
                }
                b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
                branches.add(b);
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            RefControl refControl = pctl.controlForRef(ref.getName());
            if (ref.getName().startsWith(Constants.R_HEADS) && refControl.isVisible()) {
                final Branch b = createBranch(ref.getName());
                if (ref.getObjectId() != null) {
                    b.setRevision(new RevId(ref.getObjectId().name()));
                }
                b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
                branches.add(b);
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> project(String name) throws OrmException {
    // "name" as substring.
    try {
        final ProjectControl projectControl = args.projectControlFactory.controlFor(new Project.NameKey(name));
    } catch (NoSuchProjectException e) {
        final List<ProjectPredicate> predicate = new ArrayList<ProjectPredicate>();
        for (final Project p : args.dbProvider.get().projects().all()) {
            if (p.getName().toLowerCase().contains(name.toLowerCase())) {
                predicate.add(new ProjectPredicate(args.dbProvider, p.getName()));
            }
        }
        // only one contains that, return only that one predicate by itself.
        if (predicate.size() == 1) {
            return predicate.get(0);
        } else if (predicate.size() > 1) {
            return Predicate.or(predicate);
        }
    }
    return new ProjectPredicate(args.dbProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> project(String name) {
    if (name.startsWith("^"))
        return new RegexProjectPredicate(args.dbProvider, name);
    return new ProjectPredicate(args.dbProvider, name);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    } else if (PAT_COMMIT.matcher(query).matches()) {
        return commit(query);
    } else if (PAT_EMAIL.matcher(query).find()) {
        try {
            return Predicate.or(owner(query), reviewer(query));
        } catch (OrmException err) {
            throw error("Cannot lookup user", err);
        }
    } else if (PAT_LABEL.matcher(query).find()) {
        return label(query);
    } else {
        throw error("Unsupported query:" + query);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    } else if (PAT_COMMIT.matcher(query).matches()) {
        return commit(query);
    } else if (PAT_EMAIL.matcher(query).find()) {
        try {
            return Predicate.or(owner(query), reviewer(query));
        } catch (OrmException err) {
            throw error("Cannot lookup user", err);
        }
    } else if (PAT_LABEL.matcher(query).find()) {
        return label(query);
    } else {
        // Try to match a project name by substring query.
        final List<ProjectPredicate> predicate = new ArrayList<ProjectPredicate>();
        try {
            for (final Project p : args.dbProvider.get().projects().all()) {
                if (p.getName().toLowerCase().contains(query.toLowerCase())) {
                    predicate.add(new ProjectPredicate(args.dbProvider, p.getName()));
                }
            }
            // only one contains that, return only that one predicate by itself.
            if (predicate.size() == 1) {
                return predicate.get(0);
            } else if (predicate.size() > 1) {
                return Predicate.or(predicate);
            }
        } catch (OrmException e) {
            throw error("Cannot lookup project.", e);
        }
        throw error("Unsupported query:" + query);
    }
}
#end_block

#method_before
Configuration toConfiguration() {
    configureDiskStore();
    configureDefaultCache();
    for (CacheProvider<?, ?> p : caches.values()) {
        final String name = p.getName();
        final CacheConfiguration c = newCache(name);
        c.setMemoryStoreEvictionPolicyFromObject(toPolicy(p.evictionPolicy()));
        c.setMaxElementsInMemory(getInt(name, "memorylimit", p.memoryLimit()));
        c.setTimeToIdleSeconds(0);
        c.setTimeToLiveSeconds(getSeconds(name, "maxage", p.maxAge()));
        c.setEternal(c.getTimeToLiveSeconds() == 0);
        if (p.disk() && mgr.getDiskStoreConfiguration() != null) {
            c.setMaxElementsOnDisk(getInt(name, "disklimit", p.diskLimit()));
            int v = c.getDiskSpoolBufferSizeMB() * MB;
            v = getInt(name, "diskbuffer", v) / MB;
            c.setDiskSpoolBufferSizeMB(Math.max(1, v));
            c.setOverflowToDisk(c.getMaxElementsOnDisk() > 0);
            c.setDiskPersistent(c.getMaxElementsOnDisk() > 0);
        }
        mgr.addCache(c);
    }
    return mgr;
}
#method_after
Configuration toConfiguration() {
    configureDiskStore();
    configureDefaultCache();
    for (CacheProvider<?, ?> p : caches.values()) {
        final String name = p.getName();
        final CacheConfiguration c = newCache(name);
        c.setMemoryStoreEvictionPolicyFromObject(toPolicy(p.evictionPolicy()));
        c.setMaxElementsInMemory(getInt(name, "memorylimit", p.memoryLimit()));
        long ttl = getSeconds(name, "maxage", p.maxAge());
        c.setEternal(ttl == 0);
        if (ttl != 0) {
            c.setTimeToIdleSeconds(0);
            c.setTimeToLiveSeconds(ttl);
        }
        if (p.disk() && mgr.getDiskStoreConfiguration() != null) {
            c.setMaxElementsOnDisk(getInt(name, "disklimit", p.diskLimit()));
            int v = c.getDiskSpoolBufferSizeMB() * MB;
            v = getInt(name, "diskbuffer", v) / MB;
            c.setDiskSpoolBufferSizeMB(Math.max(1, v));
            c.setOverflowToDisk(c.getMaxElementsOnDisk() > 0);
            c.setDiskPersistent(c.getMaxElementsOnDisk() > 0);
        }
        mgr.addCache(c);
    }
    return mgr;
}
#end_block

#method_before
private void configureDefaultCache() {
    final CacheConfiguration c = new CacheConfiguration();
    c.setMaxElementsInMemory(1024);
    c.setMemoryStoreEvictionPolicyFromObject(MemoryStoreEvictionPolicy.LFU);
    c.setTimeToIdleSeconds(0);
    c.setTimeToLiveSeconds(0);
    c.setEternal(true);
    if (mgr.getDiskStoreConfiguration() != null) {
        c.setMaxElementsOnDisk(16384);
        c.setOverflowToDisk(false);
        c.setDiskPersistent(false);
        c.setDiskSpoolBufferSizeMB(5);
        c.setDiskExpiryThreadIntervalSeconds(60 * 60);
    }
    mgr.setDefaultCacheConfiguration(c);
}
#method_after
private void configureDefaultCache() {
    final CacheConfiguration c = new CacheConfiguration();
    c.setMaxElementsInMemory(1024);
    c.setMemoryStoreEvictionPolicyFromObject(MemoryStoreEvictionPolicy.LFU);
    c.setEternal(true);
    if (mgr.getDiskStoreConfiguration() != null) {
        c.setMaxElementsOnDisk(16384);
        c.setOverflowToDisk(false);
        c.setDiskPersistent(false);
        c.setDiskSpoolBufferSizeMB(5);
        c.setDiskExpiryThreadIntervalSeconds(60 * 60);
    }
    mgr.setDefaultCacheConfiguration(c);
}
#end_block

#method_before
private List<ReplicationConfig> allConfigs(final SitePaths site) throws ConfigInvalidException, IOException {
    final FileBasedConfig cfg = new FileBasedConfig(site.replication_config, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfg.getFile() + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        // In case if refspec destination for push is not set then we assume it is equal to source
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#method_after
private List<ReplicationConfig> allConfigs(final SitePaths site) throws ConfigInvalidException, IOException {
    final FileBasedConfig cfg = new FileBasedConfig(site.replication_config, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfg.getFile() + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        // equal to source
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#end_block

#method_before
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String adminUrl = config.getAdminUrl();
        URIish adminURI = null;
        try {
            if (adminUrl != null && !adminUrl.isEmpty()) {
                adminURI = new URIish(adminUrl);
            }
        } catch (URISyntaxException e) {
        // syntax error
        // 
        }
        boolean adminURLUsed = false;
        if (adminURI != null) {
            final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
            if (replacedPath != null) {
                adminURI = adminURI.setPath(replacedPath);
                if (usingSSH(adminURI)) {
                    replicateProject(adminURI, head);
                    adminURLUsed = true;
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(uri, head);
            }
        }
    }
}
#method_after
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            URIish adminURI = null;
            try {
                if (url != null && !url.isEmpty()) {
                    adminURI = new URIish(url);
                }
            } catch (URISyntaxException e) {
                log.error("The URL '" + url + "' is invalid");
            }
            if (adminURI != null) {
                final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
                if (replacedPath != null) {
                    adminURI = adminURI.setPath(replacedPath);
                    if (usingSSH(adminURI)) {
                        replicateProject(adminURI, head);
                        adminURLUsed = true;
                    } else {
                        log.error("The adminURL '" + url + "' is non-SSH which is not allowed");
                    }
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(uri, head);
            }
        }
    }
}
#end_block

#method_before
void notifyStarting(final PushOp op) {
    synchronized (pending) {
        pending.remove(op.getURI());
    }
}
#method_after
void notifyStarting(final PushOp op) {
    synchronized (pending) {
        if (!op.wasCanceled()) {
            pending.remove(op.getURI());
        }
    }
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            if (abandonChange) {
                if (restoreChange) {
                    throw error("abandon and restore actions are mutually exclusive");
                }
                if (submitChange) {
                    throw error("abandon and submit actions are mutually exclusive");
                }
            }
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
            if (!toSubmit.isEmpty()) {
                final Set<Branch.NameKey> toMerge = new HashSet<Branch.NameKey>();
                try {
                    for (PatchSet.Id patchSetId : toSubmit) {
                        ChangeUtil.submit(opFactory, patchSetId, currentUser, db, new MergeQueue() {

                            @Override
                            public void merge(MergeOp.Factory mof, Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void schedule(Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void recheckAfter(Branch.NameKey branch, long delay, TimeUnit delayUnit) {
                                toMerge.add(branch);
                            }
                        });
                    }
                    for (Branch.NameKey branch : toMerge) {
                        merger.merge(opFactory, branch);
                    }
                } catch (OrmException updateError) {
                    throw new Failure(1, "one or more submits failed", updateError);
                }
            }
        }
    });
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            ChangeUtil.submit(opFactory, patchSetId, currentUser, db, merger);
        } else {
            throw error(result.getMessage());
        }
    }
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, changeId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("User does not have the privileges to abandon this change");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to abandon change");
        }
    }
    if (restoreChange) {
        if (changeControl.canRestore()) {
            ChangeUtil.restore(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to restore change");
        }
        if (submitChange) {
            changeControl = changeControlFactory.validateFor(changeId);
        }
    }
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            toSubmit.add(patchSetId);
        } else {
            throw error(result.getMessage());
        }
    }
}
#end_block

#method_before
public static void abandon(final PatchSet.Id patchSetId, final Change.Id changeId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#method_after
public static void abandon(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, changeId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroupImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
}
#end_block

#method_before
private void update() {
    if (colWidth.getIntValue() == 0) {
        new ErrorDialog("The number of columns cannot be zero").center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    listenablePrefs.set(dp);
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    listenablePrefs.set(dp);
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
private NoteMap loadRejectCommitsMap(final String refName) {
    try {
        final ObjectId rejectCommitsId = repo.resolve(refName);
        if (rejectCommitsId == null) {
            return null;
        }
        final ObjectReader reader = repo.newObjectReader();
        final RevWalk rw = new RevWalk(reader);
        final RevCommit c;
        if (rejectCommitsId instanceof RevCommit) {
            c = (RevCommit) rejectCommitsId;
        } else {
            c = rw.parseCommit(rejectCommitsId);
        }
        return NoteMap.load(reader, c);
    } catch (AmbiguousObjectException e) {
        log.error("Ambiguous reference for reject commits map: " + refName, e);
        return null;
    } catch (IOException e) {
        log.error("Error loading reject commits map", e);
        return null;
    }
}
#method_after
private NoteMap loadRejectCommitsMap() throws IOException {
    String rejectNotes = "refs/meta/reject-commits";
    try {
        Ref ref = repo.getRef(rejectNotes);
        if (ref == null) {
            return null;
        }
        RevWalk rw = rp.getRevWalk();
        RevCommit map = rw.parseCommit(ref.getObjectId());
        return NoteMap.read(rw.getObjectReader(), map);
    } catch (IOException badMap) {
        throw new IOException("Cannot load " + rejectNotes, badMap);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits != null && rejectCommits.contains(c.getId())) {
        reject(newChange, "contains bad commit " + c.getId().getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits != null && rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
private void initProjectOptions() {
    projectOptionsPanel = new VerticalPanel();
    projectOptionsPanel.add(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final Project.SubmitType type : Project.SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            if (SubmitType.FAST_FORWARD_ONLY.equals(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) {
                useContentMerge.setEnabled(false);
                useContentMerge.setValue(false);
            } else {
                useContentMerge.setEnabled(true);
            }
        }
    });
    saveEnabler.listenTo(submitType);
    projectOptionsPanel.add(submitType);
    useContentMerge = new CheckBox(Util.C.useContentMerge(), true);
    saveEnabler.listenTo(useContentMerge);
    projectOptionsPanel.add(useContentMerge);
    requireChangeID = new CheckBox(Util.C.requireChangeID(), true);
    saveEnabler.listenTo(requireChangeID);
    projectOptionsPanel.add(requireChangeID);
    add(projectOptionsPanel);
}
#method_after
private void initProjectOptions() {
    projectOptionsPanel = new VerticalPanel();
    projectOptionsPanel.add(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final Project.SubmitType type : Project.SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    projectOptionsPanel.add(submitType);
    useContentMerge = new CheckBox(Util.C.useContentMerge(), true);
    saveEnabler.listenTo(useContentMerge);
    projectOptionsPanel.add(useContentMerge);
    requireChangeID = new CheckBox(Util.C.requireChangeID(), true);
    saveEnabler.listenTo(requireChangeID);
    projectOptionsPanel.add(requireChangeID);
    add(projectOptionsPanel);
}
#end_block

#method_before
private void setSubmitType(final Project.SubmitType newSubmitType) {
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                submitType.setSelectedIndex(i);
                return;
            }
        }
        submitType.setSelectedIndex(-1);
    }
}
#method_after
private void setSubmitType(final Project.SubmitType newSubmitType) {
    int index = -1;
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                index = i;
                break;
            }
        }
        submitType.setSelectedIndex(index);
        setEnabledForUseContentMerge();
    }
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName.get());
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    break;
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName.get());
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isHead(c) || isTag(c)) {
                // We only schedule heads and tags for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefChangedHook(destBranch, c.getNewId(), this.currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isHead(c) || isTag(c)) {
                // We only schedule heads and tags for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName.get());
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    hooks.doRefChangedHook(name, object, identifiedUser.getAccount());
                    break;
                default:
                    {
                        final String msg = "Cannot create branch " + name + ": " + result.name();
                        log.error(msg);
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName.get());
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                default:
                    {
                        final String msg = "Cannot create branch " + name + ": " + result.name();
                        log.error(msg);
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public Set<Branch.NameKey> call() throws NoSuchProjectException, RepositoryNotFoundException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (Branch.NameKey k : toRemove) {
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName.get());
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result result;
            try {
                final RefUpdate u = r.updateRef(refname);
                u.setForceUpdate(true);
                result = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(result) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefChangedHook(branchKey, ObjectId.zeroId(), identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + result.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + result.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    return deleted;
}
#method_after
@Override
public Set<Branch.NameKey> call() throws NoSuchProjectException, RepositoryNotFoundException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    for (Branch.NameKey k : toRemove) {
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName.get());
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result result;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                result = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(result) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + result.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + result.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    return deleted;
}
#end_block

#method_before
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final Merger m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m;
    if (destProject.isUseContentMerge()) {
        // Settings for this project allow us to try and
        // automatically resolve conflicts within files if needed.
        // Use ResolveMerge and instruct to operate in core.
        m = MergeStrategy.RESOLVE.newMerger(db, true);
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    }
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    hooks.doRefChangedHook(destBranch, mergeTip, accountCache.get(getSubmitter(mergeTip.patchsetId).getAccountId()).getAccount());
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void createEmptyCommit(final Repository repo, final Project.NameKey project, final String ref) throws IOException {
    ObjectInserter oi = repo.newObjectInserter();
    try {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setCommitter(currentUser.newCommitterIdent());
        cb.setAuthor(cb.getCommitter());
        cb.setMessage("Initial empty repository");
        ObjectId id = oi.insert(cb);
        oi.flush();
        RefUpdate ru = repo.updateRef(Constants.HEAD);
        ru.setNewObjectId(id);
        final Result result = ru.update();
        switch(result) {
            case NEW:
                rq.scheduleUpdate(project, ref);
                break;
            default:
                {
                    final String msg = "Cannot create empty commit for " + projectName + ": " + result.name();
                    log.error(msg);
                    throw new IOException(result.name());
                }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + projectName, e);
        throw e;
    } finally {
        oi.release();
    }
}
#method_after
private void createEmptyCommit(final Repository repo, final Project.NameKey project, final String ref) throws IOException {
    ObjectInserter oi = repo.newObjectInserter();
    try {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setCommitter(serverIdent);
        cb.setAuthor(cb.getCommitter());
        cb.setMessage("Initial empty repository");
        ObjectId id = oi.insert(cb);
        oi.flush();
        RefUpdate ru = repo.updateRef(Constants.HEAD);
        ru.setNewObjectId(id);
        final Result result = ru.update();
        switch(result) {
            case NEW:
                rq.scheduleUpdate(project, ref);
                break;
            default:
                {
                    throw new IOException(result.name());
                }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + projectName, e);
        throw e;
    } finally {
        oi.release();
    }
}
#end_block

#method_before
private void createProject() throws OrmException {
    final Project.NameKey newProjectNameKey = new Project.NameKey(projectName);
    List<RefRight> access = new ArrayList<RefRight>();
    for (AccountGroup.Id ownerId : ownerIds) {
        final RefRight.Key prk = new RefRight.Key(newProjectNameKey, new RefRight.RefPattern(RefRight.ALL), ApprovalCategory.OWN, ownerId);
        final RefRight pr = new RefRight(prk);
        pr.setMaxValue((short) 1);
        pr.setMinValue((short) 1);
        access.add(pr);
    }
    db.refRights().insert(access);
    final Project newProject = new Project(newProjectNameKey);
    newProject.setDescription(projectDescription);
    newProject.setSubmitType(submitType);
    newProject.setUseContributorAgreements(contributorAgreements);
    newProject.setUseSignedOffBy(signedOffBy);
    newProject.setRequireChangeID(requireChangeID);
    if (newParent != null) {
        newProject.setParent(newParent.getProject().getNameKey());
    }
    db.projects().insert(Collections.singleton(newProject));
}
#method_after
private void createProject() throws OrmException {
    final Project.NameKey newProjectNameKey = new Project.NameKey(projectName);
    List<RefRight> access = new ArrayList<RefRight>();
    for (AccountGroup.Id ownerId : ownerIds) {
        final RefRight.Key prk = new RefRight.Key(newProjectNameKey, new RefRight.RefPattern(RefRight.ALL), ApprovalCategory.OWN, ownerId);
        final RefRight pr = new RefRight(prk);
        pr.setMaxValue((short) 1);
        pr.setMinValue((short) 1);
        access.add(pr);
    }
    db.refRights().insert(access);
    final Project newProject = new Project(newProjectNameKey);
    newProject.setDescription(projectDescription);
    newProject.setSubmitType(submitType);
    newProject.setUseContributorAgreements(contributorAgreements);
    newProject.setUseSignedOffBy(signedOffBy);
    newProject.setUseContentMerge(contentMerge);
    newProject.setRequireChangeID(requireChangeID);
    if (newParent != null) {
        newProject.setParent(newParent.getProject().getNameKey());
    }
    db.projects().insert(Collections.singleton(newProject));
}
#end_block

